window.Geo = {
    singleFile: true
};


//装载GeoSurfJSAPI库文件
(function(){
    /**
     * Namespace: Geo
     * Geo 是整个 GeoGlobeSDK 地图 API 的命名空间，本手册中介绍的所有类和对象都通过 Geo.XXX 的方式调用。
     * 如创建一个 LonLat 对象：new Geo.LonLat(121.123458,34.534227)。
     */
    window.Geo = window.Geo || {};
    window.Geo.Service = {};
    window.Geo.Query = {};
    window.Geo.Math = {};
    window.Geo.Analysis = {};
    window.Geo.View2D = {};
    window.Geo.View2D.Control = OpenLayers.Control;    
    window.Geo.View3D = {};
    window.Geo.View3D.Event = {};
    //基本类型对象
    window.Geo.Bounds = OpenLayers.Bounds;
    window.Geo.Class = OpenLayers.Class;
    window.Geo.LonLat = OpenLayers.LonLat;
    window.Geo.Pixel = OpenLayers.Pixel;
    window.Geo.Size = OpenLayers.Size;
    window.Geo.Element = OpenLayers.Element;
	window.Geo.Date = OpenLayers.Date;
	//基类
    window.Geo.Feature = OpenLayers.Feature;
    window.Geo.Filter = OpenLayers.Filter;
    window.Geo.Format = OpenLayers.Format;
    window.Geo.Geometry = OpenLayers.Geometry;
    window.Geo.View2D.Handler = OpenLayers.Handler;
    window.Geo.View2D.Layer = OpenLayers.Layer;
    window.Geo.View2D.Popup = OpenLayers.Popup;
    window.Geo.Protocol = OpenLayers.Protocol;
    window.Geo.Request = OpenLayers.Request;
    window.Geo.Strategy = OpenLayers.Strategy;
    window.Geo.Symbolizer = OpenLayers.Symbolizer;
    window.Geo.View2D.Tile = OpenLayers.Tile;
    window.Geo.View2D.Icon = OpenLayers.Icon;
    window.Geo.Projection = OpenLayers.Projection;
    window.Geo.Rule = OpenLayers.Rule;
    window.Geo.Style = OpenLayers.Style;
    window.Geo.Style2 = OpenLayers.Style2;
    window.Geo.StyleMap = OpenLayers.StyleMap;
	window.Geo.Marker = OpenLayers.Marker;
	window.Geo.Event  = OpenLayers.Event;
	window.Geo.Events  = OpenLayers.Events;
	window.Geo.Util  = OpenLayers.Util;
	window.Geo.Console  = OpenLayers.Console;
	window.Geo.Lang  = OpenLayers.Lang;
	window.Geo.Kinetic  = OpenLayers.Kinetic;
	//Geo.View2D.Event已废弃，由Geo.Event取代
    window.Geo.View2D.Event = OpenLayers.Event;
	//Geo.View2D.Events已废弃，由Geo.Events取代
    window.Geo.View2D.Events = OpenLayers.Events;
	//BaseTypes.js中的基本对象类
	window.Geo.String = OpenLayers.String;
	window.Geo.Number = OpenLayers.Number;
	window.Geo.Function = OpenLayers.Function;
	window.Geo.Array = OpenLayers.Array;
	
    if (!Geo.singleFile) {
	    //导入js文件库
	    var scriptName = "GeoGlobeJSAPI.js";
	    var jsfiles = [
			"Animator.js",
			"AnimateZoomer.js",
	        "Util.js", 
			"Pyramid.js", 
			"SymbolizerManager.js", 
			"GeoMarker.js", 
			"Util/Uuid.js",
			"Util/Format/BusCapabilities.js",
			"Util/Format/GlobeTileCapabilities.js",
			"Util/Format/Pyramid.js",
	        "Util/Format/XML2JSON.js",
	        "Util/Format/VwmtsGetVersionInfo.js",
	        "Util/Format/VwmtsGetVersions.js",
			"Util/Format/VWMTSCapabilities.v1_0_0.js",
			"Util/Format/MapServiceQuery.js",
			
			"View2D/Map.js", 
			"View2D/Layer/CWMS.js",
			"View2D/Layer/GlobeTile.js",
			"View2D/Layer/GeoWMTS.js",
			"View2D/Layer/DynamicMapService.js",
			"View2D/Layer/TileMapService.js",
			"View2D/Layer/GeoMarkers.js",
			"View2D/Layer/ArcGISTileLayer.js",
			"View2D/Layer/Buildings.js",
			"View2D/Layer/GeoThematicLayer.js",
	        "View2D/BaseLayerGroup.js", 
			"View2D/LayerGroup.js", 
			"View2D/FeatureManager.js", 
			"View2D/MarkerTag.js", 
			"View2D/Control/DrawCircle.js", 
			"View2D/Control/DrawPath.js", 
			"View2D/Control/DrawPoint.js", 
			"View2D/Control/DrawPolygon.js", 
			"View2D/Control/DrawRectangle.js",
			"View2D/Control/MagnifyingGlass.js",
			"View2D/Control/GeoPanZoom.js",
			"View2D/Control/PanZoomBarTitle.js",
			"View2D/Control/GeoOverviewMap.js",
			"View2D/Control/GeoSelectFeature.js",
			"View2D/Control/ZoomBar.js",
			"View2D/Control/Measure/AreaMeasure.js",
			"View2D/Control/Measure/DistanceMeasure.js",
			"View2D/Control/Measure/Angle.js",
			"View2D/Control/Measure/AngleMeasure.js",
			"View2D/ChartContainer.js",
			"View2D/Popup/GeoFrameCloud.js",
	
	        "ViewFl/swfobject.js",
	        "ViewFl/Map.js",
	        "ViewFl/Layer.js",
	        "ViewFl/Layer/GlobeTile.js",
			"ViewFl/Layer/WMTS.js",
			"ViewFl/Layer/WMS.js",
	        "ViewFl/Layer/Vector.js",
	        "ViewFl/BaseLayerGroup.js",
			"ViewFl/Handler.js",
	        "ViewFl/Handler/Point.js",
	        "ViewFl/Handler/Path.js",
	        "ViewFl/Handler/Polygon.js",
			"ViewFl/Handler/Click.js",
	        "ViewFl/Control.js",
	        "ViewFl/Control/Navigation.js",
	        "ViewFl/Control/PanZoom.js",
	        "ViewFl/Control/PanZoomBar.js",
	        "ViewFl/Control/ScaleLine.js",
	        "ViewFl/Control/MousePosition.js",
	        "ViewFl/Control/OverviewMap.js",
	        "ViewFl/Control/DrawFeature.js",
	        "ViewFl/Control/LayerScroll.js",
	        "ViewFl/Control/Measure.js",
	        "ViewFl/Control/SelectFeature.js",
	        "ViewFl/Control/ModifyFeature.js",
			"ViewFl/Control/ZoomBox.js",
			"ViewFl/Control/Mouse.js",
			"ViewFl/Control/SituationControl.js",
			"ViewFl/Control/GeoLayerManager.js",
			"ViewFl/Control/MeasureToolControl.js",
	        "ViewFl/Popup.js",
			"ViewFl/PopupFl.js",
			"ViewFl/Popup/Anchored.js",
			"ViewFl/Popup/AnchoredBubble.js",
			"ViewFl/Popup/Framed.js",
	        "ViewFl/Popup/FramedCloud.js",
			"ViewFl/Popup/FramedCloudFl.js",
			
			"View3D/Map.js", 
			"View3D/Layer.js", 
	        "View3D/BaseLayerGroup.js",
			"View3D/LayerGroup.js", 
			"View3D/Layer/GlobeTile.js", 
			"View3D/Layer/ArcgisRest.js",
			"View3D/Layer/Shape.js", 
			"View3D/Layer/Terrain.js", 
			"View3D/Layer/Vector.js", 
			"View3D/Layer/WMS.js", 
			"View3D/Layer/WMTS.js", 
			"View3D/Layer/WFS.js", 
			"View3D/Layer/WTFS.js", 
	        "View3D/Layer/Solid.js", 
	        "View3D/Layer/WCS.js", 
	        "View3D/Layer/Grid.js", 
	        "View3D/Layer/Model.js", 
			"View3D/Event/MouseEvent.js", 
			"View3D/Event/KeyEvent.js", 
			"View3D/Handler.js", 
			"View3D/Handler/KeybordDefaults.js", 
			"View3D/Handler/Mouse.js", 
			"View3D/Handler/Point.js", 
			"View3D/Handler/Path.js",
			"View3D/Handler/Polygon.js",
			"View3D/Handler/Box.js",
			"View3D/Handler/ModelChoose.js",
			"View3D/Handler/Feature.js",
			"View3D/Handler/Keyboard.js",
			"View3D/Control.js", 
			"View3D/Control/KeyboardDefaults.js", 
			"View3D/Control/Measure.js", 
			"View3D/Control/DrawPath.js", 
			"View3D/Control/DrawPoint.js", 
			"View3D/Control/DrawPolygon.js", 
			"View3D/Control/DrawFeature.js",
			"View3D/Control/SelectFeature.js", 
			"View3D/Control/Attribution.js",
			"View3D/Control/Box.js",
			"View3D/Control/Mouse.js",
			"View3D/Control/ModelChoose.js",
			"View3D/Control/Analysis.js",
			"View3D/Control/Keyboard.js",
			"View3D/Fly.js", 
			"View3D/Popup.js", 
			"View3D/Popup/FramedCloud.js", 
			"View3D/FeatureManager.js", 
			"View3D/Control/Measure/PointInfo.js", 
			"View3D/Control/Measure/Distance.js", 
			"View3D/Control/Measure/Area.js", 
			"View3D/Control/Measure/Volume.js", 
			"View3D/Control/Measure/Excavate.js", 
			"View3D/Control/Measure/Flood.js", 
			"View3D/Control/Measure/Profile.js", 
			"View3D/Control/Measure/TwoPointThrough.js", 
			"CombineView.js", 
			"LayerManager.js", 
			"Request.js",
			"Analysis/AreasAndLengthsParameters.js", 
			"Analysis/BufferAnalysis.js",
			"Analysis/BufferParameters.js",
			"Analysis/DensifyParameters.js",
			"Analysis/DistanceParameters.js",
			"Analysis/GeneralizeParameters.js",
			"Analysis/GeometryService.js",
			"Analysis/LengthsParameters.js",
			"Analysis/OffsetParameters.js",
			"Analysis/ProjectParameters.js",
			"Analysis/RelationParameters.js",
			"Analysis/SuperposeAnalysis.js",
			"Analysis/TrimExtendParameters.js",
			"Analysis/Util.js", 
			"Query/WFSQuery.js", 
			"Query/WFSQueryForPage.js", 
			"Query/CatalogQuery.js", 
			"Query/ModelQuery.js", 
			"Query/MapServiceQuery.js",
			"Query/MapServiceQueryParameters.js",
			"Query/MapServiceQueryResult.js",
			"Query/MapServiceIdentify.js",
			"Query/MapServiceIdentifyParameters.js",
			"Query/MapServiceIdentifyResult.js",
			"Query/MapServiceDataFeatures.js",
			"Query/MapServiceDataFeaturesParameters.js",
			"Query/MapServiceDataFeaturesResult.js",
			"Query/MapServiceFind.js",
			"Query/MapServiceFindParameters.js",
			"Query/MapServiceFindResult.js",
			"Query/GeoCodingQuery.js",
			"Query/GeoCodingQuery/v1.js",
			"Query/GeoCodingQuery/v1_0_0.js",
			"Query/GeoCodingQuery/v1_1_0.js",
			
			"Strategy/AttributeCluster.js",
			
			"Service.js", 
			"Service/GlobeTile.js", 
			"Service/Bus.js", 
			"Service/Plot.js", 
			"Service/ShortestPath.js", 
			"Service/Route.js", 
			"Service/TAS.js", 
			"Service/WPS.js",
			"Service/WFS.js",  
			"Service/WFST.js",  
			"Service/WMS.js",
			"Service/WMTS.js",
			"Service/GeoWMTS.js",
			"Service/WCS.js",  
			"Service/CSW.js",
			"Service/CWMS.js",
	 		"Service/MapService.js",
			"Service/MapServiceLayerDetail.js",
			"Service/GeoCoding.js"
			
		];
	    
	    var scriptLocation = "";
	    var isGlb = new RegExp("(^|(.*?\\/))(" + scriptName + ")(\\?|$)");
	    
	    var scripts = document.getElementsByTagName('script');
	    for (var i = 0, len = scripts.length; i < len; i++) {
	        var src = scripts[i].getAttribute('src');
	        if (src) {
	            var match = src.match(isGlb);
	            if (match) {
	                scriptLocation = match[1];
	                break;
	            }
	        }
	    }
	    
	    var agent = navigator.userAgent;
	    var docWrite = (agent.match("MSIE") || agent.match("Safari"));
	    if (docWrite) {
	        var allScriptTags = new Array(jsfiles.length);
	    }
	    
	    for (var i = 0, len = jsfiles.length; i < len; i++) {
	        if (docWrite) {
	            allScriptTags[i] = "<script src='" + scriptLocation + jsfiles[i] +
	            "'></script>";
	        }
	        else {
	            var s = document.createElement("script");
	            s.src = scriptLocation + jsfiles[i];
	            var h = document.getElementsByTagName("head").length ? document.getElementsByTagName("head")[0] : document.body;
	            h.appendChild(s);
	        }
	    }
	    if (docWrite) {
	        document.write(allScriptTags.join(""));
	    }
	}


	/**
	 * Property: scriptName
	 * {String} GeoGlobeJSAPI脚本文件名，默认值为"GeoGlobeJSAPI.js"。当前使用Geo.getScriptLocation方法
	 * 时，该方法将依据本属性值获取GeoGlobeJSAPI所在目录路径。如果引入GeoGlobeJSAPI所用的脚本文件名
	 * 不为默认值"GeoGlobeJSAPI.js"，用户可以根据实际情况自己修改。
	 */
	Geo.scriptName = (!Geo.singleFile) ? "GeoGlobeJSAPI/GeoGlobeJSAPI.js" : "GeoGlobeJS.min.js";
	
	/**
	 * Method: getScriptLocation
	 * 获取GeoGlobeJSAPI脚本文件名库脚本文件所在路径。
	 *
	 * Returns:
	 * {String} GeoGlobeJSAPI脚本文件所在路径。
	 */
	Geo.getScriptLocation = function () {
		var scriptLocation = "";            
		var isGV = new RegExp("(^|(.*?\\/))(" + Geo.scriptName + ")(\\?|$)");
	 
		var scripts = document.getElementsByTagName('script');
		for (var i=0, len=scripts.length; i<len; i++) {
			var src = scripts[i].getAttribute('src');
			if (src) {
				var match = src.match(isGV);
				if(match) {
					scriptLocation = match[1];
					break;
				}
			}
		}
		return scriptLocation;
	};
	
	/**
	 * Property: imagesPath
	 * {String} 指定图片所在路径,三维插件只能接受绝对地址的图片，此处图片路径如:http:www.geostar.com.cn/images/ 或 c:\\images\\。
	 */
	Geo.imagesPath = "";
	
	/**
	 * Method: createNS
	 * 创建名字空间,如果指定名字空间中的某一级已经存在不会覆盖已有内容。
	 * 
	 * Parameters:
	 * ns - {String} 名称空间。
	 * 
	 */		
	Geo.createNS = function(ns){
		var nsArr = ns.split(".");
		var currObj = window;
		for(var i=0; i<nsArr.length; i++){
			if(!currObj[nsArr[i]]){
				currObj[nsArr[i]] = {};
			}
			currObj = currObj[nsArr[i]];
		}
	}
	
	//此方法已废弃，更换为Geo.Request.setProxyHost
	Geo.setProxyHost = function(proxyHost){
		OpenLayers.ProxyHost = proxyHost;
	}
	
	//此方法已废弃，更换为Geo.Request.getProxyHost
	Geo.getProxyHost = function(){
		return OpenLayers.ProxyHost;
	}
	
    /**
	 * APIProperty: setDPI
	 * 设置DPI。即屏幕上的地图图片中，多少个屏幕像素点代表一英寸的距离。
	 * 
	 * Parameters:
	 * dpi - {Number} 一英寸的像素点个数。
	 */
	Geo.setDPI = function(dpi){
		if(!dpi){
			return;
		}
		OpenLayers.DOTS_PER_INCH = dpi;
	}
	
    /**
	 * Property: VERSION_NUMBER
	 * GeoGlobeSDK 地图 API 的版本号。
	 */
	Geo.VERSION_NUMBER = "GeoGlobeJSAPI 5.0.2 -- $Revision: 1.8.10 build-20130924 $";
	
	// 修改默认的瓦片缓存大小，设置为0，为不缓存，
	// 减少地图上一屏范围内对瓦片服务访问的次数。
	OpenLayers.Layer.WMTS.prototype.buffer = 0;
	OpenLayers.Layer.WMS.prototype.buffer = 0;
	// 修改拖拽地图时的“动能”滑动效果的摩擦系数，默认值设置为0.0078。值越大，摩擦力越大，滑动距离越小。
	//OpenLayers.Kinetic.prototype.deceleration = 0.0078;
	//修改显示比例尺的单位
	OpenLayers.INCHES_PER_UNIT["公里"] = OpenLayers.INCHES_PER_UNIT["km"];
	OpenLayers.INCHES_PER_UNIT["米"] = OpenLayers.INCHES_PER_UNIT["m"];
	OpenLayers.INCHES_PER_UNIT["英里"] = OpenLayers.INCHES_PER_UNIT["mi"];
	OpenLayers.INCHES_PER_UNIT["英寸"] = OpenLayers.INCHES_PER_UNIT["ft"];
	//设置ol的国际化语言为中文
	OpenLayers.Lang.setCode("zh-CN");
})()


/**
 * Class: Geo.Animator
 * 矢量要素移动动画类。可以实现点要素在指定线要素上的移动，并且能控制移动的速度。
 */
Geo.Animator = Geo.Class({

    /**
     * APIProperty: id
     * {String} 唯一标识。
     */
    id: null,
    
    //动画队列
    _queue:null,
    
    //当前播放索引
    _currentIndex:0,

    /**
     * APIProperty: feature
     * {<Geo.Feature.Vector>} 动画要素。
     */    
    feature: null,

    /**
     * APIProperty: isPlaying
     * {Boolean} 是否正在播放动画。
     */     
    isPlaying: false,

    /**
     * APIProperty: isRepeat
     * {Boolean} 是否重复播放动画，默认为值true。
     */     
    isRepeat: true,


    /**
     * APIProperty: frequence
     * {Boolean} 刷新频率，默认值为5（单位：毫秒）。
     */      
    frequence: 5,
    
    /**
     * Constructor: Geo.Animator
     * 构造函数。矢量要素动画类实例。
     *
     * Parameters:
     * options - {Object} 对象相关选项设置。
     */
    initialize: function(options){
        this.id = OpenLayers.Util.createUniqueID("Geo.Animater_");
        this._queue = [];
    },
    
	/**
     * APIMethod: setFeature
     * 添加动画要素。
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 被移动的要素。
     */	
    setFeature:function(feature){
        this.feature = feature;
    },  
    
	/**
     * APIMethod: start
     * 开始播放动画。
     */	
    start: function(){
        var item = this._queue[this._currentIndex];
        if(item){
            var fn = OpenLayers.Function.bind(function(){
                this._stepRun(item);
            },this);
            item.interval = window.setInterval(fn, this.frequence);
        }
    }, 
    
	/**
     * APIMethod: stop
     * 停止播放动画。
     */	
    stop: function(){
        this._currentIndex = 0;
        
        //清掉队列中所有的计数器
        for(var i=0; i<this._queue.length; i++){
            var item = this._queue[i];
            window.clearInterval(item.interval);
            item.counter = 0;
        }
    },
    
	/**
     * APIMethod: pause
     * 暂停播放动画。
     */	
    pause: function(){
        var item = this._queue[this._currentIndex];
        window.clearInterval(item.interval);
    },
    
    _getQueueItem: function(){
        return {
            counter: 0,
            isStop: false,
			moveType:"velocity",
            doFn: function(){},
            checkStopFn: function(){
                return false;
            },
            interval: null,
            options: {}
        };
    },
    
    _addItem: function(doFn,checkStopFn,options){
        var item = this._getQueueItem();
        if(doFn){
            item.doFn = OpenLayers.Function.bind(doFn,this);
        }
        
        if(checkStopFn){
            item.checkStopFn = OpenLayers.Function.bind(checkStopFn,this);
        }
        item.options = options;
        this._queue.push(item);
    },
    
    _stepRun: function(item){
        
        
        var isStop = item.checkStopFn();
        if(!isStop){
            item.doFn(item);
            item.counter++;
        } else {
            window.clearInterval(item.interval);
            item.counter = 0;
            
            var next = OpenLayers.Util.indexOf(this._queue,item) + 1;
            var nextItem = this._queue[next];
            if(next !== 0 && nextItem){
                var fn = OpenLayers.Function.bind(function(){
                    this._stepRun(nextItem);
                },this);
                nextItem.interval = window.setInterval(fn,5);
                this._currentIndex = next;
            } else {
                this._currentIndex = 0;
                this.onStop();
            }
        }
        
    },
    
    onStop: function(){},
    
    onChange: function(feature,type){},
    
	/**
     * APIMethod: moveTo
     * 移动到指定位置。
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>} 坐标对象。
     * options - {Object} json格式的参数。
     * 
     * Returns:
     * {<Geo.Animator>}  矢量要素动画类对象。
     */	
    moveTo: function(lonlat,options){
        
        var feature = this.feature;
        var featureLonlat = new Geo.LonLat(feature.geometry.x,
                                                  feature.geometry.y);
        
        options = options || {};
		//默认步长是0.01
        var moveRatio = options.ratio || 0.01;
		var moveType = options.moveType || "velocity";
        options = {
            from: null,
            to: lonlat,
            currentPosition: null, //featureLonlat,
            moveType:moveType,
            step: moveRatio
        };
        
        var doFn = function(item){
            var feature = this.feature;
            var item = this._queue[this._currentIndex];
            this._moveFeature(feature,item);
            this.onChange(feature,"move");
        };
        
        var checkStopFn = function(){
            var item = this._queue[this._currentIndex];
            var currentPosition = new Geo.LonLat(feature.geometry.x,
                                                        feature.geometry.y);
            var options = item.options;
            options.from = options.from || currentPosition;
            options.currentPosition = currentPosition;
            
            var from = options.from;
            var to = options.to;
            
            return this._checkIsOver(from, to, currentPosition);
        }
        
        this._addItem(doFn, checkStopFn, options);
        return this;
    },
    
	/**
     * APIMethod: moveAlong
     * 沿路径移动。
     * 
     * Parameters:
     * path - {<Geo.Feature.Vector>} 要素对象。
     * options - {Object} json格式的参数。
     *
     * 示例:
	 * (code)
	 *      //设置行走路线以及速度
	 *  	animator.moveAlong(roadLine,{
	 *			ratio : 0.01 ,// 可选，表示移动速度，缺省值是0.01
	 *     		moveType : "velocity",// 可选，表示移动的方式，缺省值是"velocity"，表示要素以ratio度的速度做匀速运动；
	 *      	// 如果设置moveType的值为"same_step"，表示要素以ratio值的步长单位匀速运动。
	 *		});
	 * (end)
     */	
    moveAlong: function(path,options){
        var nodes;
        if(path.CLASS_NAME == "OpenLayers.Feature.Vector"){
            nodes = this._getLonLatFromGeometry(path.geometry);
        }
        
        
        for(var i=0; i<nodes.length; i++){
            var newOptions = OpenLayers.Util.extend({},options);
            if(i==0){
                newOptions.ratio = 1;
            }
            this.moveTo(nodes[i],newOptions);
            
        }

    },
    
    _getLonLatFromGeometry: function(geometry){

        var points = geometry.components;
        var lonlats = [];
        for(var i=0; i<points.length; i++){
            lonlats.push(new Geo.LonLat(points[i].x,
                                               points[i].y));
        }
        return lonlats;
    },
    
    _moveFeature: function(feature,item){

        var options = item.options;
        var to = options.to;
        if(item.counter == 0){
            options.from = new Geo.LonLat(feature.geometry.x,
                                             feature.geometry.y);
        }
        var from = options.from;

        var percent = options.step;
        var lonlat = this._getMoveLonLat[options.moveType](from, to, percent * item.counter, percent);
        var angle = this._getMoveDirection(from, to);
        feature.style.rotation = angle;
        feature.move(lonlat);
        options.currentPosition = lonlat;

    },
    
    //检查是否过了
    _checkIsOver: function(from,to,middle){
        if(middle.lon == to.lon && middle.lat == to.lat){
            return true;
        }
        var isXOver = false, isYOver = false;
        var big, small;
        
        if(from.lon < to.lon){
            big = to.lon;
            small = from.lon;
        } else {
            small = to.lon;
            big = from.lon;
        }
        isXOver = (middle.lon > big) || (middle.lon < small);
        
        if(from.lat < to.lat){
            big = to.lat;
            small = from.lat;
        } else {
            small = to.lat;
            big = from.lat;
        }        
        isYOver = (middle.lat > big) || (middle.lat < small);
        
        return (isYOver && isYOver);
    },
    
    animate:function(){},
    
    fadeIn:function(){},
    
    fadeOut:function(){},
    
    hide:function(){},
    
    show:function(){},

    
    /**
     * 该方法用于返回一条线上的某一点的X坐标或Y坐标。
     * parameters:
     * from - {Number} 表示x或y。
     * to - {Number}表示x或y。
     *     当v1为某一点的x 坐标时，v2为另一点的x坐标。
     *     当v1为某一点的y 坐标时，v2为另一点的y坐标。
     *
     * percent表示步长。
     */
    _getMoveLonLat: {
		//匀速运动
		"same_step" : function(from, to, percent, step){
	        if(percent > 1){
	            percent = 1;
	        }
	        var lon, lat;
	        if(from.lon === to.lon ){
	            lon = from.lon;
	        } else {
	            lon = from.lon + percent * (to.lon - from.lon);
	        }
	        if (from.lat === to.lat) {
	            lat = from.lat;
	        } else {
	            lat = from.lat + percent * (to.lat - from.lat);
	        }
	        
	        if(from.lon < to.lon){
	            lon = (lon > to.lon) ? to.lon : lon;
	            lon = (lon < from.lon) ? from.lon : lon;
	        } 
	        if(from.lon > to.lon){
	            lon = (lon < to.lon) ? to.lon : lon;
	            lon = (lon > from.lon) ? from.lon : lon;
	        }
	        if(from.lat < to.lat){
	            lat = (lat > to.lat) ? to.lat : lat;
	            lat = (lat < from.lat) ? from.lat : lat;
	        } 
	        if(from.lat > to.lat){
	            lat = (lat < to.lat) ? to.lat : lat;
	            lat = (lat > from.lat) ? from.lat : lat;
	        }
	        return new Geo.LonLat(lon,lat);
	    },
		//相同的步长
		"velocity"	:	function(from, to, percent, step){
			var geo = (new OpenLayers.Geometry.Point(from.lon, from.lat)).distanceTo(new OpenLayers.Geometry.Point(to.lon, to.lat));
			var stepX = (to.lon - from.lon) / geo * step;
			var stepY = (to.lat - from.lat) / geo * step;
	        var lon, lat;
	        if(from.lon === to.lon ){
	            lon = from.lon;
	        } else {
	            lon = from.lon + stepX * percent;
	        }
	        if (from.lat === to.lat) {
	            lat = from.lat;
	        } else {
	            lat = from.lat + stepY * percent;
	        }
	        
	        if(from.lon < to.lon){
	            lon = (lon > to.lon) ? to.lon : lon;
	            lon = (lon < from.lon) ? from.lon : lon;
	        } 
	        if(from.lon > to.lon){
	            lon = (lon < to.lon) ? to.lon : lon;
	            lon = (lon > from.lon) ? from.lon : lon;
	        }
	        if(from.lat < to.lat){
	            lat = (lat > to.lat) ? to.lat : lat;
	            lat = (lat < from.lat) ? from.lat : lat;
	        } 
	        if(from.lat > to.lat){
	            lat = (lat < to.lat) ? to.lat : lat;
	            lat = (lat > from.lat) ? from.lat : lat;
	        }
	        return new Geo.LonLat(lon,lat);
	    }
	},
    
    
    /**
     * 该方法用于得到一条线的上的坐标，返回的坐标个数由用户输入的pointNum决定。
     * parameters:
     * from - {Object} 表示点坐标 例如:{x:10,y:10}。
     * to - {Object} 表示点坐标  例如:{x:5,y:5}。
     * pointNum {Number} 表示在该线上取多少个临时点。
     */
    _getPointsByNum: function(from, to, pointNum){
        var x1 = from.x;
        var y1 = from.y;
        var x0;
        var y0;
        var x2 = to.x;
        var y2 = to.y;
        var points = [];
        percentX = (x2 - x1) / (pointNum - 1);
        percentY = (y2 - y1) / (pointNum - 1);
        for (var i = 0; i < pointNum; i++) {
            x0 = x1 + percentX * i;
            y0 = y1 + percentY * i;
            points.push([x0, y0]);
        }
        return points;
    },
    
    /**
     * 该方法根据步长得到临时点。
     * parameters:
     * from - {Object} 表示线的一端。
     * to - {Object} 表示线的另一端。
     * percent 表示步长。
     */
    _getAllTempPointByPercent: function(from, to, percent){
        var tempPointArr = [];
        var i = 0;
        while (i < 1) {
            var x = getXorY(from.x, to.x, i);
            var y = getXorY(from.y, to.y, i);
            tempPointArr.push([x, y]);
            i += percent;
        }
        if (i >= 1) {
            tempPointArr.push([to.x, to.y]);
        }
        return tempPointArr;
    },
    
    //获取两点间线的角度
    _getMoveDirection: function(from, to){
        //以浮点型表示角度
        var dRotateAngle = Math.atan2(Math.abs(from.lon - to.lon), Math.abs(from.lat - to.lat));
        if (to.lon >= from.lon) {
            //第一象限
            if (to.lat >= from.lat) {
                dRotateAngle = dRotateAngle;
            }
            else {
                //第四象限
                dRotateAngle = Math.PI - dRotateAngle;
            }
            
        }
        else {
            //第二象限
            if (to.lat >= from.lat) {
                dRotateAngle = 2 * Math.PI - dRotateAngle;
            }
            else {
                //第四象限
                dRotateAngle = Math.PI + dRotateAngle;
            }
        }
        var angle = (dRotateAngle * 180) / Math.PI;
        return angle;
        
    },
    
    CLASS_NAME: "Geo.Animator"
});

/**
 * Class: Geo.AnimateZoomer
 * 地图图层的平滑缩放效果类。
 */
Geo.AnimateZoomer = Geo.Class({

    /**
     * Property: map
     * {<Geo.View2D.Map>} 二维地图对象。
     */
    map: null,
    
    /**
     * Property: currentStep
     * 动画当前帧号。
     */
    currentStep: 0,
    
    /**
     * APIProperty: totalStep
     * 动画帧数。
     */
    totalStep: 4,
    
    /**
     * APIProperty: intervalTime
     * 每帧间隔时间。
     */
    intervalTime: 90,
    
    /**
     * Property: animateIntervalId
     * 动画IntervalId。
     */
    animateIntervalId: null,
    
    /**
     * Property: bufferLayerContainer
     * 缓存图层容器，用于放置实现平滑效果的临时缓存图层。
     */
    bufferLayerContainer: null,
    
    /**
     * Property: zoomStep
     * 目标级别和当前级别的级别差。
     */
    zoomStep: null,
    
    /**
     * Property: layerLoaded
     * 当前平滑缩放的图层是否马上清除。
     */
    layerLoaded: false,
    
	/**
	 * Property: oraginPoint
	 * 原点位置。
	 */
    oraginPoint: null,
    
    /**
     * Constructor: Geo.AnimateZoomer
     * 构造函数。生成一个地图图层的平滑缩放效果对象。
     * 
     * Parameters:
     * map - {<Geo.View2D.Map>} 二维地图对象。
     * options - {Object} 相关选项设置。
     */
    initialize: function(map, options){
		this.handlers = {};
        if (map) {
            this.setMap(map);
        }
		OpenLayers.Util.extend(this, options);
		if (this.id == null) {
            this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
        }
    },
    
	/**
     * Method: setMap
     * 关联地图。
     * 
     * Parameters:
     * map - {<Geo.View2D.Map>} 二维地图对象。
	 */
    setMap: function(map){
        this.map = map;
        this.map.baseLayer.events.register("loadend", this, function(){
            this.layerLoaded = true;
            if (!this.isZoomAnimating()) {
                this.clearBufferLayer();
            }
        });
        
        this.handlers.wheel = new OpenLayers.Handler.MouseWheel(this, {
            "up": this.wheelUp,
            "down": this.wheelDown
        }, this.mouseWheelOptions);
		this.handlers.wheel.activate();
		
		var navs = this.map.getControlsByClass("OpenLayers.Control.Navigation");
		if(navs.length != 0){
			navs[0].disableZoomWheel();
		}

    },
	
    /** 
     * Method: wheelUp
     * 鼠标滚轮向上滚动。
     * 
     * Parameters:
     * evt - {Event}
     * delta - {Integer}
     */
    wheelUp: function(evt, delta) {
		var zoom = this.map.getZoom() + 1;
		if (!this.map.isValidZoomLevel(zoom)) {
            return;
        }
		if (this.map.enableAnimateZoomer) {
			this.playZoomAnimate(zoom, true);
		}
		this.wheelChange(evt, delta || 1);
    },

    /** 
     * Method: wheelDown
     * 鼠标滚轮向下滚动。
     * 
     * Parameters:
     * evt - {Event}
     * delta - {Integer}
     */
    wheelDown: function(evt, delta) {
		var zoom = this.map.getZoom() -1;
        if (!this.map.isValidZoomLevel(zoom)) {
            return;
        }
        if (this.map.enableAnimateZoomer) {
            this.playZoomAnimate(zoom, true);
        }
		this.wheelChange(evt, delta || -1);
    },
	
	/**
     * APIMethod: zoomIn
     * 地图放大一级。
	 */
    zoomIn: function(){
        this.zoomTo(this.map.getZoom() + 1);
    },
	
	/**
     * APIMethod: zoomOut
     * 地图缩小一级。
	 */
    zoomOut: function(){
        this.zoomTo(this.map.getZoom() - 1);
    },
    
    /** 
     * APIMethod: zoom
     * 平滑缩放至指定的级别。
     *
     * Parameters:
     * zoom - {Integer}
     */
    zoomTo: function(zoom){
        if (!this.map.isValidZoomLevel(zoom)) {
            return;
        }
		if (this.map.enableAnimateZoomer) {
			//this.layerLoaded = false;
        	this.playZoomAnimate(zoom);
		}
        this.map.zoomTo(zoom);
    },
    
    /** 
     * APIMethod: zoom
     * 地图缩放 zoomStep 级别。
     * 
     * Parameters:
     * zoomStep - {Integer} 目标级别和当前级别的级别差。
     */
    zoom: function(zoomStep){
        var map = this.map
        var zoom = map.getZoom() + zoomStep;
        
        if (!this.map.isValidZoomLevel(zoom)) {
            return;
        }
        this.playZoomAnimate(zoom);
        this.map.zoomTo(zoom);
    },
    
	/** 
     * APIMethod: playZoomAnimate
     * 开始播放动画。
     * 
     * Parameters:
     * zoom - {Integer} 目标级别。
     * lonlat - {<Geo.LonLat>} 平滑缩放的中心点，如果为null，则为地图的中心点。
     */
    playZoomAnimate: function(zoom, lonlat){
        if (lonlat) {
            // 设置为true。则鼠标滚轮滚动时，以鼠标光标为中心点扩散平滑缩放。
            this.zoomAnimateWheelEnabled = true;
        }
        else {
            // 设置为false。则级别平滑缩放，以地图中心点扩散平滑缩放。
            this.zoomAnimateWheelEnabled = false;
        }
        
        this.currentStep = 0;
        this.currentStep++;
        
        if (this.isZoomAnimating()) {
            this.stopZoomAnimate();
        }
        
        this.clearBufferLayer();
        
        //var layer = this.map.baseLayer;layer
        
        this.cloneLayersTile();
        
        if (this.bufferLayerContainer.childNodes.length == 0) {
            return;
        }
        
        this.hiddenAllLayers();
        
        var currentZoom, targetZoom;
        currentZoom = this.map.getZoom();
        targetZoom = zoom;
        this.zoomStep = targetZoom - currentZoom;
        
        this.oraginPoint = {
            top: parseInt(this.map.layerContainerDiv.style.top),
            left: parseInt(this.map.layerContainerDiv.style.left)
        }
		
		this.mousePosition = this.handlers.wheel.mousePosition;
		
        var zoomAnimateStep = OpenLayers.Function.bind(this.zoomAnimateStep, this);
		zoomAnimateStep();
        this.animateIntervalId = setInterval(zoomAnimateStep, this.intervalTime);
    },
    
	/** 
     * Method: zoomAnimateStep
     * 单步动画。
     */
    zoomAnimateStep: function(){
        if (this.shouldEndAnimate()) {
            this.stopZoomAnimate();
            if (this.layerLoaded) {
                this.clearBufferLayer();
            }
            else {
                this.backBufferLayer();
            }
            this.restoreAllLayers();
            return;
        }
        
        var ratioDelta = (Math.pow(2, this.zoomStep) - 1) / this.totalStep;
        var ratio = this.currentStep * ratioDelta;
        
        this.bufferLayerContainer.style.width = Math.round(100 * (1 + ratio)) + "px";
        this.bufferLayerContainer.style.height = Math.round(100 * (1 + ratio)) + "px";
        
        var centerPixel = this.map.getLayerPxFromLonLat(this.map.getCenter());
        //鼠标滚轮滚动时，以鼠标光标为中心点扩散平滑缩放。
        if (this.zoomAnimateWheelEnabled) {
            centerPixel = this.mousePosition || centerPixel;
        }
        centerPixel = centerPixel.add(-this.oraginPoint.left, -this.oraginPoint.top);
        
        var size = new OpenLayers.Size(1024, 512);
        
        var offsetRatioX = centerPixel.x / size.w;
        var offsetRatioY = centerPixel.y / size.h;
        var offsetX = Math.round(size.w * ratio * offsetRatioX);
        var offsetY = Math.round(size.h * ratio * offsetRatioY);
        
        this.bufferLayerContainer.style.left = this.oraginPoint.left - offsetX + "px";//
        this.bufferLayerContainer.style.top = this.oraginPoint.top - offsetY + "px";//
        this.currentStep++;
    },
    
	/** 
     * Method: frontBufferLayer
     * 把缓存图层的html元素容器显示移至地图前端。
     */
    frontBufferLayer: function(){
        this.bufferLayerContainer.style.zIndex = 746;
    },
	
	/** 
     * Method: backBufferLayer
     * 把缓存图层的html元素容器显示移至地图后端。
     */
    backBufferLayer: function(){
        this.bufferLayerContainer.style.zIndex = 99;
    },
    
	/** 
     * Method: stopZoomAnimate
     * 停止缩放动画，清除animateIntervalId。
     */
    stopZoomAnimate: function(){
        if (this.animateIntervalId) {
            clearInterval(this.animateIntervalId);
            this.animateIntervalId = null;
        }
        this.currentStep = 0;
    },
    
	/** 
     * Method: isZoomAnimating
     * 判断是否正处于动画中。
     */
    isZoomAnimating: function(){
        if (this.animateIntervalId) {
            return true;
        }
        return false;
    },
    
	/** 
     * Method: shouldEndAnimate
     * 根据当前帧号，判断是否应该结束动画。
     */
    shouldEndAnimate: function(){
        if (this.currentStep > this.totalStep) {
            return true;
        }
        return false;
    },
	
	/** 
     * Method: prepareAnimate
     */
    prepareAnimate: function(){
    
    },
	
	/** 
     * Method: hiddenAllLayers
     * 隐藏所有的图层。
     */
    hiddenAllLayers: function(){
        var layers = this.map.layers;
        for (var i = 0; i < layers.length; i++) {
            var layer = layers[i];
            layer.div.style.visibility = "hidden";
        }
        
    },
	
	/** 
     * Method: restoreAllLayers
     * 显示所有的图层。
     */
    restoreAllLayers: function(){
        var layers = this.map.layers;
        for (var i = 0; i < layers.length; i++) {
            var layer = layers[i];
            layer.div.style.visibility = "visible";
        }
        
    },
	
	/** 
     * Method: clearBufferLayer
     * 清除缓存的图层。
     */
    clearBufferLayer: function(){
        if (!this.map || !this.bufferLayerContainer) {
            return null;
        }
        
        this.map.layerContainerDiv.removeChild(this.bufferLayerContainer);
        this.bufferLayerContainer = null;
    },
    
	/** 
     * Method: clearBufferLayer
     * 复制当前显示的图层瓦片。
     */
    cloneLayersTile: function(){
    
        var bufferLayerContainer = document.createElement("div");
        bufferLayerContainer.id = "bufferLayerContainer";
        bufferLayerContainer.style.position = "absolute";
        bufferLayerContainer.style.zIndex = 749;
        bufferLayerContainer.style.width = "100px";
        bufferLayerContainer.style.height = "100px";
        
        bufferLayerContainer.style.left = this.map.layerContainerDiv.style.left;
        bufferLayerContainer.style.top = this.map.layerContainerDiv.style.top;
        
        for (var i = this.map.layers.length - 1; i >= 0; i--) {
            var layer = this.map.layers[i];
            // 复制当前显示的图层
            if (layer.div.style.display != "none") {
                if (layer.getVisibility() && layer.transitionEffect == "resize") {
                    var result = this.cloneSingleLayerTile(layer, bufferLayerContainer);
                }
            }
        }
        
        this.bufferLayerContainer = bufferLayerContainer;
        this.map.layerContainerDiv.appendChild(this.bufferLayerContainer);
        
        
    },
    
	/** 
     * Method: cloneSingleLayerTile
     * 复制单个图层瓦片至缓存图层的html元素容器内。
     * 
     * Parameters:
     * layer - {<Geo.View2D.Layer>} 图层对象。
     * bufferLayerContainer - {HTMLDivElement} 放置图层的html元素容器。
     */
    cloneSingleLayerTile: function(layer, bufferLayerContainer){
    
        if (!layer) {
            return;
        }
		
        var map = this.map;
        
        //瓦片图片矩阵
        var tileGrid = [];
        
        var grid = layer.grid;
        
        for (var i = 0, l1 = grid.length; i < l1; i++) {
            var tileGridRow = [];
            for (var j = 0, l2 = grid[i].length; j < l2; j++) {
                var tile = grid[i][j];
                var imgDiv = tile.imgDiv;
                var frame = tile.frame;
                var cloneImg;
                if (imgDiv && tile.shouldDraw) {
                    cloneImg = imgDiv.cloneNode(true);
					cloneImg.className = "olTileImage1";
                    cloneImg.id = imgDiv.id + "_clone";
                    
                    //复制瓦片外框div样式到图片
                    cloneImg.style.position = frame.style.position;
                    cloneImg.style.left = parseInt(frame.style.left) + "%";
                    cloneImg.style.top = parseInt(frame.style.top) + "%";
                    cloneImg.style.width = parseInt(frame.style.width) + "%";
                    cloneImg.style.height = parseInt(frame.style.height) + "%";
                    cloneImg.style.display = frame.style.display;
                    
                    cloneImg.style.zIndex = tile.layer.div.style.zIndex;
                    
                    bufferLayerContainer.appendChild(cloneImg);
                    
                    tileGridRow.push(cloneImg);
                }
            }
            tileGridRow.length && tileGrid.push(tileGridRow);
        }
    },
	
	/**
     * Method: wheelChange  
     *
     * Parameters:
     * evt - {Event}
     * deltaZ - {Integer}
     */
    wheelChange: function(evt, deltaZ) {
        var currentZoom = this.map.getZoom();
        var newZoom = this.map.getZoom() + Math.round(deltaZ);
        newZoom = Math.max(newZoom, 0);
        newZoom = Math.min(newZoom, this.map.getNumZoomLevels());
        if (newZoom === currentZoom) {
            return;
        }
        var size    = this.map.getSize();
        var deltaX  = size.w/2 - evt.xy.x;
        var deltaY  = evt.xy.y - size.h/2;
        var newRes  = this.map.baseLayer.getResolutionForZoom(newZoom);
        var zoomPoint = this.map.getLonLatFromPixel(evt.xy);
        var newCenter = new OpenLayers.LonLat(
                            zoomPoint.lon + deltaX * newRes,
                            zoomPoint.lat + deltaY * newRes );
        this.map.setCenter( newCenter, newZoom );
    },
	
	/**
     * Method: destroy
     * 销毁本对象。
     */
    destroy: function(){
        if (this.handler) {
            this.handler.destroy();
            this.handler = null;
        }
        if (this.handlers) {
            for (var key in this.handlers) {
                if (this.handlers.hasOwnProperty(key) &&
                typeof this.handlers[key].destroy == "function") {
                    this.handlers[key].destroy();
                }
            }
            this.handlers = null;
        }
    },
	
    CLASS_NAME: "Geo.AnimateZoomer"
});
	/**
	 * Class: Geo.Util
	 * 常用的一些函数。
	 */
	
	/**
	 * Property:englishColorToOx
	 * {Object} 颜色的英文字母表示法与RGB表示法对照表
	 */
	Geo.Util.englishColorToOx = {
		"black": "#000000",
		"blue":"#0000FF",
		"brown":"#A52A2A",
		"cyan":"#00FFFF",
		"gold":"#FFD700",
		"gray":"#808080",
		"green":"#008000",
		"lime":"#00FF00",
		"orange":"#FFA500",
		"red":"#FF0000",
		"white":"#FFFFFF",
		"yellow":"#FFFF00"
	};
	
	/**
     * Method: ToArgb
     * 
     * Parameters:
     * Rgb - {String} 颜色字符串,比如：#000000
     * Alpha - {Float} 取值范围：[0-1],0表示透明，1表示不透明
     * Returns:
     * {Integer} 
     */
	Geo.Util.ToArgb = function(Rgb, Alpha) {
		//将英文转换为"#"开头的颜色表示法
		var englishColorToOx = Geo.Util.englishColorToOx;
		for(var value in englishColorToOx) {
			if(value === Rgb) {
				Rgb = englishColorToOx[value].replace("#","");
			}
		}
		
        // rgb 颜色值
        var Rgb16 = parseInt(Rgb, 16);
        var strRGB = Rgb16.toString(2);
        var legnt = strRGB.length;
        if(legnt < 24) {
            for(i = 0; i < 24 - legnt; i++) {
                strRGB = "0" + strRGB;
            }
        }
        // int 值
        var argbStr = Alpha.toString(2) + strRGB;
        var flag = argbStr.substr(0, 1);
        if(flag == "1") {
            argbStr = argbStr.substr(1, 31);
            return 0 - (2147483647 - parseInt(argbStr, 2)) - 1;
        }
        else {
            return parseInt(Alpha.toString(2) + Rgb16.toString(2), 2);
        }
    };
	
	/**
     * APIMethod: getHexColor
     * 获取十六进制色码。
     * 
     * Parameters:
     * color - {String} 颜色字符串
     * 
     * Returns:
     * {String}
     */
	Geo.Util.getHexColor = function(color) {
		var _color = Geo.Util.englishColorToOx[color];
		var index = color.indexOf("#");
		var str = null;
		if(index == 0 && !_color) {
			var substr = color.substr(1);
			if(substr.length == 3) {
				str = substr.charAt(0)+substr.charAt(0)+substr.charAt(1)+substr.charAt(1)+ substr.charAt(2)+ substr.charAt(2);
			}else if(substr.length == 6) {
				str = substr;
			}
		}else if(index == -1 && _color) {
			str = _color.substr(1);
		}
		return "0x" + str;
	}
	
	/**
     * APIMethod: meterToDegree
	 * 根据地理坐标位置，将米转换成经纬度。
	 *
	 * Parameters:
	 * meter - {Number} 要转换的地理坐标。
	 * lonlat - {<Geo.LonLat>} 经纬度。
	 */
	Geo.Util.meterToDegree = function(meter,lonlat){
		var a = 0.00000899; //赤道上的距离1公里=0.000008993220293度
		var templat = lonlat.lat;
		return meter * ( a / Math.cos(OpenLayers.Util.rad(templat)) );
	};
	
	/**
     * APIMethod: webColorToHex
     * 转换颜色字符串为十进制，例如："#0000ff"转换成0x000000ff。
     * 
     * Parameters:
     * webcolor - {String} 颜色字符串
     * 
     * Returns:
     * {Integer} 十进制颜色数
     */
	Geo.Util.webColorToHex = function(webcolor) {
		return new Number("0x00" + webcolor.replace("#",""));
	}
	
	/**
     * APIMethod: replaceAll
     * 在字符串中查找某字符串，并全部替换成另外一个字符串。
     * 
     * Parameters:
     * string - {String} 字符串
     * find - {String} 要查找的字符串
     * replace - {String} 替换目标字符串
     * 
     * Returns:
     * {String} 替换后的结果字符串
     */      
    Geo.Util.replaceAll = function(string, find, replace) {
        replace = replace ? replace : "";
        return string.replace(new RegExp(find, "gm"), replace);
    };
	
	Geo.Util.Format = {};/**
 * Class: Geo.Pyramid
 * 金字塔对象类。
 * 金字塔对象类可以实现地理范围（坐标）与瓦片行、列属性之间的转换。
 * 地图对象必须有一个金字塔属性。本类的实例默认为地理坐标系统360度
 * 顶层瓦片金字塔方案。另外，包含了比例尺，分辨率和级别之间的转换。
 */
Geo.Pyramid = Geo.Class({

	/**
     * APIProperty: name
     * {String} 金字塔名称。
     */
	name : null,
	
	/**
     * APIProperty: pyramidID
     * {String} 金字塔ID。
     */
	pyramidID : null,
	
	/**
     * APIProperty: description
     * {String} 金字塔描述。
     */
	description : null,
	
	/**
     * APIProperty: topLevelIndex
     * {Number} 最顶层级别。
     */
	topLevelIndex : null,
	
	/**
	 * APIProperty: resolutions
	 * 分辨率数组，如果设置了分辨率数组，则maxResolution和minResolution设置了就无效
	 */
	resolutions: null,
	
	/**
     * APIProperty: bottomLevelIndex
     * {Number} 最底层级别。
     */	
	bottomLevelIndex : null,
	
	/**
     * APIProperty: scaleX
     * {Number} X轴放大系数。
     */	
	scaleX : null,
	
	/**
     * APIProperty: scaleY
     * {Number} Y轴放大系数。
     */		
	scaleY : null,
	
	/**
     * APIProperty: tileSize
     * {<Geo.Size>} 瓦片尺寸。
     */			
	tileSize: null,
	
	/**
     * APIProperty: originRowIndex
     * {Number} 瓦片行起始编号。
     */	
	originRowIndex: null,
	
	/**
     * APIProperty: originColIndex
     * {Number} 瓦片列起始编号。
     */		
	originColIndex: null,
	
	/**
     * APIProperty: topTileFromX
     * {Float} 顶层瓦片X轴坐标起点。
     */		
	topTileFromX:null,
	
	/**
     * APIProperty: topTileFromY
     * {Float} 顶层瓦片Y轴坐标起点。
     */	
	topTileFromY: null,
	
	/**
     * APIProperty: topTileToX
     * {Float} 顶层瓦片X轴坐标终点。
     */	
	topTileToX: null,
	
	/**
     * APIProperty: topTileToY
     * {Float} 顶层瓦片Y轴坐标终点。
     */	
	topTileToY: null,
	
	/**
     * APIProperty: units
     * {String} 金字塔的单位优先于地图的单位。默认为'degrees'。
     * 值可能为：'degrees' (or 'dd'), 'm', 'ft', 'km', 'mi', 'inches'.
     */
    units: 'degrees',
	
	/**
	 * Constructor: Geo.Pyramid
	 * 构造函数。
	 * 
	 * Parameters:
	 * options - {object} 金字塔设置选项。
	 */
	initialize : function (options){
		
		if (!options || options ==={}){
			options = Geo.Pyramid.DEFAULT_PYRAMID;
		}
		OpenLayers.Util.extend(this, options);	
	},

	/**
	 * APIMethod: getMaxExtent
	 * 根据根据金字塔对象相关定义获取最大范围。
	 * 
	 * Returns:
	 * {<Geo.Bounds>} 图层最大范围。
	 */	
	getMaxExtent: function(){
		var left,bottom,right,top;
		
		if(this.topTileFromX < this.topTileToX){
			left = this.topTileFromX;
			right = this.topTileToX;
		} else {
			right = this.topTileFromX;
			left = this.topTileToX;
		}
		
		if(this.topTileFromY < this.topTileToY){
			bottom = this.topTileFromY;
			top = this.topTileToY;
		} else {
			top = this.topTileFromY;
			bottom = this.topTileToY;
		}
		return new Geo.Bounds(left,bottom,right,top);
	},
	
	/**
	 * APIMethod: getResolutionForLevel
	 * 根据分辨率获取级别。
	 *
	 * Parameters:
	 * resolution - 指定分辨率。
	 * 
	 * Returns:
	 * {Integer} 级别。
	 */
	getLevelForResolution: function(resolution){
        if (!resolution) {
            return 0;
        }
		var zoom, i, diff;
		var minDiff = Number.POSITIVE_INFINITY;
		var resolutions = this.getResolutions();
		for (i = 0, len = resolutions.length; i < len; i++) {
			//判断当前分辨率与金字塔中分辨率最接近的
	        diff = Math.abs(resolutions[i] - resolution);
	        if (diff > minDiff) {
	            break;
	        }
	        minDiff = diff;
		}
		zoom = Math.max(0, i - 1);//0和(i - 1)中取大数。
		return zoom ;
	},
	
	/**
	 * APIMethod: getLevelForScale
	 * 根据比例尺获取级别。
	 *
	 * Parameters:
	 * scale - 指定比例尺。
	 * 
	 * Returns:
	 * {Integer} 级别。
	 */
	getLevelForScale: function(scale){
		var resolution = OpenLayers.Util.getResolutionFromScale(scale, this.units);
		var zoom = this.getLevelForResolution(resolution);
        return zoom ;
	},
	
	/**
	 * APIMethod: getResolutionForScale
	 * 根据比例尺获取分辨率。
	 *
	 * Parameters:
	 * scale - 指定比例尺。
	 * units - {String} 单位。
	 * 
	 * Returns:
	 * {float} 分辨率。
	 */
	getResolutionForScale: function(scale){
		var level = this.getLevelForScale(scale, this.units);
		var res = this.getResolutionForLevel(level)
        return res;
	},
	
	/**
	 * APIMethod: getResolutionForLevel
	 * 根据级别获取分辨率。
	 * 
	 * Parameters:
	 * level - 图层级别。
	 * 
	 * Returns:
	 * {float} 分辨率。
	 */
	getResolutionForLevel: function(level){
		var maxResolution = (this.getTopTileSize().w / this.tileSize.w) 
		return maxResolution / Math.pow(2, level);		
	},
	
	/**
	 * APIMethod: getMaxResolution
	 * 根据最大级别获取分辨率。
	 * 
	 * Returns:
	 * {float} 分辨率。
	 */
	getMaxResolution: function(){		
		return this.getResolutionForLevel(this.topLevelIndex)	
	},
	
	/**
	 * APIMethod: getResolutionForBottomLevel
	 * 根据最小级别获取分辨率。
	 * 
	 * Returns:
	 * {float} 分辨率。
	 */
	getMinResolution: function(){		
		return this.getResolutionForLevel(this.bottomLevelIndex)	
	},
	
	/**
	 * APIMethod: getResolutions
	 * 获取分辨率数组。
	 * 
	 * Returns:
	 * {Array} 分辨率数组。
	 */
	getResolutions: function(){
		var resolutions = new Array();
		for (var i = this.topLevelIndex; i <= this.bottomLevelIndex; i++) {
			resolutions.push(this.getResolutionForLevel(i));
		}
		return resolutions;
	},
	
	/**
	 * APIMethod: getNumZoomLevels
	 * 获取级别差。
	 * 
	 * Returns:
	 *  {Integer} 级别差。
	 */
	getNumZoomLevels: function(){
		return this.bottomLevelIndex - this.topLevelIndex + 1;
	},
	
	/**
	 * APIMethod: getTopTileSize
	 * 获取顶层瓦片尺寸。
	 * 
	 * Returns:
	 * {<Geo.Size>} 瓦片大小。
	 */	
	getTopTileSize : function(){
		var w = Math.abs(this.topTileToX - this.topTileFromX);
		var h = Math.abs(this.topTileToY - this.topTileFromY);
		return new Geo.Size(w,h);
	},
	
	/**
	 * APIMethod: getTileIndex
	 * 根据坐标和级别，获取瓦片所在行列号。
	 * 
	 * Parameters:
	 * lonlat - 经纬度坐标。
	 * level - 图层级别。
	 * 
	 * Returns:
	 * {Object} 返回瓦片的行列号。
	 */
	getTileIndex: function(lonlat, level){
			
		var lon = lonlat.lon;
		var lat = lonlat.lat;
		var size = this.getTopTileSize()
		var degree = size.w / Math.pow(2,level);
		
		//金字塔宽高
		var width = this.maxExtent.getWidth();
		var height = this.maxExtent.getHeight();
		
		//总行列数
		var totalCol = Math.round(width / degree);
		var totalRow = Math.round(height / degree);
		
		//计算列索引号
		var isStartLeft = (this.topTileFromX < this.topTileToX) ? true : false;
		var colIndex = Math.ceil(Math.abs(lon - this.topTileFromX)/degree) - 1;
		if(!isStartLeft){
			colIndex = totalCol - colIndex;
		}
		
		var isStartTop = (this.topTileFromY > this.topTileToY) ? true : false;
		var rowIndex = Math.ceil(Math.abs(lat - this.topTileFromY)/degree) - 1;
		if (!isStartTop){
			rowIndex = totalRow - rowIndex;
		}
		
		return {
			col: colIndex,
			row: rowIndex
		}

	},
	
	/**
	 * APIMethod: getTileInfoFromBounds
	 * 根据范围和级别获得最大最小行列号。
	 * 
	 * Parameters:
	 * bounds - 范围。
	 * level - 图层级别。
	 * 
	 * Returns:
	 * {Object} 返回最大最小行列号。
	 */
	getTileInfoFromBounds: function(bounds, level) {
		//判断原点
		var minTileObj = this.getTileIndex(new Geo.LonLat(bounds.left, bounds.top), level);
		var maxTileObj = this.getTileIndex(new Geo.LonLat(bounds.right, bounds.bottom), level);
		return {
			mincol: minTileObj.col,
			minrow: minTileObj.row,
			maxcol: maxTileObj.col,
			maxrow: maxTileObj.row
		}
	},
	
	/**
	 * 
	 */
	getTileInfoFromLonLat: this.getTileIndex,
	
	/**
	 * APIMethod: clone
	 * 复制对象。
	 * 
	 * Returns:
	 * {<Geo.Pyramid>} 金字塔对象。
	 */	
	clone: function(){
		return OpenLayers.Util.extend({},this);
	},
	
	CLASS_NAME : "Geo.Pyramid"
});

/**
 * APIProperty: Degree360
 * 360度金字塔定义。
 */
Geo.Pyramid.Degree360 = {
	//360度金字塔定义
	name : "360DegreePyramid",	
	topLevelIndex : 0,
	bottomLevelIndex : 20,
	scaleX : 2,
	scaleY :2,
	topTileFromX : -180.0,
	topTileFromY : 90.0,
	topTileToX : 180.0,
	topTileToY : -270.0,
	tileSize : new Geo.Size(256,256),
	originRowIndex : 0,
	originColIndex : 0,
	maxExtent : new Geo.Bounds(-180,-90,180,90)
};

/**
 * APIProperty: Degree18
 * 18度金字塔定义。
 */
Geo.Pyramid.Degree18 = {
	//18度金字塔定义
	name : "18DegreePyramid",
	topLevelIndex : 0,
	bottomLevelIndex : 20,
	scaleX : 2,
	scaleY :2,
	topTileFromX : -180.0,
	topTileFromY : -90.0,
	topTileToX : -162.0,
	topTileToY : -72.0,
	tileSize : new Geo.Size(256,256),
	originRowIndex : 0,
	originColIndex : 0,
	maxExtent : new Geo.Bounds(-180,-90,180,90)
};

/**
 * APIProperty: DEFAULT_PYRAMID
 * 默认金字塔定义（360度金字塔定义）。
 */
Geo.Pyramid.DEFAULT_PYRAMID = Geo.Pyramid.Degree360;/**
 * Class: Geo.SymbolizerManager
 * 符号组类。提供符号组的创建、删除和修改功能。默认提供常用的行业符号。
 */
Geo.SymbolizerManager = Geo.Class({

    /** 
     * Constructor: Geo.SymbolizerManager
     * Geo.SymbolizerManager类的构造函数。
     */
    initialize: function(){
    
    },
    
    /**
     * Method: getImagePath
     * 获取图片文件夹的相对路径。
     */
    getImagePath: function(){
        return Geo.getScriptLocation() + "img/";
    },
    
	/**
     * APIMethod: createSymbolizer
     * 创建符号组。
     * 
     * Parameters:
     * newSymbolizerType - {String} 新创建符号组的类型。
     * symbolizerGroup - {Array} 符号组内对象数组。
     * 		name {String} 新创建的符号组内单个符号对象的名称。
     * 		symbolizer {Object} 符号对象。
	 */
    createSymbolizer: function(newSymbolizerType, symbolizerGroup){
        Geo.SymbolizerManager.symbolizerGroup[newSymbolizerType] = {};
        for (var i = 0; i < symbolizerGroup.length; i++) {
			Geo.SymbolizerManager.symbolizerGroup[newSymbolizerType][symbolizerGroup[i].name] = symbolizerGroup[i].symbolizer;
        };
    },
    
	/**
     * APIMethod: updateSymbolizer
     * 根据符号组类型和符号名称，修改符号组内符号对象。
     * 
     * Parameters:
     * newSymbolizerType - {String} 符号组的类型。
     * name - {String} 被修改的符号组内单个符号对象的名称。
     * symbolizer - {Object} 新的符号对象。
	 */
    updateSymbolizer: function(symbolizerType, name, symbolizer){
        OpenLayers.Util.extend(Geo.SymbolizerManager.symbolizerGroup[symbolizerType][name], symbolizer);
    },
    
	/**
     * APIMethod: removeSymbolizer
     * 根据符号组类型和符号名称，删除符号组内符号对象。
     * 
     * Parameters:
     * symbolizerType - {String} 符号组的类型。
     * name - {String} 被删除的符号组内单个符号对象的名称。
	 */
    removeSymbolizer: function(symbolizerType, name){
        Geo.SymbolizerManager.symbolizerGroup[symbolizerType][name] = null;
        delete Geo.SymbolizerManager.symbolizerGroup[symbolizerType][name];
    },
    
	/**
     * APIMethod: getSymbolizerGroup
     * 获取符号组。
	 */
    getSymbolizerGroup: function(){
        return Geo.SymbolizerManager.symbolizerGroup;
    },
    
    CLASS_NAME: "Geo.SymbolizerManager"
});

/**
 * APIProperty: Geo.SymbolizerManager.symbolizerGroup
 * {Object} 符号组对象。
 */
Geo.SymbolizerManager.symbolizerGroup = {
    "COMMON": {
        "A": {
            externalGraphic: Geo.getScriptLocation() + "img/common/" + "0.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        },
        "B": {
            externalGraphic: Geo.getScriptLocation() + "img/common/" + "1.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        },
        "C": {
            externalGraphic: Geo.getScriptLocation() + "img/common/" + "2.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        },
        "D": {
            externalGraphic: Geo.getScriptLocation() + "img/common/" + "3.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        },
        "E": {
            externalGraphic: Geo.getScriptLocation() + "img/common/" + "4.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        },
        "F": {
            externalGraphic: Geo.getScriptLocation() + "img/common/" + "5.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        },
        "G": {
            externalGraphic: Geo.getScriptLocation() + "img/common/" + "6.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        },
        "H": {
            externalGraphic: Geo.getScriptLocation() + "img/common/" + "7.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        },
        "I": {
            externalGraphic: Geo.getScriptLocation() + "img/common/" + "8.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        },
        "J": {
            externalGraphic: Geo.getScriptLocation() + "img/common/" + "9.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        }
    }
};
/**
 * Class: Geo.GeoMarker
 * 可设置动画效果，自定义标签的标注类。
 */
Geo.GeoMarker = Geo.Class(Geo.Marker, {
    
    /** 
     * Constructor: Geo.GeoMarker
     * Geo.GeoMarker对象构造函数。
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>} 标注的地理坐标。
     * icon - {<Geo.View2D.Icon>}  标注的显示小图标对象。
     * tag - {<Geo.View2D.MarkerTag>}  标注的自定义标签对象。
     */
    initialize: function(lonlat, icon, tag) {
		this.tag = tag;
		Geo.Marker.prototype.initialize.apply(this, arguments);
    },
	
	/**
     * APIMethod: setAnimation
	 * 设置标注点的动画效果。
	 * 
     * Parameters:
     * animationType - {Integer} 动画效果的标识。有坠落动画(Geo.GeoMarker.ANIMATION_DROP)和跳动动画(Geo.GeoMarker.ANIMATION_BOUNCE)。
     * height - {Integer} 跳动的像素高度值。默认值为20。
     * ga - {Integer} 加速度，单位是px/s^2(像素每平方秒)。默认值为500。
	 */
	setAnimation: function(animationType, height, ga) {
		if(animationType !== Geo.GeoMarker.ANIMATION_DROP && animationType !== Geo.GeoMarker.ANIMATION_BOUNCE){
			return;
		}
		//跳动的像素高度值。
		var height = height ? height : 20;
		height = (height < 0) ? 0 : height;
		if(height == 0){
			return;
		}
		//动画的频率，每多少毫秒一帧。
		var ga = ga ? ga : 500;
		ga = (ga < 0) ? 0 : ga;
		if(ga == 0){
			return;
		}
		
        this.timerId && clearInterval(this.timerId);
		var size = this.icon.size;
		var icon = this.icon;
		
		//加速度
        var g = ga;
        var t = 0;
        var y0 = -size.h - height;
		//设置动画效果后，标注小图标会从距离坐标位置height个像素高度开始坠落。
		icon.offset.y = y0;
        //icon.moveTo();
		var b = false;
        var timerCallback = function(){
            if (b && animationType === Geo.GeoMarker.ANIMATION_DROP) {
                clearInterval(this.timerId);
				this.timerId = null;
                return;
            }
            t += 0.01;
            //t秒之后，物体下落的高度
            var s = g * t * t / 2;
            //物体实际的高度
            var y = y0 + s;
            if (y > -size.h) {
                y = -size.h;
                if (animationType === Geo.GeoMarker.ANIMATION_BOUNCE) {
                    t = -t;
                }
                b = true;
            }
            icon.offset.y = y;
            icon.moveTo();
        };
		
		this.timerId = window.setInterval(
            OpenLayers.Function.bind(timerCallback, this),
            10);
		
    },
	
    /**
     * Method: setContentHTML
     * 更改标签内容。
     * 
     * html - {String} 
     */
    setContentHTML: function(html) {
		if(this.tag){
			this.tag.setContentHTML(html);
		}
    },
	
    /** 
    * Method: drawTag
    * 绘制标签div。
    * 
    * Parameters:
    * px - {<Geo.Pixel>}
    * 
    * Returns:
    * {DOMElement} 返回一个新的标签的DOM div。
    */
    drawTag: function(px) {
        if(this.tag){
			return this.tag.draw(px);
		}
		return null;
    }, 

    /**
     * APIMethod: isDrawnTag
     * 是否已经绘制。
     * 
     * Returns:
     * {Boolean} 是否已经绘制，返回值为布尔类型。
     */
    isDrawnTag: function() {
        var isDrawn = (this.tag && this.tag.isDrawn());
        return isDrawn;   
    },
	
    /**
     * APIMethod: destroy
     * 销毁本对象。
     */
    destroy: function() {
        // erase any drawn features
        this.erase();

        this.map = null;

        this.events.destroy();
        this.events = null;

        if (this.icon != null) {
            this.icon.destroy();
            this.icon = null;
        }
        if (this.tag != null) {
            this.tag.destroy();
            this.tag = null;
        }
    },
	
	/** 
    * Method: erase
    * Erases any drawn elements for this marker.
    */
    erase: function() {
        if (this.icon != null) {
            this.icon.erase();
        }
        if (this.tag != null) {
            this.tag.erase();
        }
    },
	
    CLASS_NAME: "Geo.GeoMarker"
});

/**
 * Constant: ANIMATION_DROP
 * {Integer} 坠落动画。
 */
Geo.GeoMarker.ANIMATION_DROP = 1;

/**
 * Constant: ANIMATION_BOUNCE
 * {Integer} 跳动动画。 
 */
Geo.GeoMarker.ANIMATION_BOUNCE = 2;/**
 * Class: Geo.Uuid
 * 包含Geo.Math.uuid()方法，用于生成一个随机的uuid。
 */

/*!
Math.uuid.js (v1.4)
http://www.broofa.com
mailto:robert@broofa.com

Copyright (c) 2010 Robert Kieffer
Dual licensed under the MIT and GPL licenses.
*/

/*
 * Generate a random uuid.
 *
 * USAGE: Math.uuid(length, radix)
 *   length - the desired number of characters
 *   radix  - the number of allowable values for each character.
 *
 * EXAMPLES:
 *   // No arguments  - returns RFC4122, version 4 ID
 *   >>> Math.uuid()
 *   "92329D39-6F5C-4520-ABFC-AAB64544E172"
 * 
 *   // One argument - returns ID of the specified length
 *   >>> Math.uuid(15)     // 15 character ID (default base=62)
 *   "VcydxgltxrVZSTV"
 *
 *   // Two arguments - returns ID of the specified length, and radix. (Radix must be <= 62)
 *   >>> Math.uuid(8, 2)  // 8 character ID (base=2)
 *   "01001010"
 *   >>> Math.uuid(8, 10) // 8 character ID (base=10)
 *   "47473046"
 *   >>> Math.uuid(8, 16) // 8 character ID (base=16)
 *   "098F4D35"
 */
(function() {
  // Private array of chars to use
  var CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''); 

  Geo.Math.uuid = function (len, radix) {
    var chars = CHARS, uuid = [];
    radix = radix || chars.length;

    if (len) {
      // Compact form
      for (var i = 0; i < len; i++) uuid[i] = chars[0 | Math.random()*radix];
    } else {
      // rfc4122, version 4 form
      var r;

      // rfc4122 requires these characters
      uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';
      uuid[14] = '4';

      // Fill in random data.  At i==19 set the high bits of clock sequence as
      // per rfc4122, sec. 4.1.5
      for (var i = 0; i < 36; i++) {
        if (!uuid[i]) {
          r = 0 | Math.random()*16;
          uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
        }
      }
    }

    return uuid.join('');
  };

  // A more performant, but slightly bulkier, RFC4122v4 solution.  We boost performance
  // by minimizing calls to random()
  Geo.Math.uuidFast = function() {
    var chars = CHARS, uuid = new Array(36), rnd=0, r;
    for (var i = 0; i < 36; i++) {
      if (i==8 || i==13 ||  i==18 || i==23) {
        uuid[i] = '-';
      } else if (i==14) {
        uuid[i] = '4';
      } else {
        if (rnd <= 0x02) rnd = 0x2000000 + (Math.random()*0x1000000)|0;
        r = rnd & 0xf;
        rnd = rnd >> 4;
        uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
      }
    }
    return uuid.join('');
  };

  // A more compact, but less performant, RFC4122v4 solution:
  Geo.Math.uuidCompact = function() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
      return v.toString(16);
    }).toUpperCase();
  };
})();
/**
 * Class: Geo.Util.Format.BusCapabilities
 * 公交换乘服务Capabilities操作解析类，继承自Geo.Format.XML类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.Format.XML>
 */
Geo.Util.Format.BusCapabilities = Geo.Class(Geo.Format.XML,{
	
    /**
     * APIProperty: tagName
     * {String} 常量"NETWORK_Capabilities" ,根据该服务的getCapabilities请求返回而定。
     */
	tagName: "NETWORK_Capabilities",

	 /**
     * APIMethod: read
     * 解析一个XML串并返回capabilitiesObj｛Object｝对象。
     *
     * Parameters:
     * data - {String} 一个XML字符串。
     *
     * Returns:
     * ｛Object｝- capabilitiesObj
     */
    read: function(data){
		if(typeof data == "string") {
            data = Geo.Format.XML.prototype.read.apply(this, [data]);
        }
		
		var capabilitiesNode;
		if(data.nodeName != this.tagName){
			capabilitiesNode = data.getElementsByTagName(this.tagName);
		} else {
			capabilitiesNode = [data];
		}
		
		var capabilitiesObj = {};
		if(capabilitiesNode.length > 0){
			this.runChildNodes(capabilitiesObj, capabilitiesNode[0]);
		}
		return capabilitiesObj;
	},

	/**
     * Method: runChildNodes
     * 解析每一个节点字符串并把相对应值赋给传入最终返回的对象obj。
     *
     * Parameters:
     * obj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     * parentPath - {String}解析方法拼去，这里使用"capabilities"。
     * 
     */	
	runChildNodes: function(obj, node, parentPath) {
        var children = node.childNodes;
        var childNode, processor;
        for(var i=0; i<children.length; ++i) {
            childNode = children[i];
            if(childNode.nodeType == 1) {
				if(parentPath){
					processor = this["read_" + parentPath + "_" + childNode.nodeName];
				} else{
					processor = this["read_" + childNode.nodeName];
				}
                
                if(processor) {
                    processor.apply(this, [obj, childNode]);
                }
            }
        }
    },

	/**
     * Method: read_Service
     * 解析节点Service的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */	
	read_Service: function(capabilitiesObj, node){
		var serviceObj = {};
		this.runChildNodes(serviceObj, node, "Service");
		capabilitiesObj.service = serviceObj;
	},

	/**
     * Method: read_Service_Name
     * 解析节点为Name的节点。
     *
     * Parameters:
     * servcieObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */	
	read_Service_Name: function(servcieObj,node){
		var name = this.getChildValue(node);
		if(name) {
            servcieObj.name = name;
        }
	},

	/**
     * Method: read_Service_Title
     * 解析节点为Title的节点。
     *
     * Parameters:
     * servcieObj - {Object} 最终返回的对象
     * node - ｛DOMElement｝ 需要解析的节点对象
     */		
	read_Service_Title: function(servcieObj,node){
		var title = this.getChildValue(node);
		if(title) {
            servcieObj.title = title;
        }
	},

	/**
     * Method: read_Service_Abstract
     * 解析节点为Abstract的节点。
     *
     * Parameters:
     * servcieObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */	
	read_Service_Abstract: function(servcieObj,node){
		var serviceAbstract = this.getChildValue(node);
		if(serviceAbstract) {
            servcieObj.serviceAbstract = serviceAbstract;
        }
	},

	/**
     * Method: read_Service_KeywordList
     * 解析节点为KeywordList的节点。
     *
     * Parameters:
     * userScenarioObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Service_KeywordList: function(userScenarioObj,node){
	},

	/**
     * Method: read_Service_OnlineResource
     * 解析节点为OnlineResource的节点。
     *
     * Parameters:
     * servcieObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */	
	read_Service_OnlineResource: function(servcieObj,node){
		var onlineResource = this.getChildValue(node);
		if(servcieObj) {
            servcieObj.onlineResource = onlineResource;
        }
	},

	/**
     * Method: read_Capability
     * 解析节点为Capability的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability: function(capabilitiesObj,node){
		var capaObj = {};
		this.runChildNodes(capaObj, node, "Capability");
		capabilitiesObj.capability = capaObj;
	},

	/**
     * Method: read_Capability_Request
     * 解析节点为Request的节点。
     *
     * Parameters:
     * capaObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request: function(capaObj,node){
		var requestObj = {};
		this.runChildNodes(requestObj, node, "Capability_Request");
		capaObj.request = requestObj;
	},

	/**
     * Method: read_Capability_Request_GetCapabilities
     * 解析节点为GetCapabilities的节点。
     *
     * Parameters:
     * requestObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request_GetCapabilities: function(requestObj,node){
		var httpNode = node.getElementsByTagName("HTTP");
		var getCapaObj ={};
		if(httpNode[0]){
			this.runChildNodes(getCapaObj, httpNode[0], "Capability_Request_GetCapabilities_DCPType_HTTP");
		}
		requestObj.getCapabilities = getCapaObj;
		
	},

	/**
     * Method: read_Capability_Request_GetCapabilities_DCPType_HTTP_Get
     * 解析节点为DCPType_HTTP_Get的节点。
     *
     * Parameters:
     * getCapaObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */	
	read_Capability_Request_GetCapabilities_DCPType_HTTP_Get: function(getCapaObj,node){
		var getUrl = node.getAttribute("onlineResource");
		if(getUrl) {
            getCapaObj.getUrl = getUrl;
        }
	},

	/**
     * Method: read_Capability_Request_GetCapabilities_DCPType_HTTP_Post
     * 解析节点为DCPType_HTTP_Post的节点。
     *
     * Parameters:
     * getCapaObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */	
	read_Capability_Request_GetCapabilities_DCPType_HTTP_Post: function(getCapaObj,node){
		var postUrl = node.getAttribute("onlineResource");
		if(postUrl) {
            getCapaObj.postUrl = postUrl;
        }
	},
	
	/**
     * Method: read_Capability_Request_queryStation
     * 解析节点为queryStation的节点。
     *
     * Parameters:
     * requestObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request_queryStation: function(requestObj,node){
		var httpNode = node.getElementsByTagName("HTTP");
		var queryStationObj = {};
		if(httpNode[0]){
			this.runChildNodes(queryStationObj, httpNode[0], "Capability_Request_queryStation_DCPType_HTTP");
		}
		requestObj.queryStation = queryStationObj;
		
	},

	/**
     * Method: read_Capability_Request_queryStation_DCPType_HTTP_Get
     * 解析节点为DCPType_HTTP_Get的节点。
     *
     * Parameters:
     * queryStationObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */	
	read_Capability_Request_queryStation_DCPType_HTTP_Get: function(queryStationObj,node){
		var getUrl = node.getAttribute("onlineResource");
		if(getUrl) {
            queryStationObj.getUrl = getUrl;
        }
	},
	
	read_Capability_Request_queryStation_DCPType_HTTP_Post: function(queryStationObj,node){
		var postUrl = node.getAttribute("onlineResource");
		if(postUrl) {
            queryStationObj.postUrl = postUrl;
        }
	},

	/**
     * Method: read_Capability_Request_queryLine
     * 解析节点为queryLine的节点。
     *
     * Parameters:
     * requestObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request_queryLine: function(requestObj,node){
		var httpNode = node.getElementsByTagName("HTTP");
		var queryLineObj = {};
		if(httpNode[0]){
			this.runChildNodes(queryLineObj, httpNode[0], "Capability_Request_queryLine_DCPType_HTTP");
		}
		requestObj.queryLine = queryLineObj;
		
	},

	/**
     * Method: read_Capability_Request_queryLine_DCPType_HTTP_Get
     * 解析节点为DCPType_HTTP_Get的节点。
     *
     * Parameters:
     * queryLineObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */			
	read_Capability_Request_queryLine_DCPType_HTTP_Get: function(queryLineObj,node){
		var getUrl = node.getAttribute("onlineResource");
		if(getUrl) {
            queryLineObj.getUrl = getUrl;
        }
	},

	/**
     * Method: read_Capability_Request_queryLine_DCPType_HTTP_Post
     * 解析节点为DCPType_HTTP_Post的节点。
     *
     * Parameters:
     * queryLineObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request_queryLine_DCPType_HTTP_Post: function(queryLineObj,node){
		var postUrl = node.getAttribute("onlineResource");
		if(postUrl) {
            queryLineObj.postUrl = postUrl;
        }	
	},

	/**
     * Method: read_Capability_Request_queryChange
     * 解析节点为queryChange的节点。
     *
     * Parameters:
     * requestObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request_queryChange: function(requestObj,node){
		var httpNode = node.getElementsByTagName("HTTP");
		var queryChangeObj = {};
		if(httpNode[0]){
			this.runChildNodes(queryChangeObj, httpNode[0], "Capability_Request_queryChange_DCPType_HTTP");
		}
		
	},

	/**
     * Method: read_Capability_Request_queryChange_DCPType_HTTP_Get
     * 解析节点为DCPType_HTTP_Get的节点。
     *
     * Parameters:
     * queryChangeObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request_queryChange_DCPType_HTTP_Get: function(queryChangeObj,node){
		var getUrl = node.getAttribute("onlineResource");
		if(getUrl) {
            queryChangeObj.getUrl = getUrl;
        }
	},

	/**
     * Parameters: read_Capability_Request_queryChange_DCPType_HTTP_Post
     * 解析节点为DCPType_HTTP_Post的节点。
     *
     * Method:
     * queryChangeObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request_queryChange_DCPType_HTTP_Post: function(queryChangeObj,node){
		var postUrl = node.getAttribute("onlineResource");
		if(postUrl) {
            queryChangeObj.postUrl = postUrl;
        }	
	},

	/**
     * Method: read_Capability_Networks
     * 解析节点为Networks的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Networks: function(capabilitiesObj,node){		
		var networkNodes = node.getElementsByTagName("Name");
		var networks = [];
		for(var i=0; i<networkNodes.length; i++){
			var network = this.getChildValue(networkNodes[i]);
			if(network){
				networks.push(network);
			}			
		}
		capabilitiesObj.networks = networks;
	},
	
	CLASS_NAME:"Geo.Util.Format.BusCapabilities"
});/**
 * Class: Geo.Util.Format.GlobeTileCapabilities
 * GlobeTile服务getCapabilities操作请求结果的XML解析器，继承自Geo.Format.XML类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.Format.XML>
 */
Geo.Util.Format.GlobeTileCapabilities = Geo.Class(Geo.Format.XML,{
	
   /**
     * APIProperty: tagName
     * {String} 常量"ServiceCapabilities" ,根据该服务的getCapabilities请求返回而定。
     */
	tagName: "ServiceCapabilities",

	 /**
     * APIMethod: read
     * 解析一个XML串并返回capabilitiesObj{Object}对象。
     *
     * Parameters:
     * data - {String} 一个XML字符串。
     *
     * Returns:
     * {Object}- capabilitiesObj
     */
    read: function(data){
		if(typeof data == "string") {
            data = Geo.Format.XML.prototype.read.apply(this, [data]);
        }
		
		var capabilitiesNode;
		if(data.nodeName != this.tagName){
			capabilitiesNode = data.getElementsByTagName(this.tagName);
		} else {
			capabilitiesNode = [data];
		}
		
		var capabilitiesObj = null;
		if(capabilitiesNode.length > 0){
			capabilitiesObj = {};
			this.runChildNodes(capabilitiesObj, capabilitiesNode[0], "capabilities");
		}
		return capabilitiesObj;
	},
	
	/**
     * Method: runChildNodes
     * 解析每一个节点字符串并把相对应值赋给传入最终返回的对象obj。
     *
     * Parameters:
     * obj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     * parentPath - {String}解析方法拼去，这里使用"capabilities"。
     * 
     */
	runChildNodes: function(obj, node, parentPath) {
        var children = node.childNodes;
        var childNode, processor;
        for(var i=0; i<children.length; ++i) {
            childNode = children[i];
            if(childNode.nodeType == 1) {
                processor = this["read_" + parentPath + "_" + childNode.nodeName];
                if(processor) {
                    processor.apply(this, [obj, childNode]);
                }
            }
        }
    },
	
	/**
     * Method: read_capabilities_Name
     * 解析节点为Name的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Name: function(capabilitiesObj, node){
		var name = this.getChildValue(node);
        if(name) {
            capabilitiesObj.name = name;
        }
	},
	
	/**
     * Method: read_capabilities_Service
     * 解析节点为Service的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Service: function(capabilitiesObj, node){
		var service = this.getChildValue(node);
        if(service) {
            capabilitiesObj.service = service;
        }
	},
	
	/**
     * Method: read_capabilities_Version
     * 解析节点为Version的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Version: function(capabilitiesObj, node){
		var version = this.getChildValue(node);
        if(version) {
            capabilitiesObj.version = version;
        }
	},
	
	/**
     * Method: read_capabilities_Abstract
     * 解析节点为Abstract的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Abstract: function(capabilitiesObj, node){
		var abstractValue = this.getChildValue(node);
        if(abstractValue) {
            capabilitiesObj.abstractValue = abstractValue;
        }
	},
	
	/**
     * Method: read_capabilities_ServerAddress
     * 解析节点为ServerAddress的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_ServerAddress: function(capabilitiesObj, node){
		var serverAddress = this.getChildValue(node);
        if(serverAddress) {
            capabilitiesObj.serverAddress = serverAddress;
        }
	},
	
	/**
     * Method: read_capabilities_OperationList
     * 解析节点为OperationList的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_OperationList: function(capabilitiesObj, node){
		var operationsNode = node.getElementsByTagName("Operations");
		if(operationsNode.length > 0){
			this.read_capabilities_OperationList_Operations(capabilitiesObj, operationsNode[0]);
		}
	},	
	
	/**
     * Method: read_capabilities_OperationList_Operations
     * 解析节点为Operations的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_OperationList_Operations: function(capabilitiesObj, node){
		var operationList = {};
		var operations = {};
		this.runChildNodes(operations, node, "capabilities_OperationList_Operations");
		operationList.operations = operations;
		capabilitiesObj.operationList = operationList;
	},	
	
	/**
     * Method: read_capabilities_OperationList_Operations_GetTile
     * 解析节点为GetTile的节点。
     *
     * Parameters:
     * operations - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_OperationList_Operations_GetTile: function(operations, node){
		var getTile = {};
		var format = [];
		var formatNode = node.getElementsByTagName("Format");
		if (formatNode.length > 0) {
			for(var i = 0; i < formatNode.length; i++){
				var formatValue = this.getChildValue(formatNode[i]);
				format.push(formatValue);
			}
			getTile.format = format;
		}
		operations.getTile = getTile;
	},
	
	/**
     * Method: read_capabilities_Data
     * 解析节点为Data的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data: function(capabilitiesObj, node){
		var tileDataNode = node.getElementsByTagName("TileData");
		if(tileDataNode.length > 0){
			this.read_capabilities_Data_TileData(capabilitiesObj, tileDataNode[0]);
		}
	},
	
	/**
     * Method: read_capabilities_Data_TileData
     * 解析节点为Data_TileData的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData: function(capabilitiesObj, node){
		var tileData = {}
		this.runChildNodes(tileData, node, "capabilities_Data_TileData");
		capabilitiesObj.tileData = tileData;
	},
	
	/**
     * Method: read_capabilities_Data_TileData_Tile
     * 解析节点为Tile的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_Tile: function(tileData, node){
		var tile = this.getChildValue(node);
        if(tile) {
            tileData.tile = tile;
        }
	},
	
	/**
     * Method: read_capabilities_Data_TileData_CRS
     * 解析节点为CRS的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_CRS: function(tileData, node){
		var crs = this.getChildValue(node);
        if(crs) {
            tileData.crs = crs;
        }
	},
	
	/**
     * Method: read_capabilities_Data_TileData_BoundBox
     * 解析节点为BoundBox的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_BoundBox: function(tileData, node){
		
		var boundBox = new Geo.Bounds(
			parseFloat(node.getAttribute("minx") || node.getAttribute("minX")),
			parseFloat(node.getAttribute("miny") || node.getAttribute("minY")),
			parseFloat(node.getAttribute("maxx") || node.getAttribute("maxX")),
			parseFloat(node.getAttribute("maxy") || node.getAttribute("maxY"))
		);
        tileData.boundBox = boundBox;
        
	},
	
	/**
     * Method: read_capabilities_Data_TileData_LevelZeroTileSizeX
     * 解析节点为LevelZeroTileSizeX的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_LevelZeroTileSizeX: function(tileData, node){
		var levelZeroTileSizeX = this.getChildValue(node);
        if(levelZeroTileSizeX) {
            tileData.levelZeroTileSizeX = parseInt(levelZeroTileSizeX);
        }
	},
	
	/**
     * Method: read_capabilities_Data_TileData_LevelZeroTileSizeY
     * 解析节点为LevelZeroTileSizeY的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_LevelZeroTileSizeY: function(tileData, node){
		var levelZeroTileSizeY = this.getChildValue(node);
        if(levelZeroTileSizeY) {
            tileData.levelZeroTileSizeY = parseInt(levelZeroTileSizeY);
        }
	},
	
	/**
     * Method: read_capabilities_Data_TileData_TopLevel
     * 解析节点为TopLevel的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_TopLevel: function(tileData, node){
		var topLevel = this.getChildValue(node);
        if(topLevel) {
            tileData.topLevel = parseInt(topLevel);
        }
	},
	
	/**
     * Method: read_capabilities_Data_TileData_BottomLevel
     * 解析节点为BottomLevel的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_BottomLevel: function(tileData, node){
		var bottomLevel = this.getChildValue(node);
        if(bottomLevel) {
            tileData.bottomLevel = parseInt(bottomLevel);
        }
	},
	
	/**
     * Method: read_capabilities_Data_TileData_TileVersionTime
     * 解析节点为TileVersionTime的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_TileVersionTime: function(tileData, node){
		var tileVerstionTime = this.getChildValue(node);
		if(tileVerstionTime){
			if(!tileData.tileVerstionTime){
				tileData.tileVerstionTime = []
			}
			tileData.tileVerstionTime.push(tileVerstionTime);
		}
	},
	
	/**
     * Method: read_capabilities_Data_TileData_TilePixelsX
     * 解析节点为TilePixelsX的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_TilePixelsX: function(tileData, node){
		var tilePixelsX = this.getChildValue(node);
        if(tilePixelsX) {
            tileData.tilePixelsX = parseInt(tilePixelsX);
        }
	},
	
	/**
     * Method: read_capabilities_Data_TileData_TilePixelsY
     * 解析节点为TilePixelsY的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_TilePixelsY: function(tileData, node){
		var tilePixelsY = this.getChildValue(node);
        if(tilePixelsY) {
            tileData.tilePixelsY = parseInt(tilePixelsY);
        }
	},
	
	/**
     * Method: read_capabilities_Data_TileData_CacheExpireTime
     * 解析节点为CacheExpireTime的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_CacheExpireTime: function(tileData, node){
		var cacheExpireTime = this.getChildValue(node);
        if(cacheExpireTime) {
            tileData.cacheExpireTime = parseInt(cacheExpireTime);
        }
	},
	
	/**
     * Method: read_capabilities_Data_TileData_Pyramid
     * 解析节点为Pyramid的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_Pyramid: function(tileData, node){
        var parser = new Geo.Util.Format.Pyramid();
		var pyramidObj = parser.read(node);
		tileData.pyramid = pyramidObj;
	},
	
	CLASS_NAME:"Geo.Util.Format.GlobeTileCapabilities"
});/**
 * Class: Geo.Util.Format.Pyramid
 * 金字塔XML描述解析器，继承自Geo.Format.XML类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.Format.XML>
 */
Geo.Util.Format.Pyramid = Geo.Class(Geo.Format.XML,{
	
	 /**
     * APIProperty: tagName
     * {String} 金字塔标签名，默认为"Pyramid" 。
     */
	tagName: "Pyramid",

	/**
     * APIMethod: read
     * 解析金字塔XML描述字符串并返回解析后的JavaScript对象。
     *
     * Parameters:
     * data - {String} 一个XML字符串。
     *
     * Returns:
     * {Object}- pyramidObj
     */
    read: function(data){
		if(typeof data == "string") {
            data = Geo.Format.XML.prototype.read.apply(this, [data]);
        }
		
		var pyramidNode;
		if(data.nodeName != this.tagName){
			pyramidNode = data.getElementsByTagName(this.tagName);
		} else {
			pyramidNode = [data];
		}
		var pyramidObj = {};
		if(pyramidNode.length > 0){
			this.runChildNodes(pyramidObj, pyramidNode[0]);
		}
		return pyramidObj;
	},
	
	/**
     * Method: runChildNodes
     * 解析每一个节点字符串并把相对应值赋给传入最终返回的对象obj。
     *
     * Parameters:
     * obj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     * 
     */
	runChildNodes: function(obj, node) {
        var children = node.childNodes;
        var childNode, processor;
        for(var i=0; i<children.length; ++i) {
            childNode = children[i];
            if(childNode.nodeType == 1) {
                processor = this["read_Pyramid_" + childNode.nodeName];
                if(processor) {
                    processor.apply(this, [obj, childNode]);
                }
            }
        }
    },
	
	/**
     * Method: read_Pyramid_Basic
     * 解析节点为Basic的节点。
     *
     * Parameters:
     * pyramidObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_Pyramid_Basic: function(pyramidObj, node){
		var basic = {
			name: node.getAttribute("Name"),
			pyramidID: node.getAttribute("PyramidID"),
			description: node.getAttribute("Description")
		};
		OpenLayers.Util.extend(pyramidObj, basic);
	},
	
	/**
     * Method: read_Pyramid_Level
     * 解析节点为Level的节点。
     *
     * Parameters:
     * pyramidObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_Pyramid_Level: function(pyramidObj, node){
		var level = {
			topLevelIndex: parseInt(node.getAttribute("TopLevelIndex")),
			bottomLevelIndex: parseInt(node.getAttribute("BottomLevelIndex")),
			scaleX: parseInt(node.getAttribute("ScaleX")),
			scaleY: parseInt(node.getAttribute("ScaleY"))
		};
		OpenLayers.Util.extend(pyramidObj, level);
	},
	
	/**
     * Method: read_Pyramid_TileBasic
     * 解析节点为TileBasic的节点。
     *
     * Parameters:
     * pyramidObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_Pyramid_TileBasic: function(pyramidObj, node){
		var tileBasic = {
			tileSizeX: parseFloat(node.getAttribute("TileSizeX")),
			tileSizeY: parseFloat(node.getAttribute("TileSizeY")),
			originRowIndex: parseInt(node.getAttribute("OriginRowIndex")),
			originColIndex: parseInt(node.getAttribute("OriginColIndex"))
		};
		OpenLayers.Util.extend(pyramidObj, tileBasic);
	},
	
	/**
     * Method: read_Pyramid_TopTile
     * 解析节点为TopTile的节点。
     *
     * Parameters:
     * pyramidObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_Pyramid_TopTile: function(pyramidObj, node){
		var topTile = {
			fromX: parseInt(node.getAttribute("FromX")),
			fromY: parseInt(node.getAttribute("FromY")),
			toX: parseInt(node.getAttribute("ToX")),
			toY: parseInt(node.getAttribute("ToY"))
		};
		OpenLayers.Util.extend(pyramidObj, topTile);
	},
	
	//无用，暂时关闭
	/*read_Pyramid_Const: function(pyramidObj, node){
		var constant = {
			pi: parseFloat(node.getAttribute("PI")),
			tolerance: parseFloat(node.getAttribute("Tolerance"))
		};
		OpenLayers.Util.extend(pyramidObj, constant);
	},*/
	
	/**
     * Method: read_Pyramid_Range
     * 解析节点为Range的节点。
     *
     * Parameters:
     * pyramidObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_Pyramid_Range: function(pyramidObj, node){
		var range = {
			xmin: parseInt(node.getAttribute("XMin")),
			xmax: parseInt(node.getAttribute("XMax")),
			ymin: parseInt(node.getAttribute("YMin")),
			ymax: parseInt(node.getAttribute("YMax"))
		};
		OpenLayers.Util.extend(pyramidObj, range);
	},
	
	CLASS_NAME: "Geo.Util.Format.Pyramid"	
});
/**
 * Class: Geo.Util.Format.XML2JSON
 * 将XML文件解析成Javascript对象。
 */
Geo.Util.Format.XML2JSON = Geo.Class({
	
	/**
	 * Constructor: Geo.Util.Format.XML2JSON
	 * Geo.Util.Format.XML2JSON构造函数。
	 */
	initialize: function(){
		
	},
	
    /**
	 * APIMethod: read
	 * 将传入的XML字符串解析成Javascript对象并返回。
	 *
	 * Parameters: 
	 * xmlcode - {String} XML字符串。
	 */	
	read: function(xmlcode,ignoretags,debug){
		if(!ignoretags){ignoretags=""};
		xmlcode=xmlcode.replace(/\s*\/>/g,'/>');
		xmlcode=xmlcode.replace(/<\?[^>]*>/g,"").replace(/<\![^>]*>/g,"");
		if (!ignoretags.sort){ignoretags=ignoretags.split(",")};
		var x=this.no_fast_endings(xmlcode);
		x=this.attris_to_tags(x);
		x=escape(x);
		x=x.split("%3C").join("<").split("%3E").join(">").split("%3D").join("=").split("%22").join("\"");
		for (var i=0;i<ignoretags.length;i++){
			x=x.replace(new RegExp("<"+ignoretags[i]+">","g"),"*$**"+ignoretags[i]+"**$*");
			x=x.replace(new RegExp("</"+ignoretags[i]+">","g"),"*$***"+ignoretags[i]+"**$*")
		};
		x='<JSONTAGWRAPPER>'+x+'</JSONTAGWRAPPER>';
		this.xmlobject={};
		
		//---------------------修正禁止属性小写后,出现jsontagwrapper变成数组
		var y=this.xml_to_object(x).JSONTAGWRAPPER;
		//var y=this.xml_to_object(x).jsontagwrapper;
		
		if(debug){y=this.show_json_structure(y,debug)};
		return y
	},
	
	xml_to_object:function(xmlcode){
		var x=xmlcode.replace(/<\//g,"?");
		x=x.split("<");
		var y=[];
		var level=0;
		var opentags=[];
		for (var i=1;i<x.length;i++){
			var tagname=x[i].split(">")[0];
			opentags.push(tagname);
			level++
			y.push(level+"<"+x[i].split("?")[0]);
			while(x[i].indexOf("?"+opentags[opentags.length-1]+">")>=0){level--;opentags.pop()}
		};
		var oldniva=-1;
		var objname="this.xmlobject";
		for (var i=0;i<y.length;i++){
			var preeval="";
			var niva=y[i].split("<")[0];
			var tagnamn=y[i].split("<")[1].split(">")[0];
			
			//---------------------修正:禁止将属性和标签统一成小写,并将命名空间的冒号转成下划线
			tagnamn = tagnamn.replace(/%3A/,"_");
			//tagnamn=tagnamn.toLowerCase();
			
			var rest=y[i].split(">")[1];
			if(niva<=oldniva){
				var tabort=oldniva-niva+1;
				for (var j=0;j<tabort;j++){objname=objname.substring(0,objname.lastIndexOf("."))}
			};
			objname+="."+tagnamn;
			var pobject=objname.substring(0,objname.lastIndexOf("."));
			if (eval("typeof "+pobject) != "object"){preeval+=pobject+"={value:"+pobject+"};\n"};
			var objlast=objname.substring(objname.lastIndexOf(".")+1);
			var already=false;
			for (k in eval(pobject)){if(k==objlast){already=true}};
			var onlywhites=true;
			for(var s=0;s<rest.length;s+=3){
				if(rest.charAt(s)!="%"){onlywhites=false}
			};
			if (rest!="" && !onlywhites){
				if(rest/1!=rest){
					rest="'"+rest.replace(/\'/g,"\\'")+"'";
					rest=rest.replace(/\*\$\*\*\*/g,"</");
					rest=rest.replace(/\*\$\*\*/g,"<");
					rest=rest.replace(/\*\*\$\*/g,">")
				}
			} 
			else {rest="{}"};
			if(rest.charAt(0)=="'"){rest='unescape('+rest+')'};
			if (already && !eval(objname+".sort")){preeval+=objname+"=["+objname+"];\n"};
			var before="=";after="";
			if (already){before=".push(";after=")"};
			var toeval=preeval+objname+before+rest+after;
			eval(toeval);
			if(eval(objname+".sort")){objname+="["+eval(objname+".length-1")+"]"};
			oldniva=niva
		};
		return this.xmlobject
	},
	show_json_structure:function(obj,debug,l){
		var x='';
		if (obj.sort){x+="[\n"} else {x+="{\n"};
		for (var i in obj){
			if (!obj.sort){x+=i+":"};
			if (typeof obj[i] == "object"){
				x+=this.show_json_structure(obj[i],false,1)
			}
			else {
				if(typeof obj[i]=="function"){
					var v=obj[i]+"";
					//v=v.replace(/\t/g,"");
					x+=v
				}
				else if(typeof obj[i]!="string"){x+=obj[i]+",\n"}
				else {x+="'"+obj[i].replace(/\'/g,"\\'").replace(/\n/g,"\\n").replace(/\t/g,"\\t").replace(/\r/g,"\\r")+"',\n"}
			}
		};
		if (obj.sort){x+="],\n"} else {x+="},\n"};
		if (!l){
			x=x.substring(0,x.lastIndexOf(","));
			x=x.replace(new RegExp(",\n}","g"),"\n}");
			x=x.replace(new RegExp(",\n]","g"),"\n]");
			var y=x.split("\n");x="";
			var lvl=0;
			for (var i=0;i<y.length;i++){
				if(y[i].indexOf("}")>=0 || y[i].indexOf("]")>=0){lvl--};
				tabs="";for(var j=0;j<lvl;j++){tabs+="\t"};
				x+=tabs+y[i]+"\n";
				if(y[i].indexOf("{")>=0 || y[i].indexOf("[")>=0){lvl++}
			};
			if(debug=="html"){
				x=x.replace(/</g,"&lt;").replace(/>/g,"&gt;");
				x=x.replace(/\n/g,"<BR>").replace(/\t/g,"&nbsp;&nbsp;&nbsp;&nbsp;")
			};
			if (debug=="compact"){x=x.replace(/\n/g,"").replace(/\t/g,"")}
		};
		return x
	},
	no_fast_endings:function(x){
		x=x.split("/>");
		for (var i=1;i<x.length;i++){
			var t=x[i-1].substring(x[i-1].lastIndexOf("<")+1).split(" ")[0];
			x[i]="></"+t+">"+x[i]
		}	;
		x=x.join("");
		return x
	},
	attris_to_tags: function(x){
		var d=' ="\''.split("");
		x=x.split(">");
		for (var i=0;i<x.length;i++){
			var temp=x[i].split("<");
			for (var r=0;r<4;r++){temp[0]=temp[0].replace(new RegExp(d[r],"g"),"_jsonconvtemp"+r+"_")};
			if(temp[1]){
				temp[1]=temp[1].replace(/'/g,'"');
				temp[1]=temp[1].split('"');
				for (var j=1;j<temp[1].length;j+=2){
					for (var r=0;r<4;r++){temp[1][j]=temp[1][j].replace(new RegExp(d[r],"g"),"_jsonconvtemp"+r+"_")}
				};
				temp[1]=temp[1].join('"')
			};
			x[i]=temp.join("<")
		};
		x=x.join(">");
		x=x.replace(/ ([^=]*)=([^ |>]*)/g,"><$1>$2</$1");
		x=x.replace(/>"/g,">").replace(/"</g,"<");
		for (var r=0;r<4;r++){x=x.replace(new RegExp("_jsonconvtemp"+r+"_","g"),d[r])}	;
		return x
	},
	
    CLASS_NAME: "Geo.Util.Format.XML2JSON"
});/**
 * Class: Geo.Util.Format.VwmtsGetVersionInfo
 * WMTS多时相服务getCapabilities操作请求结果的XML解析器，继承自Geo.Util.Format.XML2JSON类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.Util.Format.XML2JSON>
 */
Geo.Util.Format.VwmtsGetVersionInfo = Geo.Class(Geo.Util.Format.XML2JSON, {
	
	 /**
     * APIMethod: read
     * 解析一个XML串并返回capabilitiesObj｛Object｝对象。
     *
     * Parameters:
     * xmlcode - {String} 一个XML字符串
     *
     * Returns:
     * ｛Object｝- capabilitiesObj
     */
    read: function(xmlcode){
        if(typeof data == "string") {
            data = Geo.Util.Format.XML2JSON.prototype.read.apply(this, [xmlcode]);
        }
		
		return data;
	},
	
	/**
     * APIProperty: CLASS_NAME
     * 类名标识
     */
	CLASS_NAME:"Geo.Util.Format.VwmtsGetVersionInfo"
});/**
 * Class: Geo.Util.Format.VwmtsGetVersions
 * WMTS多时相服务getCapabilities操作请求结果的XML解析器，继承自Geo.Util.Format.XML2JSON类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.Util.Format.XML2JSON>
 */
Geo.Util.Format.VwmtsGetVersions = Geo.Class(Geo.Util.Format.XML2JSON, {
	
	/**
     * APIMethod: read
     * 解析一个XML串并返回versionsObj｛Object｝对象。
     *
     * Parameters:
     * data - {String} 一个XML字符串
     *
     * Returns:
     * ｛Object｝- versionsObj
     */
    read: function(data){
        if(typeof data == "string") {
            data = Geo.Util.Format.XML2JSON.prototype.read.apply(this, [data]);
        }
		
		return data;
	},
	
	/**
     * APIProperty: CLASS_NAME
     * 类名标识
     */
	CLASS_NAME:"Geo.Util.Format.VwmtsGetVersions"
});/* Copyright (c) 2006-2010 by OpenLayers Contributors (see authors.txt for 
 * full list of contributors). Published under the Clear BSD license.  
 * See http://svn.openlayers.org/trunk/openlayers/license.txt for the
 * full text of the license. */

/**
 * @requires OpenLayers/Format/WMTSCapabilities.v1_0_0
 * @requires OpenLayers/Format/OWSCommon/v1_1_0.js
 */

/**
 * Class: VwmtsGetCapabilities.js
 * Read WMTS Capabilities version 1.0.0.
 * 
 * Inherits from:
 *  - <OpenLayers.Format.WMTSCapabilities.v1_0_0>
 */
 OpenLayers.Format.VWMTSCapabilities = {};
OpenLayers.Format.VWMTSCapabilities.v1_0_0 = OpenLayers.Class(
    OpenLayers.Format.WMTSCapabilities.v1_0_0, {

    initialize: function() {
        OpenLayers.Format.WMTSCapabilities.v1_0_0.prototype.initialize.apply(this, arguments);
       
    },

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {        
        "wmts": {
            "Capabilities": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Contents": function(node, obj) {
                obj.contents = {};                
                obj.contents.layers = [];
                obj.contents.tileMatrixSets = {};                
                this.readChildNodes(node, obj.contents);
            },
            "Layer": function(node, obj) {
                var layer = {
                    styles: [],
                    formats: [],
                    tileMatrixSetLinks: [],
					dimensions:[]
                };
                layer.layers = [];
                this.readChildNodes(node, layer);
                obj.layers.push(layer);
            },
            "Style": function(node, obj) {
                var style = {};
                style.isDefault = (node.getAttribute("isDefault") === "true");
                this.readChildNodes(node, style);
                obj.styles.push(style);
            },
            "Format": function(node, obj) {
                obj.formats.push(this.getChildValue(node)); 
            },
			//多时相节点解析
			"Dimension": function(node, obj) {
				var dimension = {
					values:[]
				};
                this.readChildNodes(node, dimension);
                obj.dimensions.push(dimension);
            },
			"Value": function(node, obj) {
                obj.values.push(this.getChildValue(node));
            },
            "TileMatrixSetLink": function(node, obj) {
                var tileMatrixSetLink = {};
                this.readChildNodes(node, tileMatrixSetLink);
                obj.tileMatrixSetLinks.push(tileMatrixSetLink);
            },
            "TileMatrixSet": function(node, obj) {
                // node could be child of wmts:Contents or wmts:TileMatrixSetLink
                // duck type wmts:Contents by looking for layers
                if (obj.layers) {
                    // TileMatrixSet as object type in schema
                    var tileMatrixSet = {
                        matrixIds: []
                    };
                    this.readChildNodes(node, tileMatrixSet);
                    obj.tileMatrixSets[tileMatrixSet.identifier] = tileMatrixSet;
                } else {
                    // TileMatrixSet as string type in schema
                    obj.tileMatrixSet = this.getChildValue(node);
                }
            },
            "TileMatrix": function(node, obj) {
                var tileMatrix = {
                    supportedCRS: obj.supportedCRS
                };
                this.readChildNodes(node, tileMatrix);
                obj.matrixIds.push(tileMatrix);
            },
            "ScaleDenominator": function(node, obj) {
                obj.scaleDenominator = parseFloat(this.getChildValue(node)); 
            },
            "TopLeftCorner": function(node, obj) {                
                var topLeftCorner = this.getChildValue(node);
                var coords = topLeftCorner.split(" ");
                // decide on axis order for the given CRS
                var yx;
                if (obj.supportedCRS) {
                    // extract out version from URN
                    var crs = obj.supportedCRS.replace(
                        /urn:ogc:def:crs:(\w+):.+:(\w+)$/, 
                        "urn:ogc:def:crs:$1::$2"
                    );
                    yx = !!this.yx[crs];
                }
                if (yx) {
                    obj.topLeftCorner = new OpenLayers.LonLat(
                        coords[1], coords[0]
                    );
                } else {
                    obj.topLeftCorner = new OpenLayers.LonLat(
                        coords[0], coords[1]
                    );
                }
            },
            "TileWidth": function(node, obj) {
                obj.tileWidth = parseInt(this.getChildValue(node)); 
            },
            "TileHeight": function(node, obj) {
                obj.tileHeight = parseInt(this.getChildValue(node)); 
            },
            "MatrixWidth": function(node, obj) {
                obj.matrixWidth = parseInt(this.getChildValue(node)); 
            },
            "MatrixHeight": function(node, obj) {
                obj.matrixHeight = parseInt(this.getChildValue(node)); 
            },        
            "WSDL": function(node, obj) {
                obj.wsdl = {};
                obj.wsdl.href = node.getAttribute("xlink:href");
            },
            "ServiceMetadataURL": function(node, obj) {
                obj.serviceMetadataUrl = {};
                obj.serviceMetadataUrl.href = node.getAttribute("xlink:href");
            }            
        },
        "ows": OpenLayers.Format.OWSCommon.v1_1_0.prototype.readers["ows"]
    },    
    
    CLASS_NAME: "OpenLayers.Format.WMTSCapabilities.v1_0_0" 

});
/**
 * Class: Geo.Util.Format.MapServiceQuery
 * 解析地图服务query接口的查询结果
 */
Geo.Util.Format.MapServiceQuery = Geo.Class(Geo.Format.JSON, {
    
    /**
     * Constructor: Geo.Util.Format.MapServiceQuery
     * 创建一个地图服务查询接口解析器
     */

    /**
     * APIMethod: read
     * 传入一个json串，将json串转换为要素对象
     *
     * Parameters:
     * json - {String} 解析查询返回的json串
     *    输入参数举例：
     *    点：
     *    {
     *    	features:[{
     *    		attributes:{"NAME":"007"},
	 *		   "geometry": {
	 *		       "x": 116.38094,
	 *		       "y": 39.923614999999998
	 *		   }
     *    	}]
     *    }
     *    线：
     *     {"features": [
	 *		  {
	 *		   "attributes": {
	 *		    "NAME": "ÑÀÁÖÏß"
	 *		   },
	 *		   "geometry": {
	 *		    "paths": [
	 *		     [
	 *		      [
	 *		       122.09497,
	 *		       52.033745000000003
	 *		      ],
	 *		      [
	 *		       120.75324999999999,
	 *		       49.269401999999999
	 *		      ]
	 *		     ]
	 *		    ]
	 *		   }
	 *		  }]}
     *     面：
     *      {"features": [
	 *		  {
	 *		   "attributes": {
	 *		    "NAME": "ºÚÁú½­Ê¡"
	 *		   },
	 *		   "geometry": {
	 *		    "rings": [
	 *		     [
	 *		      [
	 *		       121.48844,
	 *		       53.332649000000004
	 *		      ],
	 *		      [
	 *		       125.62043,
	 *		       53.067318
	 *		      ],
	 *		      [
	 *		       130.99547000000001,
	 *		       47.698345000000003
	 *		      ]
	 *		     ]
	 *		    ]
	 *		   }
	 *		  }}
     * filter - {Function} 过滤查询结果
     *
     * Returns: 
     * {Array} 返回要素对象数组
     */
    read: function(json, filter) {
        var features = [];
        var obj = null;
        if (typeof json == "string") {
            obj = OpenLayers.Format.JSON.prototype.read.apply(this,
                                                              [json, filter]);
        } else { 
            obj = json;
        }    
        if(!obj) {
            return features;
        } else if(!obj.features) {
            OpenLayers.Console.error("Bad GeoJSON - no type: " + json);
        } else if(obj.features.length > 0) {
			for(var i = 0,j = obj.features.length; i < j; i++) {
				features.push(this.parseFeature(obj.features[i]));
			}
        }
        return features;
    },
	
	/**
     * APIMethod: write
     * 将一个要素或一个几何对象或者要素数组转换成json串
     * 
     * Parameters:
     * obj - {Object} 可以传递一个要素对象，一个geometry对象或者一个要素对象。注意:geometry对象只支持point,MultiLineString以及Polygon 
     * pretty - {Boolean} 是否序列号输出结果，默认为false
     *
     * Returns:
     * {String} 根据输入的要素或几何对象或要素数组得到与其对应的json串 
     */
    write: function(obj, pretty) {
      	var json = {};
		var features = [];
        if(OpenLayers.Util.isArray(obj)) {
            for(var i=0; i<obj.length; ++i) {
                var element = obj[i];
                if(!element instanceof OpenLayers.Feature.Vector) {
                    var msg = "该对象在数组中不是要素 " +
                              "" + element;
                    throw msg;
                }
                var geometry = this._getGeometryRepresentation(obj[i].geometry);
				var attributes = obj[i].attributes;
				var ajson = OpenLayers.Util.extend({}, {
					attributes:attributes,
					geometry:geometry
				});
				features.push(ajson);
            }
			json.features = features;
        } else if (obj.CLASS_NAME.indexOf("OpenLayers.Geometry") == 0) {
         	var geometry = this._getGeometryRepresentation(obj);
			json.geometry = geometry;
        } else if (obj instanceof OpenLayers.Feature.Vector) {
			var geometry = this._getGeometryRepresentation(obj.geometry);
			var attributes = obj.attributes;
			OpenLayers.Util.extend(json, {
				attributes:attributes,
				geometry:geometry
			});
        }
        return OpenLayers.Format.JSON.prototype.write.apply(this,
                                                            [json, pretty]);
    },
	
	/**
	 * 得到arcgis可以理解的几何表示法
	 * @param {Object} geometry
	 */
	_getGeometryRepresentation: function(geometry) {
		if(!geometry) {
			return undefined;
		}
		var name = geometry.CLASS_NAME;
		var jsonObj = null;
		switch(name) {
			case "OpenLayers.Geometry.Point":
				jsonObj = {x:geometry.x,y:geometry.y};
				break;
			case "OpenLayers.Geometry.Polygon":
				var json = this.extract['geometry'].apply(this, [geometry]);
				jsonObj = {rings:json.coordinates};
				break;	
			case "OpenLayers.Geometry.MultiLineString":
				var json = this.extract['geometry'].apply(this, [geometry]);
				jsonObj = {paths:json.coordinates};
				break;		
			case "OpenLayers.Geometry.LineString":
				var json = this.extract['geometry'].apply(this, [geometry]);
				jsonObj = {paths:[json.coordinates]};
				break;		
		}
		return jsonObj;
	},
	
    /**
     * Method: parseFeature
     * 将表示要素的json对象转换成要素
     * Parameters:
     * obj - {Object}一个json对象
     *
     * Returns:
     * {<OpenLayers.Feature.Vector>} A feature.
     */
    parseFeature: function(obj) {
		var olGeometry = this._getGeometry(obj.geometry);
		var attributes = this._getAttribute(obj.attributes);
		var f = new OpenLayers.Feature.Vector(olGeometry,attributes);
        return  f;
    },
	
	/**
	 * 得到openlayers几何对象
	 * @param {Object} geometry
	 */
	_getGeometry: function(geometry) {
		for(var pro in geometry) {
			//TODO：服务组封装的地图服务返回的geometry节点中包含spatialReference,加了这个判断，初步估计服务组封装的查询服务的返回结果结构有问题
			if("spatialReference" == pro) {
				return;
			}
			if(geometry.hasOwnProperty("x") && geometry.hasOwnProperty("y")) {
				var geometry = new OpenLayers.Geometry.Point(geometry["x"],geometry["y"]);
			}else if(geometry.hasOwnProperty("xmin") && geometry.hasOwnProperty("ymin")&& geometry.hasOwnProperty("xmax")&& geometry.hasOwnProperty("ymax"))
			{
				 var geometry = new OpenLayers.Bounds(geometry.xmin,geometry.ymin,geometry.xmax,geometry.ymax).toGeometry();
			}else {
				var geometry = this._geometryType[pro](geometry[pro]);
			}
			return geometry;
		}
	},
   
	/**
	 * 得到要素的属性信息
	 * @param {Object} geometry
	 */
	_getAttribute: function(attrs) {
		var attributes = {};
		if(attrs && !(attrs instanceof Array)) {
			attrs = [attrs];
		}
		if(attrs instanceof Array) {
			for(var i = 0; i < attrs.length; i++) {
				 OpenLayers.Util.applyDefaults(attributes,attrs[i]);
			}
		}
		return attributes;
	},
	
	/**
	 * 将几何信息的json表示转换成
	 * @param {Object} geometry
	 */
	_geometryType: {
		"points": function(geometry) {
			var points = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var point = new OpenLayers.Geometry.Point(geometry[i][0], geometry[i][1]);
					points.push(point);
				}
			}
			return points;
		},
		"paths": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LineString(ps);
					lines.push(line);
				}
				var paths = new OpenLayers.Geometry.MultiLineString(lines);
			}
			return paths;
		},
		"rings": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LinearRing(ps);
					lines.push(line);
				}
				var Polygon = new OpenLayers.Geometry.Polygon(lines);
			}
			return Polygon;
		}
	},
		
    /**
     * Property: extract
     * Object with properties corresponding to the GeoJSON types.
     *     Property values are functions that do the actual value extraction.
     */
    extract: {
        /**
         * Method: extract.feature
         * Return a partial GeoJSON object representing a single feature.
         *
         * Parameters:
         * feature - {<OpenLayers.Feature.Vector>}
         *
         * Returns:
         * {Object} An object representing the point.
         */
        'feature': function(feature) {
            var geom = this.extract.geometry.apply(this, [feature.geometry]);
            var json = {
                "type": "Feature",
                "properties": feature.attributes,
                "geometry": geom
            };
            if (feature.fid != null) {
                json.id = feature.fid;
            }
            return json;
        },
        
        /**
         * Method: extract.geometry
         * Return a GeoJSON object representing a single geometry.
         *
         * Parameters:
         * geometry - {<OpenLayers.Geometry>}
         *
         * Returns:
         * {Object} An object representing the geometry.
         */
        'geometry': function(geometry) {
            if (geometry == null) {
                return null;
            }
            if (this.internalProjection && this.externalProjection) {
                geometry = geometry.clone();
                geometry.transform(this.internalProjection, 
                                   this.externalProjection);
            }                       
            var geometryType = geometry.CLASS_NAME.split('.')[2];
            var data = this.extract[geometryType.toLowerCase()].apply(this, [geometry]);
            var json;
            if(geometryType == "Collection") {
                json = {
                    "type": "GeometryCollection",
                    "geometries": data
                };
            } else {
                json = {
                    "type": geometryType,
                    "coordinates": data
                };
            }
            
            return json;
        },

        /**
         * Method: extract.point
         * Return an array of coordinates from a point.
         *
         * Parameters:
         * point - {<OpenLayers.Geometry.Point>}
         *
         * Returns: 
         * {Array} An array of coordinates representing the point.
         */
        'point': function(point) {
            return [point.x, point.y];
        },

        /**
         * Method: extract.multipoint
         * Return an array of point coordinates from a multipoint.
         *
         * Parameters:
         * multipoint - {<OpenLayers.Geometry.MultiPoint>}
         *
         * Returns:
         * {Array} An array of point coordinate arrays representing
         *     the multipoint.
         */
        'multipoint': function(multipoint) {
            var array = [];
            for(var i=0, len=multipoint.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [multipoint.components[i]]));
            }
            return array;
        },
        
        /**
         * Method: extract.linestring
         * Return an array of coordinate arrays from a linestring.
         *
         * Parameters:
         * linestring - {<OpenLayers.Geometry.LineString>}
         *
         * Returns:
         * {Array} An array of coordinate arrays representing
         *     the linestring.
         */
        'linestring': function(linestring) {
            var array = [];
            for(var i=0, len=linestring.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [linestring.components[i]]));
            }
            return array;
        },

        /**
         * Method: extract.multilinestring
         * Return an array of linestring arrays from a linestring.
         * 
         * Parameters:
         * linestring - {<OpenLayers.Geometry.MultiLineString>}
         * 
         * Returns:
         * {Array} An array of linestring arrays representing
         *     the multilinestring.
         */
        'multilinestring': function(multilinestring) {
            var array = [];
            for(var i=0, len=multilinestring.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [multilinestring.components[i]]));
            }
            return array;
        },
        
        /**
         * Method: extract.polygon
         * Return an array of linear ring arrays from a polygon.
         *
         * Parameters:
         * polygon - {<OpenLayers.Geometry.Polygon>}
         * 
         * Returns:
         * {Array} An array of linear ring arrays representing the polygon.
         */
        'polygon': function(polygon) {
            var array = [];
            for(var i=0, len=polygon.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [polygon.components[i]]));
            }
            return array;
        },

        /**
         * Method: extract.multipolygon
         * Return an array of polygon arrays from a multipolygon.
         * 
         * Parameters:
         * multipolygon - {<OpenLayers.Geometry.MultiPolygon>}
         * 
         * Returns:
         * {Array} An array of polygon arrays representing
         *     the multipolygon
         */
        'multipolygon': function(multipolygon) {
            var array = [];
            for(var i=0, len=multipolygon.components.length; i<len; ++i) {
                array.push(this.extract.polygon.apply(this, [multipolygon.components[i]]));
            }
            return array;
        },
        
        /**
         * Method: extract.collection
         * Return an array of geometries from a geometry collection.
         * 
         * Parameters:
         * collection - {<OpenLayers.Geometry.Collection>}
         * 
         * Returns:
         * {Array} An array of geometry objects representing the geometry
         *     collection.
         */
        'collection': function(collection) {
            var len = collection.components.length;
            var array = new Array(len);
            for(var i=0; i<len; ++i) {
                array[i] = this.extract.geometry.apply(
                    this, [collection.components[i]]
                );
            }
            return array;
        }
    },

    CLASS_NAME: "Geo.Util.Format.MapServiceQuery" 
});     /**
 * Class: Geo.View2D.Map
 * 地图对象类，继承自Geo.Map类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.Map>
 */
Geo.View2D.Map = Geo.Class(OpenLayers.Map, {

    /**
     * APIProperty: pyramid
     * {<Geo.Pyramid>} 地图的金字塔方案对象，默认值为Geo.Pyramid.DEFAULT_PYRAMID常量指定的360度金字塔方案。
     */
    pyramid: null,
    
    /**
     * APIProperty: allOverlays
     * {Boolean} 视图中所有图层是否都为覆盖图层，默认为false，也必须为false。
     */
    allOverlays: false,
    
    /**
     * APIProperty: layerGroup
     * {<Geo.LayerGroup>} 地图中加载的图层组对象的引用。
     */
    layerGroup: null,
	
	/**
     * APIProperty: EVENT_TYPES
     * {Array} 事件类型。
     */
    EVENT_TYPES: ["unloadLayerGroup", "loadlayergroup"],
    
    /**
     * APIProperty: overLayers
     * {Array} 所有的覆盖图层。
     */
    overLayers: null,
	
    /**
     * APIProperty: enableAnimateZoomer
     * {Boolean} 设置是否开启平滑缩放的效果。也能设置为一个对象。
     * 如果设置为一个对象，该对象被传递至{<Geo.AnimateZoomer>}的构造函数。
     * 默认为false
     */
    enableAnimateZoomer: false,
	
    /**
     * APIProperty: animateZoomer
     * {<Geo.AnimateZoomer>} 地图的图层平滑缩放效果对象。
     */
	animateZoomer: null,
    
    /**
     * Constructor: Geo.View2D.Map
     * Geo.View2D.Map构造函数。
     * 
     * Parameters:
     * div - {String} 地图对象将被渲染到哪个div 元素中。
     * options - {Object} 地图对象相关选项设置。
     */
    initialize: function(div, options){
		this.EVENT_TYPES =
            Geo.View2D.Map.prototype.EVENT_TYPES.concat(
            OpenLayers.Map.prototype.EVENT_TYPES
        );
        this.overLayers = [];
		options = options || {};
		if (options.controls == null) {
            this.controls = [ new Geo.View2D.Control.Navigation(),
                              new Geo.View2D.Control.PanZoomBar(),
                              new Geo.View2D.Control.ArgParser(),
							  new Geo.View2D.Control.MagnifyingGlass()
                            ];
        }else {
            this.controls = [];
        }
		
        OpenLayers.Map.prototype.initialize.apply(this, arguments);
		
		//视图中所有图层必须为为覆盖图层。
		this.allOverlays = false;
        this.pyramid = this.pyramid ? this.pyramid : new Geo.Pyramid();
        this.setPyramid(this.pyramid);
		
		//是否开启平滑缩放效果。 
		var config = {layerLoaded: true};
        if(typeof this.enableAnimateZoomer === "object") {
            config = OpenLayers.Util.extend(config, this.enableAnimateZoomer);
        }
        this.animateZoomer = this.enableAnimateZoomer ? new Geo.AnimateZoomer(this, config) : null;
    },
    
     /**
	 * APIMethod: addLayer
	 * 添加图层。一般情况下推荐使用addOverLayer方法，即将单个图层作为覆盖层添加。
	 *
	 * Parameters: 
	 * layer - {<Geo.View2D.Layer>} 二维视图图层对象。
	 */	
    
    //此方法将强行将添加图层isBaseLayer属性改为false
    //_notResetLayers为不公开参数，用于图层组加载时不更新基础层相关参数与重排列置顶层，解决图层组切换效率与跳级问题。
    //默认值为false，即让用户添加覆盖图层时会更新基础层相关参数与重排列置顶层。
    addLayer: function(layer,_notResetLayers){
        
        //强行将基础图层属性改为false
        layer.isBaseLayer = false;
        OpenLayers.Map.prototype.addLayer.apply(this, arguments);
        
        if(!_notResetLayers){
            this.updateBaseLayer();
            this.resetTopLayer();
        }
    },

    /**
	 * APIMethod: addOverLayer
	 * 将指定图层作为覆盖层添加。与addLayer方法不同的是，该图层的引用除了保存到地图对象的layers数组中，还将保存到overLayers数组。
	 * 覆盖层在基础图层组切换时，叠加顺序不受基础图层加载、卸载的影响，始终保持在所有基础图层的上方。
	 *
	 * Parameters: 
	 * layer - {<Geo.View2D.Layer>} 二维视图图层对象。
	 */		
    addOverLayer: function(layer){
        this.addLayer(layer);
        this.overLayers.push(layer);
    },
    
    removeLayer: function(layer){
        
        //移除在覆盖图层数组中的引用
        OpenLayers.Util.removeItem(this.overLayers, layer);
        OpenLayers.Map.prototype.removeLayer.apply(this, arguments);
    },
        
	/** 
     * APIMethod: raiseLayer
     * 调整图层顺序。
     *
     * Paremeters:
     * layer - {<Geo.View2D.Layer>} 图层对象的引用。
     * delta - {int} 图层调整的偏移量,当指定增量值为正时图层上移，当指定增量值为负时图层下移。
     */
	raiseLayer : function(layer, delta) {
		//要移动图层的当前位置
		var currentIndex = this.getLayerIndex(layer);
		//delta表示移动几位
	    var tempDelta = Math.abs(delta);
		if(delta > 0) {
			for (var i = currentIndex, len=this.layers.length; i<len; i++) {
				//若起大于0
				if(tempDelta == 0 || len <= i+1) {
					break;
				}
				if(!this.layers[i+1].displayInLayerSwitcher) {
					delta ++;
				}else {
					tempDelta--;
				}
        		
        	}
		}else if(delta < 0) {
			for (var i = currentIndex, len=this.layers.length;i >= 0; i--) {
        		if(tempDelta == 0 || i - 1 < 0) {
					break;
				}
				if(!this.layers[i-1].displayInLayerSwitcher) {
					delta = delta - 1;
				}else {
					tempDelta--;
				}
        	}
		}
		OpenLayers.Map.prototype.raiseLayer.apply(this, arguments);
	},

	
    /**
	 * APIMethod: resetTopLayer
	 * 将置顶图层重新排列。
	 */	
    resetTopLayer: function(){
        var layersNum = this.layers.length;
		var topIndex = layersNum - 1;
        for (var i = layersNum - 1; i >= 0; i--) {
            var layer = this.layers[i];
            if (layer.isOnTop && !layer.isBaseLayer) {
                this.setLayerIndex(layer, topIndex--);
            }
        }
    },
	
	/**
	 * APIMethod: resetOverLayer
	 * 将覆盖图层重新排列。
	 */	
	resetOverLayer:function(){
		var layersNum = this.layers.length;
		var topIndex = layersNum - 1;
        for (var i = layersNum - 1; i >= 0; i--) {
            var layer = this.layers[i];
            
            //如果不是覆盖图层则视为底图图层将之移到最底层
            if (OpenLayers.Util.indexOf(this.overLayers,layer) != -1) {
                this.setLayerIndex(layer, topIndex--);
            }
        }
	},
    
    /**
	 * APIMethod: setPyramid
	 * 设置金字塔,如果无参数默认为360度金字塔。
	 *
	 * Parameters: 
	 * pyramid - {<Geo.Pyramid>} 金字塔定义。
	 */	
    setPyramid: function(pyramid){
        if (!pyramid) {
            pyramid = new Geo.Pyramid();
        }
        this.pyramid = pyramid;
		this.numZoomLevels = this.pyramid.getNumZoomLevels();
        this.maxExtent = this.pyramid.maxExtent.clone();
		if(this.pyramid.resolutions && typeof this.pyramid.resolutions == 'object' && this.pyramid.resolutions.constructor == Array) {
			var resolutions = this.pyramid.resolutions;
			this.updateBaseLayer({
	            resolutions: resolutions,
	            maxExtent: this.maxExtent
	        });
		}else {
			this.maxResolution = this.pyramid.getMaxResolution();
        	this.minResolution = this.pyramid.getMinResolution();
			this.updateBaseLayer({
	            maxResolution: this.maxResolution,
	            minResolution: this.minResolution,
	            maxExtent: this.maxExtent
	        });
		}
    },
	
   /** 
    * APIMethod: removePopup
    * 移除浮云框
    * Parameters:
    * popup - {<Geo.View2D.Popup>}
    */
    removePopup: function(popup) {
        Geo.Util.removeItem(this.popups, popup);
        if (popup.div) {
            try { this.layerContainerDiv.removeChild(popup.div); }
            catch (e) { } // Popups sometimes apparently get disconnected
                      // from the layerContainerDiv, and cause complaints.
        }
		if(popup.calculateShadowLocation) {
			this.events.unregister("zoomend", popup,popup.calculateShadowLocation);
		}
		if(popup.shadowDiv) {
			 try {this.layerContainerDiv.removeChild(popup.shadowDiv); }
            catch (e) { }
		}
        popup.map = null;
    },
    
    /**
	 * APIMethod: updateBaseLayer
	 * 更新基础图层相关选项,如果无指定选项设置，则根据地图中所有图层相关设置更新基础图层选项。
	 *
	 * Parameters: 
	 * options - - {Object} 相关选项设置。
	 */	
    updateBaseLayer: function(options){
        var defOptions = {
            displayInLayerSwitcher: false,
            isBaseLayer: true
        }
        var blOptions = {};
        if (!options) {
			
			var resolutions = this.getResolutions();
			//优先使用数组，如果没有则使用最大最小分辨率
			if(OpenLayers.Util.isArray(resolutions)) {
				blOptions = {
	                resolutions: resolutions,
	                maxExtent: this.getLayersMaxExtent()
	            };
			}else {
				blOptions = {
	                maxResolution: this.getLayersMaxResolution(),
	                minResolution: this.getLayersMinResolution(),
	                maxExtent: this.getLayersMaxExtent()
	            };
			}
            
        }
        else {
            OpenLayers.Util.extend(blOptions, options);
        }
        OpenLayers.Util.extend(blOptions, defOptions);
        var bl = new OpenLayers.Layer("GeoGlobeBaseLayer", blOptions);
        
        if (this.baseLayer) {
            this.removeLayer(this.baseLayer);
        }
        OpenLayers.Map.prototype.addLayer.apply(this, [bl]);
    },
	
	getResolutions: function() {
		var resolutions = this.resolutions || this.pyramid.resolutions;
		return resolutions;
	},
    
    /**
	 * APIMethod: getLayersMaxResolution
	 * 获取地图中所有图层的最大分辨率，如果所有图层均无分辨率设置，则以地图金字塔最大分辨率为准。
	 * 
	 * Returns:
     * {Float} 分辨率。
	 */	
    getLayersMaxResolution: function(){
        var layers = this.layers, res = null;
        for (var i = 0; i < layers.length; i++) {
			var layerOptions  = layers[i].getOptions();
			var layerMaxRes = layerOptions.maxResolution;
            if (layers[i].isBaseLayer || !layerMaxRes) {
				continue;
			}                
            res = res ? Math.max(res, layerMaxRes) : layerMaxRes;
        }
        var pyramidMaxRes = this.pyramid.getMaxResolution();
        res = (res <= 0 || res > pyramidMaxRes) ? pyramidMaxRes : res;
        return res;
    },
    
    /**
	 * APIMethod: getLayersMinResolution
	 * 获取地图中所有图层的最小分辨率，如果所有图层均无分辨率设置，则以地图金字塔最小分辨率为准。
	 * 
	 * Returns:
     * {Float} 分辨率。
	 */	
    getLayersMinResolution: function(){
        var layers = this.layers, res = null;
        for (var i = 0; i < layers.length; i++) {
			var layerOptions  = layers[i].getOptions();
			var layerMinRes = layerOptions.minResolution;
            if(layers[i].isBaseLayer || !layerMinRes){
				continue;
			}
            res = res ? Math.min(res, layerMinRes) : layerMinRes;
        }
        var pyramidMinRes = this.pyramid.getMinResolution();
        res = (res <= 0 || res < pyramidMinRes) ? pyramidMinRes : res;
        return res;
    },
    
     /**
	 * APIMethod: getLayersMaxExtent
	 * 取所有图层的最大范围，如果所有图层均无最大范围，则以金字塔的最大范围为准。
	 * 
	 *  Returns:
     *  {<Geo.Bounds>}图层范围。
	 */	
    getLayersMaxExtent: function(){
        var extent = null;
        var layers = this.layers;
        for (var i = 0; i < layers.length; i++) {
            if (layers[i].isBaseLayer || !layers[i].maxExtent) 
                continue;
            if (extent) {
                extent.extend(layers[i].maxExtent);
            }
            else {
                extent = layers[i].maxExtent.clone();
            }
        }
        var pyramidMaxExtent = this.pyramid.maxExtent.clone();
        extent = extent ? extent : pyramidMaxExtent;
        return extent;
    },
	
    /**
     * APIMethod: loadLayerGroup
     * 加载指定方案到地图对象。
     *
     * Parameters: 
	 * layerGroup - {<Geo.LayerGroup>} 图层组，在该图层组中，序号值最大的图层在顶层，序号值最小的图层在底层。
     * 
     * Returns:
     * {Boolean} 装载方案是否成功。
     */
    loadLayerGroup: function(layerGroup){
        if (this.layerGroup == layerGroup) {
            var msg = "不能重复加载图层组到地图中！";
            OpenLayers.Console.warn(msg);
            return false;
        }
        this.unloadLayerGroup();
        layerGroup.setMap(this);
        this.layerGroup = layerGroup;
		
        this.updateBaseLayer();
		this.resetOverLayer();
        this.resetTopLayer();
		this.events.triggerEvent("loadlayergroup", {
            layerGroup: layerGroup,
			map : this
        });
    },
    
    /**
     * APIMethod: unloadLayerGroup
     * 卸载图层组。
     */
    unloadLayerGroup: function(){
		var layerGroup = this.layerGroup;
        if (!layerGroup) {
			return false;
		}
		layerGroup.removeMap();
        this.layerGroup = null;

    },
	
    CLASS_NAME: "Geo.View2D.Map"
});/**
 * Class: Geo.View2D.Layer.GlobeTile
 * GeoGlobe瓦片图层类，继承自Geo.View2D.Layer.Grid类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Layer.Grid>
 */
Geo.View2D.Layer.GlobeTile = Geo.Class(Geo.View2D.Layer.Grid,{

	/**
	 * APIProperty: alwaysInRange
	 * {Boolean} 强制在任意分辨率下显示图层，默认false。
	 */
	alwaysInRange: false,
	
	/**
     * APIProperty: isBaseLayer
     * {Boolean} 是否基础层，默认为false。
     */
	isBaseLayer:false,
	
	/**
     * APIProperty: topLevel
     * {Integer} 图层顶层级别。
     */
	topLevel: null,
	
	/**
     * APIProperty: bottomLevel
     * {Integer} 图层底层级别。
     */
	bottomLevel: null,
	
	/**
     * APIProperty: pyramid
     * {<Geo.Pyramid>} 地图金字塔。
     */
	pyramid : null,
	
	/**
     * APIProperty: accessUrl
     * {String} 服务访问地址。
     */
	accessUrl : null,
	
	/**
     * APIProperty: mirrorUrl
     * {Array} 服务镜像地址。可以为一个服务设置多个地址，解决浏览器图片链接数限制问题。
     */
	mirrorUrl : null,
	
	/**
     * APIProperty: serviceName
     * {String} 服务访问名称。
     */
	serviceName : null,
	
	/**
     * APIProperty: verstionTime
     * {String} 时间版本。
     */
	verstionTime: "9999-01-01 00:00:00",
	
	/**
     * APIProperty: cacheExpireTime
     * {String} 缓存过期时间。
     */
	cacheExpireTime : "now",

	/**
     * APIProperty: buffer
     * {String} 瓦片缓存大小。
     */
	buffer:0,
	
	/**
     * APIProperty: transitionEffect
     * {String} 平滑缩放效果。
     */
	transitionEffect: null,
	
	/**
     * Constructor: Geo.View2D.Layer.GlobeTile
     * 创建GeoGlobe瓦片图层对象实例。
     *
     * Parameters:
     * name - {String} GeoGlobe瓦片图层名称。
     * url - {String} 瓦片服务地址。
     * options - {Object} 对象构造参数。
     * 
     * 示例:
     * (code)
     * new Geo.View2D.Layer.GlobeTile("天地图矢量注记", "http://tile0.tianditu.com/services/AB0512_Anno", {
     *      topLevel: 2,
     *      bottomLevel: 12,
     *      maxExtent: new Geo.Bounds(-180, -90, 180, 90)
     * })
     * (end)
     */
	initialize : function(name, url, options){
		
		this.name = name;
		this.url = url;
		this.convertUrl(this.url);
		
		//初始化图层的金字塔和顶层底层级别，如果无金字塔指定，则默认为360度金字塔
		if(!options){
			options = {};
		};
		options.pyramid = options.pyramid ? options.pyramid : new Geo.Pyramid();
		options.topLevel = options.topLevel ? options.topLevel : options.pyramid.topLevelIndex;
		options.bottomLevel = options.bottomLevel ? options.bottomLevel : options.pyramid.bottomLevelIndex;		
		
		//初始化图层的最大最小分辨率
		var maxRes = options.pyramid.getMaxResolution();
		options.maxResolution = options.pyramid.getResolutionForLevel(options.topLevel);
		options.minResolution = options.pyramid.getResolutionForLevel(options.bottomLevel);
		
		options.tileSize = options.pyramid.tileSize;
		
		var para = null;		
		var newArguments = [name, url, para, options];
		Geo.View2D.Layer.Grid.prototype.initialize.apply(this, newArguments);
		
	},
	
	/**
     * APIMethod: convertUrl
     * 将服务地址转换成实际瓦片图片访问地址。
	 * 
	 * Paramters:
	 * url - {String} 服务地址。
     */
	convertUrl: function(url){
		var tmpUrl = url.split("/services/");
		if (tmpUrl[0] && tmpUrl[1]) {
			this.accessUrl = tmpUrl[0] + "/DataServer";
			this.serviceName = tmpUrl[1];
		} else {
			OpenLayers.Console.error("解析GeoGlobe 2.0.0服务地址错误:" + url);
			return;
		}
	},
	
	/**
     * APIMethod: addTile
     * 添加瓦片。
     * 
     * Paramters:
	 * bounds - {<Geo.Bounds>}
	 * position - {<Geo.Pixel>}
	 * 
	 * Returns:
     * {<Geo.View2D.Tile.Image>} 瓦片图片。
     */
	addTile: function(bounds, position) {
		return new Geo.View2D.Tile.Image(this, position, bounds,
                                             null, this.tileSize);
    },
 
	/**
     * APIMethod: setVerstionTime
     * 设置历史版本,设置版本后会重新绘制本图层。
     * 
     * Paramters:
	 * verstion - {String} 历史版本号,格式为"2010-06-23 18:48:23"。
     */
    setVerstionTime: function(verstion){
    	if(verstion){
    		this.verstionTime = verstion;
    		this.redraw();
    	}
    },
	
	/**
     * APIMethod: getURL
     * 获取瓦片图片地址。
     * 
     * Paramters:
	 * bounds - {<Geo.Bounds>}
	 * 
	 * Returns:
     * {String} 瓦片图片地址。
     */
	getURL: function(bounds) {
	
		var blankUrl = OpenLayers.Util.getImagesLocation() + "blank.gif";		
		bounds = this.adjustBounds(bounds);	
		var pyramidMaxResolution = this.pyramid.getMaxResolution();
		
		var deg,level,x,y;
		level = this.pyramid.getLevelForResolution(this.map.getResolution());
        deg = this.pyramid.getTopTileSize().w / Math.pow(2,level);
        
		
		//判断原点
		//宽度为正，说明X轴向从左到右
		if(this.pyramid.topTileFromX < this.pyramid.topTileToX){
			x = Math.round((bounds.left - this.pyramid.topTileFromX)/deg);
		} else {
			x = Math.round((this.pyramid.topTileFromX - bounds.right)/deg);
		}
		//高度为正，说明Y轴向从下到上
		if (this.pyramid.topTileFromY < this.pyramid.topTileToY){
			y = Math.round((bounds.bottom - this.pyramid.topTileFromY)/deg);
		} else{
			y = Math.round((this.pyramid.topTileFromY - bounds.top)/deg);
		}	
		if (x < 0 || y < 0){
			  return OpenLayers.Util.getImagesLocation() + "blank.gif";
		}
		
		// 加入服务镜像地址处理，如果图层mirrorUrl不为空，则调用HTTPRequest父类的selectUrl方法
		// 从镜像地址数组取一条url
		var accessUrl = "";
		var urlPara = {};
		if(this.mirrorUrl == null){
			accessUrl = this.accessUrl;
			urlPara = {
				"T": this.serviceName,
				"X": x,
				"Y": y,
				"L": level,
				"INDATE": this.verstionTime
			}			
		} else {			
			accessUrl = this.selectUrl(x, this.mirrorUrl); 
			var tmpUrl = accessUrl.split("/services/");
			if (tmpUrl[0] && tmpUrl[1]) {
				accessUrl = tmpUrl[0] + "/DataServer";				
				urlPara = {
					"T": tmpUrl[1],
					"X": x,
					"Y": y,
					"L": level,
					"INDATE": this.verstionTime
				}
			} 
		}
		accessUrl = this.getFullRequestString(urlPara, accessUrl);
		//document.getElementById("output").innerHTML += accessUrl + " , " + bounds.toBBOX() + " " + this.calculateInRange() +" <br>";
		return accessUrl;
		
	},
	
	/**
     * APIMethod: selectUrl
     * 镜像地址分布方法,行号(x)与镜像地址数量取余数。
     * 
     * Parameters:
     * factor - {Integer}
     * urls - {Array(String)}
     * 
     * Returns:
     * {String} 选择地址。
     */
	selectUrl:function(factor, urls){
		var len = urls.length;
		var remainder = factor % len;
		return urls[remainder];
		
	},
	
	/**
     * APIMethod: getDataExtent
     * 获取获取图层范围。
     * 
     * Returns:
     * {<Geo.Bounds>}图层范围。
     */
	getDataExtent: function () {
        if (this.maxExtent){
			return this.maxExtent.clone();
		}
    },
	
	/**
     * APIMethod: clone
     * 复制图层对象。
     * 
     * Returns:
     * {<Geo.View2D.Layer.GlobeTile>} 被克隆的图层对象。
     */
    clone : function(obj){
		if (obj == null) {
			obj = new Geo.View2D.Layer.GlobeTile(this.name,
                                       this.url,
                                       this.options);
		}
	 	obj = Geo.View2D.Layer.Grid.prototype.clone.apply(this, [obj]);
	 	return obj;
	},	
	
	CLASS_NAME: "Geo.View2D.Layer.GlobeTile"
});

/**
 * Class: Geo.View2D.Layer.CWMS
 * CWMS图层类，继承自Geo.View2D.Layer.Grid类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Layer.Grid>
 */
Geo.View2D.Layer.CWMS = Geo.Class(Geo.View2D.Layer.Grid,{
	
	/**
	 * APIProperty: layerId
	 * {String} 图层的唯一编号。
	 */
	layerId : null,
	
	/**
	 * APIProperty: mapStyleId
	 * {String}当前请求图层样式的唯一编号。
	 */
	mapStyleId : null,
	
	/**
	 * APIProperty: srid
	 * {String}图层的参考坐标系id。
	 * 
	 */
	srid : null,
	
	/**
	 * APIProperty: sourceDate
	 * {Date}数据的最后更新日期。
	 */
	sourceDate : null,
	
	/**
	 * APIProperty: formatSuffix
	 * {String}输出图片格式。
	 */
	formatSuffix : null,
	
	/**
     * APIProperty: buffer
     * {String} 瓦片缓存大小。
     */
	buffer : 0,
	
	/**
     * Constructor: Geo.Service.CWMS
     * Geo.Service.CWMS类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *    layerId - {String}图层Id 必填。
     *    mapstyleId - {String}当前请求图层样式的唯一编号 必填。
     *    srid -{String} 图层的参考坐标系 必填。
     *    sourceDate - {Date}据的最后更新日期 必填。
     *    formatSuffix - {String}输出图片格式 可选（默认值是png）。
     *    scales | resolutions - {Array} 比例尺或级别 必填。
     *    maxExtent - {<Geo.Bounds>} 图层的最大范围 必填。
     *  
     *  例子:
     *  (code)
     *  var cwmsLayer1 = new Geo.View2D.Layer.CWMS("cwms1","http://10.4.6.52:7001/CWMS1",{
	 *				layerId:"GeoGlobeMap_1",
	 *				mapStyleId:"GISP:1",
	 *				srid:"EPSG:4326",
	 *				sourceDate:myDate,
	 *				formatSuffix:"png",
	 *				scales:[4622333.678977588,2311166.839488794,1155583.419744397,577791.7098721985,288895.85493609926
	 *				,144447.92746804963,72223.96373402482,36111.98186701241],
	 *				maxExtent :Geo.Bounds.fromString("70.3125,5.625,146.25,56.25")
	 *			
	 *		});
     *  (end)
     */
	initialize: function(name, url, options){
		this.mapStyleId = options.mapStyleId;
		this.srid = options.srid;
		this.sourceDate = options.sourceDate;
		this.formatSuffix = options.formatSuffix || "png" ;
		var para = null;		
		var newArguments = [name, url, para, options];
		Geo.View2D.Layer.Grid.prototype.initialize.apply(this, newArguments);
	},
	
	/**
     * Method: addTile
     * addTile creates a tile, initializes it, and adds it to the layer div. 
     * 
     * Parameters:
     * bounds - {<Geo.Bounds>}
     * position - {<Geo.Pixel>}
     * 
     * Returns:
     * {<Geo.View2D.Tile.Image>} The added Geo.View2D.Tile.Image
     */
    addTile: function(bounds,position) {
        return new Geo.View2D.Tile.Image(this, position, bounds, 
                                         null, this.tileSize);
    },
	
	/**
     * APIMethod: getURL
     * 获取瓦片图片地址。
     * 
     * Paramters:
	 * bounds - {<Geo.Bounds>} 瓦片的范围。
	 * 
	 * Returns:
     * {String} 瓦片图片地址。
     */
	getURL: function(bounds) {
		bounds = this.adjustBounds(bounds);
        var res = this.map.getResolution();
		var fx = (bounds.left - this.map.maxExtent.left) / (res * this.tileSize.w);
		var fy = (this.map.maxExtent.top - bounds.top) / (res * this.tileSize.h);

        var col = Math.floor(fx);
        var row = Math.floor(fy);
		var cwms = new Geo.Service.CWMS(
			this.name,
			this.url
		);
		var currentRes = this.map.getResolution();
		var level = this.map.pyramid.getLevelForResolution(currentRes);
		
		var url = cwms.getMap({
			layerId : this.layerId,
			mapStyleId : this.mapStyleId,
			srid : this.srid,
			sourceDate : this.sourceDate,
			level : level,
			col : col,
			row : row,
			formatSuffix : this.formatSuffix
		});
		
		return url;
	},	
	
	CLASS_NAME: "Geo.View2D.Layer.CWMS"
});/**
 * Class: Geo.View2D.Layer.GeoWMTS
 * 吉奥多时相wmts类，继承自Geo.View2D.Layer.WMTS类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Layer.WMTS>
 */
Geo.View2D.Layer.GeoWMTS = Geo.Class(Geo.View2D.Layer.WMTS, {
	
	/**
     * APIProperty: pyramid
     * {<Geo.Pyramid>} 地图金字塔。
     */
	pyramid : null,
	
	/**
     * APIProperty: time
     * {String} 时间版本。
     *  声明：time的值只能通过setVerstionTime方法才能改变。
     */
	time: "9999-01-01 00:00:00",
	
	/**
	 * APIProperty: userecent
	 * 为FALSE时只有存在指定时相的瓦片数据时，才返回瓦片数据，
	 * 否则返回提示。为TRUE时，只要存在不晚于指定时相的瓦片数据时，
	 * 返回其中最新的瓦片数据。默认为true。
	 */
	userecent: true,
	
	/**
     * Constructor: Geo.View2D.Layer.GeoWMTS
     * 创建GeoWMTS图层对象实例。
     *
     * Parameters:
     * name - {String} GeoGlobe瓦片图层名称。
     * url - {String} 瓦片服务地址。
     * options - {Object} 对象构造参数。
     * 
     * 示例:
     * (code)
     * 
     * (end)
     */
	initialize : function(options) {
		var params = {};
		if(options.params) {//支持老结构
			if(options.params.time) {
				this.time = options.params.time;
			}
			if(typeof options.params.userecent === "boolean") {
				this.userecent = options.params.userecent;
			}
		}else {//支持新结构
			if(options.time) {
				params.time = options.time;
				this.time = options.time;
			}
			if(typeof options.userecent === "boolean") {
				params.userecent = options.userecent;
				this.userecent = options.userecent;
			}
			options.params = params;
		}
		options.pyramid = options.pyramid ? options.pyramid : new Geo.Pyramid();
		Geo.View2D.Layer.WMTS.prototype.initialize.apply(this, arguments);
	},
	
	/**
     * APIMethod: setVerstionTime
     * 设置历史版本,设置版本后会重新绘制本图层。
     * 
     * Paramters:
	 * verstion - {<String>} 历史版本号,格式为"2010-06-23 18:48:23"。
     */
    setVerstionTime: function(verstion){
    	if(verstion){
    		this.params.TIME = verstion;
			this.time = verstion;
    		this.redraw();
    	}
    },
	
	/**
     * APIMethod: setParams
     *  设置多时相相关参数。
     * 
     * Paramters:
	 *  params:
	 *   time - {String}时间版本。
	 *   userecent - {Boolean} 
	 *   为FALSE时只有存在指定时相的瓦片数据时，才返回瓦片数据，
	 *   否则返回提示。为TRUE时，只要存在不晚于指定时相的瓦片数据时，
	 *   返回其中最新的瓦片数据。默认为true。
     */
	setParams: function(params) {
		if(params.time) {
			this.params.TIME = params.time;
			this.time = params.time;
			var userecent = typeof params.userecent == "boolean" ? params.userecent : true;
			this.params.USERECENT = userecent;
			this.userecent = userecent;
			this.redraw();
		}
	},
	
    /** 
     * Method: getTileInfo
     * Get tile information for a given location at the current map resolution.
     *
     * Parameters:
     * loc - {<OpenLayers.LonLat} A location in map coordinates.
     *
     * Returns:
     * {Object} An object with "col", "row", "i", and "j" properties.  The col
     *     and row values are zero based tile indexes from the top left.  The
     *     i and j values are the number of pixels to the left and top 
     *     (respectively) of the given location within the target tile.
     */
    getTileInfo: function(lonlat) {
		var level = this.pyramid.getLevelForResolution(this.map.getResolution());
		var lon = lonlat.lon;
		var lat = lonlat.lat;
		var size = this.pyramid.getTopTileSize()
		var degree = size.w / Math.pow(2,level);
		
		//金字塔宽高
		var width = this.pyramid.maxExtent.getWidth();
		var height = this.pyramid.maxExtent.getHeight();
		
		//总行列数
		var totalCol = Math.round(width / degree);
		var totalRow = Math.round(height / degree);
		
		//计算列索引号
		var isStartLeft = (this.pyramid.topTileFromX < this.pyramid.topTileToX) ? true : false;
		var colIndex = Math.ceil(Math.abs(lon - this.pyramid.topTileFromX)/degree) - 1;
		if(!isStartLeft){
			colIndex = totalCol - colIndex;
		}
		
		var isStartTop = (this.pyramid.topTileFromY > this.pyramid.topTileToY) ? true : false;
		var rowIndex = Math.ceil(Math.abs(lat - this.pyramid.topTileFromY)/degree) - 1;
		if (!isStartTop){
			rowIndex = totalRow - rowIndex;
		}
		
		return {
			col: colIndex,
			row: rowIndex
		}
    },
	
	/**
     * APIMethod: clone
     * 复制图层对象。
     * 
     * Returns:
     * {<Geo.View2D.Layer.GlobeTile>} 被克隆的图层对象。
     */
    clone : function(obj){
		if (obj == null) {
			obj = new Geo.View2D.Layer.GeoWMTS(this.options);
		}
	 	obj = Geo.View2D.Layer.WMTS.prototype.clone.apply(this, [obj]);
	 	return obj;
	},	
	
	CLASS_NAME: "Geo.View2D.Layer.GeoWMTS"
});/**
 * Class: Geo.View2D.Layer.ArcGISTileLayer
 *	 ArcGIS瓦片图层是用于加载ArcGIS地图瓦片服务的图层。
 *	 本图层支持等比分辨率的地图瓦片服务或非等比分辨率的地图瓦片服务的加载。
 */ 
Geo.View2D.Layer.ArcGISTileLayer = Geo.Class(Geo.View2D.Layer.XYZ, {  

    /**
     * APIProperty: url
     * {String} ArcGIS地图瓦片服务地址
     */
    url: null,
	
	/**
     * Property: useArcGISServer
     * {String | Array} 
     */
	useArcGISServer:true,
    
   /**
    * Constructor: Geo.View2D.Layer.ArcGISTileLayer
    * 
    * Parameters: 
    * name - {String} 图层名称
    * url - {String} arcgis地图瓦片服务地址
    * 
    * 示例:
    * (code)
    * 	var arcgisTileLayer = new Geo.View2D.Layer.ArcGISTileLayer("arc", "http://192.168.32.64/ArcGIS/rest/services/2dmap/MapServer");
    * (end)
    */ 
    initialize: function(name, url, options) {
        OpenLayers.Layer.XYZ.prototype.initialize.apply(this, arguments);

        if (this.resolutions) {        
            this.serverResolutions = this.resolutions;
            this.maxExtent = this.getMaxExtentForResolution(this.resolutions[0]);
        }
		this.jsonp = new OpenLayers.Protocol.Script();
		this.jsonp.createRequest(url, {
            f: 'json',
            pretty: 'true'
        }, OpenLayers.Function.bind(this._loadTiles,this));
    }, 
	
	/** 
    * Method: _loadTiles
    * 访问服务能力描述信息的回调函数
    */
	_loadTiles: function(layerInfo) {
	        if (layerInfo) {
          
            var info = layerInfo;
            
            // build our extents
            var startingTileExtent = new OpenLayers.Bounds(
                info.fullExtent.xmin, 
                info.fullExtent.ymin, 
                info.fullExtent.xmax, 
                info.fullExtent.ymax  
            );

           
            this.projection = 'EPSG:' + info.spatialReference.wkid;
            this.sphericalMercator = (info.spatialReference.wkid == 102100);
            
            // convert esri units into openlayers units (basic feet or meters only)
            this.units = (info.units == "esriFeet") ? 'dd' : 'm';

            // optional extended section based on whether or not the server returned
            // specific tile information
            if (!!info.tileInfo) {            
                // either set the tiles based on rows/columns, or specific width/height
                this.tileSize = new OpenLayers.Size(
                    info.tileInfo.width || info.tileInfo.cols, 
                    info.tileInfo.height || info.tileInfo.rows
                );
                
                // this must be set when manually configuring this layer
                this.tileOrigin = new OpenLayers.LonLat(
                    info.tileInfo.origin.x, 
                    info.tileInfo.origin.y
                );

                var upperLeft = new OpenLayers.Geometry.Point(
                    startingTileExtent.left, 
                    startingTileExtent.top
                );
                
                var bottomRight = new OpenLayers.Geometry.Point(
                    startingTileExtent.right, 
                    startingTileExtent.bottom
                );            
                
                if (this.useScales) {
                    this.scales = [];
                } else {
                    this.resolutions = [];
                }
                
                this.lods = [];
                for(var key in info.tileInfo.lods) {
                    if (info.tileInfo.lods.hasOwnProperty(key)) {
                        var lod = info.tileInfo.lods[key];
                        if (this.useScales) {
                            this.scales.push(lod.scale);
                        } else {
                            this.resolutions.push(lod.resolution);
                        }
                    
                        var start = this.getContainingTileCoords(upperLeft, lod.resolution);
                        lod.startTileCol = start.x;
                        lod.startTileRow = start.y;
                    
                        var end = this.getContainingTileCoords(bottomRight, lod.resolution);
                        lod.endTileCol = end.x;
                        lod.endTileRow = end.y;    
                        this.lods.push(lod);
                    }
                }
				
                this.maxExtent = this.calculateMaxExtentWithLOD(this.lods[0]);

                this.serverResolutions = this.resolutions;
				
                if (this.overrideDPI && info.tileInfo.dpi) {
                    // see comment above for 'overrideDPI'
                    OpenLayers.DOTS_PER_INCH = info.tileInfo.dpi;
                }
            } 
       }
		
	},

	/** 
    * APIMethod: setMap
    * 添加图层到地图。
    */
	setMap: function() {
		OpenLayers.Layer.XYZ.prototype.setMap.apply(this, arguments);
		var that = this;
//		this.map.events.register("zoomend", this, function() {
//			
//			that.maxExtent = this.calculateMaxExtentWithLOD(that.lods[that.map.getZoom()]);
//		});
	},

   /** 
    * Method: getContainingTileCoords
    * Calculates the x/y pixel corresponding to the position of the tile
    *     that contains the given point and for the for the given resolution.
    * 
    * Parameters:
    * point - {<OpenLayers.Geometry.Point>} 
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<OpenLayers.Pixel>} The x/y pixel corresponding to the position 
    * of the upper left tile for the given resolution.
    */
    getContainingTileCoords: function(point, res) {
        return new OpenLayers.Pixel(
           Math.max(Math.floor((point.x - this.tileOrigin.lon) / (this.tileSize.w * res)),0),
           Math.max(Math.floor((this.tileOrigin.lat - point.y) / (this.tileSize.h * res)),0)
        );
    },
    
   /** 
    * Method: calculateMaxExtentWithLOD
    * Given a Level of Detail object from the server, this function
    *     calculates the actual max extent
    * 
    * Parameters: 
    * lod - {Object} a Level of Detail Object from the server capabilities object 
            representing a particular zoom level
    * 
    * Returns: 
    * {<OpenLayers.Bounds>} The actual extent of the tiles for the given zoom level
    */
   calculateMaxExtentWithLOD: function(lod) {

        var numTileCols = (lod.endTileCol - lod.startTileCol) + 1;
        var numTileRows = (lod.endTileRow - lod.startTileRow) + 1;        

        var minX = this.tileOrigin.lon + (lod.startTileCol * this.tileSize.w * lod.resolution);
        var maxX = minX + (numTileCols * this.tileSize.w * lod.resolution);

        var maxY = this.tileOrigin.lat - (lod.startTileRow * this.tileSize.h * lod.resolution);
        var minY = maxY - (numTileRows * this.tileSize.h * lod.resolution);
        return new OpenLayers.Bounds(minX, minY, maxX, maxY);
   },
    
   /** 
    * Method: calculateMaxExtentWithExtent
    * 
    * Parameters: 
    * extent - {<OpenLayers.Bounds>} The 'suggested' extent for the layer
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<OpenLayers.Bounds>} The actual extent of the tiles for the given zoom level
    */
   calculateMaxExtentWithExtent: function(extent, res) {
        var upperLeft = new OpenLayers.Geometry.Point(extent.left, extent.top);
        var bottomRight = new OpenLayers.Geometry.Point(extent.right, extent.bottom);
        var start = this.getContainingTileCoords(upperLeft, res);
        var end = this.getContainingTileCoords(bottomRight, res);
        var lod = {
            resolution: res,
            startTileCol: start.x,
            startTileRow: start.y,
            endTileCol: end.x,
            endTileRow: end.y
        };
        return this.calculateMaxExtentWithLOD(lod);
   },
    
    /** 
    * Method: getUpperLeftTileCoord
    * 
    * Parameters: 
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<OpenLayers.Pixel>} The x/y pixel corresponding to the position 
    * of the upper left tile for the given resolution.
    */
    getUpperLeftTileCoord: function(res) {
        var upperLeft = new OpenLayers.Geometry.Point(
            this.maxExtent.left,
            this.maxExtent.top);
        return this.getContainingTileCoords(upperLeft, res);
    },

    /** 
    * Method: getLowerRightTileCoord
    *  
    * Parameters: 
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<OpenLayers.Pixel>} The x/y pixel corresponding to the position
    * of the lower right tile for the given resolution.
    */
    getLowerRightTileCoord: function(res) {
        var bottomRight = new OpenLayers.Geometry.Point(
            this.maxExtent.right,
            this.maxExtent.bottom);
        return this.getContainingTileCoords(bottomRight, res);
    },
    
   /** 
    * Method: getMaxExtentForResolution
    * Since the max extent of a set of tiles can change from zoom level
    *     to zoom level, we need to be able to calculate that max extent 
    *     for a given resolution.
    *
    * Parameters: 
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<OpenLayers.Bounds>} The extent for this resolution
    */ 
    getMaxExtentForResolution: function(res) {
        var start = this.getUpperLeftTileCoord(res);
        var end = this.getLowerRightTileCoord(res);

        var numTileCols = (end.x - start.x) + 1;
        var numTileRows = (end.y - start.y) + 1;

        var minX = this.tileOrigin.lon + (start.x * this.tileSize.w * res);
        var maxX = minX + (numTileCols * this.tileSize.w * res);
        
        var maxY = this.tileOrigin.lat - (start.y * this.tileSize.h * res);
        var minY = maxY - (numTileRows * this.tileSize.h * res);
        return new OpenLayers.Bounds(minX, minY, maxX, maxY);
    },
    
   /** 
    * APIMethod: clone 
    * 克隆本图层
    * 
    * Parameters: 
    * [obj] - {Object} 本图层对象的一个实例
    *  
    * Returns: 
    * {<Geo.View2D.Layer.ArcGISTileLayer>} 克隆对象
    */ 
    clone: function (obj) { 
        if (obj == null) { 
            obj = new Geo.View2D.Layer.ArcGISTileLayer(this.name, this.url, this.options);
        }
        return OpenLayers.Layer.XYZ.prototype.clone.apply(this, [obj]);
    },

    /**
     * Method: getMaxExtent
     * Get this layer's maximum extent.
     *
     * Returns:
     * {OpenLayers.Bounds}
     */
    getMaxExtent: function() {
        var resolution = this.map.getResolution();
        return this.maxExtent;// = this.getMaxExtentForResolution(resolution);
    },

    /**
     * Method: getTileOrigin
     * Determine the origin for aligning the grid of tiles.  
     *     The origin will be derived from the layer's <maxExtent> property. 
     *
     * Returns:
     * {<OpenLayers.LonLat>} The tile origin.
     */
    getTileOrigin: function() {
        var extent = this.getMaxExtent();
        return new OpenLayers.LonLat(extent.left, extent.bottom);
    },

   /**
    * Method: getURL
    * Determine the URL for a tile given the tile bounds.  This is should support
    *     urls that access tiles through an ArcGIS Server MapServer or directly through
    *     the hex folder structure using HTTP.  Just be sure to set the useArcGISServer
    *     property appropriately!  This is basically the same as 
    *     'OpenLayers.Layer.TMS.getURL',  but with the addition of hex addressing,
    *     and tile rounding.
    *
    * Parameters:
    * bounds - {<OpenLayers.Bounds>}
    *
    * Returns:
    * {String} The URL for a tile based on given bounds.
    */
    getURL: function (bounds) {
        var res = this.getResolution(); 

        // tile center
        var originTileX = (this.tileOrigin.lon + (res * this.tileSize.w/2)); 
        var originTileY = (this.tileOrigin.lat - (res * this.tileSize.h/2));

        var center = bounds.getCenterLonLat();
        var point = { x: center.lon, y: center.lat };
        var x = (Math.round(Math.abs((center.lon - originTileX) / (res * this.tileSize.w)))); 
        var y = (Math.round(Math.abs((originTileY - center.lat) / (res * this.tileSize.h)))); 
        var z = this.map.getZoom();

        // this prevents us from getting pink tiles (non-existant tiles)
        if (this.lods) {        
            var lod = this.lods[this.map.getZoom()];
            if ((x < lod.startTileCol || x > lod.endTileCol) 
                || (y < lod.startTileRow || y > lod.endTileRow)) {
                    return null;
            }
        }
        else {
            var start = this.getUpperLeftTileCoord(res);
            var end = this.getLowerRightTileCoord(res);
            if ((x < start.x || x >= end.x)
                || (y < start.y || y >= end.y)) {
                    return null;
            }        
        }

        // Construct the url string
        var url = this.url;
        var s = '' + x + y + z;

        if (OpenLayers.Util.isArray(url)) {
            url = this.selectUrl(s, url);
        }
		
        // Accessing tiles through ArcGIS Server uses a different path
        // structure than direct access via the folder structure.
        if (this.useArcGISServer) {
            // AGS MapServers have pretty url access to tiles
            url = url + '/tile/${z}/${y}/${x}';
        } else {
            // The tile images are stored using hex values on disk.
            x = 'C' + this.zeroPad(x, 8, 16);
            y = 'R' + this.zeroPad(y, 8, 16);
            z = 'L' + this.zeroPad(z, 2, 16);
            url = url + '/${z}/${y}/${x}.' + this.type;
        }

        // Write the values into our formatted url
        url = OpenLayers.String.format(url, {'x': x, 'y': y, 'z': z});

        return url;
    },

    /**
     * Method: zeroPad
     * Create a zero padded string optionally with a radix for casting numbers.
     *
     * Parameters:
     * num - {Number} The number to be zero padded.
     * len - {Number} The length of the string to be returned.
     * radix - {Number} An integer between 2 and 36 specifying the base to use
     *     for representing numeric values.
     */
    zeroPad: function(num, len, radix) {
		
        var str = num.toString(radix || 10);
        while (str.length < len) {
            str = "0" + str;
        }
        return str;
    },

    CLASS_NAME: 'Geo.View2D.Layer.ArcGISTileLayer' 
}); /**
 * Copyright (C) 2013 OSM Buildings, Jan Marsch
 * A leightweight JavaScript library for visualizing 3D building geometry on interactive maps.
 * @osmbuildings, http://osmbuildings.org
 */

var OSMBuildings = (function() {

    'use strict';



// object access shortcuts  ;  Int32Array:8位有符号整数
var Int32Array = Int32Array || Array,
	//Uint8Array:8位无符号整数
    Uint8Array = Uint8Array || Array,
    m = Math,
    exp = m.exp,
    log = m.log,
    sin = m.sin,
    cos = m.cos,
    tan = m.tan,
    atan = m.atan,
    min = m.min,
    max = m.max,
    ceil = m.ceil,
    floor = m.floor,
    doc = document;





var Color = (function() {

    function hsla2rgb(hsla) { // h belongs to [0, 360]; s,l,a belong to [0, 1]
        var r, g, b;

        if (hsla.s === 0) {
            r = g = b = hsla.l; // achromatic
        } else {
            var q = hsla.l < 0.5 ? hsla.l * (1+hsla.s) : hsla.l + hsla.s - hsla.l * hsla.s,
                p = 2 * hsla.l-q;
            hsla.h /= 360;
            r = hue2rgb(p, q, hsla.h + 1/3);
            g = hue2rgb(p, q, hsla.h);
            b = hue2rgb(p, q, hsla.h - 1/3);
        }
        return new Color(
            r * 255 <<0,
            g * 255 <<0,
            b * 255 <<0,
            hsla.a
        );
    }

    function hue2rgb(p, q, t) {
        if (t < 0) {
            t += 1;
        }
        if (t > 1) {
            t -= 1;
        }
        if (t < 1 / 6) {
            return p + (q-p) * 6 * t;
        }
        if (t < 1 / 2) {
            return q;
        }
        if (t < 2 / 3) {
            return p + (q-p) * (2/3 - t) * 6;
        }
        return p;
    }

    function Color(r, g, b, a) { // r,g,b belong to [0, 255]; a belongs to [0,1]
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = arguments.length < 4 ? 1 : a;
    }

    var proto = Color.prototype;

    proto.toString = function() {
//        if (this.a === 1) {
//            return '#' + ((1 << 24) + (this.r << 16) + (this.g << 8) + this.b).toString(16).slice(1, 7);
//        }
        return 'rgba(' + [this.r <<0, this.g <<0, this.b <<0, this.a.toFixed(2)].join(',') + ')';
    };

    proto.setLightness = function(l) {
        var hsla = Color.toHSLA(this);
        hsla.l *= l;
        hsla.l = Math.min(1, Math.max(0, hsla.l));
        return hsla2rgb(hsla);
    };

    proto.setAlpha = function(a) {
        return new Color(this.r, this.g, this.b, this.a * a);
    };

    /*
     * str can be in any of the following forms:
     * "#[00-ff][00-ff][00-ff]", "#[00-ff][00-ff][00-ff][00-ff]",
     * "rgb([0-255],[0-255],[0-255])", "rgba([0-255],[0-255],[0-255],[0-1])",
     * "hsl([0-360],[0-1],[0-1])", "hsla([0-360],[0-1],[0-1],[0-1])"
     */
    Color.parse = function(str) {
        var m;
        str += '';
        if (~str.indexOf('#') && (m = str.match(/^#?(\w{2})(\w{2})(\w{2})(\w{2})?$/))) {
            return new Color(
                parseInt(m[1], 16),
                parseInt(m[2], 16),
                parseInt(m[3], 16),
                m[4] ? parseInt(m[4], 16) / 255 : 1
            );
        }

        if ((m = str.match(/rgba?\((\d+)\D+(\d+)\D+(\d+)(\D+([\d.]+))?\)/))) {
            return new Color(
                parseInt(m[1], 10),
                parseInt(m[2], 10),
                parseInt(m[3], 10),
                m[4] ? parseFloat(m[5]) : 1
            );
        }

        if ((m = str.match(/hsla?\(([\d.]+)\D+([\d.]+)\D+([\d.]+)(\D+([\d.]+))?\)/))) {
            return hsla2rgb({
                h: parseInt(m[1], 10),
                s: parseFloat(m[2]),
                l: parseFloat(m[3]),
                a: m[4] ? parseFloat(m[5]) : 1
            });
        }
    };

    Color.toHSLA = function(rgba) { // r,g,b belong to [0, 255]; a belongs to [0,1]
        var r = rgba.r/255,
            g = rgba.g/255,
            b = rgba.b/255,
            max = Math.max(r, g, b), min = Math.min(r, g, b),
            h, s, l = (max+min) / 2,
            d;

        if (max === min) {
            h = s = 0; // achromatic
        } else {
            d = max-min;
            s = l > 0.5 ? d / (2-max-min) : d / (max+min);
            switch (max) {
                case r: h = (g-b) / d + (g < b ? 6 : 0); break;
                case g: h = (b-r) / d + 2; break;
                case b: h = (r-g) / d + 4; break;
            }
            h /= 6;
        }

        return { h:h*360, s:s, l:l, a:rgba.a };
    };

    return Color;

}());



// calculations are based on http://aa.quae.nl/en/reken/zonpositie.html
// code credits to Vladimir Agafonkin (@mourner)

var getSunPosition = (function() {

    var m = Math,
      PI = m.PI,
      sin = m.sin,
      cos = m.cos,
      tan = m.tan,
      asin = m.asin,
      atan = m.atan2;

    var rad = PI/180,
      dayMs = 1000*60*60*24,
      J1970 = 2440588,
      J2000 = 2451545,
      e = rad*23.4397; // obliquity of the Earth

    function toJulian(date) {
      return date.valueOf()/dayMs - 0.5+J1970;
    }
    function toDays(date) {
      return toJulian(date)-J2000;
    }
    function getRightAscension(l, b) {
      return atan(sin(l)*cos(e) - tan(b)*sin(e), cos(l));
    }
    function getDeclination(l, b) {
      return asin(sin(b)*cos(e) + cos(b)*sin(e)*sin(l));
    }
    function getAzimuth(H, phi, dec) {
      return atan(sin(H), cos(H)*sin(phi) - tan(dec)*cos(phi));
    }
    function getAltitude(H, phi, dec) {
      return asin(sin(phi)*sin(dec) + cos(phi)*cos(dec)*cos(H));
    }
    function getSiderealTime(d, lw) {
      return rad * (280.16 + 360.9856235*d) - lw;
    }
    function getSolarMeanAnomaly(d) {
      return rad * (357.5291 + 0.98560028*d);
    }
    function getEquationOfCenter(M) {
      return rad * (1.9148*sin(M) + 0.0200 * sin(2*M) + 0.0003 * sin(3*M));
    }
    function getEclipticLongitude(M, C) {
      var P = rad*102.9372; // perihelion of the Earth
      return M+C+P+PI;
    }

    return function getSunPosition(date, lat, lon) {
      var lw = rad*-lon,
        phi = rad*lat,
        d = toDays(date),
        M = getSolarMeanAnomaly(d),
        C = getEquationOfCenter(M),
        L = getEclipticLongitude(M, C),
        D = getDeclination(L, 0),
        A = getRightAscension(L, 0),
        t = getSiderealTime(d, lw),
        H = t-A;

      return {
        altitude: getAltitude(H, phi, D),//垂直高度
        azimuth: getAzimuth(H, phi, D) - PI/2 // origin: north   //方向角
      };
    };

}());



var readGeoJSON = function(collection) {
    var i, il, j, jl, k, kl,
        res = [],
        feature,
        geometry, properties, coordinates,
        wallColor, roofColor,
        last,
        height,
        polygon, footprint, heightSum, holes,
        lat = 1, lon = 0, alt = 2,
        item;

    for (i = 0, il = collection.length; i < il; i++) {
        feature = collection[i];
        if (feature.type !== 'Feature') {
            continue;
        }

        geometry = feature.geometry;
        properties = feature.properties;

        if (geometry.type === 'LineString') {
            last = coordinates.length-1;
            if (coordinates[0][0] === coordinates[last][0] && coordinates[0][1] === coordinates[last][1]) {
                coordinates = geometry.coordinates;
            }
        }

        if (geometry.type === 'Polygon') {
            coordinates = geometry.coordinates;
        }

        // just use the outer ring
        if (geometry.type === 'MultiPolygon') {
            coordinates = geometry.coordinates[0];
        }

        if (!coordinates) {
            continue;
        }

        if (properties.color || properties.wallColor) {
            wallColor = properties.color || properties.wallColor;
        }

        if (properties.roofColor) {
            roofColor = properties.roofColor;
        }

        polygon   = coordinates[0];
        footprint = [];
        height    = properties.height;
        heightSum = 0;
        for (j = 0, jl = polygon.length; j < jl; j++) {
            footprint.push(polygon[j][lat], polygon[j][lon]);
            heightSum += height || polygon[j][alt] || 0;
        }

        holes = [];
        for (j = 1, jl = coordinates.length; j < jl; j++) {
            polygon = coordinates[i];
            holes[j-1] = [];
			//fixed:为了防止polygon.length报错
			if(!polygon) {
				continue;
			}
            for (k = 0, kl = polygon.length; k < kl; k++) {
                holes[j-1].push(polygon[k][lat], polygon[k][lon]);
            }
        }

        // one item per coordinates ring (usually just one ring)
        item = {
            id:properties.id || (footprint[0] + ',' + footprint[1]),
            footprint:makeWinding(footprint, 'CW')
        };
		//fixed:为了防止polygon为空，加了对几何信息的判断
		if(polygon) {
			 if (heightSum)            item.height    = heightSum/polygon.length <<0;
		}
       
        if (properties.minHeight) item.minHeight = properties.minHeight;
        if (wallColor)            item.wallColor = wallColor;
        if (roofColor)            item.roofColor = roofColor;
        if (holes.length)     item.holes = holes;
        res.push(item);
    }

    return res;
};



var readOSMXAPI = (function() {

    var YARD_TO_METER = 0.9144,
        FOOT_TO_METER = 0.3048,
        INCH_TO_METER = 0.0254,
        METERS_PER_LEVEL = 3;

    function parseDimension(str) {
        var value = parseFloat(str);

        if (~str.indexOf('m')) {
            return value <<0;
        }
        if (~str.indexOf('yd')) {
            return value*YARD_TO_METER <<0;
        }
        if (~str.indexOf('ft')) {
            return value*FOOT_TO_METER <<0;
        }
        if (~str.indexOf('\'')) {
            var parts = str.split('\'');
            var res = parts[0]*FOOT_TO_METER + parts[1]*INCH_TO_METER;
            return res <<0;
        }
        return value <<0;
    }

    var baseMaterials = {
        asphalt:'tar_paper',
        bitumen:'tar_paper',
        block:'stone',
        bricks:'brick',
        glas:'glass',
        glassfront:'glass',
        grass:'plants',
        masonry:'stone',
        granite:'stone',
        panels:'panel',
        paving_stones:'stone',
        plastered:'plaster',
        rooftiles:'roof_tiles',
        roofingfelt:'tar_paper',
        sandstone:'stone',
        sheet:'canvas',
        sheets:'canvas',
        shingle:'tar_paper',
        shingles:'tar_paper',
        slates:'slate',
        steel:'metal',
        tar:'tar_paper',
        tent:'canvas',
        thatch:'plants',
        tile:'roof_tiles',
        tiles:'roof_tiles'
    };

    // cardboard
    // eternit
    // limestone
    // straw

    var materialColors = {
        brick:'#cc7755',
        bronze:'#ffeecc',
        canvas:'#fff8f0',
        concrete:'#999999',
        copper:'#a0e0d0',
        glass:'#e8f8f8',
        gold:'#ffcc00',
        plants:'#009933',
        metal:'#aaaaaa',
        panel:'#fff8f0',
        plaster:'#999999',
        roof_tiles:'#f08060',
        silver:'#cccccc',
        slate:'#666666',
        stone:'#996666',
        tar_paper:'#333333',
        wood:'#deb887'
    };

    function parseMaterial(str) {
        str = str.toLowerCase();
        if (str[0] === '#') {
            return str;
        }
        return materialColors[baseMaterials[str] || str] || null;
    }

    function isBuilding(data) {
        var tags = data.tags;
        return (tags &&
            !tags.landuse &&
            (tags.building || tags['building:part']) &&
            (!tags.layer || tags.layer >= 0));
    }

//  living:'bricks',
//  nonliving:'tar_paper',
//  worship:'copper'

    function getBuildingType(tags) {
        if (tags.amenity === 'place_of_worship') {
            return 'worship';
        }

        var type = tags.building;
        if (type === 'yes' || type === 'roof') {
            type = tags['building:use'];
        }
        if (!type) {
            type = tags.amenity;
        }

        switch (type) {
            case 'apartments':
            case 'house':
            case 'residential':
            case 'hut':
                return 'living';
            case 'church':
                return 'worship';
        }

        return 'nonliving';
    }

    function getRelationWays(members) {
        var m, outer, inner = [];
        for (var i = 0, il = members.length; i < il; i++) {
            m = members[i];
            if (m.type !== 'way' || !ways[m.ref]) {
                continue;
            }
            if (!m.role || m.role === 'outer') {
                outer = ways[m.ref];
                continue;
            }
            if (m.role === 'inner' || m.role === 'enclave') {
                inner.push(ways[m.ref]);
                continue;
            }
        }
        if (!outer || !outer.tags) {
            return;
        }
        return { outer:outer, inner:inner };
    }

    function getFootprint(points) {
        if (!points) {
            return;
        }

        var footprint = [], p;
        for (var i = 0, il = points.length; i < il; i++) {
            p = nodes[ points[i] ];
            footprint.push(p[0], p[1]);
        }

        // do not close polygon yet
        if (footprint[footprint.length-2] !== footprint[0] && footprint[footprint.length-1] !== footprint[1]) {
            footprint.push(footprint[0], footprint[1]);
        }

        // can't span a polygon with just 2 points (+ start & end)
        if (footprint.length < 8) {
            return;
        }

        return footprint;
    }

    function mergeTags(dst, src) {
        for (var p in src) {
            if (!dst[p]) {
                dst[p] = src[p];
            }
        }
        return dst;
    }

    function filterTags(tags) {
        var height = 0, minHeight = 0;

        if (tags.height) {
            height = parseDimension(tags.height);
        }
        if (!height && tags['building:height']) {
            height = parseDimension(tags['building:height']);
        }

        if (!height && tags.levels) {
            height = tags.levels*METERS_PER_LEVEL <<0;
        }
        if (!height && tags['building:levels']) {
            height = tags['building:levels']*METERS_PER_LEVEL <<0;
        }

        // min_height
        if (tags.min_height) {
            minHeight = parseDimension(tags.min_height);
        }
        if (!minHeight && tags['building:min_height']) {
            minHeight = parseDimension(tags['building:min_height']);
        }

        if (!minHeight && tags.min_level) {
            minHeight = tags.min_level*METERS_PER_LEVEL <<0;
        }
        if (!minHeight && tags['building:min_level']) {
            minHeight = tags['building:min_level']*METERS_PER_LEVEL <<0;
        }

        var wallColor, roofColor;

        // wall material
        if (tags['building:material']) {
            wallColor = parseMaterial(tags['building:material']);
        }
        if (tags['building:facade:material']) {
            wallColor = parseMaterial(tags['building:facade:material']);
        }
        if (tags['building:cladding']) {
            wallColor = parseMaterial(tags['building:cladding']);
        }
        // wall color
        if (tags['building:color']) {
            wallColor = tags['building:color'];
        }
        if (tags['building:colour']) {
            wallColor = tags['building:colour'];
        }

        // roof material
        if (tags['roof:material']) {
            roofColor = parseMaterial(tags['roof:material']);
        }
        if (tags['building:roof:material']) {
            roofColor = parseMaterial(tags['building:roof:material']);
        }
        // roof color
        if (tags['roof:color']) {
            roofColor = tags['roof:color'];
        }
        if (tags['roof:colour']) {
            roofColor = tags['roof:colour'];
        }
        if (tags['building:roof:color']) {
            roofColor = tags['building:roof:color'];
        }
        if (tags['building:roof:colour']) {
            roofColor = tags['building:roof:colour'];
        }

        return {
            height:    height,
            minHeight: minHeight,
            wallColor: wallColor,
            roofColor: roofColor
        };
    }

    function processNode(node) {
        nodes[node.id] = [node.lat, node.lon];
    }

    function processWay(way) {
        var tags, footprint;
        if (isBuilding(way)) {
            tags = filterTags(way.tags);
            if ((footprint = getFootprint(way.nodes))) {
                addResult(way.id, tags, footprint);
            }
        } else {
            tags = way.tags;
            if (!tags || (!tags.highway && !tags.railway && !tags.landuse)) { // TODO: add more filters
                ways[way.id] = way;
            }
        }
    }

    function processRelation(relation) {
        var relationWays, outerWay, holes = [],
            tags, outerFootprint, innerFootprint;
        if (isBuilding(relation) && (relation.tags.type === 'multipolygon' || relation.tags.type === 'building')) {
            if ((relationWays = getRelationWays(relation.members))) {
                var relTags = filterTags(relation.tags);
                if ((outerWay = relationWays.outer)) {
                    tags = filterTags(outerWay.tags);
                    if ((outerFootprint = getFootprint(outerWay.nodes))) {
                        tags = mergeTags(tags, relTags);
                        for (var i = 0, il = relationWays.inner.length; i < il; i++) {
                            if ((innerFootprint = getFootprint(relationWays.inner[i].nodes))) {
                                holes.push(makeWinding(innerFootprint, 'CCW'));
                            }
                        }
                        addResult(outerWay.id, tags, outerFootprint, holes.length ? holes : null);
                    }
                }
            }
        }
    }

    function addResult(id, tags, footprint, holes) {
        var item = { id:id, footprint:makeWinding(footprint, 'CW'), holes:holes };
        if (tags.height)    item.height    = tags.height;
        if (tags.minHeight) item.minHeight = tags.minHeight;
        if (tags.wallColor) item.wallColor = tags.wallColor;
        if (tags.roofColor) item.roofColor = tags.roofColor;
        if (holes)      item.holes = holes;
        res.push(item);
    }

    var nodes, ways, res;

    return function(data) {
        nodes = {};
        ways = {};
        res = [];

        var item;
        for (var i = 0, il = data.length; i < il; i++) {
            item = data[i];
            switch(item.type ) {
                case 'node':     processNode(item);     break;
                case 'way':      processWay(item);      break;
                case 'relation': processRelation(item); break;
            }
        }

        return res;
    };
})();



// constants, shared to all instances
var VERSION      = '0.1.8a',
    ATTRIBUTION  = '&copy; <a href="http://osmbuildings.org">OSM Buildings</a>',
    OSM_XAPI_URL = 'http://overpass-api.de/api/interpreter?data=[out:json];(way[%22building%22]({s},{w},{n},{e});node(w);way[%22building:part%22=%22yes%22]({s},{w},{n},{e});node(w);relation[%22building%22]({s},{w},{n},{e});way(r);node(w););out;',
//  OSM_XAPI_URL = 'http://overpass.osm.rambler.ru/cgi/interpreter?data=[out:json];(way[%22building%22]({s},{w},{n},{e});node(w);way[%22building:part%22=%22yes%22]({s},{w},{n},{e});node(w);relation[%22building%22]({s},{w},{n},{e});way(r);node(w););out;',

    PI         = Math.PI,
    HALF_PI    = PI/2,
    QUARTER_PI = PI/4,
    RAD        = 180/PI,

    MAP_TILE_SIZE  = 256,    // map tile size in pixels
    DATA_TILE_SIZE = 0.0075, // data tile size in geo coordinates, smaller: less data to load but more requests

    MIN_ZOOM = 15,

    LAT = 'latitude', LON = 'longitude',

    DEFAULT_HEIGHT = 15,
    HEIGHT_SCALE = 3;



function getDistance(p1, p2) {
    var dx = p1[0]-p2[0],
        dy = p1[1]-p2[1];
    return dx*dx + dy*dy;
}
//不理解
function crop(num) {
    return (num*10000 << 0) / 10000;
}

function getCenter(points) {
    var len, x = 0, y = 0;
    for (var i = 0, il = points.length-3; i < il; i += 2) {
        x += points[i];
        y += points[i+1];
    }
    len = (points.length-2) / 2;
    return [x/len <<0, y/len <<0];
}

function getSquareSegmentDistance(px, py, p1x, p1y, p2x, p2y) {
    var dx = p2x-p1x,
        dy = p2y-p1y,
        t;
    if (dx !== 0 || dy !== 0) {
        t = ((px-p1x) * dx + (py-p1y) * dy) / (dx*dx + dy*dy);
        if (t > 1) {
            p1x = p2x;
            p1y = p2y;
        } else if (t > 0) {
            p1x += dx*t;
            p1y += dy*t;
        }
    }
    dx = px-p1x;
    dy = py-p1y;
    return dx*dx + dy*dy;
}

function simplify(points) {
    var sqTolerance = 2,
        len = points.length/2,
        markers = new Uint8Array(len),

        first = 0,
        last  = len - 1,

        i,
        maxSqDist,
        sqDist,
        index,

        firstStack = [],
        lastStack  = [],

        newPoints  = [];

    markers[first] = markers[last] = 1;

    while (last) {
        maxSqDist = 0;

        for (i = first + 1; i < last; i++) {
            sqDist = getSquareSegmentDistance(
                points[i    *2], points[i    *2 + 1],
                points[first*2], points[first*2 + 1],
                points[last *2], points[last *2 + 1]
            );
            if (sqDist > maxSqDist) {
                index = i;
                maxSqDist = sqDist;
            }
        }

        if (maxSqDist > sqTolerance) {
            markers[index] = 1;

            firstStack.push(first);
            lastStack.push(index);

            firstStack.push(index);
            lastStack.push(last);
        }

        first = firstStack.pop();
        last = lastStack.pop();
    }

    for (i = 0; i < len; i++) {
        if (markers[i]) {
            newPoints.push(points[i*2], points[i*2 + 1]);
        }
    }

    return newPoints;
}

// detect polygon winding direction: clockwise or counter clockwise
function getWinding(points) {
    var x1, y1, x2, y2,
        a = 0,
        i, il;
    for (i = 0, il = points.length-3; i < il; i += 2) {
        x1 = points[i];
        y1 = points[i+1];
        x2 = points[i+2];
        y2 = points[i+3];
        a += x1*y2 - x2*y1;
    }
    return (a/2) > 0 ? 'CW' : 'CCW';
}

// make polygon winding clockwise. This is needed for proper backface culling on client side.
function makeWinding(points, direction) {
    var winding = getWinding(points);
    if (winding === direction) {
        return points;
    }
    var revPoints = [];
    for (var i = points.length-2; i >= 0; i -= 2) {
        revPoints.push(points[i], points[i+1]);
    }
    return revPoints;
}



    var osmb = function(url) {



// private variables, specific to an instance
var width = 0, height = 0,
    halfWidth = 0, halfHeight = 0,
    originX = 0, originY = 0,
    zoom, size,

    activeRequest,

    context,
	//设置墙的默认颜色
    defaultWallColor = new Color(200, 190, 180),
	//建筑左右两边墙的亮度
    defaultAltColor  = defaultWallColor.setLightness(0.8),
	//建筑屋顶的亮度
    defaultRoofColor = defaultWallColor.setLightness(1.2),

    wallColorAlpha = defaultWallColor + '',
    altColorAlpha  = defaultAltColor + '',
    roofColorAlpha = defaultRoofColor + '',
	//淡出因数：
    fadeFactor = 1,
    animTimer,
    zoomAlpha = 1,

    minZoom = MIN_ZOOM,
    maxZoom = 20,
    maxHeight,

    camX, camY, camZ,

    isZooming;



function pixelToGeo(x, y) {
    var res = {};
    x /= size;
    y /= size;
    res[LAT] = y <= 0  ? 90 : y >= 1 ? -90 : RAD * (2 * atan(exp(PI * (1 - 2 * y))) - HALF_PI),
    res[LON] = (x === 1 ?  1 : (x % 1 + 1) % 1) * 360 - 180;
    return res;
}

function geoToPixel(lat, lon) {
    var latitude  = min(1, max(0, 0.5 - (log(tan(QUARTER_PI + HALF_PI * lat / 180)) / PI) / 2)),
        longitude = lon / 360 + 0.5;
    return {
        x: longitude*size <<0,
        y: latitude *size <<0
    };
}

function fromRange(sVal, sMin, sMax, dMin, dMax) {
    sVal = min(max(sVal, sMin), sMax);
    var rel = (sVal-sMin) / (sMax-sMin),
        range = dMax-dMin;
    return min(max(dMin + rel*range, dMin), dMax);
}

function xhr(_url, param, callback) {
    var url = _url.replace(/\{ *([\w_]+) *\}/g, function(tag, key) {
        return param[key] || tag;
    });

    var req = 'XDomainRequest' in window ? new XDomainRequest() : new XMLHttpRequest();

    function changeState(state) {
        if ('XDomainRequest' in window && state !== req.readyState) {
            req.readyState = state;
            if (req.onreadystatechange) {
                req.onreadystatechange();
            }
        }
    }

    req.onerror = function() {
        req.status = 500;
        req.statusText = 'Error';
        changeState(4);
    };

    req.ontimeout = function() {
        req.status = 408;
        req.statusText = 'Timeout';
        changeState(4);
    };

    req.onprogress = function() {
        changeState(3);
    };

    req.onload = function() {
        req.status = 200;
        req.statusText = 'Ok';
        changeState(4);
    };

    req.onreadystatechange = function() {
        if (req.readyState !== 4) {
            return;
        }
        if (!req.status || req.status < 200 || req.status > 299) {
            return;
        }
        if (callback && req.responseText) {
            callback(JSON.parse(req.responseText));
        }
    };

    changeState(0);
    req.open('GET', url);
    changeState(1);
    req.send(null);
    changeState(2);

    return req;
}



var Cache = (function() {

    var _time = new Date();
    var _data = {};

    var me = {};

    me.add = function(key, data) {
        _data[key] = { data:data, time:Date.now() };
    };

    me.get = function(key) {
        return _data[key] && _data[key].data;
    };
	//清除缓存数据
    me.purge = function() {
        _time.setMinutes(_time.getMinutes()-5);
        for (var key in _data) {
            if (_data[key].time < _time) {
                delete _data[key];
            }
        }
    };

    return me;

}());



var Data = (function() {

    var _url;
    var _index = {}; // maintain a list of cached items in order to fade in new ones

    function _closureParse(cacheKey) {
        return function(res) {
            _parse(res, cacheKey);
        };
    }

    function _parse(data, cacheKey) {
        if (!data) {
            return;
        }

        var items;
        if (data.type === 'FeatureCollection') { // GeoJSON
            items = readGeoJSON(data.features);
        } else if (data.osm3s) { // XAPI,本（readOSMXAPI）方法不是GeoJSON的返回方法，暂不考虑
            items = readOSMXAPI(data.elements);
        }

        if (cacheKey) {//添加数据到缓存
            Cache.add(cacheKey, items);
        }

        _add(items, true);
    }

    function _getFootprint(polygon) {
        var footprint = new Int32Array(polygon.length),
            px;
        for (var i = 0, il = polygon.length-1; i < il; i+=2) {
            px = geoToPixel(polygon[i], polygon[i+1]);
            footprint[i]   = px.x;
            footprint[i+1] = px.y;
        }
		//稀疏数据
        footprint = simplify(footprint);
        if (footprint.length < 8) { // 3 points + end==start (*2)
            return;
        }
        return footprint;
    }
	//不清楚isNew的含义
    function _add(data, isNew) {
        var items = _scale(data, zoom, isNew);

        var item;
        for (var i = 0, il = items.length; i < il; i++) {
            item = items[i];
            if (!_index[item.id]) {
                item.scale = isNew ? 0 : 1;
                me.renderItems.push(items[i]);
                _index[item.id] = 1;
            }
        }
        fadeIn();
    }

    function _scale(items, zoom) {
        var i, il, j, jl,
            res = [],
            item,
			//footprint屋底
            height, minHeight, footprint,
			//roof屋顶，wall:墙
            color, wallColor, altColor, roofColor,
            holes, innerFootprint,
            zoomDelta = maxZoom-zoom;

        for (i = 0, il = items.length; i < il; i++) {

            item = items[i];
			//?:HEIGHT_SCALE是一个什么概念
            height = (item.height || DEFAULT_HEIGHT)*HEIGHT_SCALE >> zoomDelta;
            if (!height) {
                continue;
            }

            minHeight = item.minHeight*HEIGHT_SCALE >> zoomDelta;
            if (minHeight > maxHeight) {
                continue;
            }

            if (!(footprint = _getFootprint(item.footprint))) {
                continue;
            }

            holes = [];
            if (item.holes) {
                for (j = 0, jl = item.holes.length; j < jl; j++) {
                    if ((innerFootprint = _getFootprint(item.holes[j]))) {
                        holes.push(innerFootprint);
                    }
                }
            }

            wallColor = null;
            altColor  = null;
            if (item.wallColor) {
                if ((color = Color.parse(item.wallColor))) {
					//带透明度的颜色，zoomAlpha是透明度
                    wallColor = color.setAlpha(zoomAlpha);
                    altColor  = '' + wallColor.setLightness(0.8);
                    wallColor = '' + wallColor;
                }
            }

            roofColor = null;
            if (item.roofColor) {
                if ((color = Color.parse(item.roofColor))) {
                    roofColor = '' + color.setAlpha(zoomAlpha);
                }
            }

            res.push({
                id:        item.id,
                footprint: footprint,
                height:    min(height, maxHeight),
                minHeight: minHeight,
                wallColor: wallColor,
                altColor:  altColor,
                roofColor: roofColor,
                center:    getCenter(footprint),
                holes:     holes.length ? holes : null
            });
        }

        return res;
    }

    var me = {};

    me.renderItems = []; // TODO: move to renderer

    me.load = function(url) {
        _url = url || OSM_XAPI_URL;
        me.update();
    };

    me.update = function() {
        if (!_url || zoom < MIN_ZOOM) {
            return;
        }

        var nw = pixelToGeo(originX,       originY),
            se = pixelToGeo(originX+width, originY+height),
            sizeLat = DATA_TILE_SIZE,
            sizeLon = DATA_TILE_SIZE*2;

        var bounds = {
            n: ceil( nw.latitude /sizeLat) * sizeLat,
            e: ceil( se.longitude/sizeLon) * sizeLon,
            s: floor(se.latitude /sizeLat) * sizeLat,
            w: floor(nw.longitude/sizeLon) * sizeLon
        };

        Cache.purge();
        me.renderItems = [];
        _index = {};

        var lat, lon,
            cached, key;

        for (lat = bounds.s; lat <= bounds.n; lat += sizeLat) {
            for (lon = bounds.w; lon <= bounds.e; lon += sizeLon) {
                key = lat + ',' + lon;
                if ((cached = Cache.get(key))) {
                    _add(cached);
                } else {
                    xhr(_url, {
                        n: crop(lat+sizeLat),
                        e: crop(lon+sizeLon),
                        s: crop(lat),
                        w: crop(lon)
                    }, _closureParse(key));
                }
            }
        }
    };

    me.set = function(data) {
        me.renderItems = [];
        _index = {};
        _parse(data);
    };

    return me;

}());




function fadeIn() {
    if (animTimer) {
        return;
    }

    animTimer = setInterval(function() {
        var item, needed = false;
        for (var i = 0, il = Data.renderItems.length; i < il; i++) {
            item = Data.renderItems[i];
            if (item.scale < 1) {
                item.scale += 0.5*0.2; // amount*easing
                if (item.scale > 1) {
                    item.scale = 1;
                }
                needed = true;
            }
        }

        renderAll();

        if (!needed) {
            clearInterval(animTimer);
            animTimer = null;
        }
    }, 33);
}

function renderAll() {
    Shadows.render();
    FlatBuildings.render();
    render();
}

function render() {
	////clearRect相当于相橡皮擦，把矩形的内容把擦掉
    context.clearRect(0, 0, width, height);

    // show on high zoom levels only and avoid rendering during zoom
    if (zoom < minZoom || isZooming) {
        return;
    }

    var i, il, j, jl,
        item,
        h, _h, mh, _mh,
        flatMaxHeight = FlatBuildings.MAX_HEIGHT,
        sortCam = [camX+originX, camY+originY],
        vp = {
            minX: originX,
            maxX: originX+width,
            minY: originY,
            maxY: originY+height
        },
        footprint, roof, holes,
        isVisible,
        wallColor, altColor;

    // TODO: FlatBuildings are drawn separately, data has to be split
    Data.renderItems.sort(function(a, b) {
        return getDistance(b.center, sortCam)/b.height - getDistance(a.center, sortCam)/a.height;
    });

    for (i = 0, il = Data.renderItems.length; i < il; i++) {
        item = Data.renderItems[i];

        if (item.height <= flatMaxHeight) {
            continue;
        }

        isVisible = false;
        footprint = item.footprint;
        for (j = 0, jl = footprint.length - 1; j < jl; j += 2) {
            // checking footprint is sufficient for visibility
            // TODO: pre-filter by data tile position
            if (!isVisible) {
                isVisible = (footprint[j] > vp.minX && footprint[j] < vp.maxX && footprint[j+1] > vp.minY && footprint[j+1] < vp.maxY);
            }
        }

        if (!isVisible) {
            continue;
        }

        // when fading in, use a dynamic height
        h = item.scale < 1 ? item.height*item.scale : item.height;
        // precalculating projection height factor
        _h = camZ / (camZ-h);

        _mh = 0;
        if (item.minHeight) {
            mh = item.scale < 1 ? item.minHeight*item.scale : item.minHeight;
            _mh = camZ / (camZ-mh);
        }

        wallColor = item.wallColor || wallColorAlpha;
        altColor  = item.altColor  || altColorAlpha;
        roof = renderPolygon(footprint, _h, _mh, wallColor, altColor);

        holes = [];
        if (item.holes) {
            for (j = 0, jl = item.holes.length; j < jl; j++) {
                holes[j] = renderPolygon(item.holes[j], _h, _mh, wallColor, altColor);
            }
        }

        // fill roof and optionally stroke it
        context.fillStyle   = item.roofColor || roofColorAlpha;
        context.strokeStyle = altColor;
        drawShape(roof, true, holes);
    }
}

function renderPolygon(polygon, h, mh, wallColor, altColor) {
    var a = { x:0, y:0 }, b = { x:0, y:0 },
        _a, _b,
        roof = [];
    for (var i = 0, il = polygon.length-3; i < il; i += 2) {
        a.x = polygon[i]  -originX;
        a.y = polygon[i+1]-originY;
        b.x = polygon[i+2]-originX;
        b.y = polygon[i+3]-originY;

        // project 3d to 2d on extruded footprint
        _a = project(a.x, a.y, h);
        _b = project(b.x, b.y, h);

        if (mh) {
            a = project(a.x, a.y, mh);
            b = project(b.x, b.y, mh);
        }

        // backface culling check
        if ((b.x-a.x) * (_a.y-a.y) > (_a.x-a.x) * (b.y-a.y)) {
            // depending on direction, set wall shading
            if ((a.x < b.x && a.y < b.y) || (a.x > b.x && a.y > b.y)) {
				//填充颜色
                context.fillStyle = altColor;
            } else {
                context.fillStyle = wallColor;
            }
            drawShape([
                b.x, b.y,
                a.x, a.y,
                _a.x, _a.y,
                _b.x, _b.y
            ]);
        }
        roof[i]   = _a.x;
        roof[i+1] = _a.y;
    }

    return roof;
}

function drawShape(points, stroke, holes) {
    if (!points.length) {
        return;
    }

    var i, il, j, jl;
    context.beginPath();

    context.moveTo(points[0], points[1]);
    for (i = 2, il = points.length; i < il; i += 2) {
        context.lineTo(points[i], points[i+1]);
    }

    if (holes) {
        for (i = 0, il = holes.length; i < il; i++) {
            points = holes[i];
            context.moveTo(points[0], points[1]);
            for (j = 2, jl = points.length; j < jl; j += 2) {
                context.lineTo(points[j], points[j+1]);
            }
        }
    }

    context.closePath();
    if (stroke) {
        context.stroke();
    }
    context.fill();
}

function project(x, y, m) {
    return {
        x: (x-camX) * m + camX <<0,
        y: (y-camY) * m + camY <<0
    };
}

/*
function debugMarker(x, y, color, size) {
    context.fillStyle = color || '#ffcc00';
    context.beginPath();
    context.arc(x, y, size || 3, 0, PI*2, true);
    context.closePath();
    context.fill();
}

function debugLine(ax, ay, bx, by, color) {
    context.strokeStyle = color || '#ff0000';
    context.beginPath();
    context.moveTo(ax, ay);
    context.lineTo(bx, by);
    context.closePath();
    context.stroke();
}
*/



var Shadows = (function() {

    var _context;
    var _enabled = true;
    var _color = new Color(0, 0, 0);
    var _date = null;
    var _direction = { x:0, y:0 };

    function _project(x, y, h) {
        return {
            x: x + _direction.x*h,
            y: y + _direction.y*h
        };
    }

    var me = {};

    me.setContext = function(context) {
        _context = context;
        // TODO: fix bad Date() syntax
        me.setDate(new Date().setHours(10)); // => render()
    };

    me.enable = function(flag) {
        _enabled = !!flag;
        // should call me.render() but it is usually set by setStyle() and there a renderAll() is called
    };

    me.render = function() {
        var center, sun, length, alpha, colorStr;

        _context.clearRect(0, 0, width, height);

        // show on high zoom levels only and avoid rendering during zoom
        if (!_enabled || zoom < minZoom || isZooming) {
            return;
        }

        // TODO: at some point, calculate me just on demand
        center = pixelToGeo(originX+halfWidth, originY+halfHeight);
        sun = getSunPosition(_date, center.latitude, center.longitude);

        if (sun.altitude <= 0) {
            return;
        }

        length = 1 / tan(sun.altitude);
        alpha = 0.4 / length;
        _direction.x = cos(sun.azimuth) * length;
        _direction.y = sin(sun.azimuth) * length;

        // TODO: maybe introduce Color.setAlpha()
        _color.a = alpha;
        colorStr = _color + '';

        var i, il, j, jl,
            item,
            f, h, g,
            x, y,
            footprint,
            mode,
            isVisible,
            ax, ay, bx, by,
            a, b, _a, _b,
            points,
            allFootprints = [];

        _context.beginPath();

        for (i = 0, il = Data.renderItems.length; i < il; i++) {
            item = Data.renderItems[i];

// TODO: no shadows when buildings are too flat => don't add them to renderItems then
//        if (item.height <= FlatBuildings.MAX_HEIGHT) {
//            continue;
//        }

            isVisible = false;
            f = item.footprint;
            footprint = [];
            for (j = 0, jl = f.length - 1; j < jl; j += 2) {
                footprint[j]   = x = f[j]  -originX;
                footprint[j+1] = y = f[j+1]-originY;

                // TODO: checking footprint is sufficient for visibility - NOT VALID FOR SHADOWS!
                if (!isVisible) {
                    isVisible = (x > 0 && x < width && y > 0 && y < height);
                }
            }

            if (!isVisible) {
                continue;
            }

            // when fading in, use a dynamic height
            h = item.scale < 1 ? item.height*item.scale : item.height;

            // prepare same calculations for min_height if applicable
            if (item.minHeight) {
                g = item.scale < 1 ? item.minHeight*item.scale : item.minHeight;
            }

            mode = null;

            for (j = 0, jl = footprint.length-3; j < jl; j += 2) {
                ax = footprint[j];
                ay = footprint[j+1];
                bx = footprint[j+2];
                by = footprint[j+3];

                _a = _project(ax, ay, h);
                _b = _project(bx, by, h);

                if (item.minHeight) {
                    a = _project(ax, ay, g);
                    b = _project(bx, by, g);
                    ax = a.x;
                    ay = a.y;
                    bx = b.x;
                    by = b.y;
                }

                if ((bx-ax) * (_a.y-ay) > (_a.x-ax) * (by-ay)) {
                    if (mode === 1) {
                        _context.lineTo(ax, ay);
                    }
                    mode = 0;
                    if (!j) {
                        _context.moveTo(ax, ay);
                    }
                    _context.lineTo(bx, by);
                } else {
                    if (mode === 0) {
                        _context.lineTo(_a.x, _a.y);
                    }
                    mode = 1;
                    if (!j) {
                        _context.moveTo(_a.x, _a.y);
                    }
                    _context.lineTo(_b.x, _b.y);
                }
            }

            _context.closePath();

            allFootprints.push(footprint);
        }

        _context.fillStyle = colorStr;
        _context.fill();

        // now draw all the footprints as negative clipping mask
        _context.globalCompositeOperation = 'destination-out';
        _context.beginPath();
        for (i = 0, il = allFootprints.length; i < il; i++) {
            points = allFootprints[i];
            _context.moveTo(points[0], points[1]);
            for (j = 2, jl = points.length; j < jl; j += 2) {
                _context.lineTo(points[j], points[j+1]);
            }
            _context.lineTo(points[0], points[1]);
            _context.closePath();
        }
        _context.fillStyle = '#00ff00';
        _context.fill();
        _context.globalCompositeOperation = 'source-over';
    };

    me.setDate = function(date) {
        _date = date;
        me.render();
    };

    return me;

}());



var FlatBuildings = (function() {

    var _context;

    var me = {};

    me.MAX_HEIGHT = 8;

    me.setContext = function(context) {
        _context = context;
    };

    me.render = function() {
        _context.clearRect(0, 0, width, height);

        // show on high zoom levels only and avoid rendering during zoom
        if (zoom < minZoom || isZooming) {
            return;
        }

        var i, il, j, jl,
            item,
            f,
            x, y,
            footprint,
            isVisible,
            ax, ay;

        _context.beginPath();

        for (i = 0, il = Data.renderItems.length; i < il; i++) {
            item = Data.renderItems[i];

            if (item.height > me.MAX_HEIGHT) {
                continue;
            }

            isVisible = false;
            f = item.footprint;
            footprint = [];
            for (j = 0, jl = f.length-1; j < jl; j += 2) {
                footprint[j]   = x = f[j]  -originX;
                footprint[j+1] = y = f[j+1]-originY;

                // checking footprint is sufficient for visibility
                if (!isVisible) {
                    isVisible = (x > 0 && x < width && y > 0 && y < height);
                }
            }

            if (!isVisible) {
                continue;
            }

            for (j = 0, jl = footprint.length-3; j < jl; j += 2) {
                ax = footprint[j];
                ay = footprint[j + 1];
                if (!j) {
                    _context.moveTo(ax, ay);
                } else {
                    _context.lineTo(ax, ay);
                }
            }

            _context.closePath();
        }

        _context.fillStyle   = roofColorAlpha;
        _context.strokeStyle = altColorAlpha;

        _context.stroke();
        _context.fill();
    };

    return me;

}());



var Layers = (function() {

    var _container = doc.createElement('DIV');
    _container.style.pointerEvents = 'none';
    _container.style.position = 'absolute';
    _container.style.left = 0;
    _container.style.top  = 0;

    var _items = [];

    // TODO: improve this to _createItem(Layer) => layer.setContext(context)
    Shadows.setContext(      _createItem());
    FlatBuildings.setContext(_createItem());
    context = _createItem(); // default (global) render context

    function _createItem() {
        var canvas = doc.createElement('CANVAS');
        canvas.style.webkitTransform = 'translate3d(0,0,0)'; // turn on hw acceleration
        canvas.style.imageRendering = 'optimizeSpeed';
        canvas.style.position = 'absolute';
        canvas.style.left = 0;
        canvas.style.top  = 0;

        var context = canvas.getContext('2d');
        context.lineCap   = 'round';
        context.lineJoin  = 'round';
        context.lineWidth = 1;

        context.mozImageSmoothingEnabled    = false;
        context.webkitImageSmoothingEnabled = false;

        _items.push(canvas);
        _container.appendChild(canvas);

        return context;
    }

    var me = {};

    me.appendTo = function(parentNode) {
        parentNode.appendChild(_container);
        return _container;
    };

    me.setSize = function(w, h) {
        for (var i = 0, il = _items.length; i < il; i++) {
            _items[i].width  = w;
            _items[i].height = h;
        }
    };

    return me;

}());



function setSize(w, h) {
    width  = w;
    height = h;
    halfWidth  = width /2 <<0;
    halfHeight = height/2 <<0;
    camX = halfWidth;
    camY = height;
	//window.devicePixelRatio是设备上物理像素和设备独立像素(device-independent pixels (dips))的比例。
	//公式表示就是：window.devicePixelRatio = 物理像素 / dips
    camZ = width / (1.5 / (window.devicePixelRatio || 1)) / tan(90/2) <<0; // adapting cam pos to field of view (90°), 1.5 is an empirical correction factor
    Layers.setSize(width, height);
    // TODO: change of maxHeight needs to adjust building heights!
    maxHeight = camZ-50;
}

function setOrigin(x, y) {
    originX = x;
    originY = y;
}

function setZoom(z) {
    zoom = z;
    size = MAP_TILE_SIZE <<zoom;

    zoomAlpha = 1 - fromRange(zoom, minZoom, maxZoom, 0, 0.3);

    wallColorAlpha = defaultWallColor.setAlpha(zoomAlpha) + '';
    altColorAlpha  = defaultAltColor.setAlpha( zoomAlpha) + '';
    roofColorAlpha = defaultRoofColor.setAlpha(zoomAlpha) + '';
}

function setCam(x, y) {
    camX = x;
    camY = y;
}

function setStyle(style) {
    style = style || {};
    if (style.color || style.wallColor) {
        defaultWallColor = Color.parse(style.color || style.wallColor);
        wallColorAlpha = defaultWallColor.setAlpha(zoomAlpha) + '';
		//设置墙的左右面透明度
        defaultAltColor = defaultWallColor.setLightness(0.8);
        altColorAlpha = defaultAltColor.setAlpha(zoomAlpha) + '';
		//设置墙的左右面透明度
        defaultRoofColor = defaultWallColor.setLightness(1.2);
        roofColorAlpha = defaultRoofColor.setAlpha(zoomAlpha) + '';
    }

    if (style.roofColor) {
        defaultRoofColor = Color.parse(style.roofColor);
        roofColorAlpha = defaultRoofColor.setAlpha(zoomAlpha) + '';
    }

    if (style.shadows !== undefined) {
        Shadows.enable(style.shadows);
    }

    renderAll();
}



this.onResize = function(e) {
    setSize(e.width, e.height);
    renderAll();
    Data.update();
}

function onMoveEnd(e) {
    renderAll();
    Data.update(); // => fadeIn() => renderAll()
}

function onZoomStart(e) {
    isZooming = true;
    // effectively clears because of isZooming flag
    renderAll();
}

function onZoomEnd(e) {
    isZooming = false;
    setZoom(e.zoom);
    Data.update(); // => fadeIn()
    renderAll();
}



this.setStyle = function(style) {
    setStyle(style);
};

this.setCamOffset = function(x, y) {
    camX = halfWidth + x;
    camY = height    + y;
};

this.setMaxZoom = function(z) {
    maxZoom = z;
};

this.setDate = function(date) {
    Shadows.setDate(date);
};

this.appendTo = function(parentNode) {
    return Layers.appendTo(parentNode);
};

this.loadData = function(url) {
    Data.load(url);
};

this.setData = function(data) {
    Data.set(data);
};

this.onMoveEnd   = onMoveEnd;
this.onZoomEnd   = onZoomEnd;
this.onZoomStart = onZoomStart;
this.setOrigin   = setOrigin;
this.setSize     = setSize;
this.setZoom     = setZoom;
this.render      = render;
this.renderAll   = renderAll;



    };

    osmb.VERSION     = VERSION;
    osmb.ATTRIBUTION = ATTRIBUTION;

    return osmb;

}());



/**
 *  Class: Geo.View2D.Layer.Buildings
 *  3D楼块图层类。
 *  本类依赖Geo.Query.MapServiceQueryParameters类以及Geo.Query.MapServiceQuery类
 *  
 *	Inherits from:
 *  	- <Geo.View2D.Layer>
 */
Geo.View2D.Layer.Buildings = Geo.Class(Geo.View2D.Layer, {

	/** 
     * APIProperty: name
     * {String} 服务名称
     */
    name: 'GEO Buildings',
	
	/**
	 * APIProperty: url
	 * {String} 地图服务服务地址
	 */
	url: null,
	
	/**
	 * APIProperty: minLevel
	 * {Integer}设置查询的最小级别，超出了最小级别则不做查询。默认值：15，取值范围[15-20]，其中minLevel必须要小于或等于maxLevel。
	 */
	minLevel: 15,
	
	/**
	 * APIProperty: maxLevel
	 * {Integer}设置查询的最大级别，超出了设定的最大级别则不做查询。默认值：20，取值范围[15-20]，其中maxLevel必须要大于或等于minLevel。
	 */
	maxLevel: 20,
	
	/**
	 *	Property: featureExt
	 *	本属性用于减少服务器负荷
	 */
	featureExt: null,
	
	/**
	 *	APIProperty: heightScaleRatio
	 *	{Integer} 房屋高度的夸张系数
	 */
	heightScaleRatio: 1,
	
	/**
	 *	APIProperty: heightAttribute
	 *	{Integer} 高度属性名称
	 */
	heightAttribute: "HRG",
	
	/**
	 * APIProperty: query
	 * {Geo.Query.MapServiceQueryParameters}
	 * 查询条件，如果用户不创建Geo.Query.MapServiceQueryParameters对象，那么图层将会创建一个默认的Geo.Query.MapServiceQueryParameters对象。
	 *	说明：
	 *	1. query对象的geometry属性：如果用户不设置geometry属性，那么geometry属性会根据地图当前可视范围以及extentScaleRatio计算得到。
	 *	如果用户设置了本属性，则以用户设置的为准。
	 */
	query: null,
	
	/**
	 *	APIProperty: extentScaleRatio
	 *	{float} 减少服务器负担，将当前视口范围放大
	 */
	extentScaleRatio: 1.9,
	
	/**
	 *	Property: dxSum
	 *	图层移动后的偏移
	 */
    dxSum: 0,
    
	/**
	 *	Property: dySum
	 *	图层移动后的偏移
	 */
    dySum: 0,
		
	/**
     * Constructor: Geo.View2D.Layer.Buildings
     *
     * Example:
     * (code)
     * 	var geoBuildings = new Geo.View2D.Layer.Buildings();
	 *	map.addLayer(geoBuildings);
     * (end)
     *
     * Parameters:
     * 	name - {String} 图层名称
     * 	url - {String} 地图服务
     * 	options - {Object}
     * 		query - {Geo.Query.MapServiceQueryParameters}(可选)
     * 		extentScaleRatio - {float} (可选)
     * 		heightAttribute - {Integer} (可选)
     * 		heightScaleRatio - {Integer} (可选)
     * 		minLevel - {Integer} (可选)
     * 		maxLevel - {Integer} (可选)
     */
    initialize: function(name, url, options) {
		
		//判断浏览器是否支持canvas画布
		if (!(!!document.createElement('canvas').getContext)) {
			alert('您的浏览器不支持当前的canvas矢量渲染方式，请使用支持HTML5的浏览器运行。');
		}
        options = options || {};
		
//	   	options.projection = 'EPSG:900913';
		
		this.format = new Geo.Format.JSON();
		
		if(options.query instanceof Geo.Query.MapServiceQueryParameters) {
			
			this.query = options.query;
			
		}else {
			this.query = new Geo.Query.MapServiceQueryParameters();
			
		}
		this.query.returnGeometry = true;
		
		if(typeof url == "string") {
			this.url = url;
			//构造图层类
			this.mapServiceQuery = new Geo.Query.MapServiceQuery(url);
			var format = this.format;
			this.mapServiceQuery.queryTemp = function(queryParameter ,successFn, failFn) {
				var params = this._getParamsFromQueryParameter(queryParameter);	
				var DEFAULT_PARAMS = {
					f:"json",
					pretty:true
				}
				Geo.Util.applyDefaults(
			        params, DEFAULT_PARAMS
			    );
				OpenLayers.loadURL(this.url,params,this,function(result) {
					var res = format.read(result.responseText);
					successFn(res);
				},failFn);
			}
		}
		
		Geo.View2D.Layer.prototype.initialize.apply(this, [name, options]);
    },
	
	/**
	 * Method: _loadData
	 */
	_loadData: function() {
		//根据当前地图视口范围，按照比例，得到一个更大的范围,根据这个更大的范围进行查询
		if((this.maxLevel >= this.map.getZoom() && this.minLevel <= this.map.getZoom())) {
			if(this.mapServiceQuery instanceof Geo.Query.MapServiceQuery) {
				this.featureExt = this.map.getExtent().scale(this.extentScaleRatio);
				this.query.geometry = (this.query.geometry instanceof Geo.Bounds || this.query.geometry instanceof Geo.Geometry) ? 
				this.query.geometry :this.featureExt;
				this.mapServiceQuery.queryTemp(this.query, Geo.Function.bind( this._onQueryComplete, this));
			}
		};
    },
	
	/**
	 * Method: _onQueryComplete
	 */
	_onQueryComplete: function(result) {
		if(result.features.length <= 0 ) {   
		   alert("没有数据!");   
		    return;   
		}
		this.geoJSON(result.features);
	},
	
//	/**
//	 * Method: _onResize
//	 * TODO:改变地图窗口大小的时候，执行本方法，目前暂未注册事件
//	 */
//	_onResize: function(extent, width, height) {
//      if (this.osmb) {
//        this.osmb.setSize(width,height );
//        this.osmb.render();
//      };
//    },
	
	/**
	 * APIMethod: loadData
	 * json {String} 加载本地json数据
	 */
	loadData: function(json) {
		if(!(typeof this.url === "string")) {
			var json = this.format.read(json);
		
			this.features = json.features;
			
			if(this.features && this.features.length > 0 && this.maxLevel >= this.map.getZoom() && this.minLevel <= this.map.getZoom()) {
				
				this.geoJSON(json.features);
			}
		}
	},
	
	/**
	 * Method: geoJSON
	 * features {Array(Geo.Feature.Vector)} 要素集合
	 */
	geoJSON: function(features) {
		var oids = {};
		var jfs = [];
		this._oids = {};
		for (var i = 0; i < features.length; i++) {
			var f = features[i];
			var gj = {
				"type": "Feature",
				"geometry": {
					"type": "Polygon",
					"coordinates": f.geometry.rings
				},
				"properties": {
					"height": f.attributes[this.heightAttribute] * this.heightScaleRatio+40,//parseInt(f.attributes["OID"]/100+2000),//f.attributes["hgt"],//
					"isNew":0
				}
			}
			jfs[i] = gj;
		}
		this.osmb.setData({
			"type": "FeatureCollection",
			"features": jfs
		});
    },
	
	/**
	 * Method: setOrigin
	 */
    setOrigin: function() {
        var origin = this.map.getLonLatFromPixel(new Geo.Pixel(0, 0)),
            res = this.map.resolution,
            ext = this.maxExtent,
            x = Math.round((origin.lon - ext.left) / res),
            y = Math.round((ext.top - origin.lat) / res);
        this.osmb.setOrigin(x, y);
    },
	
	/**
	 * APIMethod: setMap
	 * map {Geo.View2D.Map} 
	 */
    setMap: function(map) {
		
        if (!this.map) {
            Geo.View2D.Layer.prototype.setMap.call(this, map);
        }

        if (!this.osmb) {
            this.osmb = new OSMBuildings();
            this.container = this.osmb.appendTo(this.div);
        }
	//	this._loadData();
		
        this.osmb.setSize(this.map.size.w, this.map.size.h);
		
        this.osmb.setZoom(this.map.zoom);
		
        this.setOrigin();
		
		this.map.events.register("zoomend", this, this._zoomend);
		//注册地图移动等事件
		this.map.events.register("moveend", this, this._moveend);
    },
	
	_zoomend: function() {
		if(typeof this.url === "string") {
			var extent = this.map.getExtent();
			//在指定级别范围内查询
			if(this.maxLevel >= this.map.getZoom() && this.minLevel <= this.map.getZoom()) {
			//	this._loadData();
			}
		}else if(this.url === undefined || this.url === null) {
			if(this.features && this.features.length > 0 && this.maxLevel >= this.map.getZoom() && this.minLevel <= this.map.getZoom()) {
				this.geoJSON(this.features);
			}
		} 
	},
	
	/**
	 * Method: _moveend
	 */
	_moveend: function(zoomChanged) {
		
	},
	
	/**
	 * Method: removeMap
	 * 
	 */
    removeMap: function(map) {
		this.map.events.unregister("zoomend", this, this._zoomend);
		//注册地图移动等事件
		this.map.events.unregister("moveend", this, this._moveend);
        this.container.parentNode.removeChild(this.container);
		this.osmb = null;
		this.query = null;
		this.mapServiceQuery = null;
		this.format = null;
        Geo.View2D.Layer.prototype.removeMap.call(this, map);
    },
	
	/**
	 * APIMethod: onMapResize
	 * 地图窗口大小发生改变的时候，应调用此方法
	 */
    onMapResize: function() {
        Geo.View2D.Layer.prototype.onMapResize.call(this);
        this.osmb.onResize({ width: this.map.size.w, height: this.map.size.h });
    },

	/**
	 * Method: moveTo
	 */
    moveTo: function(bounds, zoomChanged, dragging) {
        var result = Geo.View2D.Layer.prototype.moveTo.call(this, bounds, zoomChanged, dragging);
        if (!dragging) {
            var
                offsetLeft = parseInt(this.map.layerContainerDiv.style.left, 10),
                offsetTop  = parseInt(this.map.layerContainerDiv.style.top, 10)
            ;
            this.div.style.left = -offsetLeft + 'px';
            this.div.style.top  = -offsetTop  + 'px';
        }

        this.setOrigin();
        this.dxSum = 0;
        this.dySum = 0;
        this.osmb.setCamOffset(this.dxSum, this.dySum);
        if (zoomChanged) {
            this.osmb.onZoomEnd({ zoom: this.map.zoom });
			if(this.maxLevel >= this.map.getZoom() && this.minLevel <= this.map.getZoom()) {
				//当this.FeatureExt不包含当前范围且级别未发生改变时，请求数据
				this._loadData();
			}
        } else {
			var extent = this.map.getExtent();
			if(this.maxLevel >= this.map.getZoom() && this.minLevel <= this.map.getZoom() && this.featureExt && !this.featureExt.containsBounds(extent)) {
				this._loadData();
			}
            this.osmb.onMoveEnd();
        }

        return result;
    },

	/**
	 * Method: moveByPx
	 */
    moveByPx: function(dx, dy) {
        this.dxSum += dx;
        this.dySum += dy;
        var result = Geo.View2D.Layer.prototype.moveByPx.call(this, dx, dy);
        this.osmb.setCamOffset(this.dxSum, this.dySum);
        this.osmb.render();
        return result;
    },

    // TODO: refactor these ugly bindings
	/**
	 * APIMethod: setStyle
	 * 设置房屋样式。
	 * 
	 * style - {Object}
	 * 	roofColor - {String} 屋顶颜色
	 * 	wallColor - {String} 围墙颜色（左右方向颜色）
	 * 示例：
	 * (code)
	 * osmb.setStyle({
	 * 		roofColor: "#ecf4ff", //屋顶颜色
	 * 		wallColor: "#ffec7e"  //围墙颜色
	 * });
	 * (end)
	 */
    setStyle: function(style) {
        this.osmb.setStyle(style);
        return this;
    },
	
	/**
	 * APIMethod: setDate
	 * 根据时间点设置房屋阴影。
	 * 
	 * Parameters:
	 * date - {Date} 某一天的时间点
	 * 示例：
	 * (code)
	 * 	osmb.setDate(new Date("2013-6-10 22:00:00"));
	 * (end)
	 */
    setDate: function(date) {
        this.osmb.setDate(date);
        return this;
    },
	
  	CLASS_NAME: 'Geo.View2D.Layer.Buildings'
	
});/**
 * Class: Geo.View2D.Layer.GeoThematicLayer
 * 专题图图层类。该类的实例用于渲染专题图数据。
 *
 * Inherits from:
 *  - <Geo.View2D.Layer.Vector>
 */
Geo.View2D.Layer.GeoThematicLayer = Geo.Class(Geo.View2D.Layer.Vector, {
    
    /**
      * Property: loaded
      * {Boolean} Flag for whether the GML data has been loaded yet.
      */
    loaded: false,

    /**
      * Property: format
      * {<OpenLayers.Format>} The format you want the data to be parsed with.
      */
    format: null,

    /**
     * Property: formatOptions
     * {Object} Hash of options which should be passed to the format when it is
     * created. Must be passed in the constructor.
     */
    formatOptions: null,

    /**
     * APIProperty: gmlUrl
     * {String} 专题图数据文件路径。
     */
    gmlUrl: null,

    /**
     * APIProperty: styleUrl
     * {String} 专题图数据样式文件路径。
     */
    styleUrl: null,

    /**
     * Constructor: Geo.View2D.Layer.GeoThematicLayer
     * 创建一个专题图图层。
     *
     * Parameters:
     * name - {String} 图层名称。
     * options - {Object} 参数选项。
     *   gmlUrl {String} (必选) 专题图数据文件路径。
     *   styleUrl {String} (必选) 专题图数据样式文件路径。
     *   该文件包含专题图数据的样式，例如在PolygonRendition属性下，包含以下样式：
     * (code)
     *   { "Type": "polygon",//类型
     *     "FillColor": "#657800",//填充颜色
     *     "FillOpacity": "1",//填充色透明度
     *     "StrokeColor": "#000000",//边框颜色
     *     "StrokeOpacity": "1",//边框颜色透明度
     *     "StrokeWidth": "1"//边框宽度
     *   }
     * (end)
     */
     initialize: function(name, options) {
        var newArguments = [];
        newArguments.push(name, options);
        Geo.View2D.Layer.Vector.prototype.initialize.apply(this, newArguments);
    },

    /**
     * APIMethod: setVisibility
     * 设置是否显示该图层。
     *  
     * Parameters:
     * visible - {Boolean} 是否显示。
     */
    setVisibility: function(visibility) {
        Geo.View2D.Layer.Vector.prototype.setVisibility.apply(this, arguments);
        if(this.visibility && !this.loaded){
            // Load the GML
            this.loadGML();
        }
    },

    /**
     * Method: moveTo
     * If layer is visible and GML has not been loaded, load GML, then load GML
     * and call Geo.View2D.Layer.Vector.moveTo() to redraw at the new location.
     * 
     * Parameters:
     * bounds - {Object} 
     * zoomChanged - {Object} 
     * minor - {Object} 
     */
    moveTo:function(bounds, zoomChanged, minor) {
        Geo.View2D.Layer.Vector.prototype.moveTo.apply(this, arguments);
        // Wait until initialisation is complete before loading GML
        // otherwise we can get a race condition where the root HTML DOM is
        // loaded after the GML is paited.
        // See http://trac.openlayers.org/ticket/404
        if(this.visibility && !this.loaded){
            this.loadGML();
        }
    },

    /**
     * Method: loadGML
     */
    loadGML: function() {
        if (!this.loaded) {
            this.events.triggerEvent("loadstart");
            OpenLayers.Request.GET({
				//async: false,
                url: this.gmlUrl,
                success: this.requestSuccess,
                failure: this.requestFailure,
                scope: this
            });
            this.loaded = true;
        }    
    },    
    
    /**
     * Method: setUrl
     * 改变GML文件路径，重新加载。
     *
     * Parameters:
     * url - {String} 文件路径。
     */
    setUrl:function(url) {
        this.gmlUrl = url;
        this.destroyFeatures();
        this.loaded = false;
        this.loadGML();
    },
    
    /**
     * Method: requestSuccess
     * 请求GML文件成功回调函数。
     *
     * Parameters:
     * request - {String} 
     */
    requestSuccess:function(request) {
        var doc = request.responseXML;
        
        if (!doc || !doc.documentElement) {
            doc = request.responseText;
        }
        
        var options = {};
        
        OpenLayers.Util.extend(options, this.formatOptions);
        if (this.map && !this.projection.equals(this.map.getProjectionObject())) {
            options.externalProjection = this.projection;
            options.internalProjection = this.map.getProjectionObject();
        }    
        
        var gml = this.format ? new this.format(options) : new OpenLayers.Format.GML(options);
		var features = gml.read(doc);
		
		if(this.styleUrl){
			//获取样式
	        OpenLayers.Request.GET({
	            async: false,
	            url: this.styleUrl,
	            success: function(result){
	                var jsonParser = new OpenLayers.Format.JSON();
	                this.thematicStyle = jsonParser.read(result.responseText);
	            },
	            failure: function(request){
	                alert("加载专题图样式文件 " + this.styleUrl + " 出现错误。");
				},
	            scope: this
	        });
		}
		//设置样式
		this.setThematicFeaturesStyle(features, this.thematicStyle);
		
        this.addFeatures(features);
		this.addThematicLegend();
        this.events.triggerEvent("loadend");
    },
    
    /**
     * Method: requestFailure
     * 请求GML文件失败回调函数。
     *
     * Parameters:
     * request - {String} 
     */
    requestFailure: function(request) {
        OpenLayers.Console.userError(OpenLayers.i18n("errorLoadingGML", {'url':this.gmlUrl}));
        this.events.triggerEvent("loadend");
    },
	
    /**
     * Method: setThematicFeaturesStyle
     * 设置专题图要素的样式。
     *
     * Parameters:
     * features - {<Geo.Feature.Vector>} 专题图要素。
     * thematicStyle - {Object} 样式对象。
     */
	setThematicFeaturesStyle: function(features, thematicStyle) {
		if(!thematicStyle){
			return;
		}
		var propertyName = thematicStyle.Renditions.PropertyRendition.PropertyName;
		var rangeValueRules = thematicStyle.Renditions.PropertyRendition.RangeValueRule;
		
        for (var i = 0; i < features.length; i++) {
			var style = {};
			var propertyRange = features[i].attributes[propertyName];
			for (var j = 0; j < rangeValueRules.length; j++) {
				var bottomValue = Number(rangeValueRules[j].BottomValue);
				var topValue = Number(rangeValueRules[j].TopValue);
				//判断属性值的取值区间，并获取样式。
                if (((rangeValueRules[j].IncludeBottom && bottomValue == propertyRange) || bottomValue < propertyRange) && 
				((rangeValueRules[j].IncludeTop && topValue == propertyRange) || propertyRange < topValue)) {
					style = {
						fillColor: rangeValueRules[j].PolygonRendition.FillColor,
						fillOpacity: Number(rangeValueRules[j].PolygonRendition.FillOpacity),
						strokeColor: rangeValueRules[j].PolygonRendition.StrokeColor,
						strokeOpacity: Number(rangeValueRules[j].PolygonRendition.StrokeOpacity),
						strokeWidth: Number(rangeValueRules[j].PolygonRendition.StrokeWidth)
					}
					break;
                }
			}
        	features[i].style = style;
        }
    },
	
    /**
     * Method: addThematicLegend
     * 添加专题图图例。
     */
	addThematicLegend: function() {
        if (!this.thematicStyle || !this.map) {
            return;
        }
		var div = document.createElement("DIV");
		this.thematicLegendDIV = div;
		div.id = "pieLegendContainer";
		div.style.position = "absolute";
		div.style.zIndex = "1000";
		div.style.right = "5px";
		div.style.bottom = "5px";
		div.style.border = "#15589a 1px solid";
		div.innerHTML = '<div id="legendTitle"><span>图例</span></div><div id="legendContent"></div>';
		this.map.viewPortDiv.appendChild(div);
		document.getElementById("legendContent").innerHTML = '';
		var rangeValueRules = this.thematicStyle.Renditions.PropertyRendition.RangeValueRule;
		for (var i = 0; i < rangeValueRules.length; i++) {
	        document.getElementById("legendContent").innerHTML += '<div class="legend-item">' +
	        '<span class="legend-color" style="background-color: ' + rangeValueRules[i].PolygonRendition.FillColor + ';"></span>' +
            '<span class="legend-itemName">' + rangeValueRules[i].BottomValue + ' - ' + rangeValueRules[i].TopValue + '</span></div>';
		}
	},
	
    /**
     * Method: removeThematicLegend
     * 删除专题图图例。
     */
	removeThematicLegend: function() {
		if (!this.map) {
            return;
        }
		if(this.map.viewPortDiv){
			this.map.viewPortDiv.removeChild(this.thematicLegendDIV);
		}
		this.thematicLegendDIV.innerHTML = "";
		this.thematicLegendDIV = null;
	},
	
    CLASS_NAME: "Geo.View2D.Layer.GeoThematicLayer"
});
/**
 * Class: Geo.View2D.BaseLayerGroup
 * 二维视图的底图图层组对象，可以将多个图层对象组合在一起，进行统一的加载和卸载操作。该图层组中的图层将作为地图中的底图置于所有图层的最下方。
 */
Geo.View2D.BaseLayerGroup = Geo.Class({

    /**
     * APIProperty: id
     * ｛String｝唯一标识符。
     */
    id: null,
    
    /**
     * APIProperty: layers
     * {Array} 图层集合。
     */
    layers: null,
    
    /**
     * APIProperty: map
     * 所属的地图对象。
     */
    map: null,
    
    /**
     * Constructor: Geo.View2D.BaseLayerGroup
     * Geo.View2D.BaseLayerGroup构造函数。
     * 
     * Parameters:
     * options - {Object} 相关选项设置。
     * 	layers - {Array} 必选 图层数组。
     * 示例代码：
     * 
     * (code)
     * var vectorGroup = new Geo.View2D.BaseLayerGroup({
     *      layers: [new Geo.View2D.Layer.GlobeTile("全球1:100万矢量底图", "http://tile0.tianditu.com/services/A0512_EMap", {
     *          transitionEffect: "resize",
     *          topLevel: 2,
     *          bottomLevel: 10,
     *          maxExtent: new Geo.Bounds(-180, -90, 180, 90)
     *      }), new Geo.View2D.Layer.GlobeTile("全球1:100万矢量注记", "http://tile0.tianditu.com/services/AB0512_Anno", {
     *          topLevel: 2,
     *          bottomLevel: 12,
     *          maxExtent: new Geo.Bounds(-180, -90, 180, 90)
     *      })]
     *  });
     * (end)
     * 
     */
    initialize: function(options){
        this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
        this.layers = [];
        OpenLayers.Util.extend(this, options);
    },
    
    /**
     * APIMethod: setMap
     * 将底图图层组关联到地图对象。
     *
     * Parameters:
     * map - {OpenLayers.Map} 地图对象。
     */
    setMap: function(map){
        if (map && !this.map) {
            this.map = map;
            for(var i=0; i<this.layers.length; i++){
                this.map.addLayer(this.layers[i],true);
            }
            
        }
    },
    
    /**
     * APIMethod: removeMap
     * 解除底图图层组与地图对象的关联。
     */
    removeMap: function(){
        if (this.map) {
            for (var i = 0; i < this.layers.length; i++) {
                var layer = this.layers[i];
                //如果图层已经被移除地图了，则不再被移除
                if(layer.map){
                    this.map.removeLayer(this.layers[i]);
                }
            }
            this.map = null;
        }
    },
    
     
    /**
     * APIMethod: getMaxResolution
     * 获取底图图层组中最大分辨率。
     *
     * Returns:
     * {Float} 分辨率
     */   
    getMaxResolution: function(){
        var layers = this.layers, res = null;
        for (var i = 0; i < layers.length; i++) {
            var layerOptions = layers[i].getOptions();
            var layerMaxRes = layerOptions.maxResolution;
            res = (res == null) ? layerMaxRes : Math.max(res, layerMaxRes);
        }
        return res;
    },
      
    /**
     * APIMethod: getMinResolution
     * 获取底图图层组中最小分辨率。
     *
     * Returns:
     * {Float} 分辨率
     */      
    getMinResolution: function(){
        var layers = this.layers, res = null;
        for (var i = 0; i < layers.length; i++) {
            var layerOptions = layers[i].getOptions();
            var layerMinRes = layerOptions.minResolution;
            res = (res == null) ? layerMinRes : Math.min(res, layerMinRes);
        }
        return res;
    },
      
    /**
     * APIMethod: getMaxExtent
     * 获取底图图层组中最大范围。
     *
     * Returns:
     * {Float} 范围
     */     
    getMaxExtent: function(){
        var bounds = null;
        for (var i = 0; i < this.layers.length; i++) {
            if (bounds) {
                bounds.extend(this.layers[i].getDataExtent());
            }
            else {
                bounds = this.layers[i].getDataExtent();
            }
        }
        return bounds;
    },
    
    /**
     * APIMethod: destroy
     * 销毁对象。
     *
     */
    destroy: function(){
		this.removeMap();
        for (var i = 0; i < layers.length; i++) {
            layers[i].destroy();
        }
		this.layers = null;
    },
    
    CLASS_NAME: "Geo.View2D.BaseLayerGroup"

});

Geo.View2D.BaseLayerGroup.getTianDiTuGroup = function(type, options){
    
    //TODO: 让Geo.View2D.BaseLayerGroup.getTianDiTuGroup支持更多设置选项
    //须将服务信息与图层对象的实例化分离
    
    /*
     * 服务相关信息定义
     * 1.影像层有缩放效果，标记层没有
     * 2.可以设置是否使用镜像服务地址，提高瓦片读取效率
     * 3.实际服务地址根据服务名和主机地址拼出
     */
    var serviceInfo = {
        "img":[
            {
                title:"全球影像底图(2-10)",
                serviceName: "sbsm0210",
                transitionEffect: "resize",
                topLevel: 2,
                bottomLevel: 10,
                maxExtent: new Geo.Bounds(-180, -90, 180, 90),
                isMirror: true
            },{
                title:"全球影像注记(2-10)",
                serviceName: "A0610_ImgAnno",
                topLevel: 2,
                bottomLevel: 10,
                maxExtent: new Geo.Bounds(-180, -90, 180, 90),
                isMirror: true
            }
            
        ],
        "dlg":[]
    };
    
    var typeMapping = {
        "img":[
            new Geo.View2D.Layer.GlobeTile("全球影像底图(2-10)", "http://tile0.tianditu.com/services/sbsm0210", {
                transitionEffect: "resize",
                topLevel: 2,
                bottomLevel: 10,
                maxExtent: new Geo.Bounds(-180, -90, 180, 90),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/sbsm0210",
    				"http://tile1.tianditu.com/services/sbsm0210",
    				"http://tile2.tianditu.com/services/sbsm0210",
    				"http://tile3.tianditu.com/services/sbsm0210",
    				"http://tile4.tianditu.com/services/sbsm0210",
    				"http://tile5.tianditu.com/services/sbsm0210",
    				"http://tile6.tianditu.com/services/sbsm0210",
    				"http://tile7.tianditu.com/services/sbsm0210"
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全球影像注记(2-10)", "http://tile0.tianditu.com/services/A0104_ImgAnnoE", {
                topLevel: 2,
                bottomLevel: 10,
                maxExtent: new Geo.Bounds(-180, -90, 180, 90),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/A0610_ImgAnno",
                    "http://tile1.tianditu.com/services/A0610_ImgAnno",
    				"http://tile2.tianditu.com/services/A0610_ImgAnno",
    				"http://tile3.tianditu.com/services/A0610_ImgAnno",
    				"http://tile4.tianditu.com/services/A0610_ImgAnno",
    				"http://tile5.tianditu.com/services/A0610_ImgAnno",
    				"http://tile6.tianditu.com/services/A0610_ImgAnno",
    				"http://tile7.tianditu.com/services/A0610_ImgAnno"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全国影像(14)", "http://tile0.tianditu.com/services/eastdawnall", {
                transitionEffect: "resize",
                topLevel: 14,
                bottomLevel: 14,
                maxExtent: new Geo.Bounds(73.30078125,17.9296875,135.17578125,53.701171875),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/eastdawnall",
                    "http://tile1.tianditu.com/services/eastdawnall",
    				"http://tile2.tianditu.com/services/eastdawnall",
    				"http://tile3.tianditu.com/services/eastdawnall",
    				"http://tile4.tianditu.com/services/eastdawnall",
    				"http://tile5.tianditu.com/services/eastdawnall",
    				"http://tile6.tianditu.com/services/eastdawnall",
    				"http://tile7.tianditu.com/services/eastdawnall"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全球影像(15-18)", "http://tile0.tianditu.com/services/sbsm1518", {
                transitionEffect: "resize",
                topLevel: 15,
                bottomLevel: 18,
                maxExtent: new Geo.Bounds(-180, -90, 180, 90),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/sbsm1518",
                    "http://tile1.tianditu.com/services/sbsm1518",
    				"http://tile2.tianditu.com/services/sbsm1518",
    				"http://tile3.tianditu.com/services/sbsm1518",
    				"http://tile4.tianditu.com/services/sbsm1518",
    				"http://tile5.tianditu.com/services/sbsm1518",
    				"http://tile6.tianditu.com/services/sbsm1518",
    				"http://tile7.tianditu.com/services/sbsm1518"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全国影像(13)", "http://tile0.tianditu.com/services/e13", {
                transitionEffect: "resize",
                topLevel: 13,
                bottomLevel: 13,
                maxExtent: new Geo.Bounds(73.30078125,17.9736328125,135.1318359375,53.6572265625),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/e13",
                    "http://tile1.tianditu.com/services/e13",
    				"http://tile2.tianditu.com/services/e13",
    				"http://tile3.tianditu.com/services/e13",
    				"http://tile4.tianditu.com/services/e13",
    				"http://tile5.tianditu.com/services/e13",
    				"http://tile6.tianditu.com/services/e13",
    				"http://tile7.tianditu.com/services/e13"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全国影像(12)", "http://tile0.tianditu.com/services/e12", {
                transitionEffect: "resize",
                topLevel: 12,
                bottomLevel: 12,
                maxExtent: new Geo.Bounds(73.30078125,17.9296875,135.17578125,53.701171875),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/e12",
                    "http://tile1.tianditu.com/services/e12",
    				"http://tile2.tianditu.com/services/e12",
    				"http://tile3.tianditu.com/services/e12",
    				"http://tile4.tianditu.com/services/e12",
    				"http://tile5.tianditu.com/services/e12",
    				"http://tile6.tianditu.com/services/e12",
    				"http://tile7.tianditu.com/services/e12"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全国影像(11)", "http://tile0.tianditu.com/services/e11", {
                transitionEffect: "resize",
                topLevel: 11,
                bottomLevel: 11,
                maxExtent: new Geo.Bounds(73.30078125,17.9296875,135.17578125,53.7890625),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/e11",
                    "http://tile1.tianditu.com/services/e11",
    				"http://tile2.tianditu.com/services/e11",
    				"http://tile3.tianditu.com/services/e11",
    				"http://tile4.tianditu.com/services/e11",
    				"http://tile5.tianditu.com/services/e11",
    				"http://tile6.tianditu.com/services/e11",
    				"http://tile7.tianditu.com/services/e11"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全国影像注记(11-14)", "http://tile0.tianditu.com/services/B0530_eImgAnno", {
                topLevel: 11,
                bottomLevel: 14,
                maxExtent: new Geo.Bounds(73.4765625,2.8125,135.439453125,53.7890625),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/B0530_eImgAnno",
                    "http://tile1.tianditu.com/services/B0530_eImgAnno",
    				"http://tile2.tianditu.com/services/B0530_eImgAnno",
    				"http://tile3.tianditu.com/services/B0530_eImgAnno",
    				"http://tile4.tianditu.com/services/B0530_eImgAnno",
    				"http://tile5.tianditu.com/services/B0530_eImgAnno",
    				"http://tile6.tianditu.com/services/B0530_eImgAnno",
    				"http://tile7.tianditu.com/services/B0530_eImgAnno"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全国影像注记(15-18)", "http://tile0.tianditu.com/services/siweiAnno68", {
                topLevel: 15,
                bottomLevel: 18,
                maxExtent: new Geo.Bounds(73.4765625,2.8125,135.439453125,53.7890625),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/siweiAnno68",
                    "http://tile1.tianditu.com/services/siweiAnno68",
    				"http://tile2.tianditu.com/services/siweiAnno68",
    				"http://tile3.tianditu.com/services/siweiAnno68",
    				"http://tile4.tianditu.com/services/siweiAnno68",
    				"http://tile5.tianditu.com/services/siweiAnno68",
    				"http://tile6.tianditu.com/services/siweiAnno68",
    				"http://tile7.tianditu.com/services/siweiAnno68"
    				
                ]
            })
        ],"dlg":[
            new Geo.View2D.Layer.GlobeTile("全国矢量(2-10)", "http://tile0.tianditu.com/services/A0512_EMap", {
                transitionEffect: "resize",
                topLevel: 2,
                bottomLevel: 10,
                maxExtent: new Geo.Bounds(-180,-90,180,90),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/A0512_EMap",
                    "http://tile1.tianditu.com/services/A0512_EMap",
    				"http://tile2.tianditu.com/services/A0512_EMap",
    				"http://tile3.tianditu.com/services/A0512_EMap",
    				"http://tile4.tianditu.com/services/A0512_EMap",
    				"http://tile5.tianditu.com/services/A0512_EMap",
    				"http://tile6.tianditu.com/services/A0512_EMap",
    				"http://tile7.tianditu.com/services/A0512_EMap"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全国矢量注记(2-10)", "http://tile0.tianditu.com/services/AB0512_Anno", {
                topLevel: 2,
                bottomLevel: 10,
                maxExtent: new Geo.Bounds(-180,-90,180,90),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/AB0512_Anno",
                    "http://tile1.tianditu.com/services/AB0512_Anno",
    				"http://tile2.tianditu.com/services/AB0512_Anno",
    				"http://tile3.tianditu.com/services/AB0512_Anno",
    				"http://tile4.tianditu.com/services/AB0512_Anno",
    				"http://tile5.tianditu.com/services/AB0512_Anno",
    				"http://tile6.tianditu.com/services/AB0512_Anno",
    				"http://tile7.tianditu.com/services/AB0512_Anno"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全国矢量(11-12)", "http://tile0.tianditu.com/services/B0627_EMap1112", {
                transitionEffect: "resize",
                topLevel: 11,
                bottomLevel: 12,
                maxExtent: new Geo.Bounds(69.9609375,0.87890625,879.9609375,56.25),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/B0627_EMap1112",
                    "http://tile1.tianditu.com/services/B0627_EMap1112",
    				"http://tile2.tianditu.com/services/B0627_EMap1112",
    				"http://tile3.tianditu.com/services/B0627_EMap1112",
    				"http://tile4.tianditu.com/services/B0627_EMap1112",
    				"http://tile5.tianditu.com/services/B0627_EMap1112",
    				"http://tile6.tianditu.com/services/B0627_EMap1112",
    				"http://tile7.tianditu.com/services/B0627_EMap1112"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全国矢量(13-18)", "http://tile0.tianditu.com/services/siwei0608", {
                transitionEffect: "resize",
                topLevel: 13,
                bottomLevel: 18,
                maxExtent: new Geo.Bounds(-180,-90,180,90),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/siwei0608",
                    "http://tile1.tianditu.com/services/siwei0608",
    				"http://tile2.tianditu.com/services/siwei0608",
    				"http://tile3.tianditu.com/services/siwei0608",
    				"http://tile4.tianditu.com/services/siwei0608",
    				"http://tile5.tianditu.com/services/siwei0608",
    				"http://tile6.tianditu.com/services/siwei0608",
    				"http://tile7.tianditu.com/services/siwei0608"
    				
                ]
            })
        ]
    };
    
    var layers = typeMapping[type];
    if(layers){
        return new Geo.View2D.BaseLayerGroup({layers: layers});
    }
    return null;
}
//此类已被废弃，推荐使用Geo.View2D.BaseLayerGroup代替
Geo.View2D.LayerGroup = Geo.View2D.BaseLayerGroup;


/**
 * Class: Geo.View2D.FeatureManager
 * 二维视图要素管理器。提供了与矢量要素相关的一系列功能。支持对同一矢量图层上的要素进行分类管理，包含矢量图层样式设置、
 * 要素选择功能、要素浮云显示、要素集客户端分页等功能。
 */
Geo.View2D.FeatureManager = Geo.Class({
	
    /**
     * APIProperty: id
     * {String} 唯一标识。
     */
    id: null,	
    
    /**
     * APIProperty: map
     * {<Geo.View2D.Map>} 所属的地图对象。
     */
    map: null,
	
	//结果类型映射
	_typeMapping: null,
	
	/**
     * APIProperty: featureSortField
     * {String} 标识要素分类的属性名，默认为"featureSort"。
     */
	featureSortField: "featureSort",

	/**
     * APIProperty: orderNumberField
     * {String} 标识要素序号的属性名，默认为"orderNumber"。
     */	
	orderNumberField: "orderNumber",

	/**
     * APIProperty: styleMap
     * {<Geo.StyleMap>} 矢量图层样式。
     */	
	styleMap: null,
    
	/**
     * APIProperty: vectorLayerOptions
     * {Object} 矢量图层对象构造参数。
     */		
	vectorLayerOptions: null,    

	/**
     * APIProperty: vectorLayer
     * {<Geo.View2D.Layer.Vector>} 矢量图层。
     */		
	vectorLayer: null,

	/**
     * APIProperty: selectControlOptions
     * {Object} 要素选择控件对象构造参数。
     */	
	selectControlOptions: null,

	/**
     * APIProperty: selectControl
     * {<Geo.View2D.Control.SelectFeature>} 矢量要素选择控件。
     */	
	selectControl: null,

	/**
     * APIProperty: maxFeaturesPerPage
     * {Integer} 默认的要素分页数量，默认值是15。
     */	
	maxFeaturesPerPage: 15,

    //提示框样式CSS类名。
	topicCSSClass: null,
	
    //提示框div
	topicDiv: null,

    /**
     * Constructor: Geo.View2D.FeatureManager
     * Geo.View2D.FeatureManager对象构造函数。
     * 
     * Parameters:
     * options - {Object} 相关选项设置。
     */
	initialize: function(options){
		this._typeMapping = {};
		this.styleMap = Geo.View2D.FeatureManager.defaultStyleMap;
		this.registerResultType("default");
		OpenLayers.Util.extend(this, options);
	},
	
	/**
     * APIMethod: setMap
     * 将要素管理器关联到相应的二维视图对象。在关联到二维视图对象时,会在二维视图对象中
     * 加入一个矢量图层和选择控件，矢量图层和选择控件的引用可以通过访问vectorLayer和
     * selectControl属性的获得。
     *
     * Parameters:
     * map - {<Geo.View2D.Map>} 地图对象。
     */
	setMap: function(map){
		if(map && !this.map){
			this.map = map;
			
			//添加结果图层
			this.vectorLayer = new OpenLayers.Layer.Vector("GeoGlobeFeatureManagerVector", {
				styleMap: this.styleMap,
				isOnTop: true,
				displayInLayerSwitcher: false,
				//要素的显示级别设置为开启状态，默认为false
				rendererOptions: {zIndexing: true}
			});
			this.map.addLayer(this.vectorLayer);
			this._initSelectControl();
			this._addTopicDiv();
		}
	},

	/**
     * APIMethod: registerFeatureSort
     * 注册要素类别。如果希望对多个分类的要素进行管理，则需要先注册要素类别加以区分，
     * 然后再调用addFeatures方法向分类中添加要素集。
     *
     * Parameters:
     * sort - {String} 要素分类。
     * options - {Object} 参数设置。
     */	
    registerFeatureSort: function(sort,options){
		var DEFAULT_PARAMS = {
			features:[],
			currentPage:0,
			maxFeaturesPerPage: this.maxFeaturesPerPage,
			onTurnToPage: this.onTurnToPage,
			onFeatureSelect: Geo.View2D.FeatureManager.showFramedCloud,
			onFeatureUnselect: Geo.View2D.FeatureManager.closeFramedCloud,
			onFeatureOver: Geo.View2D.FeatureManager.showTopic,
			onFeatureOut: Geo.View2D.FeatureManager.closeTopic
		};
		this._typeMapping[sort] = OpenLayers.Util.extend(DEFAULT_PARAMS,options);        
    }, 
     
    //此方法已被废弃，推荐使用registerResultSort
	registerResultType: function(type,options){
        this.registerFeatureSort(type,options);
	},
	
	/**
     * APIMethod: addFeatures
     * 向类别中添加要素，要素添加到类别后将在要素的外部属性中加上类型标识。
     *
     * Parameters:
     * features - {Array(<Geo.Feature.Vector>)} 添加的要素数组。
     * sort - {String} 要素类别。
     * isAppend - {Boolean} 是否追加要素。
     */		
	addFeatures: function(features,sort,isAppend){
		sort = sort || "default";
		if(!(features instanceof Array)) {
			features = [features];
		}
		if(this._typeMapping[sort]){
			var features =  this._addTypeMarker(features,sort);
			
			//为要素添加自定义样式
			var style = this._typeMapping[sort].style;
			if(style){
				this._addStyleForFeatures(features,style);
			}
			
			if(!isAppend){
				this.clearResultFromMap(sort);
				this._typeMapping[sort].features = features;
			} else {
				this._typeMapping[sort].features = this._typeMapping[sort].features.concat(features);
			}
			this._typeMapping[sort].currentPage = 0;
		}
	},
	
	/**
	 * APIMethod: onTurnToPage
	 * 获取当前页的要素，本方法需要用户自己去覆盖。
	 * 
	 */
	onTurnToPage: function(feature){
		
	},
	
	/**
     * APIMethod: turnToPageN。
     * 翻到指定页数。
     *
     * Parameters:
     * page - {Integer} 当前第几页。
     * sort - {String} 要素类别。
     * isDrawToMap - {Boolean} 是否绘制到地图上。
     */	
	turnToPageN: function(page, sort, isDrawToMap){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];

		var pageNum = this.getTotalPageNumber(sort);
		page = (page <= 0) ? 1 : page;
		page = (page > pageNum) ? pageNum : page; 
				
		var features = this._pagingFeatures({
			maxPerPage: mapping.maxFeaturesPerPage,
			pageNum:page,
			resultArr:mapping.features
		});
		
		this.addOrderForFeatures(features);
				
		if(page !== mapping.currentPage){
			this.clearResultFromMap(sort);
			this.drawFeaturesToMap(features);
			mapping.currentPage = page;
		}
		mapping.onTurnToPage(features);
		
		return features;
	},
	
	/**
     * APIMethod: turnToFirst
     * 翻到首页。
     *
     * Parameters:
     * sort - {String} 要素类别。
     * isDrawToMap - {Boolean} 是否绘制到地图上。
     */		
	turnToFirst: function(sort, isDrawToMap){
		sort = sort || "default";
		return this.turnToPageN(1,sort, isDrawToMap);
	},
	
	/**
     * APIMethod: turnToNext
     * 翻到下页。
     *
     * Parameters:
     * sort - {String} 要素类别。
     * isDrawToMap - {Boolean} 是否绘制到地图上。
     */		
	turnToNext: function(sort, isDrawToMap){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		return this.turnToPageN(mapping.currentPage + 1, sort, isDrawToMap);
	},
	
	/**
     * APIMethod: turnToPre
     * 翻到前页。
     *
     * Parameters:
     * sort - {String} 要素类别。
     * isDrawToMap - {Boolean} 是否绘制到地图上。
     */		
	turnToPre: function(sort, isDrawToMap){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		return this.turnToPageN(mapping.currentPage - 1, sort, isDrawToMap);
	},
	
	/**
     * APIMethod: turnToLast
     * 翻到尾页。
     *
     * Parameters:
     * sort - {String} 要素类别。
     * isDrawToMap - {Boolean} 是否绘制到地图上。
     */		
	turnToLast: function(sort, isDrawToMap){
		sort = sort || "default";
		var last = this.getTotalPageNumber(sort);
		this.turnToPageN(last, sort, isDrawToMap);
	},
	
	/**
     * APIMethod: getPageInfo
     * 获取分页相关情况。
     *
     * Parameters:
     * sort - {String} 要素类别。
     */		
	getPageInfo: function(sort){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		var features = mapping.features;
		return Math.ceil(features.length / mapping.maxFeaturesPerPage);
	},
	
	/**
     * APIMethod: getTotalPageNumber
     * 获取指定类别的要素分页页数。
     *
     * Parameters:
     * sort - {String} 要素类别。
     */			
	getTotalPageNumber: function(sort){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		var features = mapping.features;
		return Math.ceil(features.length / mapping.maxFeaturesPerPage);
	},
	
	/**
     * APIMethod: getFeatures
     * 获取指定结果类型的要素。
     *
     * Parameters:
     * sort - {String} 要素类别。
     */		
	getFeatures: function(sort){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		if(mapping && mapping.features) {
			return mapping.features;
		}else {
			return [];
		}
	},
	
	/**
     * APIMethod: drawFeaturesToMap
     * 将要素绘制到地图上，可以是指定类型或指定要素数组。
     *
     * Parameters:
     * content - {String|Array(<Geo.Feature.Vector>)} 要素类别。
     */		
	drawFeaturesToMap: function(content){
		var map, layer, features;
		map = this.map;
		layer = this.vectorLayer;
		
		if( typeof(content) == "string"){
			var sort = content || "default";
			if(this._typeMapping[sort] && map){
				features = this.getFeatures(sort);
			}

		};
		
		if( content instanceof  Array){
			features = content;
		};
		layer.addFeatures(features);
        
        var dataExtent = layer.getDataExtent();
        if(dataExtent){
            layer.map.zoomToExtent(dataExtent);
        }
	},
	
	/**
     * APIMethod: selectFeatureById
     * 通过ID来指定要素,通过选择控件来选择。
     *
     * Parameters:
     * featureid - {String} 要素类别。
     */	
	selectFeatureById: function(featureid){
		this.selectControl.unselectAll();
		var feature = this.vectorLayer.getFeatureById(featureid);
		//重绘的目的是为了解决点重叠的问题
		this.vectorLayer.drawFeature(feature);
		this.selectControl.select(feature);
		feature.selectControl = this.selectControl;
	},

	/**
     * APIMethod: clearFeatureFromMap
     * 清除指定类别要素,如无指定类别则默认清除"default"类别，如果指定值为"allType"则清除所有分类要素。
     *
     * Parameters:
     * sort - {String} 要素类别。
     */		
	clearFeatureFromMap: function(sort){		
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		var features;
		var layer = this.vectorLayer;
		if(sort == "allType"){
			features = this.vectorLayer.features;
		} else {
			features = mapping ? mapping.features : [];
		}
		
		if(layer){
			this.selectControl.unselectAll();
			layer.removeFeatures(features);
		}
		
		
	},

    //此方法被废弃，推荐使用clearFeatureFromMap
	clearResultFromMap: function(sort){		
		this.clearFeatureFromMap(sort);
	},
    
	/**
     * APIMethod: clearFeatures
     * 清除指定类型结果要素,如无指定类型则默认清除"default"类型，如果指定值为"allType"则清除所有分类要素。
     *
     * Parameters:
     * sort - {String} 要素类别。
     */	
    clearFeatures: function(sort){
        sort = sort || "default";
        var mapping = this._typeMapping[sort];
        if(mapping){
            this.clearResultFromMap(sort);
            mapping.features = [];
        }
    },

    //此方法被废弃，推荐使用clearFeatures
    clearResult: function(sort){
        this.clearFeatures(sort);
    },
	
	/**
     * APIMethod: addOrderForFeatures
     * 为要素数组中每个要素按顺序添加编号，编号是记录在“orderNumberField”属性指定的要素。
     * 外部属性中。
     *
     * Parameters:
     * features - {Array<Geo.Feature.Vector>} 要素数组。
     * 
     * Returns:
     * {Array<Geo.Feature.Vector>}
     */	
	addOrderForFeatures: function(features){
		//添加带序号的结果图标
	    for (var i = 0; i < features.length; i++) {
	        features[i].attributes[this.orderNumberField] = i;
	    }
		return features;
	},
	
	//为要素加上样式
	_addStyleForFeatures: function(features, style){
		for(var i=0; i<features.length; i++){
			var f = features[i];
			if(!f.style){
				f.style = style;
			}
		}
	},
	
	//为每个要素添加类型标识属性
	_addTypeMarker: function(features,type){
		for(var i=0; i<features.length; i++){
			var feature = features[i];
			feature.attributes[this.featureSortField] = type;
		}
		return features;
	},
	
	_addTopicDiv: function(){
		var mapid = this.map.id;
		var topicDiv = OpenLayers.Util.getElement(mapid + "featureManagerTopic");
		if(!topicDiv){
			topicDiv = document.createElement("div");
			if(!this.topicCSSClass){
				topicDiv.style.backgroundColor = "#fff";
				topicDiv.style.border = "1px solid #000";
				topicDiv.style.padding = "3px";
				topicDiv.style.position = "absolute";
				topicDiv.style.top = "30px";
				topicDiv.style.left = "30px";
				topicDiv.style.display = "none"
				topicDiv.innerHTML = "test";
				
			}
			this.map.div.appendChild(topicDiv);
			this.topicDiv = topicDiv;
		}
		
	},

	
	/**
	 * 对指定结果要素数组进行分页处理。
	 * options示例:
	 * {
	 * 		maxPerPage:15,
	 * 		pageNum:1,
	 * 		resultArr:[]
	 * }
	 */
	_pagingFeatures: function(options){
	    var start, end, 
			maxPerPage = options.maxPerPage, 
			pageNum = options.pageNum, 
			resultArr = options.resultArr;
	    start = (pageNum - 1) * maxPerPage;
	    end = pageNum * maxPerPage - 1;
	    
		var features = resultArr.slice(start, end + 1);
	    
	    
	    
	    return features;
	},
	
	//根据事件类型分派事件
	_dispatchEvent: function(scope,feature,eventType){
		var resultType = feature.attributes[scope.featureSortField];
		var mapping = scope._typeMapping[resultType];
		mapping[eventType](feature);
	},
	
	//激活选择控件,自动检查是否控件初始化
	_initSelectControl: function(){
		if(!this.map){
			return;
		}
		if(!this.selectControl){
			var DEFAULT_OPTIONS = {
				onSelect: OpenLayers.Function.bind(function(feature){
					this._dispatchEvent(this,feature,"onFeatureSelect");
				},this),
				onUnselect: OpenLayers.Function.bind(function(feature){
					this._dispatchEvent(this,feature,"onFeatureUnselect");
				},this),
				callbacks:{
					over: OpenLayers.Function.bind(function(feature){
						this._dispatchEvent(this,feature,"onFeatureOver");
					},this),
					out: OpenLayers.Function.bind(function(feature){
						this._dispatchEvent(this,feature,"onFeatureOut");
					},this)
				}
			};
            
            var options = OpenLayers.Util.applyDefaults(this.selectControlOptions,DEFAULT_OPTIONS);
			//添加选择控件
			this.selectControl = new Geo.View2D.Control.SelectFeature(this.vectorLayer,options)
			this.map.addControl(this.selectControl);
		}
	}
});

/**
 * APIProperty: Geo.View2D.FeatureManager.defaultStyleMap
 * {<Geo.StyleMap>} FeatureManager中vectorLayer图层的默认要素样式。
 */
Geo.View2D.FeatureManager.defaultStyleMap = new Geo.StyleMap({
    "default": new Geo.Style({
    	externalGraphic: OpenLayers.Util.getImagesLocation() + "marker.png",
    	graphicWidth:21,
		graphicHeight:25,
		graphicXOffset:-10,
		graphicYOffset:-12
    }) ,
    "select": new Geo.Style({
        externalGraphic: OpenLayers.Util.getImagesLocation() + "marker-blue.png",
    	graphicWidth:21,
		graphicHeight:25,
		graphicXOffset:-10,
		graphicYOffset:-12
    })
});

/**
 * APIMethod: Geo.View2D.FeatureManager.showFramedCloud
 * 为要素添加浮云，如果指定内容模板则浮云内空按模板规则生成。
 * 
 * Parameters:
 * feature - 浮云所属的矢量要素。
 * templateString - 字符串内容模板。
 * 
 */
Geo.View2D.FeatureManager.showFramedCloud = function(feature, templateString){
    var layer = feature.layer, map = layer ? layer.map : null;
	if(!layer || !map){
		return;
	}
	var str;
	if(templateString){
		str = templateString;
	} else {
		str = (function(){
	        var str = "";
	        for (var myitem in feature.attributes) {
	            str += myitem + ":" + feature.attributes[myitem] + "<br>";
	        }
	        return str;
	    })();
	}
    
	var lonlat = null;
	if("OpenLayers.Geometry.LineString" == feature.geometry.CLASS_NAME) {
		var location = Math.floor(feature.geometry.components.length / 2) ;
		var tempPoint = feature.geometry.components[location];
		lonlat = new Geo.LonLat(tempPoint.x,tempPoint.y);
	}else {
		lonlat = feature.geometry.getBounds().getCenterLonLat();
	}
    if (map) {
		//直接定位到中心点，没有平滑效果
        map.setCenter(lonlat);
    }
    
    var popup = new Geo.View2D.Popup.FramedCloud(
		"featureInfo", 
		lonlat, 
		null, 
		str, 
		null, 
		true, 
		Geo.View2D.FeatureManager.onPopupClose
	);
    feature.popup = popup;
	//浮云关联到要素，因为关闭浮云的时候需要取消要素的选择
	popup.feature = feature;
	if(this.selectControl) {
		feature.selectControl = this.selectControl;
	}
    map.addPopup(popup);
};

/**
 * APIMethod: Geo.View2D.FeatureManager.closeFramedCloud
 * 关闭并消毁指定要素上添加的浮云。
 * 
 * Parameters:
 * feature - 浮云所属的矢量要素。
 * 
 */
Geo.View2D.FeatureManager.closeFramedCloud = function(feature){
    var layer = feature.layer, map = layer ? layer.map : null;
    if (feature.popup && layer && map) {
        map.removePopup(feature.popup);
        feature.popup.destroy();
        feature.popup = null;
    }
};

/**
 * APIMethod: Geo.View2D.FeatureManager.onPopupClose
 * 浮云关闭时触发的方法。
 */
Geo.View2D.FeatureManager.onPopupClose = function(){
	//关闭浮云的时候取消选择,如果要素关联到控件，则执行取消操作，如果没有，直接清除浮云
	if(this.feature && this.feature.selectControl) {
		this.feature.selectControl.unselect(this.feature);
	}else {
		var map = this.map;
	    if (map) {
	        map.removePopup(this);
	    }
	}
}
	
Geo.View2D.FeatureManager.showTopic = function(feature){
	
};
	
Geo.View2D.FeatureManager.closeTopic = function(feature){
	
};
/**
 * Class: Geo.View2D.MarkerTag
 * 标注的自定义标签类。
 */
Geo.View2D.MarkerTag = Geo.Class({
    
    /** 
     * Property: size 
     * {<Geo.Size>} 自定义标签的尺寸大小。
     */
    size: null,

    /** 
     * Property: offset 
     * {<Geo.Pixel>} 像素对象，表示自定义标签的偏移量。
     */
    offset: null,    
    
    /** 
     * Property: calculateOffset 
     * {Function} 根据this.size来计算偏移量的函数（参数为this.size）。
     */
    calculateOffset: null,    
    
    /** 
     * Property: div
     * {DOMElement} 自定义标签的DIV容器。
     */
    div: null,

    /** 
     * Property: px 
     * {<Geo.Pixel>} 屏幕像素对象，表示在地图上的屏幕位置。
     */
    px: null,
    
    /** 
     * Constructor: Geo.View2D.MarkerTag
     * Geo.View2D.MarkerTag对象构造函数。
     *
     * html - {String} 自定义html字符串。
     * size - {<Geo.Size>} 标签尺寸大小。
     * offset - {<Geo.Pixel>} 标签的偏移量对象。
     * calculateOffset - {Function} 根据this.size来计算偏移量的函数（参数为this.size）。
     */
    initialize: function(html, size, offset, calculateOffset) {
		this.html = html;
		
		var containerElement = (this.map) ? this.map.layerContainerDiv : document.body;
        var realSize = OpenLayers.Util.getRenderedDimensions(html, null, {
            containerElement: containerElement
        });
        this.size = (size) ? size : realSize;
		
		
        this.offset = offset ? offset : new Geo.Pixel(-(this.size.w/2), -(this.size.h/2));
        this.calculateOffset = calculateOffset;

        var id = OpenLayers.Util.createUniqueID("OL_Div_");
		this.div = OpenLayers.Util.createDiv(id, null, null, null, "absolute", null, null, null);
    },
    
    /** 
     * Method: destroy
     * 销毁该对象。
     */
    destroy: function() {
        // erase any drawn elements
        this.erase();

        this.div.innerHTML = "";
        this.div = null;
    },

    /** 
     * Method: clone
     * 返回本对象的副本。
     * 
     * Returns:
     * {<Geo.View2D.MarkerTag>} 该类的实例。
     */
    clone: function(){
        return new Geo.View2D.MarkerTag(this.html, this.size, this.offset, this.calculateOffset);
    },
    
    /**
     * Method: setSize
     * 设置尺寸大小。
     * 
     * Parameters:
     * size - {<Geo.Size>} 尺寸大小对象。
     */
    setSize: function(size) {
        if (size != null) {
            this.size = size;
        }
        this.draw();
    },
    
    /**
     * Method: setContentHTML
     * 设置HTML内容。
     * 
     * Parameters:
     * html - {String} 内容为HTML字符串。
     */
    setContentHTML: function(html) {
        if (html != null) {
            this.html = html;
        }
        this.draw();
    },
	
    /** 
     * Method: draw
     * 绘制该自定义标签。
     * 
     * Parameters:
     * px - {<Geo.Pixel>} 屏幕像素对象。
     * 
     * Returns:
     * {DOMElement} 返回该自定义标签的DIV元素。
     */
    draw: function(px) {
		OpenLayers.Util.modifyDOMElement(this.div, null, null, this.size, "absolute");
		this.div.innerHTML = this.html;
        this.moveTo(px);
        return this.div;
    }, 

    /** 
     * Method: erase
     * 清除自定义标签的DIV元素。
     */
    erase: function() {
        if (this.div != null && this.div.parentNode != null) {
            OpenLayers.Element.remove(this.div);
        }
    }, 
    
    /** 
     * Method: setOpacity
     * 设置透明度。
     *
     * Parameters:
     * opacity - {float} 透明度值，范围：0~1，浮点类型。
     */
    setOpacity: function(opacity) {
		OpenLayers.Util.modifyDOMElement(this.div, null, null, null, null, null, null, opacity);

    },
    
    /**
     * Method: moveTo
     * 移动自定义标签。
     *
     * Parameters:
     * px - {<Geo.Pixel>} 屏幕像素对象。
     */
    moveTo: function (px) {
        //if no px passed in, use stored location
        if (px != null) {
            this.px = px;
        }

        if (this.div != null) {
            if (this.px == null) {
                this.display(false);
			} else {
                if (this.calculateOffset) {
                    this.offset = this.calculateOffset(this.size);
                }
                var offsetPx = this.px.offset(this.offset);
                OpenLayers.Util.modifyDOMElement(this.div, null, offsetPx);
            }
        }
    },
    
    /** 
     * Method: display
     * 显示或隐藏自定义标签。
     *
     * Parameters:
     * display - {Boolean} 是否显示的标识。
     */
    display: function(display) {
        this.div.style.display = (display) ? "" : "none"; 
    },
    

    /**
     * APIMethod: isDrawn
     * 是否已经绘制。
     * 
     * Returns:
     * {Boolean} 是否已经绘制，返回值为布尔类型。
     */
    isDrawn: function() {
        // nodeType 11 for ie, whose nodes *always* have a parentNode
        // (of type document fragment)
        var isDrawn = (this.div && this.div.parentNode && 
                       (this.div.parentNode.nodeType != 11));    

        return isDrawn;   
    },

    CLASS_NAME: "Geo.View2D.MarkerTag"
});
/**
 * Class: Geo.View2D.Control.DrawCircle
 * 几何圆绘制控件类，继承自Geo.View2D.Control类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.DrawCircle = Geo.Class(Geo.View2D.Control, {

    /**
     * APIProperty: type
     * 控件类型
     */    
	type: Geo.View2D.Control.TYPE_TOOL,
    
    /**
     * APIProperty: sides
     * {Integer} 圆是由正多边形构成的，sides是构成圆的正多边形的边的数目，默认值为40。 
     */
	sides: 40,

    /**
     * APIProperty: persist
     * {Boolean} 是否保留绘制上次绘制的要素，默认值为false。如果设置为true，重新开始一个新绘制时，上次绘制的要素仍将保留。
     */ 	
	persist: false,
	
	/**
	 * Constructor: Geo.View2D.Control.DrawCircle
	 * Geo.View2D.Control.DrawCircle构造函数
	 */
    initialize: function(options){
        Geo.View2D.Control.prototype.initialize.apply(this, [options]);
        
        this.handler = new OpenLayers.Handler.RegularPolygon(
							this, 
							{ "done": this.done }, 
							{ "sides": this.sides , persist: this.persist });
    },
	
    /**
     * APIMethod: done
     * 绘制完成的响应函数，用户可以使用自己定义的函数替代。
     * 
     * Parameters:
     * geometry - {<Geo.Geometry>} 绘制的几何对象。
     */
    done: function(geometry){
        
    },
    
	CLASS_NAME: "Geo.View2D.Control.DrawCircle"
});
/**
 * Class: Geo.View2D.Control.DrawPath
 * 几何线绘制控件类，继承自Geo.View2D.Control类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.DrawPath = Geo.Class(Geo.View2D.Control, {

    /**
     * APIProperty: type
     * 控件有一个类型。类型决定了控件生成实例时在控件栏上的存放位置。 
     */  
    type: Geo.View2D.Control.TYPE_TOOL,

    /**
     * APIProperty: persist
     * {Boolean} 是否保留绘制上次绘制的要素，默认值为false。如果设置为true，重新开始一个新绘制时，上次绘制的要素仍将保留。
     */ 	
	persist: false,
    
	/**
	 * Constructor: Geo.View2D.Control.DrawPath
	 * 构造函数。生成一个Geo.View2D.Control.DrawPath的实例。
	 */    
    initialize: function(options){
        Geo.View2D.Control.prototype.initialize.apply(this, [options]);
        
        this.handler = new OpenLayers.Handler.Path(this, {
            "done": this.done
        },{ 
            persist: this.persist 
        });
    },

	
    /**
     * APIMethod: done
     * 绘制完成的响应函数，用户可以使用自己定义的函数替代。
     * 
     * Parameters:
     * geometry - {<Geo.Geometry>} 绘制的几何对象。
     */	
    done: function(geometry){
        
    },
	
	CLASS_NAME: "Geo.View2D.Control.DrawPath"
});
/**
 * Class: Geo.View2D.Control.DrawPoint
 * 几何点绘制控件类，继承自Geo.View2D.Control类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.DrawPoint = Geo.Class(Geo.View2D.Control, {

    /**
     * APIProperty: type
     * 控件有一个类型。类型决定了控件生成实例时在控件栏上的存放位置。 
     */
    type: Geo.View2D.Control.TYPE_TOOL,

    /**
     * APIProperty: persist
     * {Boolean} 是否保留绘制上次绘制的要素，默认值为false。如果设置为true，重新开始一个新绘制时，上次绘制的要素仍将保留。
     */ 	
	persist: false,
       
 	/**
	 * Constructor: Geo.View2D.Control.DrawPoint
	 * 构造函数。生成一个Geo.View2D.Control.DrawPoint的实例。
	 */     
    initialize: function(options){
        Geo.View2D.Control.prototype.initialize.apply(this, [options]);
        
        this.handler = new OpenLayers.Handler.Point(this, {
            "done": this.done
        },{ 
            persist: this.persist 
        });
    },
	
    /**
     * APIMethod: done
     * 绘制完成的响应函数，用户可以使用自己定义的函数替代。
     * 
     * Parameters:
     * geometry - {<Geo.Geometry>} 绘制的几何对象。
     */		
    done: function(geometry){
        
    },
	
	CLASS_NAME: "Geo.View2D.Control.DrawPoint"
});
/**
 * Class: Geo.View2D.Control.DrawPolygon
 * 几何多边形绘制控件类，继承自Geo.View2D.Control类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.DrawPolygon = Geo.Class(Geo.View2D.Control, {

    /**
     * APIProperty: type
     * 控件有一个类型。类型决定了控件生成实例时在控件栏上的存放位置。 
     */
    type: Geo.View2D.Control.TYPE_TOOL,
 
    /**
     * APIProperty: persist
     * {Boolean} 是否保留绘制上次绘制的要素，默认值为false。如果设置为true，重新开始一个新绘制时，上次绘制的要素仍将保留。
     */ 	
	persist: false,
    
 	/**
	 * Constructor: Geo.View2D.Control.DrawPolygon
	 * 构造函数。生成一个Geo.View2D.Control.DrawPolygon的实例。
	 */   
    initialize: function(options){
        Geo.View2D.Control.prototype.initialize.apply(this, [options]);
        
        this.handler = new OpenLayers.Handler.Polygon(this, {
            "done": this.done
        });
    },
	
    /**
     * APIMethod: done
     * 绘制完成的响应函数，用户可以使用自己定义的函数替代。
     * 
     * Parameters:
     * geometry - {<Geo.Geometry>} 
     */		
    done: function(geometry){
        
    },
    
	CLASS_NAME: "Geo.View2D.Control.DrawPolygon"
});
/**
 * Class: Geo.View2D.Control.DrawRectangle
 * 几何矩形绘制控件类，继承自Geo.View2D.Control类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.DrawRectangle = Geo.Class(Geo.View2D.Control, {

    /**
     * APIProperty: type
     * 控件类型。
     */
    type: Geo.View2D.Control.TYPE_TOOL,

    /**
     * APIProperty: persist
     * {Boolean} 是否保留绘制上次绘制的要素，默认值为false。如果设置为true，重新开始一个新绘制时，上次绘制的要素仍将保留。
     */ 	
	persist: false,
 	
	/**
	 * Constructor: Geo.View2D.Control.DrawRectangle
	 * Geo.View2D.Control.DrawRectangle构造函数。
	 */   
    initialize: function(options){
        Geo.View2D.Control.prototype.initialize.apply(this, [options]);
        
        this.handler = new OpenLayers.Handler.RegularPolygon(
			this,
			{ "done": this.done }, 
			{ irregular: true, persist: this.persist }
		);
    },
	
    /**
     * APIMethod: done
     * 绘制完成的响应函数，用户可以使用自己定义的函数替代。
     * 
     * Parameters:
     * geometry - {<Geo.Geometry>} 绘制的几何对象。
     */		
    done: function(geometry){},
	
	CLASS_NAME: "Geo.View2D.Control.DrawRectangle"
});
/**
 * Class: Geo.View2D.Control.MagnifyingGlass
 * 鼠标滚轮滚动时的绘制控件类，继承自Geo.View2D.Control类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * 例如:
 * (code)
 * this.controls = [ new Geo.View2D.Control.Navigation(),
 *                            new Geo.View2D.Control.PanZoomBar(),
 *                            new Geo.View2D.Control.ArgParser(),
 *                            new Geo.View2D.Control.Attribution(),
 *							  new Geo.View2D.Control.MagnifyingGlass()//将其加入控件数组
 *                           ];
 * (end)
 * 
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.MagnifyingGlass = Geo.Class(Geo.View2D.Control, {
	/**
	 * APIProperty: autoActivate
	 * 是否自动激活。
	 */
    autoActivate: true,
	
	/**
	 * Constructor: Geo.View2D.Control.MagnifyingGlass
     * Geo.View2D.Control.MagnifyingGlass构造函数。
	 */
    initialize: function(){
        Geo.View2D.Control.prototype.initialize.apply(this, arguments);
    },
    
	/**
	 * Method: draw
	 */
    draw: function(){
        Geo.View2D.Control.prototype.draw.apply(this, arguments);
        this.handler = new Geo.View2D.Handler.MouseWheel(this, {
            "down": this.magnifyingglassZoomOut,
            "up": this.magnifyingglassZoomIn
        });
        this.initDiv();
        
    },
    
	/**
	 * Method：initDiv
	 */
    initDiv: function(){
        var a = OpenLayers.Util.createDiv("map_magnifyingglass" + this.id.split("_")[1]);
        a.style.borderRight = "medium none";
        a.style.borderTop = "medium none";
        a.style.borderLeft = "medium none";
        a.style.borderBottom = "medium none";
        a.style.width = "111px";
        a.style.height = "74px";
        a.style.display = "none";
        a.style.unselectable = "on";
        var c = OpenLayers.Util.createDiv();
        c.style.lineHeight = "1px";
        c.style.width = "4px";
        c.style.height = "4px";
        c.style.left = "0";
        var b = OpenLayers.Util.createDiv();
        b.style.lineHeight = "1px";
        b.style.width = "4px";
        b.style.height = "4px";
        b.style.right = "0";
        var d = OpenLayers.Util.createDiv();
        d.style.lineHeight = "1px";
        d.style.width = "4px";
        d.style.height = "4px";
        d.style.right = "0";
        d.style.top = "40px";
        var e = OpenLayers.Util.createDiv();
        e.style.lineHeight = "1px";
        e.style.width = "4px";
        e.style.height = "4px";
        e.style.left = "0";
        e.style.top = "40px";
        a.appendChild(c);
        a.appendChild(b);
        a.appendChild(d);
        a.appendChild(e);
        this.map.viewPortDiv.appendChild(a)
    },
    
    bw_out: null,
    bw_in: null,
    variable: 1,
	
	/**
	 * Method：getTimeout
	 * Parameters:
	 * a - {Object} 
	 * b - {Object} 
	 * c - {Object} 
	 */
    getTimeout: function(a, b, c){
        return window.setTimeout(function(){
            b.apply(a)
        }, c)
    },
	/**
	 * Method：magnifyingglassZoomOut
	 * Parameters:
	 * a - {Object}
	 */
    magnifyingglassZoomOut: function(a){
        if (this.variable == 1) {
            var b = OpenLayers.Util.getElement("map_magnifyingglass" + this.id.split("_")[1]);
            if (b) {
                b.style.width = 111;
                b.style.height = 74;
                this.evt = a;
                this.out()
            }
        }
    },
	
	/**
	 * Method：magnifyingglassZoomIn
	 * Parameters:
	 * a - {Object}
	 */
    magnifyingglassZoomIn: function(a){
        if (this.variable == 1) {
            var b = OpenLayers.Util.getElement("map_magnifyingglass" + this.id.split("_")[1]);
            if (b) {
                b.style.width = "27px";
                b.style.height = "24px";
                this.evt = a;
                this.in_()
            }
        }
    },
	
	/**
	 * Method：out
	 */
    out: function(){
        this.Rx1(true)
    },
	
	/**
	 * Method：in_
	 */
    in_: function(){
        this.Rx1(false)
    },
	
	/**
	 * Method：Rx1
	 * Parameters:
	 * a - {Object}
	 */
    Rx1: function(a){
        var b = OpenLayers.Util.getElement("map_magnifyingglass" + this.id.split("_")[1]);
        if (this.variable <= 4) {
            if (b) {
                var c = 1, d;
                if (a) {
                    d = parseInt(b.style.width);
                    obj_h = parseInt(b.style.height);
                    c *= 15;
                    if (d >= 30) {
                        if (d && c) 
                            b.style.width = Math.abs(d - (c + 6)) + "px";
                        if (obj_h >= 25) 
                            if (obj_h && c) 
                                b.style.height = Math.abs(obj_h - c) + "px";
                        b.style.left = this.evt.xy.x -
                        parseInt(b.style.width) /
                        2 +
                        "px";
                        b.style.top = this.evt.xy.y -
                        parseInt(b.style.height) /
                        2 +
                        "px";
                        b.childNodes[0].style.borderWidth = "0px 2px 2px 0px";
                        b.childNodes[0].style.borderStyle = "solid";
                        b.childNodes[0].style.borderColor = "red";
                        b.childNodes[1].style.borderWidth = "0px 0px 2px 2px";
                        b.childNodes[1].style.borderStyle = "solid";
                        b.childNodes[1].style.borderColor = "red";
                        b.childNodes[2].style.borderWidth = "2px 0px 0px 2px";
                        b.childNodes[2].style.borderStyle = "solid";
                        b.childNodes[2].style.borderColor = "red";
                        b.childNodes[3].style.borderWidth = "2px 2px 0px 0px";
                        b.childNodes[3].style.borderStyle = "solid";
                        b.childNodes[3].style.borderColor = "red";
                        b.childNodes[2].style.top = b.style.height;
                        b.childNodes[3].style.top = b.style.height;
                        b.style.display = "";
                        b.style.zIndex = 1010
                    }
                    this.variable++;
                    this.bw_out = this.getTimeout(this, a ? this.out : this.in_, 60)
                }
                else {
                    d = parseInt(b.style.width);
                    obj_h = parseInt(b.style.height);
                    c *= 15;
                    if (d <= 111) {
                        b.style.width = Math.abs(d + c) + "px";
                        if (obj_h <= 64) 
                            b.style.height = Math.abs(obj_h + c) + "px";
                        b.style.left = this.evt.xy.x -
                        parseInt(b.style.width) /
                        2 +
                        "px";
                        b.style.top = this.evt.xy.y -
                        parseInt(b.style.height) /
                        2 +
                        "px";
                        b.childNodes[0].style.borderWidth = "2px 0px 0px 2px";
                        b.childNodes[0].style.borderStyle = "solid";
                        b.childNodes[0].style.borderColor = "red";
                        b.childNodes[1].style.borderWidth = "2px 2px 0px 0px";
                        b.childNodes[1].style.borderStyle = "solid";
                        b.childNodes[1].style.borderColor = "red";
                        b.childNodes[2].style.borderWidth = "0px 2px 2px 0px";
                        b.childNodes[2].style.borderStyle = "solid";
                        b.childNodes[2].style.borderColor = "red";
                        b.childNodes[3].style.borderWidth = "0px 0px 2px 2px";
                        b.childNodes[3].style.borderStyle = "solid";
                        b.childNodes[3].style.borderColor = "red";
                        b.childNodes[2].style.top = b.style.height;
                        b.childNodes[3].style.top = b.style.height;
                        b.style.display = "";
                        b.style.zIndex = 1010
                    }
                    this.variable++;
                    this.bw_in = this.getTimeout(this, a ? this.out : this.in_, 100)
                }
            }
        }
        else {
            if (a) {
                window.clearTimeout(this.bw_out);
                this.bw_out = null
            }
            else {
                window.clearTimeout(this.bw_in);
                this.bw_in = null
            }
            this.variable = 1;
            b.style.display = "none";
            b.style.zIndex = 0;
            b.style.width = "111px";
            b.style.height = "74px"
        }
    },
	
	CLASS_NAME: "Geo.View2D.Control.MagnifyingGlass"
});
/**
 * Class: Geo.View2D.Control.PanZoomBarTitle
 * 带标题的导航控件类，继承自Geo.View2D.Control.PanZoom类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control.PanZoom>
 */
Geo.View2D.Control.PanZoomBarTitle = Geo.Class(Geo.View2D.Control.PanZoom, {
	/** 
     * APIProperty: zoomStopWidth
     * 缩放停止的宽度，默认为：18。
     */
    zoomStopWidth: 18,   

    /** 
     * APIProperty: zoomStopHeight
     * 缩放停止的高度，默认为：11。
     */
    zoomStopHeight: 11,
	
	/** 
     * Property: slider
     */
    slider: null,
	
	/** 
     * Property: sliderEvents
     * {<Geo.Events>}
     */
    sliderEvents: null,
	
	/** 
     * Property: zoombarDiv
     * {DOMElement}
     */
    zoomBarDiv: null,
	
	/** 
     * Property: divEvents
     * {<Geo.Events>}
     */
    divEvents: null,
	
	/** 
     * APIProperty: zoomWorldIcon
     * {Boolean} 是否显示在导航栏上显示一个定位至全球范围的图标。默认为false。
     */
    zoomWorldIcon: false,
	
	/** 
     * Property: leftTip
     * {Array(DOMElement)} 
     */
    leftTip: [],
	
	/** 
     * Property: leftTooltips
     * {String} 
     */
    leftTooltips: null,
	
	/** 
     * APIProperty: imageLocation
     * {String} 表示显示地图导航杆的页面与引用资源文件（panzoombar_blue）的相对路径。
     * 例如：引用资源文件（panzoombar_blue）在测试页面的上三级目录，设置为”../../../”，
     * 才能正确的访问资源文件。
     * 
	 * (code)
	 * 
	 * var panZoomBarTitle = new Geo.View2D.Control.PanZoomBarTitle({
	 *     imageLocation: "../../../"
	 * });
	 * 
	 * (end)
     */
    imageLocation: "",

    /**
     * Constructor: Geo.View2D.Control.PanZoomBarTitle
     * 构造一个新的<Geo.View2D.Control.PanZoomBarTitle>对象实例。
     */ 
    initialize: function(options){
        OpenLayers.Control.PanZoom.prototype.initialize.apply(this, arguments);
    },
	
    /**
     * APIMethod: destroy
     * 销毁本对象。
     */
    destroy: function() {
        this._removeZoomBar();
        this.map.events.un({
            "changebaselayer": this.redraw,
            scope: this
        });
        OpenLayers.Control.PanZoom.prototype.destroy.apply(this, arguments);
    },
	
    /**
     * Method: setMap
     * 
     * Parameters:
     * map - {<Geo.View2D.Map>} 
     */
    setMap: function(map){
        OpenLayers.Control.PanZoom.prototype.setMap.apply(this, arguments);
        this.map.events.register("changebaselayer", this, this.redraw);
    },
	
    /** 
     * Method: redraw
     * clear the div and start over.
     */
    redraw: function(){
        if (this.div != null) {
            this.removeButtons();
            this._removeZoomBar();
        }
        this.draw();
    },
	
    /**
    * Method: draw 
    *
    * Parameters:
    * px - {<Geo.Pixel>} 
    */
    draw: function(px){
        // initialize our internal div
        OpenLayers.Control.prototype.draw.apply(this, arguments);
        px = this.position.clone();
        
        // place the controls
        this.buttons = [];
        this.leftTip = [];
        var sz = new OpenLayers.Size(24, 24);
        var centered = new OpenLayers.Pixel(px.x + sz.w / 2, px.y);
        var wposition = sz.w;
        
        if (this.zoomWorldIcon) {
            centered = new OpenLayers.Pixel(px.x + sz.w, px.y);
        }
        
        this._addButton("panup", "panzoombar_blue/north-mini.png", centered, sz, "向上平移");
        px.y = centered.y + sz.h;
        this._addButton("panleft", "panzoombar_blue/west-mini.png", px, sz, "向左平移");
        if (this.zoomWorldIcon) {
            this._addButton("zoomworld", "panzoombar_blue/zoom-world-mini.png", px.add(sz.w, 0), sz, "全部地图");
            
            wposition *= 2;
        }
        this._addButton("panright", "panzoombar_blue/east-mini.png", px.add(wposition, 0), sz, "向右平移");
        this._addButton("pandown", "panzoombar_blue/south-mini.png", centered.add(0, sz.h * 2), sz, "向下平移");
        this._addButton("zoomin", "panzoombar_blue/zoom-plus-mini.png", centered.add(0, sz.h * 3 + 5), sz, "放大一级");
        centered = this._addZoomBar(centered.add(3, sz.h * 4 + 5));
        this._addButton("zoomout", "panzoombar_blue/zoom-minus-mini.png", centered.add(-3, 0), sz, "缩小一级");
        //添加 zoomToolTip
        var tooltipSZ = new OpenLayers.Size(62, 12);
        this._addZoomToolTip("zoomtooltip", "panzoombar_blue/zoom_0.png", centered.add(20, 0), tooltipSZ);
        
        //x :图片的宽度
        
        this.leftTooltips = {
            zltGlb: {
                url: "panzoombar_blue/zoom_Global.png",
                x: 33,
                res: 0.3515625
            },
            zltContinent: {
                url: "panzoombar_blue/zoom_Continent.png",
                x: 23,
                res: 0.087890625
            },
            zltCountry: {
                url: "panzoombar_blue/zoom_Country.png",
                x: 23,
                res: 0.02197265625
            },
            zltPro: {
                url: "panzoombar_blue/zoom_Province.png",
                x: 23,
                res: 0.0054931640625
            },
            zltCity: {
                url: "panzoombar_blue/zoom_City.png",
                x: 23,
                res: 0.0006866455078125
            },
            zltStr: {
                url: "panzoombar_blue/zoom_Street.png",
                x: 23,
                res: 0.00002145767211914062
            }
        };
        for (var myitem in this.leftTooltips) {
            var leftTooltipObj = this.leftTooltips[myitem];
            this._addZoomLeftTip(myitem, leftTooltipObj.url, centered.add(-leftTooltipObj.x, 0), new OpenLayers.Size(leftTooltipObj.x, 17), leftTooltipObj.res);
        }
        //centred, slider位置(x,y)
        return this.div;
    },
	
	/**
     * Method: _addButton
     * 
     * Parameters:
     * id - {String} 
     * img - {String} 
     * xy - {<Geo.Pixel>} 
     * sz - {<Geo.Size>} 
     * 
     * Returns:
     * {DOMElement} A Div (an alphaImageDiv, to be precise) that contains the
     *     image of the button, and has all the proper event handlers set.
     */
    _addButton:function(id, img, xy, sz) {
        var btn = OpenLayers.Util.createAlphaImageDiv(
                                    this.id + "_" + id, 
                                    xy, sz, this.imageLocation + img, "absolute");

        //we want to add the outer div
        this.div.appendChild(btn);

        OpenLayers.Event.observe(btn, "mousedown", 
            OpenLayers.Function.bindAsEventListener(this.buttonDown, btn));
        OpenLayers.Event.observe(btn, "dblclick", 
            OpenLayers.Function.bindAsEventListener(this.doubleClick, btn));
        OpenLayers.Event.observe(btn, "click", 
            OpenLayers.Function.bindAsEventListener(this.doubleClick, btn));
        btn.action = id;
        btn.map = this.map;
    
        if(!this.slideRatio){
            var slideFactorPixels = this.slideFactor;
            var getSlideFactor = function() {
                return slideFactorPixels;
            };
        } else {
            var slideRatio = this.slideRatio;
            var getSlideFactor = function(dim) {
                return this.map.getSize()[dim] * slideRatio;
            };
        }

        btn.getSlideFactor = getSlideFactor;

        //we want to remember/reference the outer div
        this.buttons.push(btn);
        return btn;
    },
	
	/**
     * Method: _addZoomToolTip
     * 添加 zoomToolTip。
     * 
     * Parameters:
     * id - {String} 
     * img - {String} 
     * xy - {<Geo.Pixel>} 
     * sz - {<Geo.Size>} 
     * 
     * Returns:
     * {DOMElement} A Div (an alphaImageDiv, to be precise) that contains the
     *     image of the button, and has all the proper event handlers set.
     */
    _addZoomToolTip: function(id, img, xy, sz){
        var tooltip = OpenLayers.Util.createAlphaImageDiv("OpenLayers_Control_PanZoom_" + id, xy, sz, this.imageLocation + img, "absolute");
        //初始化不显示
        OpenLayers.Control.PanZoomBarTitle.isVisible = false;
        this.tooltip = tooltip;
        this.tooltip.style.display = "none";
        this.div.appendChild(tooltip);
        return tooltip;
    },
	
	/**
     * Method: _addZoomToolTip
     * 添加 _addZoomLeftTip。
     * 
     * Parameters:
     * id - {String} 
     * img - {String} 
     * xy - {<Geo.Pixel>} 
     * sz - {<Geo.Size>} 
     * res - {Float} 地图分辨率（单位：度 /像素）。
     * 
     * Returns:
     * {DOMElement} A Div (an alphaImageDiv, to be precise) that contains the
     *     image of the button, and has all the proper event handlers set.
     */
    _addZoomLeftTip: function(id, img, xy, sz, res){
        if (res <= this.map.baseLayer.maxResolution && res >= this.map.baseLayer.minResolution) {
            var tooltipLeft = OpenLayers.Util.createAlphaImageDiv("OpenLayers_Control_PanZoom_" + id, xy, sz, this.imageLocation + img, "absolute");
            this.tipEvents = new OpenLayers.Events(this, tooltipLeft, null, true, {
                includeXY: true
            });
            
            var mapMaxZoom = this.getCurrentZoomNumFromResolution(this.map.baseLayer.maxResolution, this.map.baseLayer.minResolution);
            var zoom = this.map.getZoomForResolution(res);
            var tipTop = (mapMaxZoom - zoom) * this.zoomStopHeight + this.startTop;
            this.tipEvents.on({
                "click": this.tipClick,
                "mouseover": this.slideMouseOver,
                "mouseout": this.mouseOut
            });
            
            this.leftTip.push(tooltipLeft);
            this.tooltipLeft = tooltipLeft;
            tooltipLeft.res = res;
            tooltipLeft.style.top = (tipTop - 3) + "px";
            tooltipLeft.style.display = "none";
            tooltipLeft.style.cursor = "hand";
            
            this.div.appendChild(tooltipLeft);
            return tooltipLeft;
        }
        else {
            return;
        }
    },
	
	/**
	 * Method: tipClick
	 * 
     * Parameters:
	 * evt - {Object} 
	 */
    tipClick: function(evt){
        var srcElement = evt.srcElement ? evt.srcElement : evt.target;
        var leftTipName = srcElement.id.split("_")[3];
        var res = this.leftTooltips[leftTipName]["res"];
        var zoom = this.map.getZoomForResolution(res);
        if (res == 0.3515625) {
            this.map.setCenter(new OpenLayers.LonLat(104.293175, 0), zoom);
        }
        else {
            this.map.zoomTo(zoom);
        }
        OpenLayers.Event.stop(evt);
    },
	
	/** 
	 * Method: _addZoomBar
     * 
     * Parameters:
     * location - {<Geo.Pixel>} where zoombar drawing is to start.
     */
    _addZoomBar: function(centered){
        
        
        var id = this.id + "_" + this.map.id;
        var zoomsToEnd = this.map.getNumZoomLevels() - 1 - this.map.getZoom();
        var slider = OpenLayers.Util.createAlphaImageDiv(id, centered.add(-1, zoomsToEnd * this.zoomStopHeight), new OpenLayers.Size(20, 9), this.imageLocation + "panzoombar_blue/slider.png", "absolute");
        this.slider = slider;
        
        this.sliderEvents = new OpenLayers.Events(this, slider, null, true, {
            includeXY: true
        });
        this.sliderEvents.on({
            "mousedown": this.zoomBarDown,
            "mousemove": this.zoomBarDrag,
            "mouseup": this.zoomBarUp,
            "dblclick": this.doubleClick,
            "click": this.doubleClick,
            "mouseover": this.slideMouseOver,
            "mouseout": this.mouseOut
        });
        
        var sz = new OpenLayers.Size();
        sz.h = this.zoomStopHeight * this.map.getNumZoomLevels();//zoombar 的高度
        sz.w = this.zoomStopWidth;
        var div = null;
        
        if (OpenLayers.Util.alphaHack()) {
            var id = this.id + "_" + this.map.id;
            div = OpenLayers.Util.createAlphaImageDiv(id, centered, new OpenLayers.Size(sz.w, this.zoomStopHeight), this.imageLocation + "panzoombar_blue/zoombar.png", "absolute", null, "crop");
            div.style.height = sz.h + "px";
        }
        else {
            div = OpenLayers.Util.createDiv('OpenLayers_Control_PanZoomBar_Zoombar' + this.map.id, centered, sz, this.imageLocation + "panzoombar_blue/zoombar.png");
        }
        
        this.zoombarDiv = div;
        
        this.divEvents = new OpenLayers.Events(this, div, null, true, {
            includeXY: true
        });
        this.divEvents.on({
            "mousedown": this.divClick,
            "mousemove": this.passEventToSlider,
            "dblclick": this.doubleClick,
            "click": this.doubleClick,
            "mouseout": this.mouseOut
        });
        
        this.div.appendChild(div);
        
        this.startTop = parseInt(div.style.top);
        this.div.appendChild(slider);
        
        this.map.events.register("zoomend", this, this.moveZoomBar);
        
        centered = centered.add(0, this.zoomStopHeight * this.map.getNumZoomLevels());
        return centered;
    },
	
	/**
	 * Method: _removeZoomBar
	 */
    _removeZoomBar: function(){
        this.sliderEvents.un({
            "mousedown": this.zoomBarDown,
            "mousemove": this.zoomBarDrag,
            "mouseup": this.zoomBarUp,
            "dblclick": this.doubleClick,
            "click": this.doubleClick,
            "mouseover": this.slideMouseOver,
            "mouseout": this.mouseOut
        });
        this.sliderEvents.destroy();
        this.divEvents.un({
            "mousedown": this.divClick,
            "mousemove": this.passEventToSlider,
            "dblclick": this.doubleClick,
            "click": this.doubleClick,
            "mouseout": this.mouseOut
        });
        this.divEvents.destroy();
        for (var i = 0; i < this.leftTip.length; i++) {
        
            this.div.removeChild(this.leftTip[i]);
        }
        this.tooltipLeft = null;
        
        this.div.removeChild(this.zoombarDiv);
        this.zoombarDiv = null;
        this.div.removeChild(this.slider);
        this.slider = null;
        this.map.events.unregister("zoomend", this, this.moveZoomBar);
    },
	
	/**
	 * Method: slideMouseOver
	 * 
     * Parameters:
	 * evt - {Object} 
	 */
    slideMouseOver: function(evt){
        OpenLayers.Control.PanZoomBarTitle.isVisible = true;
        this.tooltip.style.display = "";
        for (var i = 0; i < this.leftTip.length; i++) {
            this.leftTip[i].style.display = "";
        }
        var fixZoom = this.getCurrentZoomNum();
        var fixTop = ((this.map.getNumZoomLevels() - 1) - this.map.getZoom()) *
        this.zoomStopHeight +
        this.startTop +
        1;
        
        
        var toolTipTop = fixTop;
        this.tooltip.style.top = (toolTipTop - 3) + "px";
        
        var img = this.tooltip.childNodes[0];
        img.src = this.imageLocation + "panzoombar_blue/zoom_" + (parseInt(fixZoom) + 0) + ".png";
    },
	
	/**
	 * Method: passEventToSlider
	 * 鼠标移动响应。
	 * 
     * Parameters:
	 * evt - {Object} 
	 */
    passEventToSlider: function(evt){
		OpenLayers.Control.PanZoomBarTitle.isVisible = true;
		this.tooltip.style.display = "";
		for (var i = 0; i < this.leftTip.length; i++) {
		  this.leftTip[i].style.display = "";
		}
		var newTop = ((this.map.getNumZoomLevels() - 1) - this.map.getZoom()) *
		this.zoomStopHeight +
		this.startTop +
		1;
		
		var overZoom = this.getFixZoom(evt.xy.y) - 10;
		if (overZoom == -1) {
		  overZoom = 0;
		}
		
		//计算当前分辨率相对金字塔级别
		var topTileSize = this.map.pyramid.getTopTileSize();
		var pyramidMaxResolution = (topTileSize.w / this.map.pyramid.tileSize.w) /
		Math.pow(2, this.map.pyramid.topLevelIndex);
		var currentResolution = this.map.getResolutionForZoom(overZoom);
		var fixZoom = this.getCurrentZoomNumFromResolution(pyramidMaxResolution, currentResolution);
		
		var fixTop = ((this.map.getNumZoomLevels() - 1) - overZoom) *
		this.zoomStopHeight +
		this.startTop +
		1;
		
		
		var toolTipTop = fixTop;
		this.tooltip.style.top = (toolTipTop - 3) + "px";
		
		var img = this.tooltip.childNodes[0];
		img.src = this.imageLocation + "panzoombar_blue/zoom_" + (parseInt(fixZoom) + 0) + ".png";
		
		this.sliderEvents.handleBrowserEvent(evt);
    },
    
	/**
	 * Method: getDataExtent
	 * 计算当前分辨率相对于金字塔的级别数
	 */
    getCurrentZoomNum: function(){
        var topTileSize = this.map.pyramid.getTopTileSize();
        var pyramidMaxResolution = (topTileSize.w / this.map.pyramid.tileSize.w) /
        Math.pow(2, this.map.pyramid.topLevelIndex);
        
        var fixZoom = this.getCurrentZoomNumFromResolution(pyramidMaxResolution, this.map.getResolution());
        return fixZoom;
    },
	
    /**
     * Method: getCurrentZoomNumFromResolution
     * 从给定金字塔最大分辨率和地图当前分辨率计算当前级别数
     * 
     * Parameters:
	 * maxRes - {Float} 地图分辨率（单位：度 /像素）
	 * currentRes - {Float} 地图分辨率（单位：度 /像素）
     */
	getCurrentZoomNumFromResolution: function(maxRes,currentRes){
	
		//原计算方法直接取地图当前级别：parseInt(this.map.getZoom());
		//现在的方法计算当前分辨率相对于金字塔最大分辨率的级别
        var zoomRatio =  maxRes / currentRes;
        
        //如果当前分辨率比金字塔最大分辨率还大，说明出错
        if(zoomRatio < 1) return 0;
        
        var zoom = 0;
        while( (zoomRatio / 2) >= 1 ){
        	zoom++;
        	zoomRatio = zoomRatio/2;
        };
        return zoom ;
	},
	
    /**
     * Method: getFixZoom
     * 
     * 
     * Parameters:
	 * height - {Number} 
     */
    getFixZoom: function(height) {
    	var currentZoom = this.map.getZoom();
		var newTop = 
        	((this.map.getNumZoomLevels()-1) - currentZoom) * 
        	this.zoomStopHeight + this.startTop + 6;
        while(true) {
        	var tmp = height - newTop;
        	if(tmp>=0) {
        		if(tmp<this.zoomStopHeight/2) {
        			break;
        		}
        		currentZoom--;
        		newTop = newTop + this.zoomStopHeight;
        	} else {
        		if(tmp>=-this.zoomStopHeight/2) {
        			break;
        		}
        		currentZoom++;
        		newTop = newTop - this.zoomStopHeight;
        	}
        }
        return currentZoom;
    },
	
    /**
     * Method: mouseOut
     * 
     * Parameters:
	 * evt - {Object} 
     */
    mouseOut: function(evt) {
    	var tooltip = this.tooltip;
    	OpenLayers.Control.PanZoomBarTitle.isVisible = false;
    	var callfn = OpenLayers.Function.bind(function() {
			if(!OpenLayers.Control.PanZoomBarTitle.isVisible) {
				tooltip.style.display = "none";
				for(var i=0;i<this.leftTip.length;i++){
		    		this.leftTip[i].style.display = "none";
		    	}
			}
    	},this);
    	
    	window.setTimeout(callfn,1000);
    	OpenLayers.Event.stop(evt);
    },
	
    /**
     * Method: divClick
     * 
     * Parameters:
	 * evt - {Object} 
     */
    divClick: function (evt) {
        if (!OpenLayers.Event.isLeftClick(evt)) {
            return;
        }
        var y = evt.xy.y;
        var top = OpenLayers.Util.pagePosition(evt.object)[1];
        var levels = (y - top)/this.zoomStopHeight;
        if(!this.map.fractionalZoom) {
            levels = Math.floor(levels);
        }
        var zoom = (this.map.getNumZoomLevels() - 1) - levels;
        zoom = Math.min(Math.max(zoom, 0), this.map.getNumZoomLevels() - 1);
        this.map.zoomTo(zoom);
        
        OpenLayers.Event.stop(evt);
    },
	
    /**
     * Method: zoomBarDown
     * 
     * Parameters:
	 * evt - {Object} 
     */
    zoomBarDown:function(evt) {
        if (!OpenLayers.Event.isLeftClick(evt)) {
            return;
        }
        this.map.events.on({
            "mousemove": this.passEventToSlider,
            "mouseup": this.passEventToSlider,
            scope: this
        });
        this.mouseDragStart = evt.xy.clone();
        this.zoomStart = evt.xy.clone();
        this.div.style.cursor = "move";
        this.zoombarDiv.offsets = null;
        OpenLayers.Event.stop(evt);
    },
	
    /**
     * Method: zoomBarDrag
     * 
     * Parameters:
	 * evt - {Object} 
     */
    zoomBarDrag:function(evt) {
        if (this.mouseDragStart != null) {
            var deltaY = this.mouseDragStart.y - evt.xy.y;
            var offsets = OpenLayers.Util.pagePosition(this.zoombarDiv);
            if ((evt.clientY - offsets[1]) > 0 &&
                (evt.clientY - offsets[1]) < parseInt(this.zoombarDiv.style.height) - 2) {
                var newTop = parseInt(this.slider.style.top) - deltaY;
                this.slider.style.top = newTop+"px";
                this.mouseDragStart = evt.xy.clone();
            }
            OpenLayers.Event.stop(evt);
        }
    },
	
    /**
     * Method: zoomBarUp
     * 
     * Parameters:
	 * evt - {Object} 
     */
    zoomBarUp:function(evt) {
        if (!OpenLayers.Event.isLeftClick(evt)) {
            return;
        }
        if (this.zoomStart) {
            this.div.style.cursor="";
            this.map.events.un({
                "mouseup": this.passEventToSlider,
                "mousemove": this.passEventToSlider,
                scope: this
            });
            var deltaY = this.zoomStart.y - evt.xy.y;
            var zoomLevel = this.map.zoom;
            if (this.map.fractionalZoom) {
                zoomLevel += deltaY/this.zoomStopHeight;
                zoomLevel = Math.min(Math.max(zoomLevel, 0),
                                     this.map.getNumZoomLevels() - 1);
            } else {
                zoomLevel += Math.round(deltaY/this.zoomStopHeight);
            }
            this.map.zoomTo(zoomLevel);
            this.moveZoomBar();
            this.mouseDragStart = null;
            OpenLayers.Event.stop(evt);
        }
    },
	
    /**
     * Method: moveZoomBar
     * 
     */
    moveZoomBar: function(){
        OpenLayers.Control.PanZoomBarTitle.isVisible = false;
        this.tooltip.style.display = "";
        //获取当前级别相对于金字塔级别
        var inPyramidZoom = this.getCurrentZoomNum();
        
        var newTop = ((this.map.getNumZoomLevels() - 1) - this.map.getZoom()) *
        this.zoomStopHeight +
        this.startTop +
        1;
        
        this.tooltip.style.top = (newTop - 3) + "px";
        var img = this.tooltip.childNodes[0];
        
        img.src = this.imageLocation + "panzoombar_blue/zoom_" + (parseInt(inPyramidZoom) + 0) + ".png";
        
        this.slider.style.top = newTop + "px";
        
        var tooltip = this.tooltip;
        var callfn = OpenLayers.Function.bind(function(){
            if (!OpenLayers.Control.PanZoomBarTitle.isVisible) {
                tooltip.style.display = "none";
                for (var i = 0; i < this.leftTip.length; i++) {
                    this.leftTip[i].style.display = "none";
                }
            }
        }, this);
        
        window.setTimeout(callfn, 1000);
    },
	
    CLASS_NAME: "Geo.View2D.Control.PanZoomBarTitle"
});/**
 * Class: Geo.View2D.Control.GeoOverviewMap
 * 鹰眼图类，继承自Geo.View2D.Control.OverviewMap类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control.OverviewMap>
 */
Geo.View2D.Control.GeoOverviewMap = Geo.Class(Geo.View2D.Control.OverviewMap,{
	
	/**
	 * Constructor: Geo.View2D.Control.GeoOverviewMap
	 * Geo.View2D.Control.GeoOverviewMap对象构造函数。
	 * 
	 * Parameters:
     * options - {Object} 相关选项设置
     * 
     * (code)
     * 	// 鹰眼控件
     *      var overviewMap = new Geo.View2D.Control.GeoOverviewMap({
     *          maximized: true,//true表示鹰眼图是展开的
     *          layers: [tileLayer] //设置鹰眼图层
     *      });
     * (end)
	 */
	initialize : function(options) {
		options = options || {};
		if(options.layers && options.layers.length > 0) {
			//将参数中的图层设置成覆盖层，isBaseLayer都强制设置为false
			for(var i = 0,len = options.layers.length; i < len; i++) {
				if(options.layers[i] instanceof Geo.View2D.Layer.Vector) {
					//禁止添加矢量图层，如果是矢量图层，则进入下一次循环
					continue;
				}
				//添加的图层不能受外部操作的影响，需要克隆
				options.layers[i] = options.layers[i].clone();
				options.layers[i].isBaseLayer = false;
			}
			//添加基础图层
			/*
			 * 在创建鹰眼图的时候必须要有个基础图层。本来可以利用主地图的基础图层的，但是当用户使用自定义的图层后，主地图中的基础图层就被这个参数layers
			 * 给覆盖了
			 */
			var baseLayer = new Geo.View2D.Layer("GeoGlobeBaseLayer", {
	            displayInLayerSwitcher: false,
	            isBaseLayer: true
	        });
			options.layers.push(baseLayer);
		}
		
		Geo.View2D.Control.OverviewMap.prototype.initialize.apply(this, [options]);
	},
	
	/**
	 * Method: draw
	 * 该方法由API类自动调用。
	 */
    draw: function(){
       var div = Geo.View2D.Control.OverviewMap.prototype.draw.apply(this, arguments);
	   return div;
    },
    
	/**
	 * Method: createMap
	 * 该方法由API类自动调用。
	 */
    createMap: function(){
        Geo.View2D.Control.OverviewMap.prototype.createMap.apply(this,arguments);
		//如果图层长度为1则表示用户没有设置layers参数。
		if(this.layers.length == 1) {
			if(this.map && this.map.layerGroup) {
				this._loadLayers(this.map);
			}
			//监听图层组加载事件
			this.map.events.on({
	        "loadlayergroup":function(mainMap){
				this._unloadLayers(mainMap.map);
				this._loadLayers(mainMap.map);
			},
	        scope: this
	    	});
		}else if(this.layers.length > 1) {//如果图层长度大于1则表示用户自己添加图层参数
			//同步鹰眼图中的基础图层
			this._updateBaseLayer(this.map);
		}
		
		
    },
	
	//加载图层组
    _loadLayers : function(mainMap) {
		this.layers = [];
        var maplayers = mainMap.layerGroup.layers;
        for(var i=0; i<maplayers.length; i++){
			if(maplayers[i] instanceof Geo.View2D.Layer.Vector) {
				continue;
			}
			var layer = maplayers[i].clone();
			this.layers.push(layer);
        }
		this.ovmap.addLayers(this.layers);
		//同步鹰眼图中的基础图层
		this._updateBaseLayer(mainMap);

	},
	
	//更新基础图层
	_updateBaseLayer: function(mainMap) {
		var ovmap = this.ovmap;
		//同步鹰眼图中的基础图层
		if(mainMap.baseLayer) {
			var baseLayer = mainMap.baseLayer.clone();
			for(var i = 0,len = this.layers.length; i < len; i++) {
				if(this.layers[i].baseLayer) {
					OpenLayers.Util.removeItem(this.layers,this.layers[i]);
				}
			}
			this.layers.push(baseLayer);
			if (ovmap.baseLayer) {
           		ovmap.removeLayer(ovmap.baseLayer);
        	}
			ovmap.addLayer(baseLayer);
		}
	},
	
	//卸载图层组
    _unloadLayers: function(mainMap){
		var ovmap = this.ovmap;
		var layers = ovmap.layers;
		var layersTemp = [];
	    for(var i=0,len = layers.length; i < len; i++){
			if(!layers[i].isBaseLayer) {
				layersTemp.push(layers[i]);
			}
	    }
		for(var i=0,len = layersTemp.length; i < len; i++) {
			ovmap.removeLayer(layersTemp[i]);
		}
    },
	
	/**
	 * Method: destroy
	 * 该方法由API类自动调用。
	 */
	destroy : function() {
		this.map.events.un({
	        "loadlayergroup" : this.loadLayerGroup,
	        scope: this
    	});
		Geo.View2D.Control.OverviewMap.prototype.destroy.apply(this,arguments);
	}
});/**
 * Class: Geo.View2D.Control.GeoPanZoom
 * 迷你地图导航控件类，该类的实例是一个可定义的迷你地图导航控件类，默认画在地图的左上角。
 *
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.GeoPanZoom = Geo.Class(Geo.View2D.Control, {

    /** 
     * APIProperty: slideFactor
     * {Integer} 点击地图上任意方向上的箭头按钮后地图平移的像素数。
     * 如果你想通过地图尺寸的比率平移，请使用slideRatio代替。
     */
    slideFactor: 50,

    /** 
     * APIProperty: slideRatio
     * {Number} 地图宽与高的比值，是我们通过点击箭头按钮来平移地图的数量。默认为null。
     * 如果设置将会覆盖<slideFactor>。例如如果slideRatio为5,那么向上平移将会平移地图高度的一半。
     */
    slideRatio: null,

    /** 
     * Property: buttons
     * {Array(DOMElement)} Array of Button Divs 
     */
    buttons: null,

    /** 
     * Property: position
     * {<Geo.Pixel>} 
     */
    position: null,
	
    /** 
     * APIProperty: zoomWorldIcon
     * {Boolean} 是否显示缩放至世界范围的按钮图标。
     * 
     */
    zoomWorldIcon: false,
	
    /**
     * Constructor: Geo.View2D.Control.GeoPanZoom
     * 
     * Parameters:
     * options - {Object}
     */
    initialize: function(options) {
        this.position = new OpenLayers.Pixel(Geo.View2D.Control.GeoPanZoom.X,
                                             Geo.View2D.Control.GeoPanZoom.Y);
        OpenLayers.Control.prototype.initialize.apply(this, arguments);
    },

    /**
     * APIMethod: destroy
     * 销毁本对象。
     */
    destroy: function() {
        this.removeButtons();
        this.buttons = null;
        this.position = null;
        OpenLayers.Control.prototype.destroy.apply(this, arguments);
    },

    /**
     * Method: draw
     *
     * Parameters:
     * px - {<Geo.Pixel>} 
     * 
     * Returns:
     * {DOMElement} A reference to the container div for the PanZoom control.
     */
    draw: function(px) {
        // initialize our internal div
        OpenLayers.Control.prototype.draw.apply(this, arguments);
        px = this.position;

        // place the controls
        this.buttons = [];

        var sz = new OpenLayers.Size(18,18);
        var centered = new OpenLayers.Pixel(px.x+sz.w/2, px.y);

        this._addButton("panup", "north-mini.png", centered, sz);
        px.y = centered.y+sz.h;
        this._addButton("panleft", "west-mini.png", px, sz);
        this._addButton("panright", "east-mini.png", px.add(sz.w, 0), sz);
        this._addButton("pandown", "south-mini.png", 
                        centered.add(0, sz.h*2), sz);
        this._addButton("zoomin", "zoom-plus-mini.png", 
                        centered.add(0, sz.h*3+5), sz);
						
		var num = 4;
		if(this.zoomWorldIcon){
            this._addButton("zoomworld", "zoom-world-mini.png", centered.add(0, sz.h * num++ + 5), sz);
		}
        this._addButton("zoomout", "zoom-minus-mini.png", centered.add(0, sz.h * num++ + 5), sz);
        return this.div;
    },
    
    /**
     * Method: _addButton
     * 
     * Parameters:
     * id - {String} 
     * img - {String} 
     * xy - {<Geo.Pixel>} 
     * sz - {<Geo.Size>} 
     * 
     * Returns:
     * {DOMElement} A Div (an alphaImageDiv, to be precise) that contains the
     *     image of the button, and has all the proper event handlers set.
     */
    _addButton:function(id, img, xy, sz) {
        var imgLocation = OpenLayers.Util.getImagesLocation() + img;
        var btn = OpenLayers.Util.createAlphaImageDiv(
                                    this.id + "_" + id, 
                                    xy, sz, imgLocation, "absolute");
        btn.style.cursor = "pointer";
        //we want to add the outer div
        this.div.appendChild(btn);

        OpenLayers.Event.observe(btn, "mousedown", 
            OpenLayers.Function.bindAsEventListener(this.buttonDown, btn));
        OpenLayers.Event.observe(btn, "dblclick", 
            OpenLayers.Function.bindAsEventListener(this.doubleClick, btn));
        OpenLayers.Event.observe(btn, "click", 
            OpenLayers.Function.bindAsEventListener(this.doubleClick, btn));
        btn.action = id;
        btn.map = this.map;
    
        if(!this.slideRatio){
            var slideFactorPixels = this.slideFactor;
            var getSlideFactor = function() {
                return slideFactorPixels;
            };
        } else {
            var slideRatio = this.slideRatio;
            var getSlideFactor = function(dim) {
                return this.map.getSize()[dim] * slideRatio;
            };
        }

        btn.getSlideFactor = getSlideFactor;

        //we want to remember/reference the outer div
        this.buttons.push(btn);
        return btn;
    },
    
    /**
     * Method: _removeButton
     * 
     * Parameters:
     * btn - {Object}
     */
    _removeButton: function(btn) {
        OpenLayers.Event.stopObservingElement(btn);
        btn.map = null;
        btn.getSlideFactor = null;
        this.div.removeChild(btn);
        OpenLayers.Util.removeItem(this.buttons, btn);
    },
    
    /**
     * Method: removeButtons
     */
    removeButtons: function() {
        for(var i=this.buttons.length-1; i>=0; --i) {
            this._removeButton(this.buttons[i]);
        }
    },
    
    /**
     * Method: doubleClick
     *
     * Parameters:
     * evt - {Event} 
     *
     * Returns:
     * {Boolean}
     */
    doubleClick: function (evt) {
        OpenLayers.Event.stop(evt);
        return false;
    },
    
    /**
     * Method: buttonDown
     *
     * Parameters:
     * evt - {Event} 
     */
    buttonDown: function (evt) {
        if (!OpenLayers.Event.isLeftClick(evt)) {
            return;
        }

        switch (this.action) {
            case "panup": 
                this.map.pan(0, -this.getSlideFactor("h"));
                break;
            case "pandown": 
                this.map.pan(0, this.getSlideFactor("h"));
                break;
            case "panleft": 
                this.map.pan(-this.getSlideFactor("w"), 0);
                break;
            case "panright": 
                this.map.pan(this.getSlideFactor("w"), 0);
                break;
            case "zoomin": 
                this.map.zoomIn(); 
                break;
            case "zoomout": 
                this.map.zoomOut(); 
                break;
            case "zoomworld": 
                this.map.zoomToMaxExtent(); 
                break;
        }

        OpenLayers.Event.stop(evt);
    },

    CLASS_NAME: "Geo.View2D.Control.GeoPanZoom"
});

/**
 * Constant: X
 * {Integer}
 */
Geo.View2D.Control.GeoPanZoom.X = 4;

/**
 * Constant: Y
 * {Integer}
 */
Geo.View2D.Control.GeoPanZoom.Y = 4;
/**
 * Class: Geo.View2D.Control.GeoSelectFeature
 * 选择要素控件，实现拉框，绘制多边形，点击或停留在指定的图层上选择矢量要素的功能。
 *
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
OpenLayers.Control.GeoSelectFeature = Geo.Class(Geo.View2D.Control, {

    /**
     * Constant: EVENT_TYPES
     * 事件类型。
     * 支持的事件类型:
     *  - *beforefeaturehighlighted* 
     *  要素在高亮以前触发。
     *  - *featurehighlighted* 
     *  要素高亮后触发。
     *  - *featureunhighlighted* 
     *  取消高亮时触发。
     */
    EVENT_TYPES: ["beforefeaturehighlighted", "featurehighlighted", "featureunhighlighted"],
    
    /**
     * Property: multipleKey
     * {String} An event modifier ('altKey' or 'shiftKey') that temporarily sets
     *     the <multiple> property to true.  Default is null.
     */
    multipleKey: null,
    
    /**
     * Property: toggleKey
     * {String} An event modifier ('altKey' or 'shiftKey') that temporarily sets
     *     the <toggle> property to true.  Default is null.
     */
    toggleKey: null,
    
    /**
     * APIProperty: multiple
     * {Boolean} 允许选择多个几何要素，默认为false。
     */
    multiple: false, 

    /**
     * APIProperty: clickout
     * {Boolean} 在任何要素以外点击的时候取消选择，默认为true。
     */
    clickout: true,

    /**
     * APIProperty: toggle
     * {Boolean} 点击取消选择一个选定的要素，默认值为false。
     */
    toggle: false,

    /**
     * APIProperty: hover
     * {Boolean} 在鼠标经过时选择，鼠标移除时取消选择。如果是true,将会忽视点击动作，仅监听鼠标经过动作。
     */
    hover: false,

    /**
     * APIProperty: highlightOnly
     * {Boolean} 如果设置为true,要素不会被选择仅仅会高亮。如果hover为false,本属性不会受影响。默认是false。
     */
    highlightOnly: false,
    
    /**
     * APIProperty: handlerSelection
     * {<Geo.View2D.Handler>} 控件动作监听类。允许通过拉框，鼠标绘制多边形或规则多边形来选择要素。
     */
    handlerSelection: null,
	
    /**
     * APIProperty: handlerOptions
     * {Object} 选取要素控件的动作监听对象需要设置的属性。
     */
    handlerSelOptions: null,
    
    /**
     * Property: onBeforeSelect 
     * {Function} Optional function to be called before a feature is selected.
     *     The function should expect to be called with a feature.
     */
    onBeforeSelect: function() {},
    
    /**
     * APIProperty: onSelect 
     * {Function} 当要素被选择后触发本函数。
     */
    onSelect: function() {},

    /**
     * APIProperty: onUnselect
     * {Function} 当要素被取消选择的时候触发本函数。
     */
    onUnselect: function() {},
    
    /**
     * Property: scope
     * {Object} The scope to use with the onBeforeSelect, onSelect, onUnselect
     *     callbacks. If null the scope will be this control.
     */
    scope: null,

    /**
     * APIProperty: geometryTypes
     * {Array(String)} 本数组用于存放需要被限制选择的几何对象名称。
     */
    geometryTypes: null,

    /**
     * Property: layer
     * {<Geo.View2D.Layer.Vector>} The vector layer with a common renderer
     * root for all layers this control is configured with (if an array of
     * layers was passed to the constructor), or the vector layer the control
     * was configured with (if a single layer was passed to the constructor).
     */
    layer: null,
    
    /**
     * Property: layers
     * {Array(<Geo.View2D.Layer.Vector>)} The layers this control will work on,
     * or null if the control was configured with a single layer
     */
    layers: null,
    
    /**
     * APIProperty: callbacks
     * {Object} 包含监听类型以及监听动作的对象。例如： {"onSelect": function(){}}
     */
    callbacks: null,
    
    /**
     * APIProperty: selectStyle 
     * {Object} 样式的json表示。
     */
    selectStyle: null,
    
    /**
     * Property: renderIntent
     * {String} key used to retrieve the select style from the layer's
     * style map.
     */
    renderIntent: "select",

    /**
     * Property: handlers
     * {Object} Object with references to multiple <Geo.View2D.Handler>
     *     instances.
     */
    handlers: null,

    /**
     * Constructor: Geo.View2D.Control.GeoSelectFeature
     * 构造一个新的<OpenLayers.Control.GeoSelectFeature>对象实例。
     *
     * Parameters:
     * layers - {<Geo.View2D.Layer.Vector>} 图层或图层数组。
     * options - {Object} 参数选项。
     */
    initialize: function(layers, options) {
        // concatenate events specific to this control with those from the base
        this.EVENT_TYPES =
            OpenLayers.Control.GeoSelectFeature.prototype.EVENT_TYPES.concat(
            OpenLayers.Control.prototype.EVENT_TYPES
        );
        OpenLayers.Control.prototype.initialize.apply(this, [options]);
        
        if(this.scope === null) {
            this.scope = this;
        }
        this.initLayer(layers);
        var callbacks = {
            click: this.clickFeature,
            clickout: this.clickoutFeature
        };
        if (this.hover) {
            callbacks.over = this.overFeature;
            callbacks.out = this.outFeature;
        }
             
        this.callbacks = OpenLayers.Util.extend(callbacks, this.callbacks);
        this.handlers = {
            feature: new OpenLayers.Handler.Feature(
                this, this.layer, this.callbacks,
                {geometryTypes: this.geometryTypes}
            )
        };

        if (this.handlerSelection) {
            this.handlerSelOptions = this.handlerSelOptions || {};
            
			// 拉框选取控件
            if (this.handlerSelection == OpenLayers.Handler.Box) {
                if (!this.handlerSelOptions.boxDivClassName) {
                    this.handlerSelOptions.boxDivClassName = "olHandlerBoxSelectFeature";
                }
				this.handlers.handlerSelection = new OpenLayers.Handler.Box(
	                this, {done: this.selectBox}, this.handlerSelOptions
	            ); 
            }
			
            // 多边形选取要素
            if (this.handlerSelection == OpenLayers.Handler.Polygon || this.handlerSelection == OpenLayers.Handler.RegularPolygon) {
                this.handlers.handlerSelection = new this.handlerSelection(this, {
                    done: this.selectPolygon
                }, this.handlerSelOptions);
            }
        }
    },

    /**
     * Method: initLayer
     * Assign the layer property. If layers is an array, we need to use
     *     a RootContainer.
     *
     * Parameters:
     * layers - {<Geo.View2D.Layer.Vector>}, or an array of vector layers.
     */
    initLayer: function(layers) {
        if(OpenLayers.Util.isArray(layers)) {
            this.layers = layers;
            this.layer = new OpenLayers.Layer.Vector.RootContainer(
                this.id + "_container", {
                    layers: layers
                }
            );
        } else {
            this.layer = layers;
        }
    },
    
    /**
     * Method: destroy
     */
    destroy: function() {
        if(this.active && this.layers) {
            this.map.removeLayer(this.layer);
        }
        OpenLayers.Control.prototype.destroy.apply(this, arguments);
        if(this.layers) {
            this.layer.destroy();
        }
    },

    /**
     * Method: activate
     * Activates the control.
     * 
     * Returns:
     * {Boolean} The control was effectively activated.
     */
    activate: function () {
        if (!this.active) {
            if(this.layers) {
                this.map.addLayer(this.layer);
            }
            this.handlers.feature.activate();
            if(this.handlerSelection && this.handlers.handlerSelection) {
                this.handlers.handlerSelection.activate();
            }
        }
        return OpenLayers.Control.prototype.activate.apply(
            this, arguments
        );
    },

    /**
     * Method: deactivate
     * Deactivates the control.
     * 
     * Returns:
     * {Boolean} The control was effectively deactivated.
     */
    deactivate: function () {
        if (this.active) {
            this.handlers.feature.deactivate();
            if(this.handlers.handlerSelection) {
                this.handlers.handlerSelection.deactivate();
            }
            if(this.layers) {
                this.map.removeLayer(this.layer);
            }
        }
        return OpenLayers.Control.prototype.deactivate.apply(
            this, arguments
        );
    },

    /**
     * Method: unselectAll
     * Unselect all selected features.  To unselect all except for a single
     *     feature, set the options.except property to the feature.
     *
     * Parameters:
     * options - {Object} Optional configuration object.
     */
    unselectAll: function(options) {
        // we'll want an option to supress notification here
        var layers = this.layers || [this.layer];
        var layer, feature;
        for(var l=0; l<layers.length; ++l) {
            layer = layers[l];
            for(var i=layer.selectedFeatures.length-1; i>=0; --i) {
                feature = layer.selectedFeatures[i];
                if(!options || options.except != feature) {
                    this.unselect(feature);
                }
            }
        }
    },

    /**
     * Method: clickFeature
     * Called on click in a feature
     * Only responds if this.hover is false.
     *
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 
     */
    clickFeature: function(feature) {
        if(!this.hover) {
            var selected = (OpenLayers.Util.indexOf(
                feature.layer.selectedFeatures, feature) > -1);
            if(selected) {
                if(this.toggleSelect()) {
                    this.unselect(feature);
                } else if(!this.multipleSelect()) {
                    this.unselectAll({except: feature});
                }
            } else {
                if(!this.multipleSelect()) {
                    this.unselectAll({except: feature});
                }
                this.select(feature);
            }
        }
    },

    /**
     * Method: multipleSelect
     * Allow for multiple selected features based on <multiple> property and
     *     <multipleKey> event modifier.
     *
     * Returns:
     * {Boolean} Allow for multiple selected features.
     */
    multipleSelect: function() {
        return this.multiple || (this.handlers.feature.evt &&
                                 this.handlers.feature.evt[this.multipleKey]);
    },
    
    /**
     * Method: toggleSelect
     * Event should toggle the selected state of a feature based on <toggle>
     *     property and <toggleKey> event modifier.
     *
     * Returns:
     * {Boolean} Toggle the selected state of a feature.
     */
    toggleSelect: function() {
        return this.toggle || (this.handlers.feature.evt &&
                               this.handlers.feature.evt[this.toggleKey]);
    },

    /**
     * Method: clickoutFeature
     * Called on click outside a previously clicked (selected) feature.
     * Only responds if this.hover is false.
     *
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 
     */
    clickoutFeature: function(feature) {
        if(!this.hover && this.clickout) {
            this.unselectAll();
        }
    },

    /**
     * Method: overFeature
     * Called on over a feature.
     * Only responds if this.hover is true.
     *
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 
     */
    overFeature: function(feature) {
        var layer = feature.layer;
        if(this.hover) {
            if(this.highlightOnly) {
                this.highlight(feature);
            } else if(OpenLayers.Util.indexOf(
                layer.selectedFeatures, feature) == -1) {
                this.select(feature);
            }
        }
    },

    /**
     * Method: outFeature
     * Called on out of a selected feature.
     * Only responds if this.hover is true.
     *
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 
     */
    outFeature: function(feature) {
        if(this.hover) {
            if(this.highlightOnly) {
                // we do nothing if we're not the last highlighter of the
                // feature
                if(feature._lastHighlighter == this.id) {
                    // if another select control had highlighted the feature before
                    // we did it ourself then we use that control to highlight the
                    // feature as it was before we highlighted it, else we just
                    // unhighlight it
                    if(feature._prevHighlighter &&
                       feature._prevHighlighter != this.id) {
                        delete feature._lastHighlighter;
                        var control = this.map.getControl(
                            feature._prevHighlighter);
                        if(control) {
                            control.highlight(feature);
                        }
                    } else {
                        this.unhighlight(feature);
                    }
                }
            } else {
                this.unselect(feature);
            }
        }
    },

    /**
     * Method: highlight
     * Redraw feature with the select style.
     *
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 
     */
    highlight: function(feature) {
        var layer = feature.layer;
        var cont = this.events.triggerEvent("beforefeaturehighlighted", {
            feature : feature
        });
        if(cont !== false) {
            feature._prevHighlighter = feature._lastHighlighter;
            feature._lastHighlighter = this.id;
            var style = this.selectStyle || this.renderIntent;
            layer.drawFeature(feature, style);
            this.events.triggerEvent("featurehighlighted", {feature : feature});
        }
    },

    /**
     * Method: unhighlight
     * Redraw feature with the "default" style
     *
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 
     */
    unhighlight: function(feature) {
        var layer = feature.layer;
        // three cases:
        // 1. there's no other highlighter, in that case _prev is undefined,
        //    and we just need to undef _last
        // 2. another control highlighted the feature after we did it, in
        //    that case _last references this other control, and we just
        //    need to undef _prev
        // 3. another control highlighted the feature before we did it, in
        //    that case _prev references this other control, and we need to
        //    set _last to _prev and undef _prev
        if(feature._prevHighlighter == undefined) {
            delete feature._lastHighlighter;
        } else if(feature._prevHighlighter == this.id) {
            delete feature._prevHighlighter;
        } else {
            feature._lastHighlighter = feature._prevHighlighter;
            delete feature._prevHighlighter;
        }
        layer.drawFeature(feature, feature.style || feature.layer.style ||
            "default");
        this.events.triggerEvent("featureunhighlighted", {feature : feature});
    },
    
    /**
     * Method: select
     * Add feature to the layer's selectedFeature array, render the feature as
     * selected, and call the onSelect function.
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 
     */
    select: function(feature) {
        var cont = this.onBeforeSelect.call(this.scope, feature);
        var layer = feature.layer;
        if(cont !== false) {
            cont = layer.events.triggerEvent("beforefeatureselected", {
                feature: feature
            });
            if(cont !== false) {
                layer.selectedFeatures.push(feature);
                this.highlight(feature);
                // if the feature handler isn't involved in the feature
                // selection (because the box handler is used or the
                // feature is selected programatically) we fake the
                // feature handler to allow unselecting on click
                if(!this.handlers.feature.lastFeature) {
                    this.handlers.feature.lastFeature = layer.selectedFeatures[0];
                }
                layer.events.triggerEvent("featureselected", {feature: feature});
                this.onSelect.call(this.scope, feature);
            }
        }
    },

    /**
     * Method: unselect
     * Remove feature from the layer's selectedFeature array, render the feature as
     * normal, and call the onUnselect function.
     *
     * Parameters:
     * feature - {<Geo.Feature.Vector>}
     */
    unselect: function(feature) {
        var layer = feature.layer;
        // Store feature style for restoration later
        this.unhighlight(feature);
        OpenLayers.Util.removeItem(layer.selectedFeatures, feature);
        layer.events.triggerEvent("featureunselected", {feature: feature});
        this.onUnselect.call(this.scope, feature);
    },
    
    /**
     * Method: selectBox
     * Callback from the handlers.box set up when <box> selection is true
     *     on.
     *
     * Parameters:
     * position - {<Geo.Bounds> || <Geo.Pixel> }  
     */
    selectBox: function(position) {
        if (position instanceof OpenLayers.Bounds) {
            var minXY = this.map.getLonLatFromPixel(
                new OpenLayers.Pixel(position.left, position.bottom)
            );
            var maxXY = this.map.getLonLatFromPixel(
                new OpenLayers.Pixel(position.right, position.top)
            );
            var bounds = new OpenLayers.Bounds(
                minXY.lon, minXY.lat, maxXY.lon, maxXY.lat
            );
            
            // if multiple is false, first deselect currently selected features
            if (!this.multipleSelect()) {
                this.unselectAll();
            }
            
            // because we're using a box, we consider we want multiple selection
            var prevMultiple = this.multiple;
            this.multiple = true;
            var layers = this.layers || [this.layer];
            var layer;
            for(var l=0; l<layers.length; ++l) {
                layer = layers[l];
                for(var i=0, len = layer.features.length; i<len; ++i) {
                    var feature = layer.features[i];
                    // check if the feature is displayed
                    if (!feature.getVisibility()) {
                        continue;
                    }

                    if (this.geometryTypes == null || OpenLayers.Util.indexOf(
                            this.geometryTypes, feature.geometry.CLASS_NAME) > -1) {
                        if (bounds.toGeometry().intersects(feature.geometry)) {
                            if (OpenLayers.Util.indexOf(layer.selectedFeatures, feature) == -1) {
                                this.select(feature);
                            }
                        }
                    }
                }
            }
            this.multiple = prevMultiple;
        }
    },

	/**
     * Method: selectPolygon
     * Callback from the handlers.handlerSelection set up when <polygon> selection has been setted.
     *
     * Parameters:
     * geometry - {<Geo.Geometry>}  
     */
    selectPolygon: function(geometry) {
		if (geometry instanceof OpenLayers.Geometry) {
			// if multiple is false, first deselect currently selected features
            if (!this.multipleSelect()) {
                this.unselectAll();
            }
            
            // because we're using a polygon, we consider we want multiple selection
            var prevMultiple = this.multiple;
            this.multiple = true;
			var layers = this.layers || [this.layer];
            var layer;
            for(var l=0; l<layers.length; ++l) {
                layer = layers[l];
                for(var i=0, len = layer.features.length; i<len; ++i) {
                    var feature = layer.features[i];
                    // check if the feature is displayed
                    if (!feature.getVisibility()) {
                        continue;
                    }

                    if (this.geometryTypes == null || OpenLayers.Util.indexOf(
                            this.geometryTypes, feature.geometry.CLASS_NAME) > -1) {
                        if (geometry.intersects(feature.geometry)) {
                            if (OpenLayers.Util.indexOf(layer.selectedFeatures, feature) == -1) {
                                this.select(feature);
                            }
                        }
                    }
                }
            }
			this.multiple = prevMultiple;
        }
	},
	
    /** 
     * Method: setMap
     * Set the map property for the control. 
     * 
     * Parameters:
     * map - {<Geo.View2D.Map>} 
     */
    setMap: function(map) {
        this.handlers.feature.setMap(map);
        if (this.handlerSelection) {
            this.handlers.handlerSelection.setMap(map);
        }
        OpenLayers.Control.prototype.setMap.apply(this, arguments);
    },
    
    /**
     * APIMethod: setLayer
     * 将一个新的图层添加到本控件上，这样会覆盖所有已经存在的图层。
     * 
     * Parameters:
     * layers - {<Geo.View2D.Layer.Vector>}数组 或单个{<Geo.View2D.Layer.Vector>}对象。
     */
    setLayer: function(layers) {
        var isActive = this.active;
        this.unselectAll();
        this.deactivate();
        if(this.layers) {
            this.layer.destroy();
            this.layers = null;
        }
        this.initLayer(layers);
        this.handlers.feature.layer = this.layer;
        if (isActive) {
            this.activate();
        }
    },
    
    CLASS_NAME: "Geo.View2D.Control.GeoSelectFeature"
});
/**
 * Class: Geo.View2D.Control.ZoomBar
 * 简单的缩放工具条。
 * 制作图片时，放大缩小工具zoomin zoomout的宽度和缩放条zoombar宽度一致。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control.PanZoom>
 */
Geo.View2D.Control.ZoomBar = Geo.Class(Geo.View2D.Control.PanZoom, {
    /** 
     * APIProperty: zoomStopWidth
     * 缩放条停止的宽度，默认为18。
     */
    //zoomStopWidth: 18,
	zoombarWidth: 18,

    /** 
     * APIProperty: zoomStopHeight
     * 缩放条刻度的高度，默认为14。
     */
    zoomStopHeight: 14,

    /** 
     * Property: slider
     * 定义滑动对象。
     */
    slider: null,

    /** 
     * Property: sliderEvents
     * {<OpenLayers.Events>}
     * 滑动事件。
     */
    sliderEvents: null,

    /** 
     * Property: zoombarDiv
     * {DOMElement} 缩放条DIV对象。
     */
    zoombarDiv: null,

    /** 
     * Property: divEvents
     * {<OpenLayers.Events>} div事件对象。
     */
    divEvents: null,

    /** 
     * APIProperty: zoomWorldIcon
     * {Boolean} 是否显示全图，默认为不显示false。
     */
    zoomWorldIcon: false,

    /**
     * APIProperty: panIcons
     * {Boolean} 设置属性为false不显示上下左右工具，设置为true显示，默认为false。
     */
    panIcons: false,

    /**
     * APIProperty: forceFixedZoomLevel
     * {Boolean} Force a fixed zoom level even though the map has 
     *     fractionalZoom
     */
    forceFixedZoomLevel: false,

    /**
     * Property: mouseDragStart
     * {<OpenLayers.Pixel>}
     */
    mouseDragStart: null,

    /**
     * Property: deltaY
     * {Number} The cumulative vertical pixel offset during a zoom bar drag.
     */
    deltaY: null,

    /**
     * Property: zoomStart
     * {<OpenLayers.Pixel>}
     */
    zoomStart: null,
    
    /**
     * Property: imgLocation
     * @type String 设置工具使用的图标位置,如："img/",默认为空，使用openlayers下面的图片。
     */
    imgLocation:"",
    
    /**
     * Property: zoomIcon
     * @type Boolean  设置这个属性true显示放大缩小工具,如果设置false不显示放大缩小工具，默认为false。
     */
    zoomIcon:false,
    
    /**
     * Property: defaultIcon
     * @type Boolean  设置这个属性true显示默认的缩放工具条,如果设置false显示自定义工具条，默认为true。
     */
    defaultIcon:true,
    
     /** 
     * APIProperty: zoomWidth
     * 放大缩小工具zoomin zoomout的宽度，默认为18。
     */
    zoomWidth: 18,
    
     /** 
     * APIProperty: zoomHeight
     * 放大缩小工具zoomin zoomout的高度，默认为18。
     */
    zoomHeight: 18,
    
    /** 
     * APIProperty: sliderWidth
     * 滑动条slider的宽度，默认为20。
     */
    sliderWidth:20,
    
    /** 
     * APIProperty: sliderHeight
     * 滑动条slider的高度，默认为9。
     */
    sliderHeight:9,
    
    /** 
     * APIProperty: zoombarWidth
     * 缩放条zoombar的宽度，默认为18。
     */
    zoombarWidth:18,
    
    /**
     * APIMethod: destroy
     * 销毁本对象。
     */
    destroy: function() {

        this._removeZoomBar();

        this.map.events.un({
            "changebaselayer": this.redraw,
            scope: this
        });

        OpenLayers.Control.PanZoom.prototype.destroy.apply(this, arguments);

        delete this.mouseDragStart;
        delete this.zoomStart;
    },
    
    /**
     * Method: setMap
     * 关联地图。
     * 
     * Parameters:
     * map - {<OpenLayers.Map>} 
     */
    setMap: function(map) {
        OpenLayers.Control.PanZoom.prototype.setMap.apply(this, arguments);
        this.map.events.register("changebaselayer", this, this.redraw);
    },

    /** 
     * Method: redraw
     * clear the div and start over.
     */
    redraw: function() {
        if (this.div != null) {
            this.removeButtons();
            this._removeZoomBar();
        }  
        this.draw();
    },
    
    /**
    * Method: draw
    * 绘制方法。
    *
    * Parameters:
    * px - {<OpenLayers.Pixel>} 
    */
    draw: function(px) {
        // initialize our internal div
        OpenLayers.Control.prototype.draw.apply(this, arguments);
        px = this.position.clone();

        // place the controls
        this.buttons = [];
        
        
        var sz = new OpenLayers.Size(this.zoomWidth,this.zoomHeight);
        
        /**
        if (this.panIcons) {
            var centered = new OpenLayers.Pixel(px.x+sz.w/2, px.y);
            var wposition = sz.w;

            if (this.zoomWorldIcon) {
                centered = new OpenLayers.Pixel(px.x+sz.w, px.y);
            }

            this._addButton("panup", "north-mini.png", centered, sz);
            px.y = centered.y+sz.h;
            this._addButton("panleft", "west-mini.png", px, sz);
            if (this.zoomWorldIcon) {
                this._addButton("zoomworld", "zoom-world-mini.png", px.add(sz.w, 0), sz);

                wposition *= 2;
            }
            this._addButton("panright", "east-mini.png", px.add(wposition, 0), sz);
            this._addButton("pandown", "south-mini.png", centered.add(0, sz.h*2), sz);
            this._addButton("zoomin", "zoom-plus-mini.png", centered.add(0, sz.h*3+5), sz);
            centered = this._addZoomBar(centered.add(0, sz.h*4 + 5));
            this._addButton("zoomout", "zoom-minus-mini.png", centered, sz);
        }
        else */
        if(this.zoomIcon){
        	/**
        	 var centered = new OpenLayers.Pixel(px.x + sz.w / 2, px.y);
        	  this._addButton("zoomin", "zoom-plus-mini.png", centered.add(0, sz.h * 3 + 5), sz, "放大一级");
		      centered = this._addZoomBar(centered.add(0, sz.h * 4 + 5));
		      this._addButton("zoomout", "zoom-minus-mini.png", centered.add(0, sz.h * 4 + 10), sz, "缩小一级");
        	*/
        	
        	/**
        	var centered = new OpenLayers.Pixel(px.x + sz.w / 2, px.y);
    	    this._addButton("zoomin", "zoom-plus-mini.png", centered.add(0, sz.h * 3 + 5), sz, "放大一级");
    	    centered = this._addZoomBar(centered.add(3, sz.h * 4 + 5));
   		    this._addButton("zoomout", "zoom-minus-mini.png", centered.add(-3, 0), sz, "缩小一级");
        	            */
        	
        	var centered = new OpenLayers.Pixel(px.x+sz.w/2, px.y);
            this._addButton("zoomin", "zoom-plus-mini.png", px, sz);
            
            centered = this._addZoomBar(px.add(0, sz.h));
            
            this._addButton("zoomout", "zoom-minus-mini.png", centered, sz);

//            if (this.zoomWorldIcon) {
//                centered = centered.add(0, sz.h+3);
//                this._addButton("zoomworld", "zoom-world-mini.png", centered, sz);
//            }
        } else {
            centered = this._addZoomBar(px.add(0, sz.h));
//            if (this.zoomWorldIcon) {
//                centered = centered.add(0, sz.h+3);
//                this._addButton("zoomworld", "zoom-world-mini.png", centered, sz);
//            }
        }
        return this.div;
    },
    
    /**
     * Method: _addButton
     * 
     * Parameters:
     * id - {String} 
     * img - {String} 
     * xy - {<OpenLayers.Pixel>} 
     * sz - {<OpenLayers.Size>} 
     * 
     * Returns:
     * {DOMElement} A Div (an alphaImageDiv, to be precise) that contains the
     *     image of the button, and has all the proper event handlers set.
     */
    _addButton:function(id, img, xy, sz) {
        var imgLocation = OpenLayers.Util.getImagesLocation() + img;
        if(this.defaultIcon){
        	var btn = OpenLayers.Util.createAlphaImageDiv(this.id + "_" + id, 
                                    xy, sz, imgLocation, "absolute");
        }else{
        	var className = id;
        	var btn = OpenLayers.Util.createAlphaImageDiv(this.id + "_" + id, 
                                    xy, sz, "", "absolute");
            btn.className = className;                        
        }
        btn.style.cursor = "pointer";
        //we want to add the outer div
        this.div.appendChild(btn);

        OpenLayers.Event.observe(btn, "mousedown", 
            OpenLayers.Function.bindAsEventListener(this.buttonDown, btn));
        OpenLayers.Event.observe(btn, "dblclick", 
            OpenLayers.Function.bindAsEventListener(this.doubleClick, btn));
        OpenLayers.Event.observe(btn, "click", 
            OpenLayers.Function.bindAsEventListener(this.doubleClick, btn));
        btn.action = id;
        btn.map = this.map;
    
        if(!this.slideRatio){
            var slideFactorPixels = this.slideFactor;
            var getSlideFactor = function() {
                return slideFactorPixels;
            };
        } else {
            var slideRatio = this.slideRatio;
            var getSlideFactor = function(dim) {
                return this.map.getSize()[dim] * slideRatio;
            };
        }

        btn.getSlideFactor = getSlideFactor;
		
        //we want to remember/reference the outer div
        this.buttons.push(btn);
        return btn;
    },
    /** 
    * Method: _addZoomBar
    * 
    * Parameters:
    * location - {<OpenLayers.Pixel>} where zoombar drawing is to start.
    */
    _addZoomBar:function(centered) {
    	var imgLocation = this.imgLocation;
        if(this.imgLocation == ""){
        	 imgLocation = OpenLayers.Util.getImagesLocation();
        }
        var id = this.id + "_" + this.map.id;
        var zoomsToEnd = this.map.getNumZoomLevels() - 1 - this.map.getZoom();
        if(this.defaultIcon){
        	var slider = OpenLayers.Util.createAlphaImageDiv(id,
                       centered.add(-1, zoomsToEnd * this.zoomStopHeight),
                       //centered.add(-1, zoomsToEnd * this.zoomStopHeight),
                       //centered.add(8, zoomsToEnd * this.zoomStopHeight),
                       new OpenLayers.Size(20,9),
                       //new OpenLayers.Size(18,18),
                       imgLocation+"slider.png",
                       "absolute");
        }else{
        	var slider = OpenLayers.Util.createAlphaImageDiv(id,
                       centered.add((this.zoomWidth - this.sliderWidth) / 2, zoomsToEnd * this.zoomStopHeight),
                       new OpenLayers.Size(this.sliderWidth,this.sliderHeight),
                       "",
                       "absolute");
            slider.className = "slider";
        }
        
        slider.style.cursor = "move";
        this.slider = slider;
        
        this.sliderEvents = new OpenLayers.Events(this, slider, null, true,
                                            {includeXY: true});
        this.sliderEvents.on({
            "touchstart": this.zoomBarDown,
            "touchmove": this.zoomBarDrag,
            "touchend": this.zoomBarUp,
            "mousedown": this.zoomBarDown,
            "mousemove": this.zoomBarDrag,
            "mouseup": this.zoomBarUp,
            "dblclick": this.doubleClick,
            "click": this.doubleClick
        });
        
        var sz = new OpenLayers.Size();
        sz.h = this.zoomStopHeight * this.map.getNumZoomLevels();
        //sz.w = this.zoomStopWidth;
        sz.w = this.zoombarWidth;
        var div = null;
        
        if (OpenLayers.Util.alphaHack()) {
            var id = this.id + "_" + this.map.id;
            div = OpenLayers.Util.createAlphaImageDiv(id, centered,
                                      new OpenLayers.Size(sz.w, 
                                              this.zoomStopHeight),
                                      imgLocation + "zoombar.png", 
                                      "absolute", null, "crop");
            div.style.height = sz.h + "px";
        } else {
        	if(this.defaultIcon){
        		 div = OpenLayers.Util.createDiv(
                        'OpenLayers_Control_PanZoomBar_Zoombar' + this.map.id,
                        centered,
                        sz,
                        imgLocation+"zoombar.png");
        	}else{
            	div = OpenLayers.Util.createDiv(
                        'OpenLayers_Control_PanZoomBar_Zoombar' + this.map.id,
                        centered,
                        sz
                       );
        		div.className = "zoombar";
        	}
        }
        div.style.cursor = "pointer";
        
        
        this.zoombarDiv = div;
        
        
        this.divEvents = new OpenLayers.Events(this, div, null, true, 
                                                {includeXY: true});
        this.divEvents.on({
            "touchmove": this.passEventToSlider,
            "mousedown": this.divClick,
            "mousemove": this.passEventToSlider,
            "dblclick": this.doubleClick,
            "click": this.doubleClick
        });
        
        this.div.appendChild(div);

        this.startTop = parseInt(div.style.top);
        this.div.appendChild(slider);
        
        this.div.onmouseover = this._onmouseover;
        this.div.onmouseout = this._onmouseout;

        this.map.events.register("zoomend", this, this.moveZoomBar);

        centered = centered.add(0,
        //centered = centered.add((this.zoomWidth-this.zoomStopWidth)/2,
            this.zoomStopHeight * this.map.getNumZoomLevels());
        return centered; 
    },
    
    //移在上面触发
    _onmouseover:function(){
    		for (var i = 0; i < this.childNodes.length; i ++) {
				var div = this.childNodes[i];
				if(div.className == "zoomin"){
					div.className="zoomin_";
				}
				if(div.className == "zoomout"){
					div.className="zoomout_";
				}
				if(div.className == "zoombar"){
					div.className="zoombar_";
				}
				if(div.className == "slider"){
					div.className="slider_";
				}
			}
    },
    //移出触发
    _onmouseout:function(){
    		for (var i = 0; i < this.childNodes.length; i ++) {
				var div = this.childNodes[i];
				
				if(div.className == "zoomin_"){
					
					div.className="zoomin";
				}
				if(div.className == "zoomout_"){
					div.className="zoomout";
				}
				if(div.className == "zoombar_"){
					div.className="zoombar";
				}
				if(div.className == "slider_"){
					div.className="slider";
				}
			}
    },
    
    /**
     * Method: _removeZoomBar
     */
    _removeZoomBar: function() {
        this.sliderEvents.un({
            "touchmove": this.zoomBarDrag,
            "mousedown": this.zoomBarDown,
            "mousemove": this.zoomBarDrag,
            "mouseup": this.zoomBarUp,
            "dblclick": this.doubleClick,
            "click": this.doubleClick
        });
        this.sliderEvents.destroy();

        this.divEvents.un({
            "touchmove": this.passEventToSlider,
            "mousedown": this.divClick,
            "mousemove": this.passEventToSlider,
            "dblclick": this.doubleClick,
            "click": this.doubleClick
        });
        this.divEvents.destroy();
        
        this.div.removeChild(this.zoombarDiv);
        this.zoombarDiv = null;
        this.div.removeChild(this.slider);
        this.slider = null;
        
        this.map.events.unregister("zoomend", this, this.moveZoomBar);
    },
    
    /**
     * Method: passEventToSlider
     * This function is used to pass events that happen on the div, or the map,
     * through to the slider, which then does its moving thing.
     *
     * Parameters:
     * evt - {<OpenLayers.Event>} 
     */
    passEventToSlider:function(evt) {
        this.sliderEvents.handleBrowserEvent(evt);
    },
    
    /**
     * Method: divClick
     * Picks up on clicks directly on the zoombar div
     *           and sets the zoom level appropriately.
     */
    divClick: function (evt) {
        if (!OpenLayers.Event.isLeftClick(evt)) {
            return;
        }
        var levels = evt.xy.y / this.zoomStopHeight;
        if(this.forceFixedZoomLevel || !this.map.fractionalZoom) {
            levels = Math.floor(levels);
        }    
        var zoom = (this.map.getNumZoomLevels() - 1) - levels; 
        zoom = Math.min(Math.max(zoom, 0), this.map.getNumZoomLevels() - 1);
        this.map.zoomTo(zoom);
        OpenLayers.Event.stop(evt);
    },
    
    /**
     * Method: zoomBarDown
     * event listener for clicks on the slider
     *
     * Parameters:
     * evt - {<OpenLayers.Event>} 
     */
    zoomBarDown:function(evt) {
        if (!OpenLayers.Event.isLeftClick(evt) && !OpenLayers.Event.isSingleTouch(evt)) {
            return;
        }
        this.map.events.on({
            "touchmove": this.passEventToSlider,
            "mousemove": this.passEventToSlider,
            "mouseup": this.passEventToSlider,
            scope: this
        });
        this.mouseDragStart = evt.xy.clone();
        this.zoomStart = evt.xy.clone();
        this.div.style.cursor = "move";
        // reset the div offsets just in case the div moved
        this.zoombarDiv.offsets = null; 
        OpenLayers.Event.stop(evt);
    },
    
    /**
     * Method: zoomBarDrag
     * This is what happens when a click has occurred, and the client is
     * dragging.  Here we must ensure that the slider doesn't go beyond the
     * bottom/top of the zoombar div, as well as moving the slider to its new
     * visual location
     *
     * Parameters:
     * evt - {<OpenLayers.Event>} 
     */
    zoomBarDrag:function(evt) {
        if (this.mouseDragStart != null) {
            var deltaY = this.mouseDragStart.y - evt.xy.y;
            var offsets = OpenLayers.Util.pagePosition(this.zoombarDiv);
            if ((evt.clientY - offsets[1]) > 0 && 
                (evt.clientY - offsets[1]) < parseInt(this.zoombarDiv.style.height) - 2) {
                var newTop = parseInt(this.slider.style.top) - deltaY;
                this.slider.style.top = newTop+"px";
                this.mouseDragStart = evt.xy.clone();
            }
            // set cumulative displacement
            this.deltaY = this.zoomStart.y - evt.xy.y;
            OpenLayers.Event.stop(evt);
        }
    },
    
    /**
     * Method: zoomBarUp
     * Perform cleanup when a mouseup event is received -- discover new zoom
     * level and switch to it.
     *
     * Parameters:
     * evt - {<OpenLayers.Event>} 
     */
    zoomBarUp:function(evt) {
        if (!OpenLayers.Event.isLeftClick(evt) && evt.type !== "touchend") {
            return;
        }
        if (this.mouseDragStart) {
            this.div.style.cursor="";
            this.map.events.un({
                "touchmove": this.passEventToSlider,
                "mouseup": this.passEventToSlider,
                "mousemove": this.passEventToSlider,
                scope: this
            });
            var zoomLevel = this.map.zoom;
            if (!this.forceFixedZoomLevel && this.map.fractionalZoom) {
                zoomLevel += this.deltaY/this.zoomStopHeight;
                zoomLevel = Math.min(Math.max(zoomLevel, 0), 
                                     this.map.getNumZoomLevels() - 1);
            } else {
                zoomLevel += this.deltaY/this.zoomStopHeight;
                zoomLevel = Math.max(Math.round(zoomLevel), 0);      
            }
            this.map.zoomTo(zoomLevel);
            this.mouseDragStart = null;
            this.zoomStart = null;
            this.deltaY = 0;
            OpenLayers.Event.stop(evt);
        }
    },
    
   /**
    * Method: moveZoomBar
    * Change the location of the slider to match the current zoom level.
    */
    moveZoomBar:function() {
        var newTop = 
            ((this.map.getNumZoomLevels()-1) - this.map.getZoom()) * 
            this.zoomStopHeight + this.startTop + 1;
        this.slider.style.top = newTop + "px";
    },    
    
    CLASS_NAME: "Geo.View2D.Control.ZoomBar"
});
/**
 * Class: Geo.View2D.Control.GeoNavigationHistory
 * 操作历史导航控件类。用户使用鼠标操作地图或者在地图上绘制要素，
 * 此控件能记录地图的平移和缩放操作、矢量要素，并将这些信息存放到本地浏览器的localStorage对象中。
 * 当用户关闭浏览器再次打开时读取这些信息，并通过控件的“前进”、“后退”按钮进行浏览查看。
 *
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.GeoNavigationHistory = Geo.Class(Geo.View2D.Control, {

    /**
     * Property: type
     * {String} Note that this control is not intended to be added directly
     *     to a control panel.  Instead, add the sub-controls previous and
     *     next.  These sub-controls are button type controls that activate
     *     and deactivate themselves.  If this parent control is added to
     *     a panel, it will act as a toggle.
     */
    type: Geo.View2D.Control.TYPE_TOGGLE,

    /**
     * APIProperty: previous
     * {<Geo.View2D.Control>} "上一步"的控件按钮对象。
     */
    previous: null,
    
    /**
     * APIProperty: previousOptions
     * {Object} 设置"上一步"的控件对象的构造参数对象。
     */
    previousOptions: null,
    
    /**
     * APIProperty: next
     * {<Geo.View2D.Control>} "下一步"的控件按钮对象。
     */
    next: null,

    /**
     * APIProperty: nextOptions
     * {Object} 设置"下一步"的控件对象的构造参数对象。
     */
    nextOptions: null,

    /**
     * APIProperty: limit
     * {Integer} 历史操作的记录限制数量。
     */
    limit: 50,

    /**
     * APIProperty: autoActivate
     * {Boolean} 是否在控件添加至地图后自动激活。
     */
    autoActivate: true,

    /**
     * Property: clearOnDeactivate
     * {Boolean} Clear the history when the control is deactivated.  Default
     *     is false.
     */
    clearOnDeactivate: false,

    /**
     * Property: registry
     * {Object} An object with keys corresponding to event types.  Values
     *     are functions that return an object representing the current state.
     */
    registry: null,

    /**
     * Property: nextStack
     * {Array} Array of items in the history.
     */
    nextStack: null,

    /**
     * Property: previousStack
     * {Array} List of items in the history.  First item represents the current
     *     state.
     */
    previousStack: null,
    
    /**
     * Property: listeners
     * {Object} An object containing properties corresponding to event types.
     *     This object is used to configure the control and is modified on
     *     construction.
     */
    listeners: null,
    
    /**
     * Property: restoring
     * {Boolean} Currently restoring a history state.  This is set to true
     *     before calling restore and set to false after restore returns.
     */
    restoring: false,
    
    /**
     * Constructor: Geo.View2D.Control.GeoNavigationHistory
     * Geo.View2D.Control.GeoNavigationHistory对象构造函数。
     * 
     * Parameters:
     * options - {Object} 参数对象。
     * vectorLayer - {<Geo.View2D.Layer.Vector>} 矢量要素图层。
     */
    initialize: function(options, vectorLayer) {
        Geo.View2D.Control.prototype.initialize.apply(this, [options]);
		this.vectorLayer = vectorLayer;
        this.registry = OpenLayers.Util.extend({
            "moveend": this.getState,
			"featureadded": this.getState,
			"featureremoved": this.getState
        }, this.registry);
        
        var previousOptions = {
            trigger: OpenLayers.Function.bind(this.previousTrigger, this),
            displayClass: this.displayClass + " " + this.displayClass + "Previous"
        };
        OpenLayers.Util.extend(previousOptions, this.previousOptions);
        this.previous = new Geo.View2D.Control.Button(previousOptions);
        
        var nextOptions = {
            trigger: OpenLayers.Function.bind(this.nextTrigger, this),
            displayClass: this.displayClass + " " + this.displayClass + "Next"
        };
        OpenLayers.Util.extend(nextOptions, this.nextOptions);
        this.next = new Geo.View2D.Control.Button(nextOptions);

        this.clear();
		
        this.format = this.format ? this.format : new Geo.Format.GML();
        this.jsonParser = new OpenLayers.Format.JSON();
		
		//window.localStorage.clear();
		try {
			this.previousStack = this.readStack(window.localStorage.getItem("previousStack"));
			this.nextStack = this.readStack(window.localStorage.getItem("nextStack"));
		} catch (e) {
		}
		
		this.initFlag = true;
    },
    
    /**
     * Method: onPreviousChange
     * Called when the previous history stack changes.
     *
     * Parameters:
     * state - {Object} An object representing the state to be restored
     *     if previous is triggered again or null if no previous states remain.
     * length - {Integer} The number of remaining previous states that can
     *     be restored.
     */
    onPreviousChange: function(state, length) {
        if(state && !this.previous.active) {
            this.previous.activate();
        } else if(!state && this.previous.active) {
            this.previous.deactivate();
        }
    },
    
    /**
     * Method: onNextChange
     * Called when the next history stack changes.
     *
     * Parameters:
     * state - {Object} An object representing the state to be restored
     *     if next is triggered again or null if no next states remain.
     * length - {Integer} The number of remaining next states that can
     *     be restored.
     */
    onNextChange: function(state, length) {
        if(state && !this.next.active) {
            this.next.activate();
        } else if(!state && this.next.active) {
            this.next.deactivate();
        }
    },
    
    /**
     * APIMethod: destroy
     * 销毁这个控件。
     */
    destroy: function() {
        Geo.View2D.Control.prototype.destroy.apply(this);
        this.previous.destroy();
        this.next.destroy();
        this.deactivate();
        for(var prop in this) {
            this[prop] = null;
        }
    },
    
    /** 
     * Method: setMap
     * Set the map property for the control and <previous> and <next> child
     *     controls.
     *
     * Parameters:
     * map - {<Geo.View2D.Map>} 
     */
    setMap: function(map) {
        this.map = map;
        this.next.setMap(map);
        this.previous.setMap(map);
    },

    /**
     * Method: draw
     * Called when the control is added to the map.
     */
    draw: function() {
        Geo.View2D.Control.prototype.draw.apply(this, arguments);
        this.next.draw();
        this.previous.draw();
    },
    
    /**
     * Method: previousTrigger
     * Restore the previous state.  If no items are in the previous history
     *     stack, this has no effect.
     *
     * Returns:
     * {Object} Item representing state that was restored.  Undefined if no
     *     items are in the previous history stack.
     */
    previousTrigger: function() {
        var current = this.previousStack.shift();
        var state = this.previousStack.shift();
        if(state != undefined) {
            this.nextStack.unshift(current);
            this.previousStack.unshift(state);
            this.restoring = true;
            this.restore(state);
            this.restoring = false;
            this.onNextChange(this.nextStack[0], this.nextStack.length);
            this.onPreviousChange(
                this.previousStack[1], this.previousStack.length - 1
            );
        } else {
            this.previousStack.unshift(current);
        }
		try {
			window.localStorage.setItem("previousStack", this.writeStack(this.previousStack));
			window.localStorage.setItem("nextStack", this.writeStack(this.nextStack));
		}catch(e){
		}
        return state;
    },
    
    /**
     * APIMethod: nextTrigger
     * 点击“前进”按钮触发的函数。
     *
     * Returns:
     * {Object} 返回“前进”后的状态对象。
     */
    nextTrigger: function() {
        var state = this.nextStack.shift();
        if(state != undefined) {
            this.previousStack.unshift(state);
            this.restoring = true;
            this.restore(state);
            this.restoring = false;
            this.onNextChange(this.nextStack[0], this.nextStack.length);
            this.onPreviousChange(
                this.previousStack[1], this.previousStack.length - 1
            );
        }
		try {
			window.localStorage.setItem("previousStack", this.writeStack(this.previousStack));
			window.localStorage.setItem("nextStack", this.writeStack(this.nextStack));
		}catch(e){
		}
        return state;
    },
    
    /**
     * APIMethod: clear
     * 清除内存中该控件记录的操作信息。
     */
    clear: function() {
        this.previousStack = [];
        this.previous.deactivate();
        this.nextStack = [];
        this.next.deactivate();
    },

    /**
     * Method: getState
     * Get the current state and return it.
     *
     * Returns:
     * {Object} An object representing the current state.
     */
    getState: function() {
		var features = OpenLayers.Util.extend([], this.vectorLayer.features);
        return {
            center: this.map.getCenter(),
            resolution: this.map.getResolution(),
            projection: this.map.getProjectionObject(),
            units: this.map.getProjectionObject().getUnits() || 
                this.map.units || this.map.baseLayer.units,
			features: features//OpenLayers.Util.extend({}, this.vectorLayer.features)
        };
    },

    /**
     * Method: restore
     * Update the state with the given object.
     *
     * Parameters:
     * state - {Object} An object representing the state to restore.
     */
    restore: function(state) {
        var center, zoom;
        if (this.map.getProjectionObject() == state.projection) { 
            zoom = this.map.getZoomForResolution(state.resolution);
            center = state.center;
        } else {
            center = state.center.clone();
            center.transform(state.projection, this.map.getProjectionObject());
            var sourceUnits = state.units;
            var targetUnits = this.map.getProjectionObject().getUnits() || 
                this.map.units || this.map.baseLayer.units;
            var resolutionFactor = sourceUnits && targetUnits ? 
                OpenLayers.INCHES_PER_UNIT[sourceUnits] / OpenLayers.INCHES_PER_UNIT[targetUnits] : 1;
            zoom = this.map.getZoomForResolution(resolutionFactor*state.resolution); 
        }
        this.map.setCenter(center, zoom);
		
		var features;
		features = state.features;
		this.vectorLayer.removeFeatures(this.vectorLayer.features);
		if(features && features.length){
			this.vectorLayer.addFeatures(features);
		}
		
    },
    
    /**
     * Method: writeStack
     */
    writeStack: function(stack) {
		var preStack = new Array();
        for (var i = 0; i < stack.length; i++) {
			var features = this.format.write(stack[i].features);
            var item = {
                center: stack[i].center,
                resolution: stack[i].resolution,
                projection: stack[i].projection,
                units: stack[i].units,
                features: features
            }
			preStack.push(item);
        }
		this.preStackJsonStr = this.jsonParser.write(preStack);
		return this.preStackJsonStr;
	},
    
    /**
     * Method: readStack
     */
    readStack: function(stackStr) {
		var preStack = new Array();
		if(!stackStr){
			return [];
		}
        var jsonObj = this.jsonParser.read(stackStr);
        for (var i = 0; i < jsonObj.length; i++) {
			 var item = {
                center: new OpenLayers.LonLat(jsonObj[i].center.lon, jsonObj[i].center.lat),
                resolution: jsonObj[i].resolution,
                projection: new OpenLayers.Projection(jsonObj[i].projection.projCode),
                units: jsonObj[i].units,
                features: this.format.read(jsonObj[i].features)
            }
			preStack.push(item);
        }
		return preStack;
	},
	
    /**
     * Method: setListeners
     * Sets functions to be registered in the listeners object.
     */
    setListeners: function() {
        this.listeners = {};
        for(var type in this.registry) {
            if (type == "featureadded" && this.vectorLayer) {
				//要素被添加后，触发该函数。保存这次操作。
				this.listeners["featureadded"] = OpenLayers.Function.bind(function(){
					if (!this.restoring) {
                        var state = this.registry["featureadded"].apply(this, arguments);
                        this.previousStack.unshift(state);
                        if (this.previousStack.length > 1) {
                            this.onPreviousChange(this.previousStack[1], this.previousStack.length - 1);
                        }
                        if (this.previousStack.length > (this.limit + 1)) {
                            this.previousStack.pop();
                        }
                        if (this.nextStack.length > 0) {
                            this.nextStack = [];
                            this.onNextChange(null, 0);
                        }
						
						/* 保存至localStorage。HTML5的功能 */
						try{
							window.localStorage.setItem("previousStack", this.writeStack(this.previousStack));
							window.localStorage.setItem("nextStack", this.writeStack(this.nextStack));
						}catch(e){
							
						}
                    }
                    return true;
				}, this);
            } else if(type == "featureremoved" && this.vectorLayer){
				//要素被添加后，触发该函数。保存这次操作。
				this.listeners["featureremoved"] = OpenLayers.Function.bind(function(){
					if (!this.restoring) {
						if(!this.registry){
							return true;
						}
                        var state = this.registry["featureremoved"].apply(this, arguments);
                        this.previousStack.unshift(state);
                        if (this.previousStack.length > 1) {
                            this.onPreviousChange(this.previousStack[1], this.previousStack.length - 1);
                        }
                        if (this.previousStack.length > (this.limit + 1)) {
                            this.previousStack.pop();
                        }
                        if (this.nextStack.length > 0) {
                            this.nextStack = [];
                            this.onNextChange(null, 0);
                        }
						
						/* 保存至localStorage。HTML5的功能 */
						try{
							window.localStorage.setItem("previousStack", this.writeStack(this.previousStack));
							window.localStorage.setItem("nextStack", this.writeStack(this.nextStack));
						}catch(e){
							
						}
                    }
                    return true;
				}, this);
			} else if(type == "moveend"){
				//地图被操作后，触发该函数。保存这次操作。
                this.listeners["moveend"] = OpenLayers.Function.bind(function(){
                    if (!this.restoring) {
						// 不支持HTML5
						if (!window.localStorage) {
							var state = this.registry["moveend"].apply(this, arguments);
	                        this.previousStack.unshift(state);
	                        if (this.previousStack.length > 1) {
	                            this.onPreviousChange(this.previousStack[1], this.previousStack.length - 1);
	                        }
	                        if (this.previousStack.length > (this.limit + 1)) {
	                            this.previousStack.pop();
	                        }
	                        if (this.nextStack.length > 0) {
	                            this.nextStack = [];
	                            this.onNextChange(null, 0);
	                        }
						}
						
						// 支持HTML5
						if (window.localStorage) {
							//第一进入时，有要素则绘制在地图上。
							if (this.initFlag) {
								//this.previousTrigger();
								if (this.previousStack.length > 0) {
									var state = this.previousStack[0]
									if (state != undefined) {
										//this.nextStack.unshift(current);
										//this.previousStack.unshift(state);
										this.restoring = true;
										this.restore(state);
										this.restoring = false;
									}
								}
							}
							//不是第一次进入时
							if (!this.initFlag) {
								var state = this.registry["moveend"].apply(this, arguments);
								this.previousStack.unshift(state);
							}
							if (this.previousStack.length > 1) {
								this.onPreviousChange(this.previousStack[1], this.previousStack.length - 1);
							}
							if (this.previousStack.length > (this.limit + 1)) {
								this.previousStack.pop();
							}
							
							//不是第一次进入时
							if (this.nextStack.length > 0 && !this.initFlag) {
								this.nextStack = [];
								this.onNextChange(null, 0);
							}
							else 
								if (this.initFlag) {//第一次进入时，是否可用前进。
									this.onNextChange(this.nextStack[0], this.nextStack.length);
									this.initFlag = false;
								}
								
							/* 保存至localStorage。HTML5的功能 */
							try{
								window.localStorage.setItem("previousStack", this.writeStack(this.previousStack));
								window.localStorage.setItem("nextStack", this.writeStack(this.nextStack));
							}catch(e){
								
							}
						}
                    }
                    return true;
                }, this);
			}
        }
    },

    /**
     * APIMethod: activate
     * 激活控件。
     *
     * Returns:
     * {Boolean} 是否激活成功。
     */
    activate: function() {
        var activated = false;
        if(this.map) {
            if(Geo.View2D.Control.prototype.activate.apply(this)) {
                if(this.listeners == null) {
                    this.setListeners();
                }
                for(var type in this.listeners) {
                    if (type == "featureadded" && this.vectorLayer) {
                        this.vectorLayer.events.register(type, this, this.listeners[type]);
                    } if (type == "featureremoved" && this.vectorLayer) {
						this.vectorLayer.events.register(type, this, this.listeners[type]);
                    } else {
                        this.map.events.register(type, this, this.listeners[type]);
                    }
                }
                activated = true;
                if(this.previousStack.length == 0) {
                    this.initStack();
                }
            }
        }
        return activated;
    },
    
    /**
     * Method: initStack
     * Called after the control is activated if the previous history stack is
     *     empty.
     */
    initStack: function() {
        if(this.map.getCenter()) {
            this.listeners.moveend();
        }
    },
    
    /**
     * APIMethod: deactivate
     * 关闭控件。
     *
     * Returns:
     * {Boolean} 是否关闭成功。
     */
    deactivate: function() {
        var deactivated = false;
        if(this.map) {
            if(Geo.View2D.Control.prototype.deactivate.apply(this)) {
                for(var type in this.listeners) {
                    this.map.events.unregister(
                        type, this, this.listeners[type]
                    );
                }
                if(this.clearOnDeactivate) {
                    this.clear();
                }
                deactivated = true;
            }
        }
        return deactivated;
    },
    
    /**
     * APIMethod: clearRecordStack
     * 清除localStorage对象中该控件记录的操作信息。
     */
    clearRecordStack: function() {
        window.localStorage.removeItem("previousStack");
        window.localStorage.removeItem("nextStack");
    },
	
    CLASS_NAME: "Geo.View2D.Control.GeoNavigationHistory"
});
/**
 * Class: Geo.View2D.Control.Measure.AreaMeasure
 * 面积量算类，继承自Geo.View2D.Control.Measure类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control.Measure>
 */
Geo.View2D.Control.Measure.AreaMeasure = Geo.Class(OpenLayers.Control.Measure, {
	
	/**
     * APIProperty: result
     * {Array} 量算结果集合，用于存放量算结果和popup。
	 */
	result: null,
    
	/**
     * Property: currentPopups
     * {Array} 用于存放popup的数组。
	 */
    currentPopups: null,

    /**
     * APIProperty: persist
     * {Boolean} 如果设置为true，则在一次测量绘制完成后，保持这个临时的测量结果的几何要素。
     *  直到一个新的测量操作开始，几何要素被清除。
     *  如果设置为false，则在一次测量绘制完成后，清除几何要素。默认值为false。
     */
    persist: false,
	
	/**
     * Constructor: Geo.View2D.Control.Measure.AreaMeasure
     * 构造函数。生成一个Geo.View2D.Control.Measure.AreaMeasure的实例。
     */
    initialize: function(options){
    
        var areaMeatureHandler = OpenLayers.Class(OpenLayers.Handler.Polygon, {
        
            moveTitleDiv: null,
            
            deactivate: function(){
                if (!OpenLayers.Handler.prototype.deactivate.apply(this, arguments)) {
                    return false;
                }
				
				//清除所有的量算结果。
                this.control.destoryAllResult();
				if(this.moveTitleDiv){
					this.moveTitleDiv.style.display = "none";
				}
				
                // call the cancel callback if mid-drawing
                if (this.lastUp) {
                    this.cancel();
                }
                
                 this.destroyFeature();
                 // If a layer's map property is set to null, it means that that layer
                 // isn't added to the map. Since we ourself added the layer to the map
                 // in activate(), we can assume that if this.layer.map is null it means
                 // that the layer has been destroyed (as a result of map.destroy() for
                 // example.
                 if (this.layer.map != null) {
                 	this.layer.destroy(false);
                 }
                 this.layer = null;
                 
                return true;
            },
            
			/**
             * 绘制结束后不立即清除本次量算线段。
             * @param {Object} cancel
             */
            finalize: function(cancel){
				OpenLayers.Handler.Path.prototype.finalize.apply(this, arguments);
				if(this.layer && (cancel || !this.persist)) {
		            this.control.destoryAllResult();
		        }
            },
			
            /**
			 * 鼠标移动时光标显示提示信息，当未开始点击时显示"单击确定起点"。
			 * 点击起点后显示"单击确定中间点，双击结束量算"。
			 * 提示信息距光标位置有一定偏移量。
			 * @param {Object} evt
			 */
            mousemove: function(evt){
                var result = OpenLayers.Handler.Path.prototype.mousemove.apply(this, arguments);
                if (!this.moveTitleDiv) {
                    this.moveTitleDiv = document.createElement("div");
                    this.map.viewPortDiv.appendChild(this.moveTitleDiv);
                }else {
                    this.moveTitleDiv.style.display = "";
                }
                
                var msg = "";
                if (this.lastUp) {
                    msg = "单击确定起点，双击结束量算";
                }
                else {
                    msg = "单击确定起点";
                }
                
                this.moveTitleDiv.innerHTML = msg;
                this.moveTitleDiv.style.position = "absolute";
                this.moveTitleDiv.style.zIndex = this.control.div.style.zIndex;
                this.moveTitleDiv.style.left = evt.xy.x + 15 + "px";
                this.moveTitleDiv.style.top = evt.xy.y + 15 + "px";
                
                return result;
            },
			up: function(){
				var result = OpenLayers.Handler.Path.prototype.up.apply(this, arguments);
				if(this.persist) {
					this.control.destoryResult(this.control.result.length - 1);
				}
				return result;
			}
        });
        var handler = areaMeatureHandler;
        
        this.result = [];
        this.currentPopups = [];
        OpenLayers.Control.Measure.prototype.initialize.apply(this, [handler, options]);
        
        this.events.on({
            "measure": this.handleMeasurementsEnd,
            "measurepartial": this.handleMeasurements
        });
    },
    
    /**
     * Method: measurePartial
     * 判断第一次点击时节点提示为"起点"。
     * 
     * point - {<Geo.Geometry.Point>} 几何点对象。
     * geometry - {<Geo.Geometry>} 几何对象。
     */
    measurePartial: function(point, geometry){
        OpenLayers.Control.Measure.prototype.measurePartial.apply(this, arguments);
    },
    
    /**
     * Method: addNodePopup
     * 添加节点提示框，并保存到currentPopups数组。
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>} 坐标对象。
     * out - {String} 输出的HTML内容。
     */
    addNodePopup: function(lonlat, out){
    
        var popup = new OpenLayers.Popup("chicken", lonlat, null, "<span class='rightBg'>" + out + "<span>", false);
        popup.autoSize = true;
        popup.setBackgroundColor("transparent");
        this.map.addPopup(popup);
        this.currentPopups.push(popup);
    },
    
    /**
     * Method: destoryResult
     * 清除指定索引号的量算结果。
     * 
     * Parameters:
     * resultIndex - {Number} 指定索引号。
     */
    destoryResult: function(resultIndex){
        var result = this.result[resultIndex];
		if(!result){
			return;
		}
        var feature = result.feature;
        var popups = result.popups;
        if (typeof(feature) == "string") {
            feature = this.handler.layer.getFeatureById(feature);
        }
        this.handler.layer.destroyFeatures([feature]);
        for (var i = 0; i < popups.length; i++) {
            this.map.removePopup(popups[i]);
        }
        
    },
	
    /**
     * Method: destoryResult
     * 清除所有的量算结果。
     */
    destoryAllResult: function(){
		for (var i = 0; i < this.result.length; i++) {
            this.destoryResult(i);
        }
		this.result = [];
    },
	
    /**
     * APIMethod: handleMeasurements
     * 量算结束响应方法。
     * 
     * Parameters:
     * event - {<Geo.View2D.Event>} 事件对象。
     */
    handleMeasurements: function(event){
        var geometry = event.geometry;
        
        var units = event.units;
        var order = event.order;
        var measure = event.measure;
        //var element = document.getElementById('output');
        var out = "";
        if (order == 1) {
            out += measure.toFixed(3) + " " + units;
        }
        else {
            out += measure.toFixed(3) + " " + units + "<sup>2</" + "sup>";
        }
        //element.innerHTML = out;
    },
	
    /**
     * APIMethod: handleMeasurementsEnd
     * 量算结束响应方法。
     * 
     * Parameters:
     * event - {<Geo.View2D.Event>} 事件对象。
     */
    handleMeasurementsEnd: function(event){
        var geometry = event.geometry;
        
        var units = event.units;
        var order = event.order;
        var measure = event.measure;
		if(!measure){
			return;
		}
        //var element = document.getElementById('output');
        var out = "";
        if (order == 1) {
            out += measure.toFixed(3) + " " + units;
        }
        else {
            out += measure.toFixed(3) + " " + units + "<sup>2</" + "sup>";
        }
        //element.innerHTML = out;
        
        //getCentroid取质心点
        var point = geometry.getCentroid();
        var ll = new OpenLayers.LonLat(point.x + this.map.getResolution() * 10, point.y - this.map.getResolution() * 10);
        var currentPolygon = this.handler.polygon;
        this.addNodePopup(ll, "总面积：" + out + "<a id = '" + geometry.id + "_a' class='result_close' href='#' style=''> X</a>");
        
        var resultIndex = this.result.length;
        document.getElementById(geometry.id + "_a").onclick = OpenLayers.Function.bind(function(){
            this.destoryResult(resultIndex);
        }, this);
        
        this.result.push({
            feature: currentPolygon,
            popups: this.currentPopups
        });
        this.currentPopups = [];
    }
    
});
/**
 * Class: Geo.View2D.Control.Measure.DistanceMeasure
 * 距离量算类，继承自Geo.View2D.Control.Measure类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control.Measure>
 */
Geo.View2D.Control.Measure.DistanceMeasure = Geo.Class(Geo.View2D.Control.Measure, {
    
	/**
     * APIProperty: result
     * {Array} 量算结果集合，用于存放量算结果和popup。
	 */
	result: null,
    
	/**
     * Property: currentPopups
     * {Array} 用于存放popup的数组。
	 */
    currentPopups: null,

    /**
     * APIProperty: persist
     * {Boolean} 如果设置为true，则在一次测量绘制完成后，保持这个临时的测量结果的几何要素。
     *  直到一个新的测量操作开始，几何要素被清除。
     *  如果设置为false，则在一次测量绘制完成后，清除几何要素。默认值为false。
     */
    persist: false,
	
    /**
     * Constructor: Geo.View2D.Control.Measure.DistanceMeasure
     * 构造函数。生成一个Geo.View2D.Control.Measure.DistanceMeasure的实例。
     */
    initialize: function(options){
        var distanceMeatureHandler = OpenLayers.Class(OpenLayers.Handler.Path, {
        
            //量算过程所有中间点
            points: null,
            
            //移动时光标提示框
            moveTitleDiv: null,
            
            //关闭控件时需要手工来清除绘制的多个距离量算结果
            deactivate: function(){
                if (!OpenLayers.Handler.prototype.deactivate.apply(this, arguments)) {
                    return false;
                }
				
				//清除所有的量算结果。
                this.control.destoryAllResult();
				this.control.removerNodePopups();
				if(this.moveTitleDiv){
					this.moveTitleDiv.style.display = "none";
				}
                // call the cancel callback if mid-drawing
                if (this.lastUp) {
                    this.cancel();
                }
                
                 this.destroyFeature();
                 // If a layer's map property is set to null, it means that that layer
                 // isn't added to the map. Since we ourself added the layer to the map
                 // in activate(), we can assume that if this.layer.map is null it means
                 // that the layer has been destroyed (as a result of map.destroy() for
                 // example.
                 if (this.layer.map != null) {
                     this.layer.destroy(false);
                 }
                 this.layer = null;
                 
                return true;
            },
            
            /**
             * 绘制结束后不立即清除本次量算线段。
             * @param {Object} cancel
             */
            finalize: function(cancel){
				OpenLayers.Handler.Path.prototype.finalize.apply(this, arguments);
				if(this.layer && (cancel || !this.persist)) {
		            this.control.destoryAllResult();
		        }

//				var key = cancel ? "cancel" : "done";
//		        this.mouseDown = false;
//		        this.lastDown = null;
//		        this.lastUp = null;
//		        this.lastTouchPx = null;
//		        this.callback(key, [this.geometryClone()]);
//		        //this.destroyFeature(cancel);
//				this.line = null;
//				this.point = null;
            },
            
			/**
			 * 鼠标移动时光标显示提示信息，当未开始点击时显示"单击确定起点"。
			 * 点击起点后显示"单击确定中间点，双击结束量算"。
			 * 提示信息距光标位置有一定偏移量。
			 * @param {Object} evt
			 */
            mousemove: function(evt){
                var result = OpenLayers.Handler.Path.prototype.mousemove.apply(this, arguments);
                if (!this.moveTitleDiv) {
                    this.moveTitleDiv = document.createElement("div");
                    this.map.viewPortDiv.appendChild(this.moveTitleDiv);
                }else{
					this.moveTitleDiv.style.display = "";
				}
                
                var msg = "";
                if (this.lastUp) {
                    msg = "单击确定中间点，双击结束量算";
                }
                else {
                    msg = "单击确定起点";
                }
                this.moveTitleDiv.innerHTML = msg;
                this.moveTitleDiv.style.position = "absolute";
                this.moveTitleDiv.style.zIndex = this.control.div.style.zIndex;
                this.moveTitleDiv.style.left = evt.xy.x + 15 + "px";
                this.moveTitleDiv.style.top = evt.xy.y + 15 + "px";
                return result;
            },
			up: function(){
				var result = OpenLayers.Handler.Path.prototype.up.apply(this, arguments);
				if(this.persist) {
					this.control.destoryResult(this.control.result.length - 1);
				}
				return result;
			}
        });
        var handler = distanceMeatureHandler;
        
        //支持保存多个距离结果，保存当前所有节点提示框
        this.result = [];
        this.currentPopups = [];
        
        OpenLayers.Control.Measure.prototype.initialize.apply(this, [handler, options]);
        
        //量算过程中和结束有不同处理
        this.events.on({
            "measure": this.handleMeasurementsEnd,
            "measurepartial": this.handleMeasurements
        });
    },
    
    /**
     * Method: measurePartial
     * 判断第一次点击时节点提示为"起点"。
     * 
     * point - {<Geo.Geometry.Point>} 几何点对象。
     * geometry - {<Geo.Geometry>} 几何对象。
     */
    measurePartial: function(point, geometry){
        if (geometry.getLength() == 0) {
            var ll = new OpenLayers.LonLat(point.x + this.map.getResolution() * 10, point.y - this.map.getResolution() * 10);
            this.addNodePopup(ll, "起点");
        }
        
        OpenLayers.Control.Measure.prototype.measurePartial.apply(this, arguments);
    },
    
    /**
     * Method: addNodePopup
     * 添加节点提示框，并保存到currentPopups数组。
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>} 坐标对象。
     * out - {String} 输出的HTML内容。
     */
    addNodePopup: function(lonlat, out){
    
        var popup = new OpenLayers.Popup("chicken", lonlat, null, "<span class='rightBg'>" + out + "<span>", false);
        popup.autoSize = true;
        popup.setBackgroundColor("transparent");
        this.map.addPopup(popup);
        this.currentPopups.push(popup);
    },
    
    /**
     * Method: removerNodePopups
     * 删除节点提示框。
     */
    removerNodePopups: function(){
		var popups = this.currentPopups;
		for (var i = 0; i < popups.length; i++) {
            this.map.removePopup(popups[i]);
        }
    },
    
    /**
     * Method: destoryResult
     * 清除指定索引号的量算结果。
     * 
     * Parameters:
     * resultIndex - {Number} 指定索引号。
     */
    destoryResult: function(resultIndex){
        var result = this.result[resultIndex];
		if(!result){
			return;
		}
        var feature = result.feature;
        var popups = result.popups;
        if (typeof(feature) == "string") {
            feature = this.handler.layer.getFeatureById(feature);
        }
        this.handler.layer.destroyFeatures([feature]);
        for (var i = 0; i < popups.length; i++) {
            this.map.removePopup(popups[i]);
        }
    },
	
    /**
     * Method: destoryResult
     * 清除所有的量算结果。
     */
    destoryAllResult: function(){
		for (var i = 0; i < this.result.length; i++) {
            this.destoryResult(i);
        }
		this.result = [];
    },
    
    /**
     * APIMethod: handleMeasurements
     * 量算结束响应方法。
     * 
     * Parameters:
     * event - {<Geo.View2D.Event>} 事件对象。
     */
    handleMeasurements: function(event){
        var geometry = event.geometry;
        
        var units = event.units;
        var order = event.order;
        var measure = event.measure;
		if(measure == 0){
			return;
		}
        //var element = document.getElementById('output');
        var out = "";
        if (order == 1) {
            out += measure.toFixed(3) + " " + units;
        }
        else {
            out += measure.toFixed(3) + " " + units + "<sup>2</" + "sup>";
        }
        //element.innerHTML = out;
        
        var point = geometry.components[geometry.components.length - 1];
        var ll = new OpenLayers.LonLat(point.x + this.map.getResolution() * 5, point.y - this.map.getResolution() * 5);
        this.addNodePopup(ll, out);
    },
    
    /**
     * APIMethod: handleMeasurementsEnd
     * 量算结束响应方法。
     * 
     * Parameters:
     * event - {<Geo.View2D.Event>} 事件对象。
     */
    handleMeasurementsEnd: function(event){
        var geometry = event.geometry;
        
        var units = event.units;
        var order = event.order;
        var measure = event.measure;
        //var element = document.getElementById('output');
        var out = "";
        if (order == 1) {
            out += measure.toFixed(3) + " " + units;
        }
        else {
            out += measure.toFixed(3) + " " + units + "<sup>2</" + "sup>";
        }
        //element.innerHTML = out;
        
        var point = geometry.components[geometry.components.length - 1];
        var ll = new OpenLayers.LonLat(point.x + this.map.getResolution() * 10, point.y - this.map.getResolution() * 10);
        var currentPath = this.handler.line;
        this.addNodePopup(ll, "总长：" + out + "<a id = '" + geometry.id + "_a' class='result_close' href='#' style=''> X</a>");
        
        var resultIndex = this.result.length;
        document.getElementById(geometry.id + "_a").onclick = OpenLayers.Function.bind(function(){
            this.destoryResult(resultIndex);
        }, this);
        
        this.result.push({
            feature: currentPath,
            popups: this.currentPopups
        });
        this.currentPopups = [];
    }


});
/**
 * Class: Geo.View2D.Control.Measure.Angle
 * 角度量算类，继承自Geo.View2D.Control.Measure类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 *
 * Inherits from:
 *  - <Geo.View2D.Control.Measure>
 */
Geo.View2D.Control.Measure.Angle = Geo.Class(Geo.View2D.Control.Measure, {
	
    /**
     * Constructor: Geo.View2D.Control.Measure.Angle
     * 构造函数。生成一个Geo.View2D.Control.Measure.Angle的实例。
     * 
     * Parameters:
     * options - {Object} 构造参数选项。
     */
    initialize: function(options){
        var handler = Geo.View2D.Handler.Path;
        Geo.View2D.Control.Measure.prototype.initialize.apply(this, [handler, options]);
    },
	
	/**
     * Method: measure
     *
     * Parameters:
     * geometry - {<Geo.View2D.Geometry>}
     * eventType - {String}
     */
    measure: function(geometry, eventType) {
        var stat, order;
        if(geometry.CLASS_NAME.indexOf('LineString') > -1) {
            //stat = this.getBestLength(geometry);
            stat = this.getAngle(geometry);
            order = 3;
        }
        this.events.triggerEvent(eventType, {
            measure: stat[0],
            units: stat[1],
			angles: stat[2],
            order: order,
            geometry: geometry
        });
    },
	
	/**
     * Method: getAngle
     * 获取当前绘制的线段与前一绘制的线段之间的角度值。
     *
     * Parameters:
     * geometry - {<Geo.View2D.Geometry>}
     *
     * Returns:
     * {Array([Float, String, Array])}
     * 返回一个数组，包含3个选项，最后量算的角度值，角度单位，所有量算的角度值的数组。
     */
    getAngle: function(geometry) {
        var unit = "°";
        var angle = 0;
        var angles = new Array();
		var kqs = [];
		var length = geometry.components.length;
        length = (geometry.components[length - 1].x == geometry.components[length - 2].x && geometry.components[length - 1].y == geometry.components[length - 2].y) ? length - 1 : length;
		for (var i = 0; i < length; i++) {
            if (i) {
                var x1 = geometry.components[i - 1].x;
                var y1 = geometry.components[i - 1].y;
                var x2 = geometry.components[i].x;
                var y2 = geometry.components[i].y;
				//直线的斜率
                var k = (y2 - y1) / (x2 - x1);
                
                var quadrant = "";
                if (y2 > y1 && x2 > x1) {
                    quadrant = 1;//"rt";//第一象限
                }
                if (y2 > y1 && x2 < x1) {
                    quadrant = 2;//"lt";//第二象限
                }
                if (y2 < y1 && x2 < x1) {
                    quadrant = 3;//"lb";//第三象限
                }
                if (y2 < y1 && x2 > x1) {
                    quadrant = 4;//"rb";//第四象限
                }
                
                kqs.push({
                    k: k,
                    quadrant: quadrant
                });
                if (i > 1) {
                    var k1 = kqs[i - 2].k;
                    var k2 = kqs[i - 1].k;
                    //两直线的斜率分别用k1与k2表示，则两直线夹角x的正切值可用下述公式表示：
                    //var tanx = Math.abs((k2 - k1) / (1 + (k2 * k1)));
                    var tanx = (k2 - k1) / (1 + (k2 * k1));
                    //反正切值。返回的值是 -PI/2 到 PI/2 之间的弧度值。
                    var radian = Math.atan(tanx);
                    //算角度值。弧度=角度*（2PI/360）
                    var angle = radian / ((2 * Math.PI) / 360);
                    
                    var q1 = kqs[i - 2].quadrant;
                    var q2 = kqs[i - 1].quadrant;
                    
//					一 一：正数则180-，负数则+180
//					一 二：正数则180-，负数则取绝对值
//					一 三：正负数都取绝对值
//					一 四：正数取绝对值，负数则+180
//					
//					二 一：正数取绝对值，负数则+180
//					二 二：正数则180-，负数则+180
//					二 三：正数则180-，负数则取绝对值
//					二 四：正负数都取绝对值
//					
//					三 一：正负数都取绝对值
//					三 二：正数取绝对值，负数则+180
//					三 三：正数则180-，负数则+180
//					三 四：正数则180-，负数则取绝对值
//					
//					四 一：正数则180-，负数则取绝对值
//					四 二：正负数都取绝对值
//					四 三：正数取绝对值，负数则+180
//					四 四：正数则180-，负数则+180
                    var res = (q2 - q1) < 0 ? (q2 - q1) + 4 : (q2 - q1);
                    switch (res) {
                        case 0:
                            angle = (angle > 0) ? (180 - angle) : (180 + angle);
                            break;
                        case 1:
                            angle = (angle > 0) ? (180 - angle) : Math.abs(angle);
                            break;
                        case 2:
                            angle = Math.abs(angle);
                            break;
                        case 3:
                            angle = (angle > 0) ? angle : (180 + angle);
                            break;
                    }
					angles.push(angle);
					
                }
            }
        }
        return [angle, unit, angles];
    }
});
/**
 * Class: Geo.View2D.Control.Measure.AngleMeasure
 * 角度量算类，继承自Geo.View2D.Control.Measure.Angle类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 在地图上动态显示每次测量的角度。
 *
 * Inherits from:
 *  - <Geo.View2D.Control.Measure.Angle>
 */
Geo.View2D.Control.Measure.AngleMeasure = Geo.Class(Geo.View2D.Control.Measure.Angle, {
    
	/**
     * APIProperty: result
     * {Array} 量算结果集合，用于存放量算结果和popup。
	 */
	result: null,
    
	/**
     * Property: currentPopups
     * {Array} 用于存放popup的数组。
	 */
    currentPopups: null,

    /**
     * APIProperty: persist
     * {Boolean} 如果设置为true，则在一次测量绘制完成后，保持这个临时的测量结果的几何要素。
     *  直到一个新的测量操作开始，几何要素被清除。
     *  如果设置为false，则在一次测量绘制完成后，清除几何要素。默认值为false。
     */
    persist: false,
	
    /**
     * Constructor: Geo.View2D.Control.Measure.DistanceMeasure
     * 构造函数。生成一个Geo.View2D.Control.Measure.DistanceMeasure的实例。
     */
    initialize: function(options){
        var distanceMeatureHandler = OpenLayers.Class(OpenLayers.Handler.Path, {
        
            //量算过程所有中间点
            points: null,
            
            //移动时光标提示框
            moveTitleDiv: null,
            
            //关闭控件时需要手工来清除绘制的多个距离量算结果
            deactivate: function(){
                if (!OpenLayers.Handler.prototype.deactivate.apply(this, arguments)) {
                    return false;
                }
				
				//清除所有的量算结果。
                this.control.destoryAllResult();
				this.control.removerNodePopups();
				if(this.moveTitleDiv){
					this.moveTitleDiv.style.display = "none";
				}
                // call the cancel callback if mid-drawing
                if (this.lastUp) {
                    this.cancel();
                }
                
                 this.destroyFeature();
                 // If a layer's map property is set to null, it means that that layer
                 // isn't added to the map. Since we ourself added the layer to the map
                 // in activate(), we can assume that if this.layer.map is null it means
                 // that the layer has been destroyed (as a result of map.destroy() for
                 // example.
                 if (this.layer.map != null) {
                     this.layer.destroy(false);
                 }
                 this.layer = null;
                 
                return true;
            },
            
            /**
             * 绘制结束后不立即清除本次量算线段。
             */
            finalize: function(cancel){
				OpenLayers.Handler.Path.prototype.finalize.apply(this, arguments);
				if(this.layer && (cancel || !this.persist)) {
		            this.control.destoryAllResult();
		        }
            },
            
			/**
			 * 鼠标移动时光标显示提示信息，当未开始点击时显示"单击确定起点"。
			 * 点击起点后显示"单击确定中间点，双击结束量算"。
			 * 提示信息距光标位置有一定偏移量。
			 */
            mousemove: function(evt){
                var result = OpenLayers.Handler.Path.prototype.mousemove.apply(this, arguments);
                if (!this.moveTitleDiv) {
                    this.moveTitleDiv = document.createElement("div");
                    this.map.viewPortDiv.appendChild(this.moveTitleDiv);
                }else{
					this.moveTitleDiv.style.display = "";
				}
                
                var msg = "";
                if (this.lastUp) {
                    msg = "单击确定中间点，双击结束量算";
                }
                else {
                    msg = "单击确定起点";
                }
                this.moveTitleDiv.innerHTML = msg;
                this.moveTitleDiv.style.position = "absolute";
                this.moveTitleDiv.style.zIndex = this.control.div.style.zIndex;
                this.moveTitleDiv.style.left = evt.xy.x + 15 + "px";
                this.moveTitleDiv.style.top = evt.xy.y + 15 + "px";
                return result;
            },
			up: function(){
				var result = OpenLayers.Handler.Path.prototype.up.apply(this, arguments);
				if(this.persist) {
					this.control.destoryResult(this.control.result.length - 1);
				}
				return result;
			}
        });
        var handler = distanceMeatureHandler;
        
        //支持保存多个距离结果，保存当前所有节点提示框
        this.result = [];
        this.currentPopups = [];
        
        OpenLayers.Control.Measure.prototype.initialize.apply(this, [handler, options]);
        
        //量算过程中和结束有不同处理
        this.events.on({
            "measure": this.handleMeasurementsEnd,
            "measurepartial": this.handleMeasurements
        });
    },
    
    /**
     * Method: measurePartial
     * 判断第一次点击时节点提示为"起点"。
     * 
     * point - {<Geo.Geometry.Point>} 几何点对象。
     * geometry - {<Geo.Geometry>} 几何对象。
     */
    measurePartial: function(point, geometry){
        if (geometry.getLength() == 0) {
            var ll = new OpenLayers.LonLat(point.x + this.map.getResolution() * 10, point.y - this.map.getResolution() * 10);
            this.addNodePopup(ll, "起点");
        }
        
        OpenLayers.Control.Measure.prototype.measurePartial.apply(this, arguments);
    },
    
    /**
     * Method: addNodePopup
     * 添加节点提示框，并保存到currentPopups数组。
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>} 坐标对象。
     * out - {String} 输出的HTML内容。
     */
    addNodePopup: function(lonlat, out){
    
        var popup = new OpenLayers.Popup("chicken", lonlat, null, "<span class='rightBg'>" + out + "<span>", false);
        popup.autoSize = true;
        popup.setBackgroundColor("transparent");
        this.map.addPopup(popup);
        this.currentPopups.push(popup);
    },
    
    /**
     * Method: removerNodePopups
     * 删除节点提示框。
     */
    removerNodePopups: function(){
		var popups = this.currentPopups;
		for (var i = 0; i < popups.length; i++) {
            this.map.removePopup(popups[i]);
        }
    },
    
    /**
     * Method: destoryResult
     * 清除指定索引号的量算结果。
     * 
     * Parameters:
     * resultIndex - {Number} 指定索引号。
     */
    destoryResult: function(resultIndex){
        var result = this.result[resultIndex];
		if(!result){
			return;
		}
        var feature = result.feature;
        var popups = result.popups;
        if (typeof(feature) == "string") {
            feature = this.handler.layer.getFeatureById(feature);
        }
        this.handler.layer.destroyFeatures([feature]);
        for (var i = 0; i < popups.length; i++) {
            this.map.removePopup(popups[i]);
        }
    },
	
    /**
     * Method: destoryResult
     * 清除所有的量算结果。
     */
    destoryAllResult: function(){
		for (var i = 0; i < this.result.length; i++) {
            this.destoryResult(i);
        }
		this.result = [];
    },
    
    /**
     * APIMethod: handleMeasurements
     * 量算结束响应方法。
     * 
     * Parameters:
     * event - {<Geo.View2D.Event>} 事件对象。
     */
    handleMeasurements: function(event){
        var geometry = event.geometry;
        
        var units = event.units;
        var order = event.order;
        var measure = event.measure;
		if(measure == 0){
			return;
		}
        //var element = document.getElementById('output');
        var out = "";
        if (order == 1) {
            out += measure.toFixed(3) + " " + units;
        }else if(order == 2){
            out += measure.toFixed(3) + " " + units + "<sup>2</" + "sup>";
        }else if(order == 3){
			out += measure.toFixed(3) + " " + units;
		}
        //element.innerHTML = out;
        var point = geometry.components[geometry.components.length - 3];
        var ll = new OpenLayers.LonLat(point.x + this.map.getResolution() * 5, point.y - this.map.getResolution() * 5);
        this.addNodePopup(ll, out);
    },
    
    /**
     * APIMethod: handleMeasurementsEnd
     * 量算结束响应方法。
     * 
     * Parameters:
     * event - {<Geo.View2D.Event>} 事件对象。
     */
    handleMeasurementsEnd: function(event){
        var geometry = event.geometry;
        
        var units = event.units;
        var order = event.order;
        var measure = event.measure;
        //var element = document.getElementById('output');
        var out = "";
        if (order == 1) {
            out += measure.toFixed(3) + " " + units;
        }else if(order == 2){
            out += measure.toFixed(3) + " " + units + "<sup>2</" + "sup>";
        }else if(order == 3){
			out += measure.toFixed(3) + " " + units;
		}
        //element.innerHTML = out;
        
        var point = geometry.components[geometry.components.length - 2];
        var ll = new OpenLayers.LonLat(point.x + this.map.getResolution() * 10, point.y - this.map.getResolution() * 10);
        var currentPath = this.handler.line;
        this.addNodePopup(ll, "" + out + "<a id = '" + geometry.id + "_a' class='result_close' href='#' style=''> X</a>");
        
        var resultIndex = this.result.length;
        document.getElementById(geometry.id + "_a").onclick = OpenLayers.Function.bind(function(){
            this.destoryResult(resultIndex);
        }, this);
        
        this.result.push({
            feature: currentPath,
            popups: this.currentPopups
        });
        this.currentPopups = [];
    }
});
/**
 * Class: Geo.View2D.Layer.DynamicMapService
 * rest服务的动态地图图层类。继承自Geo.View2D.Layer.Grid类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 本图层用于展示rest服务的动态地图服务提供的瓦片数据。
 * 本图层支持的服务类型：OGC_Geo_MapService_Rest、Arcgis_MapService_Rest。
 * 
 * Inherits from:
 *  - <Geo.View2D.Layer.Grid>
 */
Geo.View2D.Layer.DynamicMapService = Geo.Class(Geo.View2D.Layer.Grid, {

    /**
     * Constant: DEFAULT_PARAMS
     * {Object} 键值对对象。为参数设置默认值
     */
    DEFAULT_PARAMS: {
      format: "png"
    },
        
    /**
     * APIProperty: isBaseLayer
     * {Boolean} 是否为基础图层
     */
    isBaseLayer: true,
	
	/**
	 *  APIProperty: layers
	 * 确定哪些图层在导出图像上出现。可以通过四种方式指定图层显示。
	 * 
	 * 参数如下：
	 *	show: 仅导出列表中指定的图层。 
	 *	hide: 导出列表指定图层以外的所有图层。 
	 *	include: 除了以默认方式导出图层以外, 列表中指定的图层也会被导出。 
	 *	exclude:没有在这个列表中指定的,以默认方式导出的图层将会被导出。
	 *	示例: layers=show:2,4,7
     *
	 */
	layers:null,
	
	/**
	 * APIProperty: time
	 * {Object} 请求指定时间段内的瓦片。默认可不填
		取值举例：
		timeExtent： {
			startTime:new Date("6/1/2013"),
			endTime:new Date("6/1/2003")
		}
	 */
	timeExtent:null,
	
	/**
	 * APIProperty: layerDefs
	 * 允许你通过定义图层的表达式来过滤单个图层的要素。 
     *
	 *	语法: layerId1:layerDef1;layerId2:layerDef2
	 *	layerId1, layerId2 是地图服务资源返回的图层ID 
	 *	
	 *	示例: 0:POP2000 > 1000000;5:AREA > 100000
	 */
	layerDefs: null,
	
    /**
     * Constructor: Geo.View2D.Layer.DynamicMapService
     * 创建一个动态地图图层
     *
     * Parameters：
     * name - {String} 图层名称
     * url - {String} 动态地图服务地址
     * params - {object}
     * 		format - {String}瓦片格式
     * 		transparent - {Boolean} 透明度
     *      layers: {String} 确定哪些图层在导出图像上出现。
     * 		time - {String} 指定请问时间范围内的瓦片，比如：time:"2013-05-16,2013-05-16"
     * 		gdbVersion - {String} 地图的数据版本，在10.1版本后支持     
     * Example:
     * (code)
     * var arcims = new Geo.View2D.Layer.DynamicMapService("MyName",
     * "http://sampleserver1.arcgisonline.com/ArcGIS/rest/services/Specialty/ESRI_StateCityHighway_USA/MapServer", 
     * {
     *    layers: "0,1,2"
     * }
     * );
     * (end)
     * 	
     */
    initialize: function(name, url, params, options) {
		var location = url.indexOf("/",url.length - 1);
		if(location != -1) {
			url = url + "export";
		}else {
			url = url + "/" + "export";
		}
        var newArguments = [];
        //uppercase params
        params = OpenLayers.Util.upperCaseObject(params);
        newArguments.push(name, url, params, options);
        OpenLayers.Layer.Grid.prototype.initialize.apply(this, newArguments);
        OpenLayers.Util.applyDefaults(
                       this.params, 
                       OpenLayers.Util.upperCaseObject(this.DEFAULT_PARAMS)
                       );
                       
        //layer is transparent        
        if (this.params.TRANSPARENT && 
            this.params.TRANSPARENT.toString().toLowerCase() == "true") {
            
            // unless explicitly set in options, make layer an overlay
            if ( (options == null) || (!options.isBaseLayer) ) {
                this.isBaseLayer = false;
            } 
            
            // jpegs can never be transparent, so intelligently switch the 
            //  format, depending on the browser's capabilities
            if (this.params.FORMAT == "jpg") {
                this.params.FORMAT = OpenLayers.Util.alphaHack() ? "gif"
                                                                 : "png";
            }
        }
		
		if(this.params.TIMEEXTENT) {
			if(this.params.TIMEEXTENT.startTime instanceof Date && this.params.TIMEEXTENT.endTime instanceof Date) {
				var startTime = Date.parse(this.params.TIMEEXTENT.startTime);
				var endTime = Date.parse(this.params.TIMEEXTENT.endTime);
				this.params.TIME = startTime + "," + endTime;
				delete this.params.TIMEEXTENT;
			}
		}
    },    

    
    /**
     * Method: destroy
     * Destroy this layer
     */
    destroy: function() {
        // for now, nothing special to do here. 
        OpenLayers.Layer.Grid.prototype.destroy.apply(this, arguments);  
    },   
    
    /**
     * Method: clone
     * Create a clone of this layer
     *
     * Returns:
     * {<Geo.View2D.Layer.DynamicMapService>} An exact clone of this layer
     */
    clone: function (obj) {
        
        if (obj == null) {
            obj = new Geo.View2D.Layer.DynamicMapService(this.name,
                                           this.url,
                                           this.params,
                                           this.getOptions());
        }

        //get all additions from superclasses
        obj = OpenLayers.Layer.Grid.prototype.clone.apply(this, [obj]);

        // copy/set any non-init, non-simple values here

        return obj;
    },
    
    /**
     * Method: getURL
     * Return an image url this layer.
     *
     * Parameters:
     * bounds - {<OpenLayers.Bounds>} A bounds representing the bbox for the
     *                                request.
     *
     * Returns:
     * {String} A string with the map image's url.
     */
    getURL: function (bounds) {
        bounds = this.adjustBounds(bounds);

        // ArcGIS Server only wants the numeric portion of the projection ID.
        var projWords = this.projection.getCode().split(":");
        var srid = projWords[projWords.length - 1];

        var imageSize = this.getImageSize(); 
        var newParams = {
            'BBOX': bounds.toBBOX(),
            'SIZE': imageSize.w + "," + imageSize.h,
            // We always want image, the other options were json, image with a whole lotta html around it, etc.
            'F': "image",
            'BBOXSR': srid,
            'IMAGESR': srid
        };

        // Now add the filter parameters.
        if (this.layerDefs) {
            var layerDefStrList = [];
            var layerID;
            for(layerID in this.layerDefs) {
                if (this.layerDefs.hasOwnProperty(layerID)) {
                    if (this.layerDefs[layerID]) {
                        layerDefStrList.push(layerID);
                        layerDefStrList.push(":");
                        layerDefStrList.push(this.layerDefs[layerID]);
                        layerDefStrList.push(";");
                    }
                }
            }
            if (layerDefStrList.length > 0) {
                newParams['LAYERDEFS'] = layerDefStrList.join("");
            }
        }
        var requestString = this.getFullRequestString(newParams);
        return requestString;
    },
    
    /**
     * Method: setLayerFilter
     * addTile creates a tile, initializes it, and adds it to the layer div. 
     *
     * Parameters:
     * id - {String} The id of the layer to which the filter applies.
     * queryDef - {String} A sql-ish query filter, for more detail see the ESRI
     *                     documentation at http://sampleserver1.arcgisonline.com/ArcGIS/SDK/REST/export.html
     */
    setLayerFilter: function ( id, queryDef ) {
        if (!this.layerDefs) {
            this.layerDefs = {};
        }
        if (queryDef) {
            this.layerDefs[id] = queryDef;
        } else {
            delete this.layerDefs[id];
        }
    },
    
    /**
     * Method: clearLayerFilter
     * Clears layer filters, either from a specific layer,
     * or all of them.
     *
     * Parameters:
     * id - {String} The id of the layer from which to remove any
     *               filter.  If unspecified/blank, all filters
     *               will be removed.
     */
    clearLayerFilter: function ( id ) {
        if (id) {
            delete this.layerDefs[id];
        } else {
            delete this.layerDefs;
        }
    },
    
    /**
     * APIMethod: mergeNewParams
     * 在调用父类的可变参数以前将可变参数与大写的新参数合并。一旦参数变化，瓦片将会使用新的参数重新加载。
     * 
     * Parameters:
     * newParams - {Object}键值对参数，参数是本类的成员属性
     */
    mergeNewParams:function(newParams) {
        var upperParams = OpenLayers.Util.upperCaseObject(newParams);
        var newArguments = [upperParams];
        return OpenLayers.Layer.Grid.prototype.mergeNewParams.apply(this, 
                                                             newArguments);
    },

    CLASS_NAME: "Geo.View2D.Layer.DynamicMapService"
});/**
 * Class: Geo.View2D.Layer.TileMapService
 *	 地图瓦片图层。该服务请求的瓦片是服务端已经缓存好的瓦片，而不是实时渲染生成的。  
 *   本图层支持的服务类型：OGC_Geo_MapService_Rest、Arcgis_MapService_Rest
 */
Geo.View2D.Layer.TileMapService = Geo.Class(Geo.View2D.Layer.XYZ, {  

    /**
     * APIProperty: url
     * {String | Array}瓦片图层服务地址. 如果服务提供了多个原点，那么这里可以填写
     * 多个服务地址
     */
    url: null,
    
   /**
    * APIProperty: tileOrigin
    * {<Geo.LonLat>} 瓦片原点
    */
    tileOrigin: null, 
   
   /**
    * APIProperty: tileSize
    * {<Geo.Size>} 每个瓦片的大小，默认宽高是256像素
    */
    tileSize: new Geo.Size(256, 256),
    
   /**
    * APIProperty: useArcGISServer
    * {Boolean} 是否按照tile/z/y/x格式去请求瓦片。
    * 如果为true,请求格式为tile/z/y/x；如果为false,请求格式为tile/z/y/x.type；其中type为瓦片类型，其默认值为png
	*	
    */    
    useArcGISServer: true,

   /**
    * APIProperty: type
    * {String}请求瓦片的格式
    */
    type: 'png',
    
   /**
    * Constructor: Geo.View2D.Layer.TileMapService
    * 创建一个地图瓦片图层
    * 
    * Parameters: 
    * name - {String} 图层名
    * url - {String} 切片地图服务地址
    * options - {Object} 键值对对象。可以设置本类及其父类的属性。具体拼写格式请参照下面的示例：
    * 
    * (code)
    * 	//墨卡托投影下创建地图服务瓦片图层
	* 	var tileLayer = new Geo.View2D.Layer.TileMapService( "TileMapService",
    *     	"http://services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer", {
    *       isBaseLayer: true,                    
    *       tileSize: new Geo.Size(256, 256),                        
    *       tileOrigin: new Geo.LonLat(-20037508.342787 , 20037508.342787),                        
    *       maxExtent: new Geo.Bounds(-20037507.067162,-19971868.880409,20037507.067162,19971868.880409)
    *  });
    * (end)
    * 	
    */ 
    initialize: function(name, url, options) { 
        Geo.View2D.Layer.XYZ.prototype.initialize.apply(this, arguments);

        if (this.resolutions) {        
            this.serverResolutions = this.resolutions;
       //     this.maxExtent = this.getMaxExtentForResolution(this.resolutions[0]);
        }

        // this block steps through translating the values from the server layer JSON 
        // capabilities object into values that we can use.  This is also a helpful
        // reference when configuring this layer directly.
        if (this.layerInfo) {
            // alias the object
            var info = this.layerInfo;
            
            // build our extents
            var startingTileExtent = new Geo.Bounds(
                info.fullExtent.xmin, 
                info.fullExtent.ymin, 
                info.fullExtent.xmax, 
                info.fullExtent.ymax  
            );

            // set our projection based on the given spatial reference.
            // esri uses slightly different IDs, so this may not be comprehensive
            this.projection = 'EPSG:' + info.spatialReference.wkid;
            this.sphericalMercator = (info.spatialReference.wkid == 102100);
            
            // convert esri units into openlayers units (basic feet or meters only)
            this.units = (info.units == "esriFeet") ? 'ft' : 'm';

            // optional extended section based on whether or not the server returned
            // specific tile information
            if (!!info.tileInfo) {            
                // either set the tiles based on rows/columns, or specific width/height
                this.tileSize = new Geo.Size(
                    info.tileInfo.width || info.tileInfo.cols, 
                    info.tileInfo.height || info.tileInfo.rows
                );
                
                // this must be set when manually configuring this layer
                this.tileOrigin = new Geo.LonLat(
                    info.tileInfo.origin.x, 
                    info.tileInfo.origin.y
                );

                var upperLeft = new Geo.Geometry.Point(
                    startingTileExtent.left, 
                    startingTileExtent.top
                );
                
                var bottomRight = new Geo.Geometry.Point(
                    startingTileExtent.right, 
                    startingTileExtent.bottom
                );            
                
                if (this.useScales) {
                    this.scales = [];
                } else {
                    this.resolutions = [];
                }
                
                this.lods = [];
                for(var key in info.tileInfo.lods) {
                    if (info.tileInfo.lods.hasOwnProperty(key)) {
                        var lod = info.tileInfo.lods[key];
                        if (this.useScales) {
                            this.scales.push(lod.scale);
                        } else {
                            this.resolutions.push(lod.resolution);
                        }
                    
                        var start = this.getContainingTileCoords(upperLeft, lod.resolution);
                        lod.startTileCol = start.x;
                        lod.startTileRow = start.y;
                    
                        var end = this.getContainingTileCoords(bottomRight, lod.resolution);
                        lod.endTileCol = end.x;
                        lod.endTileRow = end.y;    
                        this.lods.push(lod);
                    }
                }

                this.maxExtent = this.calculateMaxExtentWithLOD(this.lods[0]);
                this.serverResolutions = this.resolutions;
                if (this.overrideDPI && info.tileInfo.dpi) {
                    // see comment above for 'overrideDPI'
                    OpenLayers.DOTS_PER_INCH = info.tileInfo.dpi;
                }
            } 
       }
    }, 

   /** 
    * Method: getContainingTileCoords
    * Calculates the x/y pixel corresponding to the position of the tile
    *     that contains the given point and for the for the given resolution.
    * 
    * Parameters:
    * point - {<Geo.Geometry.Point>} 
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<Geo.Pixel>} The x/y pixel corresponding to the position 
    * of the upper left tile for the given resolution.
    */
    getContainingTileCoords: function(point, res) {
        return new Geo.Pixel(
           Math.max(Math.floor((point.x - this.tileOrigin.lon) / (this.tileSize.w * res)),0),
           Math.max(Math.floor((this.tileOrigin.lat - point.y) / (this.tileSize.h * res)),0)
        );
    },
    
   /** 
    * Method: calculateMaxExtentWithLOD
    * Given a Level of Detail object from the server, this function
    *     calculates the actual max extent
    * 
    * Parameters: 
    * lod - {Object} a Level of Detail Object from the server capabilities object 
            representing a particular zoom level
    * 
    * Returns: 
    * {<Geo.Bounds>} The actual extent of the tiles for the given zoom level
    */
   calculateMaxExtentWithLOD: function(lod) {
        // the max extent we're provided with just overlaps some tiles
        // our real extent is the bounds of all the tiles we touch

        var numTileCols = (lod.endTileCol - lod.startTileCol) + 1;
        var numTileRows = (lod.endTileRow - lod.startTileRow) + 1;        

        var minX = this.tileOrigin.lon + (lod.startTileCol * this.tileSize.w * lod.resolution);
        var maxX = minX + (numTileCols * this.tileSize.w * lod.resolution);

        var maxY = this.tileOrigin.lat - (lod.startTileRow * this.tileSize.h * lod.resolution);
        var minY = maxY - (numTileRows * this.tileSize.h * lod.resolution);
        return new Geo.Bounds(minX, minY, maxX, maxY);
   },
    
   /** 
    * Method: calculateMaxExtentWithExtent
    * Given a 'suggested' max extent from the server, this function uses
    *     information about the actual tile sizes to determine the actual
    *     extent of the layer.
    * 
    * Parameters: 
    * extent - {<Geo.Bounds>} The 'suggested' extent for the layer
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<Geo.Bounds>} The actual extent of the tiles for the given zoom level
    */
   calculateMaxExtentWithExtent: function(extent, res) {
        var upperLeft = new Geo.Geometry.Point(extent.left, extent.top);
        var bottomRight = new Geo.Geometry.Point(extent.right, extent.bottom);
        var start = this.getContainingTileCoords(upperLeft, res);
        var end = this.getContainingTileCoords(bottomRight, res);
        var lod = {
            resolution: res,
            startTileCol: start.x,
            startTileRow: start.y,
            endTileCol: end.x,
            endTileRow: end.y
        };
        return this.calculateMaxExtentWithLOD(lod);
   },
    
    /** 
    * Method: getUpperLeftTileCoord
    * Calculates the x/y pixel corresponding to the position 
    *     of the upper left tile for the given resolution.
    * 
    * Parameters: 
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<Geo.Pixel>} The x/y pixel corresponding to the position 
    * of the upper left tile for the given resolution.
    */
    getUpperLeftTileCoord: function(res) {
        var upperLeft = new Geo.Geometry.Point(
            this.maxExtent.left,
            this.maxExtent.top);
        return this.getContainingTileCoords(upperLeft, res);
    },

    /** 
    * Method: getLowerRightTileCoord
    * Calculates the x/y pixel corresponding to the position 
    *     of the lower right tile for the given resolution.
    *  
    * Parameters: 
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<Geo.Pixel>} The x/y pixel corresponding to the position
    * of the lower right tile for the given resolution.
    */
    getLowerRightTileCoord: function(res) {
        var bottomRight = new Geo.Geometry.Point(
            this.maxExtent.right,
            this.maxExtent.bottom);
        return this.getContainingTileCoords(bottomRight, res);
    },
    
   /** 
    * Method: getMaxExtentForResolution
    * Since the max extent of a set of tiles can change from zoom level
    *     to zoom level, we need to be able to calculate that max extent 
    *     for a given resolution.
    * 在进行级别切换的时候瓦片的最大范围会发生变化，所以我们需要计算给定分辨率的最大范围。
    * Parameters: 
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<Geo.Bounds>} The extent for this resolution
    */ 
    getMaxExtentForResolution: function(res) {
        var start = this.getUpperLeftTileCoord(res);
        var end = this.getLowerRightTileCoord(res);

        var numTileCols = (end.x - start.x) + 1;
        var numTileRows = (end.y - start.y) + 1;

        var minX = this.tileOrigin.lon + (start.x * this.tileSize.w * res);
        var maxX = minX + (numTileCols * this.tileSize.w * res);
        
        var maxY = this.tileOrigin.lat - (start.y * this.tileSize.h * res);
        var minY = maxY - (numTileRows * this.tileSize.h * res);
        return new Geo.Bounds(minX, minY, maxX, maxY);
    },
    
   /** 
    * APIMethod: clone 
    * 克隆图层
    * 
    * Parameters: 
    * [obj] - {Object} 传入本对象的一个实例.
    *  
    * Returns: 
    * {<Geo.View2D.Layer.ArcGISCache>} 返回克隆对象 
    */ 
    clone: function (obj) { 
        if (obj == null) { 
            obj = new Geo.View2D.Layer.TileMapService(this.name, this.url, this.options);
        }
        return Geo.View2D.Layer.XYZ.prototype.clone.apply(this, [obj]);
    },

    /**
     * Method: getMaxExtent
     * Get this layer's maximum extent.
     *	获取当前图层的最大范围
     * Returns:
     * {Geo.Bounds}
     */
    getMaxExtent: function() {
        var resolution = this.map.getResolution();
        return this.maxExtent = this.getMaxExtentForResolution(resolution);
    },

    /**
     * Method: getTileOrigin
     * Determine the origin for aligning the grid of tiles.  
     *     The origin will be derived from the layer's <maxExtent> property. 
     * 根据图层的最大范围获取瓦片的原点。
     * Returns:
     * {<Geo.LonLat>} The tile origin.
     */
    getTileOrigin: function() {
        var extent = this.getMaxExtent();
        return new Geo.LonLat(extent.left, extent.bottom);
    },

   /**
    * Method: getURL
    * Determine the URL for a tile given the tile bounds.  This is should support
    *     urls that access tiles through an ArcGIS Server MapServer or directly through
    *     the hex folder structure using HTTP.  Just be sure to set the useArcGISServer
    *     property appropriately!  This is basically the same as 
    *     'OpenLayers.Layer.TMS.getURL',  but with the addition of hex addressing,
    *     and tile rounding.
    *	
    * Parameters:
    * bounds - {<Geo.Bounds>}
    *
    * Returns:
    * {String} The URL for a tile based on given bounds.
    */
	getURL: function (bounds) {
		bounds = this.adjustBounds(bounds);
        var res = this.map.getResolution();
        var x = Math.round((bounds.left - this.tileOrigin.lon) /
            (res * this.tileSize.w));
        var y = Math.round((this.tileOrigin.lat - bounds.top) /
            (res * this.tileSize.h));
        var z = 
            this.map.getZoom() + this.zoomOffset;

        var limit = Math.pow(2, z);
        if (this.wrapDateLine)
        {
           x = ((x % limit) + limit) % limit;
        }

   //     return {'x': x, 'y': y, 'z': z};
   		var url = this.url;
		var location = url.indexOf("/",url.length - 1);
		if(location != -1) {
			url = url + 'tile/${z}/${y}/${x}';
		}else {
			url = url + '/tile/${z}/${y}/${x}';
		}
//		url = url + '/tile/${z}/${y}/${x}';
        // Write the values into our formatted url
        url = OpenLayers.String.format(url, {'x': x, 'y': y, 'z': z});

        return url;
    }, 

    /**
     * Method: zeroPad
     * Create a zero padded string optionally with a radix for casting numbers.
     *
     * Parameters:
     * num - {Number} The number to be zero padded.
     * len - {Number} The length of the string to be returned.
     * radix - {Number} An integer between 2 and 36 specifying the base to use
     *     for representing numeric values.
     */
    zeroPad: function(num, len, radix) {
        var str = num.toString(radix || 10);
        while (str.length < len) {
            str = "0" + str;
        }
        return str;
    },

    CLASS_NAME: 'Geo.View2D.Layer.TileMapService' 
}); /**
 * Class: Geo.View2D.Layer.GeoMarkers
 * 吉奥标记图层构造类，本类的实例用来在吉奥标记图层上显示地图上的吉奥标记。
 * 
 * Inherits from:
 *  - <Geo.View2D.Layer.Markers> 
 */
Geo.View2D.Layer.GeoMarkers = Geo.Class(Geo.View2D.Layer.Markers, {

    /** 
     * Method: drawMarker
     * Calculate the pixel location for the marker, create it, and 
     *    add it to the layer's div
     *
     * Parameters:
     * marker - {<OpenLayers.Marker>} 
     */
    drawMarker: function(marker) {
        var px = this.map.getLayerPxFromLonLat(marker.lonlat);
        if (px == null) {
            marker.display(false);
        } else {
            if (!marker.isDrawn()) {
                var markerImg = marker.draw(px);
                this.div.appendChild(markerImg);
            } else if(marker.icon) {
                marker.icon.moveTo(px);
            }
			// 新增标签div绘制
			if (!marker.isDrawnTag()) {
                var div = marker.drawTag(px);
				if(div){
					this.div.appendChild(div);
				}
            } else if(marker.tag) {
                marker.tag.moveTo(px);
            }
        }
    },
    
    CLASS_NAME: "Geo.View2D.Layer.GeoMarkers"
});
/**
 * Class: Geo.View2D.ChartContainer
 * 专题图图表容器类。
 */
Geo.View2D.ChartContainer = Geo.Class({

    /** 
     * Property: events  
     * {<OpenLayers.Events>} custom event manager 
     */
    events: null,
    
    /** Property: id
     * {String} the unique identifier assigned to this popup.
     */
    id: "",

    /** 
     * Property: lonlat 
     * {<OpenLayers.LonLat>} the position of this popup on the map
     */
    lonlat: null,

    /** 
     * Property: div 
     * {DOMElement} the div that contains this popup.
     */
    div: null,

    /** 
     * Property: contentSize 
     * {<OpenLayers.Size>} the width and height of the content.
     */
    contentSize: null,    

    /** 
     * Property: size 
     * {<OpenLayers.Size>} the width and height of the popup.
     */
    size: null,    

    /** 
     * Property: contentHTML 
     * {String} An HTML string for this popup to display.
     */
    contentHTML: null,
    
    /** 
     * Property: backgroundColor 
     * {String} the background color used by the popup.
     */
    backgroundColor: "",
    
    /** 
     * Property: opacity 
     * {float} the opacity of this popup (between 0.0 and 1.0)
     */
    opacity: "",

    /** 
     * Property: border 
     * {String} the border size of the popup.  (eg 2px)
     */
    border: "",
    
    /** 
     * Property: contentDiv 
     * {DOMElement} a reference to the element that holds the content of
     *              the div.
     */
    contentDiv: null,
    
    /** 
     * Property: groupDiv 
     * {DOMElement} First and only child of 'div'. The group Div contains the
     *     'contentDiv' and the 'closeDiv'.
     */
    groupDiv: null,

    /** 
     * Property: closeDiv
     * {DOMElement} the optional closer image
     */
    closeDiv: null,

    /** 
     * APIProperty: autoSize
     * {Boolean} 根据内容自动调整浮云的大小，默认为false。
     */
    autoSize: false,

    /**
     * APIProperty: minSize
     * {<Geo.Size>}允许窗口显示的最小尺寸。
     */
    minSize: null,

    /**
     * APIProperty: maxSize
     * {<Geo.Size>}允许窗口显示的最大尺寸。
     */
    maxSize: null,

    /** 
     * Property: displayClass
     * {String} The CSS class of the popup.
     */
    displayClass: "olPopup",

    /** 
     * Property: contentDisplayClass
     * {String} The CSS class of the popup content div.
     */
    contentDisplayClass: "olPopupContent",

    /** 
     * Property: padding 
     * {int or <OpenLayers.Bounds>} An extra opportunity to specify internal 
     *     padding of the content div inside the popup. This was originally
     *     confused with the css padding as specified in style.css's 
     *     'olPopupContent' class. We would like to get rid of this altogether,
     *     except that it does come in handy for the framed and anchoredbubble
     *     popups, who need to maintain yet another barrier between their 
     *     content and the outer border of the popup itself. 
     * 
     *     Note that in order to not break API, we must continue to support 
     *     this property being set as an integer. Really, though, we'd like to 
     *     have this specified as a Bounds object so that user can specify
     *     distinct left, top, right, bottom paddings. With the 3.0 release
     *     we can make this only a bounds.
     */
    padding: 0,

    /** 
     * Property: disableFirefoxOverflowHack
     * {Boolean} The hack for overflow in Firefox causes all elements 
     *     to be re-drawn, which causes Flash elements to be 
     *     re-initialized, which is troublesome.
     *     With this property the hack can be disabled.
     */
    disableFirefoxOverflowHack: false,

    /**
     * Method: fixPadding
     * To be removed in 3.0, this function merely helps us to deal with the 
     *     case where the user may have set an integer value for padding, 
     *     instead of an <OpenLayers.Bounds> object.
     */
    fixPadding: function() {
        if (typeof this.padding == "number") {
            this.padding = new OpenLayers.Bounds(
                this.padding, this.padding, this.padding, this.padding
            );
        }
    },

    /**
     * APIProperty: panMapIfOutOfView
     *  {Boolean} 当绘制和地图的上下左右移动时，整个弹出框在当前视口是可见的。默认为false。
     */
    panMapIfOutOfView: false,
    
    /**
     * APIProperty: keepInMap 
     * {Boolean} 将该容器保存在地图对象里，默认为false。
     */
    keepInMap: false,

    /**
     * APIProperty: closeOnMove
     * {Boolean} 当地图平移时，关闭该容器。默认为false。
     */
    closeOnMove: false,

    /**
     * APIProperty: offset
     * {<Geo.Pixel>} 像素对象，表示图表容器的偏移量。
     */
    offset: null,
    
    /** 
     * Property: map 
     * {<OpenLayers.Map>} this gets set in Map.js when the popup is added to the map
     */
    map: null,

    /** 
    * Constructor: Geo.View2D.ChartContainer
    * 创建一个专题图图表容器。
    * 
    * Parameters: 
    * id - {String}  该容器的唯一标识，如果没有设置将会自动生成一个。
    * lonlat - {<Geo.LonLat>}  容器显示的地理位置。
    * contentSize - {<Geo.Size>} 容器的尺寸。
    * contentHTML - {String}  容器内容。
    * closeBox - {Boolean}   是否显示关闭该容器。
    * closeBoxCallback - {Function}   点击关闭该容器时的回调方法。
    */
    initialize:function(id, lonlat, contentSize, contentHTML, closeBox, closeBoxCallback) {
        if (id == null) {
            id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
        }

        this.id = id;
        this.lonlat = lonlat;

        this.contentSize = (contentSize != null) ? contentSize 
                                  : new OpenLayers.Size(
                                                   Geo.View2D.ChartContainer.WIDTH,
                                                   Geo.View2D.ChartContainer.HEIGHT);
        if (contentHTML != null) { 
             this.contentHTML = contentHTML;
        }
        this.backgroundColor = Geo.View2D.ChartContainer.COLOR;
        this.opacity = Geo.View2D.ChartContainer.OPACITY;
        this.border = Geo.View2D.ChartContainer.BORDER;

        this.div = OpenLayers.Util.createDiv(this.id, null, null, 
                                             null, null, null, "hidden");
        this.div.className = this.displayClass;
        
        var groupDivId = this.id + "_GroupDiv";
        this.groupDiv = OpenLayers.Util.createDiv(groupDivId, null, null, 
                                                    null, "relative", null,
                                                    "hidden");

        var id = this.div.id + "_contentDiv";
        this.contentDiv = OpenLayers.Util.createDiv(id, null, this.contentSize.clone(), 
                                                    null, "relative");
        this.contentDiv.className = this.contentDisplayClass;
        this.groupDiv.appendChild(this.contentDiv);
        this.div.appendChild(this.groupDiv);

        if (closeBox) {
            this.addCloseBox(closeBoxCallback);
        } 

        this.registerEvents();
    },

    /** 
     * Method: destroy
     * nullify references to prevent circular references and memory leaks
     */
    destroy: function() {

        this.id = null;
        this.lonlat = null;
        this.size = null;
        this.contentHTML = null;
        
        this.backgroundColor = null;
        this.opacity = null;
        this.border = null;
        
        if (this.closeOnMove && this.map) {
            this.map.events.unregister("movestart", this, this.hide);
        }

        this.events.destroy();
        this.events = null;
        
        if (this.closeDiv) {
            OpenLayers.Event.stopObservingElement(this.closeDiv); 
            this.groupDiv.removeChild(this.closeDiv);
        }
        this.closeDiv = null;
        
        this.div.removeChild(this.groupDiv);
        this.groupDiv = null;

        if (this.map != null) {
            this.map.removePopup(this);
        }
        this.map = null;
        this.div = null;
        
        this.autoSize = null;
        this.minSize = null;
        this.maxSize = null;
        this.padding = null;
        this.panMapIfOutOfView = null;
    },

    /** 
    * Method: draw
    * Constructs the elements that make up the popup.
    *
    * Parameters:
    * px - {<OpenLayers.Pixel>} the position the popup in pixels.
    * 
    * Returns:
    * {DOMElement} Reference to a div that contains the drawn popup
    */
    draw: function(px) {
        if (px == null) {
            if ((this.lonlat != null) && (this.map != null)) {
                px = this.map.getLayerPxFromLonLat(this.lonlat);
            }
        }

        // this assumes that this.map already exists, which is okay because 
        // this.draw is only called once the popup has been added to the map.
        if (this.closeOnMove) {
            this.map.events.register("movestart", this, this.hide);
        }
        
        //listen to movestart, moveend to disable overflow (FF bug)
        if (!this.disableFirefoxOverflowHack && OpenLayers.BROWSER_NAME == 'firefox') {
            this.map.events.register("movestart", this, function() {
                var style = document.defaultView.getComputedStyle(
                    this.contentDiv, null
                );
                var currentOverflow = style.getPropertyValue("overflow");
                if (currentOverflow != "hidden") {
                    this.contentDiv._oldOverflow = currentOverflow;
                    this.contentDiv.style.overflow = "hidden";
                }
            });
            this.map.events.register("moveend", this, function() {
                var oldOverflow = this.contentDiv._oldOverflow;
                if (oldOverflow) {
                    this.contentDiv.style.overflow = oldOverflow;
                    this.contentDiv._oldOverflow = null;
                }
            });
        }

        this.moveTo(px);
        if (!this.autoSize && !this.size) {
            this.setSize(this.contentSize);
        }
        this.setBackgroundColor();
        this.setOpacity();
        this.setBorder();
        this.setContentHTML();
        
        if (this.panMapIfOutOfView) {
            this.panIntoView();
        }    

        return this.div;
    },

    /** 
     * Method: updatePosition
     * if the popup has a lonlat and its map members set, 
     * then have it move itself to its proper position
     */
    updatePosition: function() {
        if ((this.lonlat) && (this.map)) {
            var px = this.map.getLayerPxFromLonLat(this.lonlat);
            if (px) {
                this.moveTo(px);           
            }    
        }
    },

    /**
     * Method: moveTo
     * 
     * Parameters:
     * px - {<OpenLayers.Pixel>} the top and left position of the popup div. 
     */
    moveTo: function(px) {
        if ((px != null) && (this.div != null)) {
			var px = px.offset(this.offset);
            this.div.style.left = px.x + "px";
            this.div.style.top = px.y + "px";
        }
    },

    /**
     * Method: visible
     *
     * Returns:      
     * {Boolean} Boolean indicating whether or not the popup is visible
     */
    visible: function() {
        return OpenLayers.Element.visible(this.div);
    },

    /**
     * Method: toggle
     * Toggles visibility of the popup.
     */
    toggle: function() {
        if (this.visible()) {
            this.hide();
        } else {
            this.show();
        }
    },

    /**
     * Method: show
     * Makes the popup visible.
     */
    show: function() {
        this.div.style.display = '';

        if (this.panMapIfOutOfView) {
            this.panIntoView();
        }    
    },

    /**
     * Method: hide
     * Makes the popup invisible.
     */
    hide: function() {
        this.div.style.display = 'none';
    },

    /**
     * Method: setSize
     * Used to adjust the size of the popup. 
     *
     * Parameters:
     * contentSize - {<OpenLayers.Size>} the new size for the popup's 
     *     contents div (in pixels).
     */
    setSize:function(contentSize) { 
        this.size = contentSize.clone(); 
        
        // if our contentDiv has a css 'padding' set on it by a stylesheet, we 
        //  must add that to the desired "size". 
        var contentDivPadding = this.getContentDivPadding();
        var wPadding = contentDivPadding.left + contentDivPadding.right;
        var hPadding = contentDivPadding.top + contentDivPadding.bottom;

        // take into account the popup's 'padding' property
        this.fixPadding();
        wPadding += this.padding.left + this.padding.right;
        hPadding += this.padding.top + this.padding.bottom;

        // make extra space for the close div
        if (this.closeDiv) {
            var closeDivWidth = parseInt(this.closeDiv.style.width);
            wPadding += closeDivWidth + contentDivPadding.right;
        }

        //increase size of the main popup div to take into account the 
        // users's desired padding and close div.        
        this.size.w += wPadding;
        this.size.h += hPadding;

        //now if our browser is IE, we need to actually make the contents 
        // div itself bigger to take its own padding into effect. this makes 
        // me want to shoot someone, but so it goes.
        if (OpenLayers.BROWSER_NAME == "msie") {
            this.contentSize.w += 
                contentDivPadding.left + contentDivPadding.right;
            this.contentSize.h += 
                contentDivPadding.bottom + contentDivPadding.top;
        }

        if (this.div != null) {
            this.div.style.width = this.size.w + "px";
            this.div.style.height = this.size.h + "px";
        }
        if (this.contentDiv != null){
            this.contentDiv.style.width = contentSize.w + "px";
            this.contentDiv.style.height = contentSize.h + "px";
        }
    },  

    /**
     * APIMethod: updateSize
     * 更新尺寸大小。
     */
    updateSize: function() {
        
        // determine actual render dimensions of the contents by putting its
        // contents into a fake contentDiv (for the CSS) and then measuring it
        var preparedHTML = "<div class='" + this.contentDisplayClass+ "'>" + 
            this.contentDiv.innerHTML + 
            "</div>";
 
        var containerElement = (this.map) ? this.map.layerContainerDiv
        								  : document.body;
        var realSize = OpenLayers.Util.getRenderedDimensions(
            preparedHTML, null,	{
                displayClass: this.displayClass,
                containerElement: containerElement
            }
        );

        // is the "real" size of the div is safe to display in our map?
        var safeSize = this.getSafeContentSize(realSize);

        var newSize = null;
        if (safeSize.equals(realSize)) {
            //real size of content is small enough to fit on the map, 
            // so we use real size.
            newSize = realSize;

        } else {

            //make a new OL.Size object with the clipped dimensions 
            // set or null if not clipped.
            var fixedSize = new OpenLayers.Size();
            fixedSize.w = (safeSize.w < realSize.w) ? safeSize.w : null;
            fixedSize.h = (safeSize.h < realSize.h) ? safeSize.h : null;
        
            if (fixedSize.w && fixedSize.h) {
                //content is too big in both directions, so we will use 
                // max popup size (safeSize), knowing well that it will 
                // overflow both ways.                
                newSize = safeSize;
            } else {
                //content is clipped in only one direction, so we need to 
                // run getRenderedDimensions() again with a fixed dimension
                var clippedSize = OpenLayers.Util.getRenderedDimensions(
                    preparedHTML, fixedSize, {
                        displayClass: this.contentDisplayClass,
                        containerElement: containerElement
                    }
                );
                
                //if the clipped size is still the same as the safeSize, 
                // that means that our content must be fixed in the 
                // offending direction. If overflow is 'auto', this means 
                // we are going to have a scrollbar for sure, so we must 
                // adjust for that.
                //
                var currentOverflow = OpenLayers.Element.getStyle(
                    this.contentDiv, "overflow"
                );
                if ( (currentOverflow != "hidden") && 
                     (clippedSize.equals(safeSize)) ) {
                    var scrollBar = OpenLayers.Util.getScrollbarWidth();
                    if (fixedSize.w) {
                        clippedSize.h += scrollBar;
                    } else {
                        clippedSize.w += scrollBar;
                    }
                }
                
                newSize = this.getSafeContentSize(clippedSize);
            }
        }                        
        this.setSize(newSize);     
    },    

    /**
     * Method: setBackgroundColor
     * Sets the background color of the popup.
     *
     * Parameters:
     * color - {String} the background color.  eg "#FFBBBB"
     */
    setBackgroundColor:function(color) { 
        if (color != undefined) {
            this.backgroundColor = color; 
        }
        
        if (this.div != null) {
            this.div.style.backgroundColor = this.backgroundColor;
        }
    },  
    
    /**
     * Method: setOpacity
     * Sets the opacity of the popup.
     * 
     * Parameters:
     * opacity - {float} A value between 0.0 (transparent) and 1.0 (solid).   
     */
    setOpacity:function(opacity) { 
        if (opacity != undefined) {
            this.opacity = opacity; 
        }
        
        if (this.div != null) {
            // for Mozilla and Safari
            this.div.style.opacity = this.opacity;

            // for IE
            //this.div.style.filter = 'alpha(opacity=' + this.opacity*100 + ')';
        }
    },  
    
    /**
     * Method: setBorder
     * Sets the border style of the popup.
     *
     * Parameters:
     * border - {String} The border style value. eg 2px 
     */
    setBorder:function(border) { 
        if (border != undefined) {
            this.border = border;
        }
        
        if (this.div != null) {
            this.div.style.border = this.border;
        }
    },      
    
    /**
     * Method: setContentHTML
     * Allows the user to set the HTML content of the popup.
     *
     * Parameters:
     * contentHTML - {String} HTML for the div.
     */
    setContentHTML:function(contentHTML) {

        if (contentHTML != null) {
            this.contentHTML = contentHTML;
        }
       
        if ((this.contentDiv != null) && 
            (this.contentHTML != null) &&
            (this.contentHTML != this.contentDiv.innerHTML)) {
       
            this.contentDiv.innerHTML = this.contentHTML;
       
            if (this.autoSize) {
                
                //if popup has images, listen for when they finish
                // loading and resize accordingly
                this.registerImageListeners();

                //auto size the popup to its current contents
                this.updateSize();
            }
        }    

    },
    
    /**
     * Method: registerImageListeners
     * Called when an image contained by the popup loaded. this function
     *     updates the popup size, then unregisters the image load listener.
     */   
    registerImageListeners: function() { 

        // As the images load, this function will call updateSize() to 
        // resize the popup to fit the content div (which presumably is now
        // bigger than when the image was not loaded).
        // 
        // If the 'panMapIfOutOfView' property is set, we will pan the newly
        // resized popup back into view.
        // 
        // Note that this function, when called, will have 'popup' and 
        // 'img' properties in the context.
        //
        var onImgLoad = function() {
            
            this.popup.updateSize();
     
            if ( this.popup.visible() && this.popup.panMapIfOutOfView ) {
                this.popup.panIntoView();
            }

            OpenLayers.Event.stopObserving(
                this.img, "load", this.img._onImageLoad
            );
    
        };

        //cycle through the images and if their size is 0x0, that means that 
        // they haven't been loaded yet, so we attach the listener, which 
        // will fire when the images finish loading and will resize the 
        // popup accordingly to its new size.
        var images = this.contentDiv.getElementsByTagName("img");
        for (var i = 0, len = images.length; i < len; i++) {
            var img = images[i];
            if (img.width == 0 || img.height == 0) {

                var context = {
                    'popup': this,
                    'img': img
                };

                //expando this function to the image itself before registering
                // it. This way we can easily and properly unregister it.
                img._onImgLoad = OpenLayers.Function.bind(onImgLoad, context);

                OpenLayers.Event.observe(img, 'load', img._onImgLoad);
            }    
        } 
    },

    /**
     * APIMethod: getSafeContentSize
     * 该容器的尺寸既不小于最小尺寸，也不大于最大尺寸，而是计算相对于视口的合适尺寸大小。
     * 
     * Parameters:
     * size - {<Geo.Size>} 所需区域的大小。
     * 
     * Returns:
     * {<Geo.Size>} 返回合适的尺寸。
     */
    getSafeContentSize: function(size) {

        var safeContentSize = size.clone();

        // if our contentDiv has a css 'padding' set on it by a stylesheet, we 
        //  must add that to the desired "size". 
        var contentDivPadding = this.getContentDivPadding();
        var wPadding = contentDivPadding.left + contentDivPadding.right;
        var hPadding = contentDivPadding.top + contentDivPadding.bottom;

        // take into account the popup's 'padding' property
        this.fixPadding();
        wPadding += this.padding.left + this.padding.right;
        hPadding += this.padding.top + this.padding.bottom;

        if (this.closeDiv) {
            var closeDivWidth = parseInt(this.closeDiv.style.width);
            wPadding += closeDivWidth + contentDivPadding.right;
        }

        // prevent the popup from being smaller than a specified minimal size
        if (this.minSize) {
            safeContentSize.w = Math.max(safeContentSize.w, 
                (this.minSize.w - wPadding));
            safeContentSize.h = Math.max(safeContentSize.h, 
                (this.minSize.h - hPadding));
        }

        // prevent the popup from being bigger than a specified maximum size
        if (this.maxSize) {
            safeContentSize.w = Math.min(safeContentSize.w, 
                (this.maxSize.w - wPadding));
            safeContentSize.h = Math.min(safeContentSize.h, 
                (this.maxSize.h - hPadding));
        }
        
        //make sure the desired size to set doesn't result in a popup that 
        // is bigger than the map's viewport.
        //
        if (this.map && this.map.size) {
            
            var extraX = 0, extraY = 0;
            if (this.keepInMap && !this.panMapIfOutOfView) {
                var px = this.map.getPixelFromLonLat(this.lonlat);
                switch (this.relativePosition) {
                    case "tr":
                        extraX = px.x;
                        extraY = this.map.size.h - px.y;
                        break;
                    case "tl":
                        extraX = this.map.size.w - px.x;
                        extraY = this.map.size.h - px.y;
                        break;
                    case "bl":
                        extraX = this.map.size.w - px.x;
                        extraY = px.y;
                        break;
                    case "br":
                        extraX = px.x;
                        extraY = px.y;
                        break;
                    default:    
                        extraX = px.x;
                        extraY = this.map.size.h - px.y;
                        break;
                }
            }    
          
            var maxY = this.map.size.h - 
                this.map.paddingForPopups.top - 
                this.map.paddingForPopups.bottom - 
                hPadding - extraY;
            
            var maxX = this.map.size.w - 
                this.map.paddingForPopups.left - 
                this.map.paddingForPopups.right - 
                wPadding - extraX;
            
            safeContentSize.w = Math.min(safeContentSize.w, maxX);
            safeContentSize.h = Math.min(safeContentSize.h, maxY);
        }
        
        return safeContentSize;
    },
    
    /**
     * Method: getContentDivPadding
     * Glorious, oh glorious hack in order to determine the css 'padding' of 
     *     the contentDiv. IE/Opera return null here unless we actually add the 
     *     popup's main 'div' element (which contains contentDiv) to the DOM. 
     *     So we make it invisible and then add it to the document temporarily. 
     *
     *     Once we've taken the padding readings we need, we then remove it 
     *     from the DOM (it will actually get added to the DOM in 
     *     Map.js's addPopup)
     *
     * Returns:
     * {<OpenLayers.Bounds>}
     */
    getContentDivPadding: function() {

        //use cached value if we have it
        var contentDivPadding = this._contentDivPadding;
        if (!contentDivPadding) {

        	if (this.div.parentNode == null) {
	        	//make the div invisible and add it to the page        
	            this.div.style.display = "none";
	            document.body.appendChild(this.div);
	    	}
	            
            //read the padding settings from css, put them in an OL.Bounds        
            contentDivPadding = new OpenLayers.Bounds(
                OpenLayers.Element.getStyle(this.contentDiv, "padding-left"),
                OpenLayers.Element.getStyle(this.contentDiv, "padding-bottom"),
                OpenLayers.Element.getStyle(this.contentDiv, "padding-right"),
                OpenLayers.Element.getStyle(this.contentDiv, "padding-top")
            );
    
            //cache the value
            this._contentDivPadding = contentDivPadding;

            if (this.div.parentNode == document.body) {
	            //remove the div from the page and make it visible again
	            document.body.removeChild(this.div);
	            this.div.style.display = "";
            }
        }
        return contentDivPadding;
    },

    /**
     * Method: addCloseBox
     * 
     * Parameters:
     * callback - {Function} The callback to be called when the close button
     *     is clicked.
     */
    addCloseBox: function(callback) {

        this.closeDiv = OpenLayers.Util.createDiv(
            this.id + "_close", null, new OpenLayers.Size(17, 17)
        );
        this.closeDiv.className = "olPopupCloseBox"; 
        
        // use the content div's css padding to determine if we should
        //  padd the close div
        var contentDivPadding = this.getContentDivPadding();
         
        this.closeDiv.style.right = contentDivPadding.right + "px";
        this.closeDiv.style.top = contentDivPadding.top + "px";
        this.groupDiv.appendChild(this.closeDiv);

        var closePopup = callback || function(e) {
            this.hide();
            OpenLayers.Event.stop(e);
        };
        OpenLayers.Event.observe(this.closeDiv, "touchend", 
                OpenLayers.Function.bindAsEventListener(closePopup, this));
        OpenLayers.Event.observe(this.closeDiv, "click", 
                OpenLayers.Function.bindAsEventListener(closePopup, this));
    },

    /**
     * Method: panIntoView
     * Pans the map such that the popup is totaly viewable (if necessary)
     */
    panIntoView: function() {
        
        var mapSize = this.map.getSize();
    
        //start with the top left corner of the popup, in px, 
        // relative to the viewport
        var origTL = this.map.getViewPortPxFromLayerPx( new OpenLayers.Pixel(
            parseInt(this.div.style.left),
            parseInt(this.div.style.top)
        ));
        var newTL = origTL.clone();
    
        //new left (compare to margins, using this.size to calculate right)
        if (origTL.x < this.map.paddingForPopups.left) {
            newTL.x = this.map.paddingForPopups.left;
        } else 
        if ( (origTL.x + this.size.w) > (mapSize.w - this.map.paddingForPopups.right)) {
            newTL.x = mapSize.w - this.map.paddingForPopups.right - this.size.w;
        }
        
        //new top (compare to margins, using this.size to calculate bottom)
        if (origTL.y < this.map.paddingForPopups.top) {
            newTL.y = this.map.paddingForPopups.top;
        } else 
        if ( (origTL.y + this.size.h) > (mapSize.h - this.map.paddingForPopups.bottom)) {
            newTL.y = mapSize.h - this.map.paddingForPopups.bottom - this.size.h;
        }
        
        var dx = origTL.x - newTL.x;
        var dy = origTL.y - newTL.y;
        
        this.map.pan(dx, dy);
    },

    /** 
     * Method: registerEvents
     * Registers events on the popup.
     *
     * Do this in a separate function so that subclasses can 
     *   choose to override it if they wish to deal differently
     *   with mouse events
     * 
     *   Note in the following handler functions that some special
     *    care is needed to deal correctly with mousing and popups. 
     *   
     *   Because the user might select the zoom-rectangle option and
     *    then drag it over a popup, we need a safe way to allow the
     *    mousemove and mouseup events to pass through the popup when
     *    they are initiated from outside. The same procedure is needed for
     *    touchmove and touchend events.
     * 
     *   Otherwise, we want to essentially kill the event propagation
     *    for all other events, though we have to do so carefully, 
     *    without disabling basic html functionality, like clicking on 
     *    hyperlinks or drag-selecting text.
     */
     registerEvents:function() {
        this.events = new OpenLayers.Events(this, this.div, null, true);

        function onTouchstart(evt) {
            OpenLayers.Event.stop(evt, true);
        }
        this.events.on({
            "mousedown": this.onmousedown,
            "mousemove": this.onmousemove,
            "mouseup": this.onmouseup,
            "click": this.onclick,
            "mouseout": this.onmouseout,
            "dblclick": this.ondblclick,
            "touchstart": onTouchstart,
            scope: this
        });
        
     },

    /** 
     * Method: onmousedown 
     * When mouse goes down within the popup, make a note of
     *   it locally, and then do not propagate the mousedown 
     *   (but do so safely so that user can select text inside)
     * 
     * Parameters:
     * evt - {Event} 
     */
    onmousedown: function (evt) {
        this.mousedown = true;
        OpenLayers.Event.stop(evt, true);
    },

    /** 
     * Method: onmousemove
     * If the drag was started within the popup, then 
     *   do not propagate the mousemove (but do so safely
     *   so that user can select text inside)
     * 
     * Parameters:
     * evt - {Event} 
     */
    onmousemove: function (evt) {
        if (this.mousedown) {
            OpenLayers.Event.stop(evt, true);
        }
    },

    /** 
     * Method: onmouseup
     * When mouse comes up within the popup, after going down 
     *   in it, reset the flag, and then (once again) do not 
     *   propagate the event, but do so safely so that user can 
     *   select text inside
     * 
     * Parameters:
     * evt - {Event} 
     */
    onmouseup: function (evt) {
        if (this.mousedown) {
            this.mousedown = false;
            OpenLayers.Event.stop(evt, true);
        }
    },

    /**
     * Method: onclick
     * Ignore clicks, but allowing default browser handling
     * 
     * Parameters:
     * evt - {Event} 
     */
    onclick: function (evt) {
        OpenLayers.Event.stop(evt, true);
    },

    /** 
     * Method: onmouseout
     * When mouse goes out of the popup set the flag to false so that
     *   if they let go and then drag back in, we won't be confused.
     * 
     * Parameters:
     * evt - {Event} 
     */
    onmouseout: function (evt) {
        this.mousedown = false;
    },
    
    /** 
     * Method: ondblclick
     * Ignore double-clicks, but allowing default browser handling
     * 
     * Parameters:
     * evt - {Event} 
     */
    ondblclick: function (evt) {
        OpenLayers.Event.stop(evt, true);
    },

    CLASS_NAME: "OpenLayers.Popup"
});

Geo.View2D.ChartContainer.WIDTH = 200;
Geo.View2D.ChartContainer.HEIGHT = 200;
Geo.View2D.ChartContainer.COLOR = "white";
Geo.View2D.ChartContainer.OPACITY = 1;
Geo.View2D.ChartContainer.BORDER = "0px";
/**
 * Class: Geo.View2D.Popup.GeoFrameCloud
 * 带有阴影的浮云框
 * 
 *  Inherits from:
 *  - <Geo.View2D.Popup.FramedCloud>
 */
Geo.View2D.Popup.GeoFrameCloud = Geo.Class(Geo.View2D.Popup.FramedCloud, {
	/**
	 * Property: shadowSrc
	 * {String} 阴影图片的地址
	 */
	shadowSrc: null,
	
	/**
	 * APIProperty: isShowShadow
	 * 是否显示阴影,默认为truel。
	 */
	isShowShadow:true,
	
	/**
	 * APIProperty: shadowOffset
	 * 阴影偏移量
	 * {Geo.Pixel}
	 */
	shadowOffset:null,
	
	/**
	 * APIProperty: minSize
	 * 最小宽度等于左下角阴影宽度+尾巴阴影宽度。
	 * 申明：如果使用带阴影的浮云框，最小宽度不得低于120
	 */
	minSize:new Geo.Size(120, 10),

	/** 
	 * Constructor: Geo.View2D.Popup.GeoFrameCloud
	 * 构造器
	 * 
	 * Parameters:
	 * id - {String}  浮云框的唯一标识，如果没有设置将会自动生成一个。
     * lonlat - {<Geo.LonLat>} 地图上浮云显示的位置。
     * contentSize - {<Geo.Size>} 浮云的尺寸。
     * contentHTML - {String} 浮云内容，浮云内容为HTML要素的字符串。
     * anchor - {Object} 锚点。包含一个大小信息{<Geo.Size>}和偏移信息{<Geo.Pixel>}的对象。(一般为{<Geo.View2D.Icon>}类型）。
     * closeBox - {Boolean} 是否显示关闭浮云窗口的按钮。
     * closeBoxCallback - {Function} 关闭浮云触发该回调函数。
	 * shadowOptions - {Object}
	 *    isShowShadow -  {Boolean} 是否显示阴影,默认为true
	 *    shadowOffset - {<Geo.Pixel>} 
	 *    阴影偏移,默认无偏移。取值举例：shadowOffset的值为new Geo.Pixel(2,3)，表示
	 *    浮云框阴影向右偏移2个像素，向下偏移3个像素。
	 */
	initialize:function(id, lonlat, contentSize, contentHTML, anchor, closeBox, 
						closeBoxCallback,shadowOptions) {
		
		if(shadowOptions && typeof shadowOptions.isShowShadow === "boolean" ) {
			this.isShowShadow = shadowOptions.isShowShadow === false ?  shadowOptions.isShowShadow : true;
		}
		if(shadowOptions && shadowOptions.shadowOffset instanceof OpenLayers.Pixel) {
			this.shadowOffset = shadowOptions.shadowOffset;
		}
		if(typeof shadowOptions.clickFeature === "function") {
			this.clickFeature = shadowOptions.clickFeature;
		}	
		if(typeof shadowOptions.moveoverShadow === "function") {
			this.moveoverShadow = shadowOptions.moveoverShadow;
		}				
		
		this.fixedRelativePosition = true;
		//固定浮云框显示位置为右上角
		this.relativePosition = "tr";
		this.shadowSrc = OpenLayers.Util.getImagesLocation() + "shadow.png";
		OpenLayers.Popup.FramedCloud.prototype.initialize.apply(this, arguments);
		//让阴影能够显示出来
		this.div.style.overflow = "visible";
	},
	
	/** 
	 *	Method:createShadow
	 */
	createShadow: function() {
		var imgId = this.id + '_shadomImg_' ;
		//创建一个图片
		
		if ((this.lonlat != null) && (this.map != null)) {
			px = this.map.getLayerPxFromLonLat(this.lonlat);
		}
		
		var divId = this.id + '_shadomDiv_' ;
		this.shadowDiv = OpenLayers.Util.createDiv(divId, 
			null, null, null, "absolute", null, "visible", null
		);
		this.shadowDiv.style.position="absolute";
	   
		this.shadowDiv.style.zIndex = 0;
		this.calculateShadowDivLocation(this.size, this.shadowDiv);
		this.map.layerContainerDiv.appendChild(this.shadowDiv);
		this.shadowevents = new OpenLayers.Events(this, this.shadowDiv, null, true);
		var isClick = false;	
		this.shadowevents.on({
			"click": this.clickFeature,
			//鼠标是否经过阴影区
			"mousemove":this.moveoverShadow,
			scope: this
		});		
		this.map.events.register("zoomend", this,this.calculateShadowLocation);
	},
	
	/**
	 * Method:calculateShadowDivLocation
	 * 计算阴影div的位置
	 */
	calculateShadowDivLocation: function(size, div) {
		var divId = this.id + '_leftTop_shadowdiv_';
		var divLocation = new OpenLayers.Pixel(0,0);
	
		this.divSize = new OpenLayers.Size();
		this.divSize.h = size.h * 0.5 - 30; //30是尾巴的高度
		this.divSize.w = size.w;// - divSize.h;//浮云框的宽度等于左上角阴影的宽度
		//创建左上角DIV
		var leftTop_shadowdiv = OpenLayers.Util.createDiv(divId,
			divLocation, this.divSize, null, "absolute",null, "hidden", null
		);
		
		var imgId = this.id + '_leftTop_shadomImg_' ;
		
		//左上角阴影left = (0+this.divSize.w);top = 0 TODO:需要限制divSize.h最大高度为330
		var imgleftLocation = 320 - this.divSize.h - 24; //320是浮云框阴影左边斜线组成的正方形的宽度，24是偏移
		var imgLocation = new OpenLayers.Pixel(-(0 + imgleftLocation), 0);
		
		
		var imgSize = new OpenLayers.Size(1062,356);
		
		var image = OpenLayers.Util.createImage(imgId, 
			imgLocation, imgSize, this.shadowSrc,
			"absolute", null, null, null
		);
		leftTop_shadowdiv.appendChild(image);
		div.appendChild(leftTop_shadowdiv);
		
		this.setrightTopshadowdiv(this.divSize,imgSize,div);
		this.setleftBottomShadowDiv(this.divSize,imgSize,div);
		this.setleftBottom23shadowdiv(this.divSize,imgSize,div);
		this.setrightBottomshadowdiv(this.divSize,imgSize,div);
		
	},
	/**
	 * Method:calculateShadowDivLocation
	 * 计算右上角阴影的位置
	 */						
	setrightTopshadowdiv:function(divSize,imgSize,div) {
		//创建右上角DIV
		var divId = this.id + '_rightTop_shadowdiv_';
		var divrightTopLocation = new OpenLayers.Pixel(divSize.w,0);
		var divrightTopSize = new OpenLayers.Size();
		divrightTopSize.h = divSize.h; //40是尾巴的高度
		divrightTopSize.w = divSize.h + 20+11;//20是多加的长度
		var rightTop_shadowdiv = OpenLayers.Util.createDiv(divId,
			divrightTopLocation, divrightTopSize, null, "absolute",  null, "hidden", null
		);
		//创建右上角img
		var imgrightTopLocation = new OpenLayers.Pixel(-(1062 - divSize.h - 20-24-25), 1);//上面的div宽度多加了20，这里减去20
		var imgId = this.id + '_rightTop_shadomImg_' ;
		var rightTopImage = OpenLayers.Util.createImage(imgId, 
			imgrightTopLocation, imgSize, this.shadowSrc, 
			"absolute", null, null, null
		);
		rightTop_shadowdiv.appendChild(rightTopImage);
		div.appendChild(rightTop_shadowdiv);
		
	},
	/**
	 * Method:calculateShadowLocation
	 *  计算整个阴影的位置
	 */	
	calculateShadowLocation: function() {
		var divleftBottomSize = this.divleftBottomSize;
		var div = this.shadowDiv;
		var shadowoffsetY = (this.divSize.h + divleftBottomSize.h);
		var px = this.map.getLayerPxFromLonLat(this.lonlat);
		//阴影尾巴的位置
		if(this.shadowOffset instanceof OpenLayers.Pixel) {
		div.style.top= (px.y - shadowoffsetY - 10 + this.shadowOffset.y)  + "px";//
		div.style.left= (px.x - divleftBottomSize.w - 5 + this.shadowOffset.x)+ "px";//
		}else {
			div.style.top= (px.y - shadowoffsetY - 10)  + "px";//
			div.style.left= (px.x - divleftBottomSize.w - 5)+ "px";//
		}
		this.setShadowzIndex(div);
	},
	
	/**
	 * Method:recalculateShadowLocation
	 * 重新计算整个阴影的位置
	 */		
	recalculateShadowLocation: function(divSize, divleftBottomSize, div) {
		var shadowoffsetY = (this.divSize.h + divleftBottomSize.h);
		var px = this.map.getLayerPxFromLonLat(this.lonlat);
		//阴影尾巴的位置
		if(this.shadowOffset instanceof OpenLayers.Pixel) {
			div.style.top= (px.y - shadowoffsetY - 10 + this.shadowOffset.y)  + "px";//
			div.style.left= (px.x - divleftBottomSize.w - 5 + this.shadowOffset.x)+ "px";//
		}else {
			div.style.top= (px.y - shadowoffsetY - 10)  + "px";//
			div.style.left= (px.x - divleftBottomSize.w - 5)+ "px";//
		}
		
		this.setShadowzIndex(div);
		
	},
	/**
	 * Method:setShadowzIndex
	 * 设置div阴影的的zindex
	 */	
	setShadowzIndex: function(div) { //设置阴影级别
		div.style.zIndex = this.map.Z_INDEX_BASE['Popup'] +
				this.map.popups.length;
	},
	/**
	 * Method:setrightBottomshadowdiv
	 * 添加右下角div阴影
	 */
	setrightBottomshadowdiv:function(divSize,imgSize,div) {
		//左下边第三个DIV
		var divId3 = this.id + '_rightBottom_shadowdiv_';
		var divrightBottomLocation = new OpenLayers.Pixel(divSize.w,divSize.h);
		var divrightBottomSize = new OpenLayers.Size();
		divrightBottomSize.h = 40; //27是临时定的值
		//TODO:需要判断divSize.w至少要大于等于(divleftBottom2Size.w + 30)
		divrightBottomSize.w = 45;
		
		var imgrightBottom_shadowdiv = OpenLayers.Util.createDiv(divId3,
			divrightBottomLocation, divrightBottomSize, null, "absolute",  null, "hidden", null
		);
		
		//img
		var imgrightBottomLocation = new OpenLayers.Pixel(-703, -290);
		var imgId3 = this.id + '_rightBottom_shadomImg_' ;
		var imgrightBottomImage = OpenLayers.Util.createImage(imgId3, 
			imgrightBottomLocation, imgSize, this.shadowSrc, 
			"absolute", null, null, null
		);
		imgrightBottom_shadowdiv.appendChild(imgrightBottomImage);
		div.appendChild(imgrightBottom_shadowdiv);
	},
	/**
	 * Method:setrightBottomshadowdiv
	 * 添加左下角右边的两个阴影
	 */
	setleftBottom23shadowdiv:function(divSize,imgSize,div) {
		//左下边第二个DIV
		var divId = this.id + '_leftBottom2_shadowdiv_';
		var divleftBottom2Location = new OpenLayers.Pixel(35,divSize.h);
		var divleftBottom2Size = new OpenLayers.Size();
		divleftBottom2Size.h = 70; //40是尾巴的高度
		divleftBottom2Size.w = 70;
		var imgleftBottom2_shadowdiv = OpenLayers.Util.createDiv(divId,
			divleftBottom2Location, divleftBottom2Size, null, "absolute",  null, "hidden", null
		);
		
		//img
		var imgleftBottom2Location = new OpenLayers.Pixel(-440, -290);
		var imgId = this.id + '_leftBottom2_shadomImg_' ;
		var imgleftBottom2Image = OpenLayers.Util.createImage(imgId, 
			imgleftBottom2Location, imgSize, this.shadowSrc, 
			"absolute", null, null, null
		);
		imgleftBottom2_shadowdiv.appendChild(imgleftBottom2Image);
		div.appendChild(imgleftBottom2_shadowdiv);
		
		//左下边第三个DIV
		var divId3 = this.id + '_leftBottom3_shadowdiv_';
		var divleftBottom3Location = new OpenLayers.Pixel((35 + divleftBottom2Size.w),divSize.h);
		var divleftBottom3Size = new OpenLayers.Size();
		divleftBottom3Size.h = 35; //35是临时定的值
		//TODO:需要判断divSize.w至少要大于等于(divleftBottom2Size.w + 30)
		
		divleftBottom3Size.w = divSize.w - divleftBottom2Size.w - 35;//这个30是divleftBottomSize.w
		var imgleftBottom3_shadowdiv = OpenLayers.Util.createDiv(divId3,
			divleftBottom3Location, divleftBottom3Size, null, "absolute",  null, "hidden", null
		);
		
		//img
		var imgleftBottom3Location = new OpenLayers.Pixel(-60, -290);
		var imgId3 = this.id + '_leftBottom3_shadomImg_' ;
		var imgleftBottom3Image = OpenLayers.Util.createImage(imgId3, 
			imgleftBottom3Location, imgSize, this.shadowSrc, 
			"absolute", null, null, null
		);
		imgleftBottom3_shadowdiv.appendChild(imgleftBottom3Image);
		div.appendChild(imgleftBottom3_shadowdiv);
	},
	/**
	 * Method:setrightBottomshadowdiv
	 * 添加左下角阴影
	 */
	setleftBottomShadowDiv:function(divSize,imgSize, div) {
		//创建左下角DIV
		var divId = this.id + '_leftBottom_shadowdiv_';
		var divleftBottomLocation = new OpenLayers.Pixel(0,divSize.h);
		this.divleftBottomSize = new OpenLayers.Size();
		this.divleftBottomSize.h = 70 - 30; //TODO:70是临时得出来的，没有经过计算
		this.divleftBottomSize.w = 35;//TODO:30是临时得出来的，没有经过计算
		var leftBottom_shadowdiv = OpenLayers.Util.createDiv(divId,
			divleftBottomLocation, this.divleftBottomSize, null, "absolute",  null, "hidden", null
		);
		//创建左下角img
		var imgleftBottomLocation = new OpenLayers.Pixel(-5, -290);//TODO:310是临时得出来的，没有经过计算
		var imgId = this.id + '_leftBottom_shadomImg_' ;
		var leftBottomImage = OpenLayers.Util.createImage(imgId, 
			imgleftBottomLocation, imgSize, this.shadowSrc, 
			"absolute", null, null, null
		);
		leftBottom_shadowdiv.appendChild(leftBottomImage);
		div.appendChild(leftBottom_shadowdiv);
		this.recalculateShadowLocation(divSize, this.divleftBottomSize, div);
	},
	/**
	 * Method:setrightBottomshadowdiv
	 * 设置浮云框阴影的大小和位置
	 */
	setShadowSize: function() {
		var image = this.image;
		var size = this.size;
		//设置阴影框大小
		image.style.width= (size.w + 80) + "px";
		image.style.height= size.h / 2+ "px";
		image.style.left= 0 + "px";
		image.style.bottom= 40 + "px";
	},
	
    /** 
     * Method: draw
     * 
     * Parameters:
     * px - {<OpenLayers.Pixel>}
     * 
     * Returns:
     * {DOMElement} 包含浮云框的div
     */
    draw: function(px) {
        
        OpenLayers.Popup.Anchored.prototype.draw.apply(this, arguments);
        if(this.isShowShadow) {
			//创建阴影图
			this.createShadow();
		}

        return this.div;
    },
	
	/**
	 * Method: addCloseBox
	 * 
	 * Parameters:
	 * callback - {Function} 点击关闭按钮的时候执行该回调
	 */
	addCloseBox: function(callback) {

		this.closeDiv = OpenLayers.Util.createDiv(
			this.id + "_close", null, new OpenLayers.Size(17, 17)
		);
		this.closeDiv.className = "olPopupCloseBox"; 
		
		// use the content div's css padding to determine if we should
		//  padd the close div
		var contentDivPadding = this.getContentDivPadding();
		 
		this.closeDiv.style.right = contentDivPadding.right + "px";
		this.closeDiv.style.top = contentDivPadding.top + "px";
		this.groupDiv.appendChild(this.closeDiv);
		
		var closePopup = callback || function(e) {
			this.hide();
			OpenLayers.Event.stop(e);
		};
		OpenLayers.Event.observe(this.closeDiv, "touchend", 
				OpenLayers.Function.bindAsEventListener(closePopup, this));
		OpenLayers.Event.observe(this.closeDiv, "click", 
				OpenLayers.Function.bindAsEventListener(closePopup, this));
	},
	
	/**
	 * Method: hide
	 * 设置浮云框隐藏
	 */
	hide: function() {
	   if(this.shadowDiv) {
			this.shadowDiv.style.display = 'none';
		}
		OpenLayers.Popup.FramedCloud.prototype.hide.apply(this, arguments);
	},
	
	/**
	 * Method: show
	 * 设置浮云框可显
	 */
	show: function() {
		if(this.shadowDiv) {
			this.shadowDiv.style.display = '';
		}
		OpenLayers.Popup.FramedCloud.prototype.show.apply(this, arguments);   
	},
	
	/**
	 *	APIMethod:clickFeature
	 *	点击要素操作，由用户重写此方法，自定义操作内容。
	 *	event -  事件对象
	 */
	clickFeature:function(event) {
//		if(isClick) {
//			alert("点击");
//		}else {
//		
//		}	
	},	
	
	/** 
	 * APIMethod: destroy
	 * 销毁浮云框对象
	 */
	destroy: function() {
		if(this.shadowDiv && this.map) {
			this.shadowevents.unregister({
				"click": this.clickFeature,
				//鼠标是否经过阴影区
				"mousemove":this.moveoverShadow,
				scope: this
			});	
			//移除浮云框阴影
			this.map.events.unregister("zoomend", this,this.calculateShadowLocation);
			this.map.layerContainerDiv.removeChild(this.shadowDiv);
			this.shadowDiv = null;	
		}
		OpenLayers.Popup.FramedCloud.prototype.destroy.apply(this, arguments);
	},
	
	/**
	 *	APIMethod:moveoverShadow
	 *	移动到浮云阴影上的操作，由用户重写此方法，自定义操作内容。
	 *	event -  事件对象
	 */
	moveoverShadow: function(event) {
//		//this.isHoverShaow = true;
//		var px = map.getViewPortPxFromLonLat(new OpenLayers.LonLat(258.04688,63.98438));
//		//计算图标的位置
//		var bounds = new OpenLayers.Bounds(px.x-10,px.y-22.5,px.x+10,px.y+22.5);
//		var pxLocation = bounds.containsPixel(new OpenLayers.Pixel(evt.x,evt.y));
//
//		if(pxLocation) {
//			isClick = true;
//		//	document.getElementById("mousePosition").innerHTML = pxLocation + " " + px.x + "," + px.y;
//			this.shadowDiv.style.cursor = "pointer";
//				
//		}else {
//			isClick = false;
//		//	document.getElementById("mousePosition").innerHTML = pxLocation + " " + px.x + "," + px.y;
//			this.shadowDiv.style.cursor = "default";
//			
//		}
	},	

	CLASS_NAME: "Geo.View2D.Popup.GeoFrameCloud"
});/*!	SWFObject v2.2 <http://code.google.com/p/swfobject/> 
	is released under the MIT License <http://www.opensource.org/licenses/mit-license.php> 
*/

var swfobject = function() {
	
	var UNDEF = "undefined",
		OBJECT = "object",
		SHOCKWAVE_FLASH = "Shockwave Flash",
		SHOCKWAVE_FLASH_AX = "ShockwaveFlash.ShockwaveFlash",
		FLASH_MIME_TYPE = "application/x-shockwave-flash",
		EXPRESS_INSTALL_ID = "SWFObjectExprInst",
		ON_READY_STATE_CHANGE = "onreadystatechange",
		
		win = window,
		doc = document,
		nav = navigator,
		
		plugin = false,
		domLoadFnArr = [main],
		regObjArr = [],
		objIdArr = [],
		listenersArr = [],
		storedAltContent,
		storedAltContentId,
		storedCallbackFn,
		storedCallbackObj,
		isDomLoaded = false,
		isExpressInstallActive = false,
		dynamicStylesheet,
		dynamicStylesheetMedia,
		autoHideShow = true,
	
	/* Centralized function for browser feature detection
		- User agent string detection is only used when no good alternative is possible
		- Is executed directly for optimal performance
	*/	
	ua = function() {
		var w3cdom = typeof doc.getElementById != UNDEF && typeof doc.getElementsByTagName != UNDEF && typeof doc.createElement != UNDEF,
			u = nav.userAgent.toLowerCase(),
			p = nav.platform.toLowerCase(),
			windows = p ? /win/.test(p) : /win/.test(u),
			mac = p ? /mac/.test(p) : /mac/.test(u),
			webkit = /webkit/.test(u) ? parseFloat(u.replace(/^.*webkit\/(\d+(\.\d+)?).*$/, "$1")) : false, // returns either the webkit version or false if not webkit
			ie = !+"\v1", // feature detection based on Andrea Giammarchi's solution: http://webreflection.blogspot.com/2009/01/32-bytes-to-know-if-your-browser-is-ie.html
			playerVersion = [0,0,0],
			d = null;
		if (typeof nav.plugins != UNDEF && typeof nav.plugins[SHOCKWAVE_FLASH] == OBJECT) {
			d = nav.plugins[SHOCKWAVE_FLASH].description;
			if (d && !(typeof nav.mimeTypes != UNDEF && nav.mimeTypes[FLASH_MIME_TYPE] && !nav.mimeTypes[FLASH_MIME_TYPE].enabledPlugin)) { // navigator.mimeTypes["application/x-shockwave-flash"].enabledPlugin indicates whether plug-ins are enabled or disabled in Safari 3+
				plugin = true;
				ie = false; // cascaded feature detection for Internet Explorer
				d = d.replace(/^.*\s+(\S+\s+\S+$)/, "$1");
				playerVersion[0] = parseInt(d.replace(/^(.*)\..*$/, "$1"), 10);
				playerVersion[1] = parseInt(d.replace(/^.*\.(.*)\s.*$/, "$1"), 10);
				playerVersion[2] = /[a-zA-Z]/.test(d) ? parseInt(d.replace(/^.*[a-zA-Z]+(.*)$/, "$1"), 10) : 0;
			}
		}
		else if (typeof win.ActiveXObject != UNDEF) {
			try {
				var a = new ActiveXObject(SHOCKWAVE_FLASH_AX);
				if (a) { // a will return null when ActiveX is disabled
					d = a.GetVariable("$version");
					if (d) {
						ie = true; // cascaded feature detection for Internet Explorer
						d = d.split(" ")[1].split(",");
						playerVersion = [parseInt(d[0], 10), parseInt(d[1], 10), parseInt(d[2], 10)];
					}
				}
			}
			catch(e) {}
		}
		return { w3:w3cdom, pv:playerVersion, wk:webkit, ie:ie, win:windows, mac:mac };
	}(),
	
	/* Cross-browser onDomLoad
		- Will fire an event as soon as the DOM of a web page is loaded
		- Internet Explorer workaround based on Diego Perini's solution: http://javascript.nwbox.com/IEContentLoaded/
		- Regular onload serves as fallback
	*/ 
	onDomLoad = function() {
		if (!ua.w3) { return; }
		if ((typeof doc.readyState != UNDEF && doc.readyState == "complete") || (typeof doc.readyState == UNDEF && (doc.getElementsByTagName("body")[0] || doc.body))) { // function is fired after onload, e.g. when script is inserted dynamically 
			callDomLoadFunctions();
		}
		if (!isDomLoaded) {
			if (typeof doc.addEventListener != UNDEF) {
				doc.addEventListener("DOMContentLoaded", callDomLoadFunctions, false);
			}		
			if (ua.ie && ua.win) {
				doc.attachEvent(ON_READY_STATE_CHANGE, function() {
					if (doc.readyState == "complete") {
						doc.detachEvent(ON_READY_STATE_CHANGE, arguments.callee);
						callDomLoadFunctions();
					}
				});
				if (win == top) { // if not inside an iframe
					(function(){
						if (isDomLoaded) { return; }
						try {
							doc.documentElement.doScroll("left");
						}
						catch(e) {
							setTimeout(arguments.callee, 0);
							return;
						}
						callDomLoadFunctions();
					})();
				}
			}
			if (ua.wk) {
				(function(){
					if (isDomLoaded) { return; }
					if (!/loaded|complete/.test(doc.readyState)) {
						setTimeout(arguments.callee, 0);
						return;
					}
					callDomLoadFunctions();
				})();
			}
			addLoadEvent(callDomLoadFunctions);
		}
	}();
	
	function callDomLoadFunctions() {
		if (isDomLoaded) { return; }
		try { // test if we can really add/remove elements to/from the DOM; we don't want to fire it too early
			var t = doc.getElementsByTagName("body")[0].appendChild(createElement("span"));
			t.parentNode.removeChild(t);
		}
		catch (e) { return; }
		isDomLoaded = true;
		var dl = domLoadFnArr.length;
		for (var i = 0; i < dl; i++) {
			domLoadFnArr[i]();
		}
	}
	
	function addDomLoadEvent(fn) {
		if (isDomLoaded) {
			fn();
		}
		else { 
			domLoadFnArr[domLoadFnArr.length] = fn; // Array.push() is only available in IE5.5+
		}
	}
	
	/* Cross-browser onload
		- Based on James Edwards' solution: http://brothercake.com/site/resources/scripts/onload/
		- Will fire an event as soon as a web page including all of its assets are loaded 
	 */
	function addLoadEvent(fn) {
		if (typeof win.addEventListener != UNDEF) {
			win.addEventListener("load", fn, false);
		}
		else if (typeof doc.addEventListener != UNDEF) {
			doc.addEventListener("load", fn, false);
		}
		else if (typeof win.attachEvent != UNDEF) {
			addListener(win, "onload", fn);
		}
		else if (typeof win.onload == "function") {
			var fnOld = win.onload;
			win.onload = function() {
				fnOld();
				fn();
			};
		}
		else {
			win.onload = fn;
		}
	}
	
	/* Main function
		- Will preferably execute onDomLoad, otherwise onload (as a fallback)
	*/
	function main() { 
		if (plugin) {
			testPlayerVersion();
		}
		else {
			matchVersions();
		}
	}
	
	/* Detect the Flash Player version for non-Internet Explorer browsers
		- Detecting the plug-in version via the object element is more precise than using the plugins collection item's description:
		  a. Both release and build numbers can be detected
		  b. Avoid wrong descriptions by corrupt installers provided by Adobe
		  c. Avoid wrong descriptions by multiple Flash Player entries in the plugin Array, caused by incorrect browser imports
		- Disadvantage of this method is that it depends on the availability of the DOM, while the plugins collection is immediately available
	*/
	function testPlayerVersion() {
		var b = doc.getElementsByTagName("body")[0];
		var o = createElement(OBJECT);
		o.setAttribute("type", FLASH_MIME_TYPE);
		var t = b.appendChild(o);
		if (t) {
			var counter = 0;
			(function(){
				if (typeof t.GetVariable != UNDEF) {
					var d = t.GetVariable("$version");
					if (d) {
						d = d.split(" ")[1].split(",");
						ua.pv = [parseInt(d[0], 10), parseInt(d[1], 10), parseInt(d[2], 10)];
					}
				}
				else if (counter < 10) {
					counter++;
					setTimeout(arguments.callee, 10);
					return;
				}
				b.removeChild(o);
				t = null;
				matchVersions();
			})();
		}
		else {
			matchVersions();
		}
	}
	
	/* Perform Flash Player and SWF version matching; static publishing only
	*/
	function matchVersions() {
		var rl = regObjArr.length;
		if (rl > 0) {
			for (var i = 0; i < rl; i++) { // for each registered object element
				var id = regObjArr[i].id;
				var cb = regObjArr[i].callbackFn;
				var cbObj = {success:false, id:id};
				if (ua.pv[0] > 0) {
					var obj = getElementById(id);
					if (obj) {
						if (hasPlayerVersion(regObjArr[i].swfVersion) && !(ua.wk && ua.wk < 312)) { // Flash Player version >= published SWF version: Houston, we have a match!
							setVisibility(id, true);
							if (cb) {
								cbObj.success = true;
								cbObj.ref = getObjectById(id);
								cb(cbObj);
							}
						}
						else if (regObjArr[i].expressInstall && canExpressInstall()) { // show the Adobe Express Install dialog if set by the web page author and if supported
							var att = {};
							att.data = regObjArr[i].expressInstall;
							att.width = obj.getAttribute("width") || "0";
							att.height = obj.getAttribute("height") || "0";
							if (obj.getAttribute("class")) { att.styleclass = obj.getAttribute("class"); }
							if (obj.getAttribute("align")) { att.align = obj.getAttribute("align"); }
							// parse HTML object param element's name-value pairs
							var par = {};
							var p = obj.getElementsByTagName("param");
							var pl = p.length;
							for (var j = 0; j < pl; j++) {
								if (p[j].getAttribute("name").toLowerCase() != "movie") {
									par[p[j].getAttribute("name")] = p[j].getAttribute("value");
								}
							}
							showExpressInstall(att, par, id, cb);
						}
						else { // Flash Player and SWF version mismatch or an older Webkit engine that ignores the HTML object element's nested param elements: display alternative content instead of SWF
							displayAltContent(obj);
							if (cb) { cb(cbObj); }
						}
					}
				}
				else {	// if no Flash Player is installed or the fp version cannot be detected we let the HTML object element do its job (either show a SWF or alternative content)
					setVisibility(id, true);
					if (cb) {
						var o = getObjectById(id); // test whether there is an HTML object element or not
						if (o && typeof o.SetVariable != UNDEF) { 
							cbObj.success = true;
							cbObj.ref = o;
						}
						cb(cbObj);
					}
				}
			}
		}
	}
	
	function getObjectById(objectIdStr) {
		var r = null;
		var o = getElementById(objectIdStr);
		if (o && o.nodeName == "OBJECT") {
			if (typeof o.SetVariable != UNDEF) {
				r = o;
			}
			else {
				var n = o.getElementsByTagName(OBJECT)[0];
				if (n) {
					r = n;
				}
			}
		}
		return r;
	}
	
	/* Requirements for Adobe Express Install
		- only one instance can be active at a time
		- fp 6.0.65 or higher
		- Win/Mac OS only
		- no Webkit engines older than version 312
	*/
	function canExpressInstall() {
		return !isExpressInstallActive && hasPlayerVersion("6.0.65") && (ua.win || ua.mac) && !(ua.wk && ua.wk < 312);
	}
	
	/* Show the Adobe Express Install dialog
		- Reference: http://www.adobe.com/cfusion/knowledgebase/index.cfm?id=6a253b75
	*/
	function showExpressInstall(att, par, replaceElemIdStr, callbackFn) {
		isExpressInstallActive = true;
		storedCallbackFn = callbackFn || null;
		storedCallbackObj = {success:false, id:replaceElemIdStr};
		var obj = getElementById(replaceElemIdStr);
		if (obj) {
			if (obj.nodeName == "OBJECT") { // static publishing
				storedAltContent = abstractAltContent(obj);
				storedAltContentId = null;
			}
			else { // dynamic publishing
				storedAltContent = obj;
				storedAltContentId = replaceElemIdStr;
			}
			att.id = EXPRESS_INSTALL_ID;
			if (typeof att.width == UNDEF || (!/%$/.test(att.width) && parseInt(att.width, 10) < 310)) { att.width = "310"; }
			if (typeof att.height == UNDEF || (!/%$/.test(att.height) && parseInt(att.height, 10) < 137)) { att.height = "137"; }
			doc.title = doc.title.slice(0, 47) + " - Flash Player Installation";
			var pt = ua.ie && ua.win ? "ActiveX" : "PlugIn",
				fv = "MMredirectURL=" + encodeURI(window.location).toString().replace(/&/g,"%26") + "&MMplayerType=" + pt + "&MMdoctitle=" + doc.title;
			if (typeof par.flashvars != UNDEF) {
				par.flashvars += "&" + fv;
			}
			else {
				par.flashvars = fv;
			}
			// IE only: when a SWF is loading (AND: not available in cache) wait for the readyState of the object element to become 4 before removing it,
			// because you cannot properly cancel a loading SWF file without breaking browser load references, also obj.onreadystatechange doesn't work
			if (ua.ie && ua.win && obj.readyState != 4) {
				var newObj = createElement("div");
				replaceElemIdStr += "SWFObjectNew";
				newObj.setAttribute("id", replaceElemIdStr);
				obj.parentNode.insertBefore(newObj, obj); // insert placeholder div that will be replaced by the object element that loads expressinstall.swf
				obj.style.display = "none";
				(function(){
					if (obj.readyState == 4) {
						obj.parentNode.removeChild(obj);
					}
					else {
						setTimeout(arguments.callee, 10);
					}
				})();
			}
			createSWF(att, par, replaceElemIdStr);
		}
	}
	
	/* Functions to abstract and display alternative content
	*/
	function displayAltContent(obj) {
		if (ua.ie && ua.win && obj.readyState != 4) {
			// IE only: when a SWF is loading (AND: not available in cache) wait for the readyState of the object element to become 4 before removing it,
			// because you cannot properly cancel a loading SWF file without breaking browser load references, also obj.onreadystatechange doesn't work
			var el = createElement("div");
			obj.parentNode.insertBefore(el, obj); // insert placeholder div that will be replaced by the alternative content
			el.parentNode.replaceChild(abstractAltContent(obj), el);
			obj.style.display = "none";
			(function(){
				if (obj.readyState == 4) {
					obj.parentNode.removeChild(obj);
				}
				else {
					setTimeout(arguments.callee, 10);
				}
			})();
		}
		else {
			obj.parentNode.replaceChild(abstractAltContent(obj), obj);
		}
	} 

	function abstractAltContent(obj) {
		var ac = createElement("div");
		if (ua.win && ua.ie) {
			ac.innerHTML = obj.innerHTML;
		}
		else {
			var nestedObj = obj.getElementsByTagName(OBJECT)[0];
			if (nestedObj) {
				var c = nestedObj.childNodes;
				if (c) {
					var cl = c.length;
					for (var i = 0; i < cl; i++) {
						if (!(c[i].nodeType == 1 && c[i].nodeName == "PARAM") && !(c[i].nodeType == 8)) {
							ac.appendChild(c[i].cloneNode(true));
						}
					}
				}
			}
		}
		return ac;
	}
	
	/* Cross-browser dynamic SWF creation
	*/
	function createSWF(attObj, parObj, id) {
		var r, el = getElementById(id);
		if (ua.wk && ua.wk < 312) { return r; }
		if (el) {
			if (typeof attObj.id == UNDEF) { // if no 'id' is defined for the object element, it will inherit the 'id' from the alternative content
				attObj.id = id;
			}
			if (ua.ie && ua.win) { // Internet Explorer + the HTML object element + W3C DOM methods do not combine: fall back to outerHTML
				var att = "";
				for (var i in attObj) {
					if (attObj[i] != Object.prototype[i]) { // filter out prototype additions from other potential libraries
						if (i.toLowerCase() == "data") {
							parObj.movie = attObj[i];
						}
						else if (i.toLowerCase() == "styleclass") { // 'class' is an ECMA4 reserved keyword
							att += ' class="' + attObj[i] + '"';
						}
						else if (i.toLowerCase() != "classid") {
							att += ' ' + i + '="' + attObj[i] + '"';
						}
					}
				}
				var par = "";
				for (var j in parObj) {
					if (parObj[j] != Object.prototype[j]) { // filter out prototype additions from other potential libraries
						par += '<param name="' + j + '" value="' + parObj[j] + '" />';
					}
				}
				el.outerHTML = '<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"' + att + '>' + par + '</object>';
				objIdArr[objIdArr.length] = attObj.id; // stored to fix object 'leaks' on unload (dynamic publishing only)
				r = getElementById(attObj.id);	
			}
			else { // well-behaving browsers
				var o = createElement(OBJECT);
				o.setAttribute("type", FLASH_MIME_TYPE);
				for (var m in attObj) {
					if (attObj[m] != Object.prototype[m]) { // filter out prototype additions from other potential libraries
						if (m.toLowerCase() == "styleclass") { // 'class' is an ECMA4 reserved keyword
							o.setAttribute("class", attObj[m]);
						}
						else if (m.toLowerCase() != "classid") { // filter out IE specific attribute
							o.setAttribute(m, attObj[m]);
						}
					}
				}
				for (var n in parObj) {
					if (parObj[n] != Object.prototype[n] && n.toLowerCase() != "movie") { // filter out prototype additions from other potential libraries and IE specific param element
						createObjParam(o, n, parObj[n]);
					}
				}
				el.parentNode.replaceChild(o, el);
				r = o;
			}
		}
		return r;
	}
	
	function createObjParam(el, pName, pValue) {
		var p = createElement("param");
		p.setAttribute("name", pName);	
		p.setAttribute("value", pValue);
		el.appendChild(p);
	}
	
	/* Cross-browser SWF removal
		- Especially needed to safely and completely remove a SWF in Internet Explorer
	*/
	function removeSWF(id) {
		var obj = getElementById(id);
		if (obj && obj.nodeName == "OBJECT") {
			if (ua.ie && ua.win) {
				obj.style.display = "none";
				(function(){
					if (obj.readyState == 4) {
						removeObjectInIE(id);
					}
					else {
						setTimeout(arguments.callee, 10);
					}
				})();
			}
			else {
				obj.parentNode.removeChild(obj);
			}
		}
	}
	
	function removeObjectInIE(id) {
		var obj = getElementById(id);
		if (obj) {
			for (var i in obj) {
				if (typeof obj[i] == "function") {
					obj[i] = null;
				}
			}
			obj.parentNode.removeChild(obj);
		}
	}
	
	/* Functions to optimize JavaScript compression
	*/
	function getElementById(id) {
		var el = null;
		try {
			el = doc.getElementById(id);
		}
		catch (e) {}
		return el;
	}
	
	function createElement(el) {
		return doc.createElement(el);
	}
	
	/* Updated attachEvent function for Internet Explorer
		- Stores attachEvent information in an Array, so on unload the detachEvent functions can be called to avoid memory leaks
	*/	
	function addListener(target, eventType, fn) {
		target.attachEvent(eventType, fn);
		listenersArr[listenersArr.length] = [target, eventType, fn];
	}
	
	/* Flash Player and SWF content version matching
	*/
	function hasPlayerVersion(rv) {
		var pv = ua.pv, v = rv.split(".");
		v[0] = parseInt(v[0], 10);
		v[1] = parseInt(v[1], 10) || 0; // supports short notation, e.g. "9" instead of "9.0.0"
		v[2] = parseInt(v[2], 10) || 0;
		return (pv[0] > v[0] || (pv[0] == v[0] && pv[1] > v[1]) || (pv[0] == v[0] && pv[1] == v[1] && pv[2] >= v[2])) ? true : false;
	}
	
	/* Cross-browser dynamic CSS creation
		- Based on Bobby van der Sluis' solution: http://www.bobbyvandersluis.com/articles/dynamicCSS.php
	*/	
	function createCSS(sel, decl, media, newStyle) {
		if (ua.ie && ua.mac) { return; }
		var h = doc.getElementsByTagName("head")[0];
		if (!h) { return; } // to also support badly authored HTML pages that lack a head element
		var m = (media && typeof media == "string") ? media : "screen";
		if (newStyle) {
			dynamicStylesheet = null;
			dynamicStylesheetMedia = null;
		}
		if (!dynamicStylesheet || dynamicStylesheetMedia != m) { 
			// create dynamic stylesheet + get a global reference to it
			var s = createElement("style");
			s.setAttribute("type", "text/css");
			s.setAttribute("media", m);
			dynamicStylesheet = h.appendChild(s);
			if (ua.ie && ua.win && typeof doc.styleSheets != UNDEF && doc.styleSheets.length > 0) {
				dynamicStylesheet = doc.styleSheets[doc.styleSheets.length - 1];
			}
			dynamicStylesheetMedia = m;
		}
		// add style rule
		if (ua.ie && ua.win) {
			if (dynamicStylesheet && typeof dynamicStylesheet.addRule == OBJECT) {
				dynamicStylesheet.addRule(sel, decl);
			}
		}
		else {
			if (dynamicStylesheet && typeof doc.createTextNode != UNDEF) {
				dynamicStylesheet.appendChild(doc.createTextNode(sel + " {" + decl + "}"));
			}
		}
	}
	
	function setVisibility(id, isVisible) {
		if (!autoHideShow) { return; }
		var v = isVisible ? "visible" : "hidden";
		if (isDomLoaded && getElementById(id)) {
			getElementById(id).style.visibility = v;
		}
		else {
			createCSS("#" + id, "visibility:" + v);
		}
	}

	/* Filter to avoid XSS attacks
	*/
	function urlEncodeIfNecessary(s) {
		var regex = /[\\\"<>\.;]/;
		var hasBadChars = regex.exec(s) != null;
		return hasBadChars && typeof encodeURIComponent != UNDEF ? encodeURIComponent(s) : s;
	}
	
	/* Release memory to avoid memory leaks caused by closures, fix hanging audio/video threads and force open sockets/NetConnections to disconnect (Internet Explorer only)
	*/
	var cleanup = function() {
		if (ua.ie && ua.win) {
			window.attachEvent("onunload", function() {
				// remove listeners to avoid memory leaks
				var ll = listenersArr.length;
				for (var i = 0; i < ll; i++) {
					listenersArr[i][0].detachEvent(listenersArr[i][1], listenersArr[i][2]);
				}
				// cleanup dynamically embedded objects to fix audio/video threads and force open sockets and NetConnections to disconnect
				var il = objIdArr.length;
				for (var j = 0; j < il; j++) {
					removeSWF(objIdArr[j]);
				}
				// cleanup library's main closures to avoid memory leaks
				for (var k in ua) {
					ua[k] = null;
				}
				ua = null;
				for (var l in swfobject) {
					swfobject[l] = null;
				}
				swfobject = null;
			});
		}
	}();
	
	return {
		/* Public API
			- Reference: http://code.google.com/p/swfobject/wiki/documentation
		*/ 
		registerObject: function(objectIdStr, swfVersionStr, xiSwfUrlStr, callbackFn) {
			if (ua.w3 && objectIdStr && swfVersionStr) {
				var regObj = {};
				regObj.id = objectIdStr;
				regObj.swfVersion = swfVersionStr;
				regObj.expressInstall = xiSwfUrlStr;
				regObj.callbackFn = callbackFn;
				regObjArr[regObjArr.length] = regObj;
				setVisibility(objectIdStr, false);
			}
			else if (callbackFn) {
				callbackFn({success:false, id:objectIdStr});
			}
		},
		
		getObjectById: function(objectIdStr) {
			if (ua.w3) {
				return getObjectById(objectIdStr);
			}
		},
		
		embedSWF: function(swfUrlStr, replaceElemIdStr, widthStr, heightStr, swfVersionStr, xiSwfUrlStr, flashvarsObj, parObj, attObj, callbackFn) {
			var callbackObj = {success:false, id:replaceElemIdStr};
			if (ua.w3 && !(ua.wk && ua.wk < 312) && swfUrlStr && replaceElemIdStr && widthStr && heightStr && swfVersionStr) {
				setVisibility(replaceElemIdStr, false);
				addDomLoadEvent(function() {
					widthStr += ""; // auto-convert to string
					heightStr += "";
					var att = {};
					if (attObj && typeof attObj === OBJECT) {
						for (var i in attObj) { // copy object to avoid the use of references, because web authors often reuse attObj for multiple SWFs
							att[i] = attObj[i];
						}
					}
					att.data = swfUrlStr;
					att.width = widthStr;
					att.height = heightStr;
					var par = {}; 
					if (parObj && typeof parObj === OBJECT) {
						for (var j in parObj) { // copy object to avoid the use of references, because web authors often reuse parObj for multiple SWFs
							par[j] = parObj[j];
						}
					}
					if (flashvarsObj && typeof flashvarsObj === OBJECT) {
						for (var k in flashvarsObj) { // copy object to avoid the use of references, because web authors often reuse flashvarsObj for multiple SWFs
							if (typeof par.flashvars != UNDEF) {
								par.flashvars += "&" + k + "=" + flashvarsObj[k];
							}
							else {
								par.flashvars = k + "=" + flashvarsObj[k];
							}
						}
					}
					if (hasPlayerVersion(swfVersionStr)) { // create SWF
						var obj = createSWF(att, par, replaceElemIdStr);
						if (att.id == replaceElemIdStr) {
							setVisibility(replaceElemIdStr, true);
						}
						callbackObj.success = true;
						callbackObj.ref = obj;
					}
					else if (xiSwfUrlStr && canExpressInstall()) { // show Adobe Express Install
						att.data = xiSwfUrlStr;
						showExpressInstall(att, par, replaceElemIdStr, callbackFn);
						return;
					}
					else { // show alternative content
						setVisibility(replaceElemIdStr, true);
					}
					if (callbackFn) { callbackFn(callbackObj); }
				});
			}
			else if (callbackFn) { callbackFn(callbackObj);	}
		},
		
		switchOffAutoHideShow: function() {
			autoHideShow = false;
		},
		
		ua: ua,
		
		getFlashPlayerVersion: function() {
			return { major:ua.pv[0], minor:ua.pv[1], release:ua.pv[2] };
		},
		
		hasFlashPlayerVersion: hasPlayerVersion,
		
		createSWF: function(attObj, parObj, replaceElemIdStr) {
			if (ua.w3) {
				return createSWF(attObj, parObj, replaceElemIdStr);
			}
			else {
				return undefined;
			}
		},
		
		showExpressInstall: function(att, par, replaceElemIdStr, callbackFn) {
			if (ua.w3 && canExpressInstall()) {
				showExpressInstall(att, par, replaceElemIdStr, callbackFn);
			}
		},
		
		removeSWF: function(objElemIdStr) {
			if (ua.w3) {
				removeSWF(objElemIdStr);
			}
		},
		
		createCSS: function(selStr, declStr, mediaStr, newStyleBoolean) {
			if (ua.w3) {
				createCSS(selStr, declStr, mediaStr, newStyleBoolean);
			}
		},
		
		addDomLoadEvent: addDomLoadEvent,
		
		addLoadEvent: addLoadEvent,
		
		getQueryParamValue: function(param) {
			var q = doc.location.search || doc.location.hash;
			if (q) {
				if (/\?/.test(q)) { q = q.split("?")[1]; } // strip question mark
				if (param == null) {
					return urlEncodeIfNecessary(q);
				}
				var pairs = q.split("&");
				for (var i = 0; i < pairs.length; i++) {
					if (pairs[i].substring(0, pairs[i].indexOf("=")) == param) {
						return urlEncodeIfNecessary(pairs[i].substring((pairs[i].indexOf("=") + 1)));
					}
				}
			}
			return "";
		},
		
		// For internal usage only
		expressInstallCallback: function() {
			if (isExpressInstallActive) {
				var obj = getElementById(EXPRESS_INSTALL_ID);
				if (obj && storedAltContent) {
					obj.parentNode.replaceChild(storedAltContent, obj);
					if (storedAltContentId) {
						setVisibility(storedAltContentId, true);
						if (ua.ie && ua.win) { storedAltContent.style.display = "block"; }
					}
					if (storedCallbackFn) { storedCallbackFn(storedCallbackObj); }
				}
				isExpressInstallActive = false;
			} 
		}
	};
}();
Geo.ViewFl = {};
Geo.ViewFl._jsonParser = new Geo.Format.JSON();
Geo.ViewFl.mapInstances = {};
Geo.ViewFl.counter = 1;
Geo.ViewFl.featureSelectedHandler = function(){};
/**
 * Class: Geo.ViewFl.Map
 * Flash视图下的地图对象。
 */
Geo.ViewFl.Map = Geo.Class({
	
    /**
     * Constant: Z_INDEX_BASE
     * {Object} 地图中所用到的各个类的Z-INDEX索引基准。
     */
    Z_INDEX_BASE: {
       Popup: 750
    },
	
    /**
     * Property: EVENT_TYPES
     * {Array} 支持的事件类型。
     */
	EVENT_TYPES: ["preaddlayer", "addlayer","preremovelayer", "removelayer", "changelayer","unloadLayerGroup", "loadLayerGroup"],

    /**
     * Property: id
     * {String} 唯一标识符。
     */
    id: null,
	
	/**
     * APIProperty: events
     * {<Geo.View2D.Events>} 事件对象。
     */
    events: null,

    /**
     * Property: div
     * {DOMElement} 地图所在的div容器。
     */
    div: null,

    /**
     * Property: activexObj
     * {DOMElement} 地图的ACTIVEX对象引用。
     */
    swfObj: null,
	
	/**
     * Property: size
     * {<Geo.Size>} Size of the main div (this.div)
     */
    size: null,

    /**
     * Property: layers
     * {Array} 地图中所有图层。
     */
    layers: null,

    /**
     * Property: overLayers
     * {Array} 所有的覆盖图层。
     */
    overLayers: null,

	/**
     * Property: handlers
     * {Array} 地图中所有鼠标事件监听器。
     */
    handlers:null,
	
    /**
     * Property: controls
     * {Array} 地图中所有控件。
     */
    controls: null,

    /**
     * Property: popups
     * {Array(<Geo.ViewFl.Popup>)}关联到地图的popup清单（popup表示一个窗口）。
     */
    popups: null,
    
    /**
     * Property: center
     * {<Geo.LonLat>} 地图中心点。
     */
    center: null,

    /**
     * Property: resolution
     * {Float} 地图当前分辨率。
     */
    resolution: null,

    /**
     * Property: zoom
     * {Integer} 地图当前的级别。
     */
    zoom: 0,
	
	/**
     * APIProperty: tileSize
     * {<Geo.Size>} 在地图的options参数中覆盖地图默认的瓦片尺寸。
     */
    tileSize: null,

    /**
     * APIProperty: projection
     * {String} 在地图的options参数中覆盖地图默认的投影串- 也要设置 maxExtent, maxResolution以及units属性。
     *          默认值是"EPSG:4326"。
     */
    projection: "EPSG:4326",    
        
    /**
     * APIProperty: units
     * {String} 地图单位。默认是度。该属性的值可能是'degrees' (or 'dd'), 'm', 'ft', 'km', 'mi', 'inches'。
     */
    units: 'degrees',
	
	/**
     * APIProperty: resolutions
     * {Array(Float)} 值是从大到小的地图分辨率清单（地图每像素的单位），如果在图层的构造器中没有设置，该属性将以其他相关联的属性为基准
     * (maxExtent, maxResolution, maxScale等。)
     *      
     */
    resolutions: null,

    /**
     * APIProperty: maxResolution
     * {Float} 默认最大值是360 度 / 256像素，它表示地图的第0级。 如果你不使用地图投影和不显示全球范围。就在地图参数选项上设置一个不同的值。     
     */
    maxResolution: 1.40625,

    /**
     * APIProperty: minResolution
     * {Float} 最小分辨率。
     */
    minResolution: null,

    /**
     * APIProperty: maxScale
     * {Float} 最大比例尺分母。
     */
    maxScale: null,

    /**
     * APIProperty: minScale
     * {Float} 最小比例尺分母。
     */
    minScale: null,

    /**
     * APIProperty: maxExtent
     * {<Geo.Bounds>}   地图的最大范围。在十进制度数(-180, -90, 180, 90)中默认范围是全球。
	 * 							   如果你不使用地图投影和不显示全球范围。就在地图参数选项上设置一个不同的值。               
     */
    maxExtent: null,
    
    /**
     * APIProperty: minExtent
     * {<Geo.Bounds>} 地图的最小范围。
     */
    minExtent: null,
    
    /**
     * APIProperty: restrictedExtent
     * {<Geo.Bounds>}  限制地图导航的范围。如果restrictedExtent值不为null,指定的范围将会被限制平移。另外，
     * 缩放到一个在限制范围中的分辨率，如果该分辨率超出了限制的范围的话，地图将会进行中心定位。如果你希望限制缩放级别或分辨率，使用maxResolution。
     */
    restrictedExtent: null,

    /**
     * APIProperty: numZoomLevels
     * {Integer} 地图的缩放级别数。默认是放大到16级。可以根据需求在图层参数选择中设置其他的值。
     */
    numZoomLevels: 16,
	
	/** 
     * APIProperty: displayProjection
     * {<Geo.Projection>} 要求使用proj4js(proj4js能实现客户端坐标转换)的support.Projection来让几个控件显示用户的数据。
     * 如果设置了这个属性，他将对任何设置了displayProjection为null的已经加入到地图的控件起作用。
     */
    displayProjection: null,
	
    /**
     * APIProperty: fallThrough
     * {Boolean} OpenLayers 能让地图上的事件不会出现在页面上的其他元素上或压制其他元素的这些事件吗？默认是事件阻断的。          
     */
    fallThrough: true,
	
	/**
     * APIProperty: eventListeners
     * {Object} 如果在构造器中设置一个option属性，事件监听器对象将会注册到 <Geo.View2D.Events.on>上。
     *          对象的构造者必须是一个监听器对象，该对象陈列在 events.on方法的例子里。
     */
    eventListeners: null,
	
    /**
     * Property: paddingForPopups
     * {<OpenLayers.Bounds>} Outside margin of the popup. Used to prevent 
     *     the popup from getting too close to the map border.
     */
    paddingForPopups : null,

    /**
     * Constructor: Geo.ViewFl.Map
     * Geo.ViewFl.Map构造方法。
     *
     * Parameters:
     * div - {DOMElement|String} DIV元素 说明：该div必须要设置宽高才能正常显示。
     * options - {Object} 选项。
     *
     */
    initialize: function(div, options) {
				
        if (typeof(div) == "string") {
            this.div = document.getElementById(div);
        }
        else {
            this.div = div;
        }
        this.id = OpenLayers.Util.createUniqueID("ViewFlash2D_Map_");
		OpenLayers.Element.addClass(this.div, 'olMap');
		
        //要把mapInstances改成swfInstances
        Geo.ViewFl.mapInstances[this.id] = {
            loaded: false,
            mapObj: this,
            flashEventHandler: function(eventType, objectId, params) {

                var mapObj = this.mapObj

                var eventFn = {
                    "onReady":function() {

                        mapObj._initMap();
						mapObj.handlers = [];
                        mapObj.onReady();
                    }
                    ,"featureSelected": function(){
                        Geo.ViewFl.featureSelectedHandler(objectId, params);
                    },	
					changeCenter: function() {//地图放大缩小或中心点位置发生改变触发本事件
						for(var i = 0, len = mapObj.popups.length; i < len; i++) {
							//浮云存在两个版本，一个是js版本，一个是flex版本，在flex版本中不需要调用updatePosition,所以要做判断
							if(mapObj.popups[i].updatePosition) {
								mapObj.popups[i].updatePosition();
							}
						}
					},
					//新增示例需求功能
					resizeEnd:function(){
						mapObj.resizeEndFn(params);
					},
					zoomChange:function(){
						mapObj.zoomChangeFn(params);
					},
					mapCenterChange:function(){
						mapObj.mapCenterChangeFn(params);
					},
					featureClick:function(){
						mapObj.featureClickFn(params);
					}
					
					
                };
                if(eventFn[eventType]){
                    eventFn[eventType]();
                }

            },
            handlers:[]
        }
		
        var swfObj = document.createElement("div");
        swfObj.id = this.id;
		// the viewPortDiv is the outermost div we modify
        var id = this.id + "_OpenLayers_ViewPort";
        this.viewPortDiv = OpenLayers.Util.createDiv(id, null, null, null,
                                                     "relative", null,
                                                     "hidden");
        this.viewPortDiv.style.width = "100%";
        this.viewPortDiv.style.height = "100%";
        this.viewPortDiv.className = "olMapViewport";
        this.div.appendChild(this.viewPortDiv);
//		
        this.viewPortDiv.appendChild(swfObj);
		this.paddingForPopups = new OpenLayers.Bounds(15, 15, 15, 15);
		
        var apiFilePath = Geo.getScriptLocation() + "bin/FlashView.swf";
        var expressInstallFilePath = Geo.getScriptLocation() + "bin/playerProductInstall.swf";
        var fn = Geo.ViewFl.mapInstances[this.id].flashEventHandler
        var flashParams = {mapid: this.id};
		//设置{wmode: "transparent"}是为了能够让div始终在flash上面
        swfobject.embedSWF(
            apiFilePath, this.id, "100%", "100%", "9.0.0", expressInstallFilePath, flashParams, {wmode: "transparent"}, null
            , OpenLayers.Function.bind(function(e) {
	            this.swfObj = e.ref;
	            this.viewPortDiv.appendChild(this.swfObj);
	        }, this)
        );
		
        this.events = new OpenLayers.Events(this,
                                    this.div,
                                    this.EVENT_TYPES,
                                    this.fallThrough,
                                    {includeXY: true});
        this.layers = [];
        this.overLayers = [];
        this.popups = [];
		
        this.updateSize();
        if(this.eventListeners instanceof Object) {
            this.events.on(this.eventListeners);
        }
 
        // update the map size and location before the map moves
        this.events.register("movestart", this, this.updateSize);

        // Because Mozilla does not support the "resize" event for elements 
        // other than "window", we need to put a hack here. 
        if (OpenLayers.String.contains(navigator.appName, "Microsoft")) {
            // If IE, register the resize on the div
            this.events.register("resize", this, this.updateSize);
        } else {
            // Else updateSize on catching the window's resize
            //  Note that this is ok, as updateSize() does nothing if the 
            //  map's size has not actually changed.
            this.updateSizeDestroy = OpenLayers.Function.bind(this.updateSize, 
                this);
            OpenLayers.Event.observe(window, 'resize',
                            this.updateSizeDestroy);
        }
        
        this.unloadDestroy = OpenLayers.Function.bind(this.destroy, this);
        
		
        // always call map.destroy()
        OpenLayers.Event.observe(window, 'unload', this.unloadDestroy);
        
        // add any initial layers
        if (options && options.layers) {
            this.addLayers(options.layers);        
            // set center (and optionally zoom)
            if (options.center) {
                // zoom can be undefined here
                this.setCenter(options.center, options.zoom);
            }
        }
    },
	
	/**
     * APIMethod: destroy
     * 销毁地图对象。
     */
    destroy: function() {
//		        // if unloadDestroy is null, we've already been destroyed
//        if (!this.unloadDestroy) {
//            return false;
//        }
//        
//        // make sure panning doesn't continue after destruction
//        if(this.panTween) {
//            this.panTween.stop();
//            this.panTween = null;
//        }
//
//        // map has been destroyed. dont do it again!
//        OpenLayers.Event.stopObserving(window, 'unload', this.unloadDestroy);
//        this.unloadDestroy = null;
//
//        if (this.updateSizeDestroy) {
//            OpenLayers.Event.stopObserving(window, 'resize', 
//                                           this.updateSizeDestroy);
//        } else {
//            this.events.unregister("resize", this, this.updateSize);
//        }    
//        
//        this.paddingForPopups = null;    
//
//        if (this.controls != null) {
//            for (var i = this.controls.length - 1; i>=0; --i) {
//                this.controls[i].destroy();
//            } 
//            this.controls = null;
//        }
//        if (this.layers != null) {
//            for (var i = this.layers.length - 1; i>=0; --i) {
//                //pass 'false' to destroy so that map wont try to set a new 
//                // baselayer after each baselayer is removed
//                this.layers[i].destroy(false);
//            } 
//            this.layers = null;
//        }
//        if (this.viewPortDiv) {
//            this.div.removeChild(this.viewPortDiv);
//        }
//        this.viewPortDiv = null;
//
//        if(this.eventListeners) {
//            this.events.un(this.eventListeners);
//            this.eventListeners = null;
//        }
//        this.events.destroy();
//        this.events = null;
	},
	
    /**
     * APIMethod: loadLayerGroup
     * 加载图层组至地图中。
     * 
     * Parameters:
     * layerGroup - {Object} 图层组对象。
     * 
     */
    loadLayerGroup: function(layerGroup){
		
        if (this.layerGroup == layerGroup) {
            msg = "不能重复加载图层组到地图中！";
            OpenLayers.Console.warn(msg);
            return false;
        }
        this.unloadLayerGroup();

        layerGroup.setMap(this);
        this.layerGroup = layerGroup;
        
        this.resetOverLayer();
        this.resetTopLayer();
        
        this.events.triggerEvent("loadlayergroup", {
            layerGroup: layerGroup,
			map : this
        });
    },
	
    /**
     * APIMethod: unloadLayerGroup
     * 卸载图层组。
     */
    unloadLayerGroup: function(){
		var layerGroup = this.layerGroup;
        if (!layerGroup) {
			return false;
		}
        var layers = layerGroup.layers;
        for (var i = 0; i < layers.length; i++) {
            var layer = layers[i];
            this.removeLayer(layer);
        }
        layerGroup.map = null;
        this.layerGroup = null;
        this.events.triggerEvent("unloadLayerGroup", {
            layerGroup: layerGroup,
			map : this
        });
    },
	
		
    /**
	 * APIMethod: resetTopLayer
	 * 将置顶图层重新排列。
	 */	
    resetTopLayer: function(){
        var layersNum = this.layers.length;
		var topIndex = layersNum - 1;
        for (var i = layersNum - 1; i >= 0; i--) {
            var layer = this.layers[i];
            if (layer.isOnTop) {
                this.setLayerIndex(layer, topIndex--);
            }
        }
    },
	
	/**
	 * APIMethod: resetOverLayer
	 * 将覆盖图层重新排列。
	 */	
	resetOverLayer:function(){
		var layersNum = this.layers.length;
		var topIndex = layersNum - 1;
        for (var i = layersNum - 1; i >= 0; i--) {
            var layer = this.layers[i];
            
            //如果不是覆盖图层则视为底图图层将之移到最底层
            if (OpenLayers.Util.indexOf(this.overLayers,layer) != -1) {
                this.setLayerIndex(layer, topIndex--);
            }
        }
	},
	
	/**
     * APIMethod: setOptions
     * 设置地图构造参数选项。
     * 
     * Parameters:
     * 	options - {Object} 选项。
     */
	setOptions: function(options) {
		
	},
	
	/**
     * APIMethod: getTileSize
     * 获取地图的瓦片尺寸。
     * 
     * Returns:
     * {<Geo.Size>}
     */
	getTileSize: function() {
		
	},
	
	/**
     * APIMethod: getBy
     * 获取符合指定属性和匹配项的对象列表。
     * 
     * Parameters:
     * array - {String} 地图对象属性数组。
     * property - {String} 数组中的一个属性。
     * match - {String | Object} 匹配值。
     *
     * Returns:
     * {Array} 从对象数组中获取符合条件的记录。
     */
	getBy: function(array, property, match) {
        var test = (typeof match.test == "function");
        var found = OpenLayers.Array.filter(this[array], function(item) {
            return item[property] == match || (test && match.test(item[property]));
        });
        return found;
	},
	
	/**
     * APIMethod: getLayersBy
     * 从图层数组中获取符合条件的记录。
     * 
     * Parameter:
     * property - {String} 指定的对象属性。
     * match - {String | Object} 匹配值。
     *
     * Returns:
     * {Array(<Geo.ViewFl.Layer>)}包含符合条件的图层对象数组。如果没有匹配的，返回空数组。
     */
	getLayersBy: function(property, match) {
		return this.getBy("layers", property, match);	
	},
	
	/**
     * APIMethod: getLayersByName
 	 * 通过名称来获取图层列表。
 	 * 
     * Parameter:
     * match - {String | Object} 图层名称或正式表达式对象。
     *
     * Returns:
     * {Array(<Geo.ViewFl.Layer>)} 包含符合条件的图层对象数组。
     */
	getLayersByName: function(match) {
		return this.getLayersBy("name", match);
	},
	
	/**
     * APIMethod: getLayersByClass
     * 根据图层类名获取符合条件的图层。
     * 
     * Parameter:
     * match - {String | Object}图层类型或正式表达式对象。
     * 
     * Returns:
     * {Array(<Geo.ViewFl.Layer>)} 包含符合条件的图层对象数组。
     */
	getLayersByClass: function(match) {
		
	},
	
	/**
     * APIMethod: getControlsBy
     * 通过与给定条件相匹配的属性来获取控件列表。
     * 
     * Parameter:
     * property - {String} 控件的属性。
     * match - {String | Object} 匹配的字符串，也可以是一个正则表达式的文本或对象。
     *
     * Returns:
     * {Array(<Geo.ViewFl.Control>)} 返回与给定的条件相匹配的控件清单。如果没有匹配的，返回空数组。
     */
	getControlsBy: function(property, match) {
		
	},
	
	/**
     * APIMethod: getControlsByClass
     * 通过CLASS_NAME来获取控件列表。
     * 
     * Parameter:
     * match - {String | Object} 控件的类名，也可以是一个正则表达式的文本或对象。
     *
     * Returns:
     * {Array(<Geo.ViewFl.Control>)} 返回与给定的CLSSS_NAME相匹配的控件清单。如果没有匹配的，返回空数组。
     */
	getControlsByClass: function(match) {
		
	},
	
	/**
     * APIMethod: getLayer
     * 通过图层的id来获取图层对象。
     * 
     * Parameter:
     * id - {String} 图层ID。
     *
     * Returns:
     * {<Geo.ViewFl.Layer>} 地图图层，返回的这个图层是根据id来匹配的。               
     */
	getLayer: function(id) {
        var foundLayer = null;
        for (var i=0, len=this.layers.length; i<len; i++) {
            var layer = this.layers[i];
            if (layer.id == id) {
                foundLayer = layer;
                break;
            }
        }
        return foundLayer;
	},
	
	/**
     * APIMethod: addLayer
     * 添加图层。
     * 
     * Parameters:
     * layer - {<Geo.ViewFl.Layer>} 
     */
	addLayer: function(layer) {
				
        var layers = this.layers;
        if (!layer) {
            return false;
        }
        for (var i = 0, len = layers.length; i < len; i++) {
            if (this.layers[i] == layer) {
                var msg = OpenLayers.i18n('layerAlreadyAdded',
                {'layerName':layer.name});
                OpenLayers.Console.warn(msg);
                return false;
            }
        }
        this.layers.push(layer);
		
        layer.setMap(this);
		
	},
	
    /**
     * APIMethod: addLayers
     * 添加多个图层到地图中。
     * 
     * Parameters:
     * layers - {Array(<Geo.View3D.Layer>)}图层对象数组。
     */
    addLayers: function(layers){
        if (!(layers instanceof Array)) {
            layers = [layers];
        }
        for (var i = 0; i < layers.length; i++) {
            this.addLayer(layers[i]);
        }
    },

    /**
	 * APIMethod: addOverLayer
	 * 将指定图层作为覆盖层添加。与addLayer方法不同的是，该图层的引用除了保存到地图对象的layers数组中，还将保存到overLayers数组。
	 * 覆盖层在基础图层组切换时，叠加顺序不受基础图层加载、卸载的影响，始终保持在所有基础图层的上方。
	 *
	 * Parameters: 
	 * layer - {Geo.View2D.Layer} 二维视图图层对象。
	 */		
    addOverLayer: function(layer){
        this.addLayer(layer);
        this.overLayers.push(layer);
    },
	
	/**
     * APIMethod: removeLayer
     * 从地图中移除图层。
     * 
     * Parameters:
     * layer - {<Geo.ViewFl.Layer>} 
     */
	removeLayer: function(layer) {
		OpenLayers.Util.removeItem(this.overLayers, layer);
        OpenLayers.Util.removeItem(this.layers, layer);
        layer.removeMap(this);
        layer.map = null;
		
	},
	
	/**
     * APIMethod: getNumLayers
     * 获取当前添加到地图中的图层数量。
     * 
     * Returns:
     * {Int} 返回与地图相关联的图层数量。
     */
	getNumLayers: function() {
		
		
	},
	
	/**
     * APIMethod: getLayerIndex
     * 获取图层在图层数组中的索引位置。
     * 
     * Parameters:
     * layer - {<Geo.ViewFl.Layer>} 表示要被设置在指定位置的图层。
     *
     * Returns:
     * {Integer} 返回图层在图层数组中的索引位置。
     */
	getLayerIndex: function(layer) {
		return OpenLayers.Util.indexOf(this.layers, layer);
	},
	
	/**
     * APIMethod: setLayerIndex
     * 设置图层在指定的位置。这个方法对基础图层是无效的。
     * 
     * Parameters:
     * layer - {<Geo.ViewFl.Layer>} 表示要被设置在指定位置的图层。
     * idx - {int} 表示要设置的位置。
     */
	setLayerIndex: function(layer, idx) {
        var base = this.getLayerIndex(layer);
		/***/
		// 该图层前一个索引图层
		var aLayer = null;
		// 该图层后一个索引图层
		var bLayer = null;
		if(base == 0){
			var bLayer = this.layers[base + 1];
		}else if(base == this.layers.length - 1){
			var aLayer = this.layers[base - 1];
		}else{
			var aLayer = this.layers[base - 1];
			var bLayer = this.layers[base + 1];
		}
        var alayerData = null;
        var blayerData = null;
        
        if (aLayer && aLayer._flashObjId) {
            alayerData = aLayer._flashObjId;
            //针对前一个索引图层为WMS图层中会有多个指定子图层
        }
        if (bLayer && bLayer._flashObjId) {
            blayerData = bLayer._flashObjId;
            //针对后一个索引图层为WMS图层中会有多个指定子图层
        }
        
		/***/
        if (idx < 0) {
            idx = 0;
        } else if (idx > this.layers.length) {
            idx = this.layers.length;
        }
        if (base != idx) {
            this.layers.splice(base, 1);
            this.layers.splice(idx, 0, layer);
            
            //根据偏移量，移动插件中的图层
            var delta = idx - base;
			var layerData = layer._flashObjId;
			
			if(delta == this.layers.length){
				delta = this.layers.length-1;
			}
			/***/
			if (layerData) {
				this.swfObj.setLayerIndex('{"layerId":"'+layer._flashObjId+'","index":'+delta+'}');
			}
        }
	},
	
	/**
     * APIMethod: raiseLayer
     * 上移图层，如果delta是正数，图层会上移，如果是负数，图层会下移。这个方法对基础图层是无效的。
     * 
     * Paremeters:
     * layer - {<Geo.ViewFl.Layer>} 指定的图层对象。
     * delta - {int} 移动增量。
     * 
     * (code)
     *  var map = new Geo.ViewFl.Map("mapBox");
     *  map.onReady = function() {
     *  //创建wmts图层对象
	 *	 	var wms = new Geo.ViewFl.Layer.WMS("WMS","http://map.geostar.com.cn:9001/wms/wms",
	 *		{
	 *			layers:"BOU2_4M_L,BOU1_4M_S"
	 *		});
	 *		//向地图中添加WMS服务
	 *		map.addLayer(wms);
	 *		//将wms图层上移一层
	 *		map.raiseLayer(wms, 1);
	 *		//将wms图层下移一层
	 *		map.raiseLayer(wms, -1);
     *  }
     * (end)
     */
	raiseLayer: function(layer, delta) {
		//要移动图层的当前位置
		var currentIndex = this.getLayerIndex(layer);
		//delta表示移动几位
	    var tempDelta = Math.abs(delta);
		if(delta > 0) {
			for (var i = currentIndex, len=this.layers.length; i<len; i++) {
				//若起大于0
				if(tempDelta == 0 || len <= i+1) {
					break;
				}
				if(!this.layers[i+1].displayInLayerSwitcher) {
					delta ++;
				}else {
					tempDelta--;
				}
        		
        	}
		}else if(delta < 0) {
			for (var i = currentIndex, len=this.layers.length;i >= 0; i--) {
        		if(tempDelta == 0 || i - 1 < 0) {
					break;
				}
				if(!this.layers[i-1].displayInLayerSwitcher) {
					delta = delta - 1;
				}else {
					tempDelta--;
				}
        	}
		}
		
		var idx = this.getLayerIndex(layer) + delta;
        this.setLayerIndex(layer, idx);
	},
	
	/**
     * APIMethod: addControl
     * 添加控件，将控件保存到地图对象的控件数组中，
     * 如果指定的是单个控件对象则将它转换成数组。
     * 
     * Parameters:
     * control - {<Geo.ViewFl.Control>} 控件。
     * px - {<Geo.Pixel>} 屏幕位置。
     */
	addControl: function(control, px) {
		if(!this.controls){
			this.controls = [];
		}
		this.controls.push(control);
        this.addControlToMap(control);
	},
	
	/**
     * APIMethod: addControlToMap
     * 添加控件到地图中。
     * 
     * Parameters:
     * control - {<Geo.ViewFl.Control>} 控件。
     * px - {<Geo.Pixel>} 屏幕位置。
     */
	addControlToMap: function(control, px) {
		control.setMap(this);
        control.draw(px);
        if (control.autoActivate) {
            control.activate();
        }
	},
	
	/**
     * APIMethod: getControl
     * 根据控件标识获取控件对象引用。
     * 
	 * Parameters:
     * id - {String} 控件唯一标识。
     * 
     * Returns:
     * {<Geo.ViewFl.Control>} 控件对象。
     */
	getControl: function(id) {
		var returnControl = null;
        for(var i=0, len=this.controls.length; i<len; i++) {
            var control = this.controls[i];
            if (control._flashObjId == id) {
                returnControl = control;
                break;
            }
        }
        return returnControl;
	},
	
	/**
     * APIMethod: removeControl
     * 删除地图中的控件。移除的控件来自于地图对象的控件列表。
     * 
     * Parameters:
     * control - {<Geo.ViewFl.Control>} 移除的控件。
     */
	removeControl: function(control) {
		if( (control) && (control == this.getControl(control._flashObjId)) ){
			OpenLayers.Util.removeItem(this.controls, control);
			return this.swfObj.removeControl(control._flashObjId);
		}
		return false;
	},
	
	/**
     * APIMethod: addPopup
     * 添加弹出框。
     * 
     * Parameters:
     * popup - {<Geo.ViewFl.Popup>} 弹出框对象的引用。
     * exclusive - 如果是true,首先会关闭所有其他的 popup。
     */
	addPopup: function(popup, exclusive) {
		if (exclusive) {
            //remove all other popups from screen
            for (var i = this.popups.length - 1; i >= 0; --i) {
                this.removePopup(this.popups[i]);
            }
        }

        popup.map = this;
        this.popups.push(popup);
        var popupDiv = popup.draw();
		//js方式实现的浮云
		if(popupDiv && popup instanceof Geo.ViewFl.Popup) {
            popupDiv.style.zIndex = this.Z_INDEX_BASE['Popup'] +
                                    this.popups.length;
            this.viewPortDiv.appendChild(popupDiv);
		}
        
	},
	
	/**
     * APIMethod: removePopup
     * 将指定的弹出框对象从地图中移除。
     * 
     * Parameters:
     * popup - {<Geo.ViewFl.Popup>} 指定的弹出框对象。
     */
	removePopup: function(popup) {
		//如果参数为空，清除全部
        if (!popup) {
            popup = this.popups;
        }
        if (!(popup instanceof Array)) {
            popup = [popup];
        }
        for (var i = popup.length - 1; i >= 0; i--) {
			var popupTmp = popup[i];
			OpenLayers.Util.removeItem(this.popups, popupTmp);
			//js方式实现的浮云
			if(popupTmp instanceof Geo.ViewFl.Popup) {
				if (popupTmp.div) {
	            try { this.viewPortDiv.removeChild(popupTmp.div); }
	            catch (e) { } // Popups sometimes apparently get disconnected
	                      // from the layerContainerDiv, and cause complaints.
		        }
		        popupTmp.map = null;
				//flex方式实现的浮云
			}else if(popupTmp instanceof Geo.ViewFl.PopupFl) {
				if (popupTmp.map) {
                popupTmp._clear();
	            }
	            popupTmp.map = null;
			}
        }
	},
	
	/**
     * APIMethod: removePopupFl
     * 将指定的弹出框对象从地图中移除。
     * 说明：在flash视口下,如果用户使用的是Geo.ViewFl.PopupFl或其子类则销毁浮云的时候调用本方法。
     * 
     * Parameters:
     * popup - {<Geo.ViewFl.PopupFl>} 指定的弹出框对象。
     */
	removePopupFl: function(popup) {
		//如果参数为空，清除全部
        if (!popup) {
            popup = this.popups;
        }
        if (!(popup instanceof Array)) {
            popup = [popup];
        }
        for (var i = popup.length - 1; i >= 0; i--) {
			var popupTmp = popup[i];
			OpenLayers.Util.removeItem(this.popups, popupTmp);
            if (popupTmp.map) {
                popupTmp._clear();
            }
            popupTmp.map = null;
            
        }
	},
	
	/**
     * APIMethod: getSize
     * 返回当前地图的尺寸对象复本。
     * 
     * Returns:
     * {<Geo.Size>} 地图的尺寸对象复本。
     */
	getSize: function() {
        var size = null;
        if (this.size != null) {
            size = this.size.clone();
        }
        return size;
	},
	
	/**
     * APIMethod: updateSize
     * 更新地图尺寸与中心点。
     */
	updateSize: function() {
        // the div might have moved on the page, also
        var newSize = this.getCurrentSize();
        if (newSize && !isNaN(newSize.h) && !isNaN(newSize.w)) {
            this.events.clearMouseCache();
            var oldSize = this.getSize();
            if (oldSize == null) {
                this.size = oldSize = newSize;
            }
            if (!newSize.equals(oldSize)) {
                
                // store the new size
                this.size = newSize;
    
                //notify layers of mapresize
                for(var i=0, len=this.layers.length; i<len; i++) {
                    this.layers[i].onMapResize();                
                }
    
                var center = this.getCenter();
    
                if (this.baseLayer != null && center != null) {
                    var zoom = this.getZoom();
                    this.zoom = null;
                    this.setCenter(center, zoom);
                }
    
            }
        }
	},
	
	/**
     * APIMethod: getCurrentSize
     * 获取当前地图尺寸。
     * 
     * Returns:
     * {<Geo.Size>}地图尺寸。
     */
	getCurrentSize: function() {
		
        var size = new OpenLayers.Size(this.div.clientWidth, 
                                       this.div.clientHeight);

        if (size.w == 0 && size.h == 0 || isNaN(size.w) && isNaN(size.h)) {
            size.w = this.div.offsetWidth;
            size.h = this.div.offsetHeight;
        }
        if (size.w == 0 && size.h == 0 || isNaN(size.w) && isNaN(size.h)) {
            size.w = parseInt(this.div.style.width);
            size.h = parseInt(this.div.style.height);
        }
        return size;
	},
	
	/** 
     * Method: calculateBounds
     * 
     * Parameters:
     * center - {<OpenLayers.LonLat>} Default is this.getCenter()
     * resolution - {float} Default is this.getResolution() 
     * 
     * Returns:
     * {<OpenLayers.Bounds>} A bounds based on resolution, center, and 
     *                       current mapsize.
     */
    calculateBounds: function(center, resolution) {

        var extent = null;
        
        if (center == null) {
            center = this.getCenter();
        }                
        if (resolution == null) {
            resolution = this.getResolution();
        }
    
        if ((center != null) && (resolution != null)) {

            var size = this.getSize();
            var w_deg = size.w * resolution;
            var h_deg = size.h * resolution;
        
            extent = new OpenLayers.Bounds(center.lon - w_deg / 2,
                                           center.lat - h_deg / 2,
                                           center.lon + w_deg / 2,
                                           center.lat + h_deg / 2);
        
        }

        return extent;
    },
	
	/**
     * APIMethod: getCenter
     * 获取中心点坐标。
     * 
     * Returns:
     * {<Geo.LonLat>} 地理坐标。
     */
	getCenter: function() {
		var result = Geo.ViewFl._jsonParser.read(this.swfObj.getCenter());
        return OpenLayers.LonLat.fromString(result.lonlat);
	},
	
	/**
     * APIMethod: getCachedCenter
     * 获取被缓存的中心点坐标。
     * 
     * Returns:
     * {<Geo.LonLat>} 中心点坐标。
     */
	getCachedCenter: function() {
		
	},
	
	/**
     * APIMethod: getZoom
     * 获取地图当前的级别。
     * 
     * Returns:
     * {Integer} 地图级别。
     */
	getZoom: function() {
		return this.swfObj.getZoom();
	},
	
	/**
     * APIMethod: pan
     * 地图平移指定像素值。
     * 
     * Parameters:
     * dx - {Integer} 
     * dy - {Integer} 
     */
	pan: function(dx, dy) {
		
	},
	
	/**
     * APIMethod: panTo
     * 地图平移到指定地理坐标。
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>} 指定地理坐标 。
     */
	panTo: function(lonlat) {
		
	},
	
	/**
     * APIMethod: setCenter
     * 地图中心定位(包括缩放级别)。
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>} 要定位的中心位置。
     * zoom - {Integer} 缩放级别。
     * (code)
  	 *	map.onReady = function() {
	 *		var tile = new Geo.ViewFl.Layer.GlobeTile("tile","http://tile0.tianditu.com/services/A0512_EMap",{
	 *			"topLevel":"2",
	 *			"bottomLevel":"10"
	 *		});
	 *		map.addLayer(tile);
	 *		var lonlat = new Geo.LonLat(115.468505859375,35.5506591796875);
	 *		//设置地图的中心点和级别
	 *		map.setCenter(lonlat, 4);
	 *	}
     * (end)
     */
	setCenter: function(lonlat, zoom) {
		var param = '{"lonlat":"'+lonlat.lon+','+lonlat.lat+'","zoom":"'+zoom+'"}';
		this.swfObj.setCenter(param);
	},
	
	/**
     * APIMethod: moveTo
     * 将地图移到指定地理坐标与级别。
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>} 地理位置。
     * zoom - {Integer} 级别。
     * options - {Object} 可选性。
     */
	moveTo: function(lonlat, zoom, options) {
		
	},
	
	/**
     * APIMethod: isValidLonLat
     * 是否有效地理坐标。
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>} 地理位置。
     * 
     * Returns:
     * {Boolean} 是否有效。
     */
	isValidLonLat: function(lonlat) {
		
	},
	
	/**
     * APIMethod: getProjection
     * 获取投影类型代号。
     * 
     * Returns:
     * {String}投影类型代号。
     */
	getProjection: function() {
		
	},
	
	/**
     * APIMethod: getProjectionObject
     * 获取投影对象。
     * 
     * Returns:
     * {<Geo.Projection>} 投影对象。
     */
	getProjectionObject: function() {
		
	},
	
	/**
     * APIMethod: getMaxResolution
     * 获取最大分辨率。
     * 
     * Returns:
     * {Number} 最大分辨率。
     */
	getMaxResolution: function() {
		
	},
	
	/**
     * APIMethod: getMaxExtent
     * 获取地图最大范围。
     * 
     * Returns:
     * {<Geo.Bounds>} 地图最大范围。
     */
	getMaxExtent: function() {
		
	},
	
	/**
     * APIMethod: getNumZoomLevels
     * 获取地图的级别数量。
     * 
     * Returns:
     * {Integer} 级别数量。
     */
	getNumZoomLevels: function() {
		
	},
	
	/**
     * APIMethod: getExtent
     * 获取地图当前范围。
     * 
     * Returns:
     * {<Geo.Bounds>} 地图当前范围。
     */
	getExtent: function() {
		var bboxObj = this.swfObj.getExtent();
		var result = Geo.ViewFl._jsonParser.read(bboxObj);
		return Geo.Bounds.fromString(result.bounds);
	},
	
	/**
     * APIMethod: getResolution
     * 获取当前地图分辨率。
     * 
     * Returns:
     * {Float} 地图当前分辨率。
     */
	getResolution: function() {
		
	},
	
	/**
     * APIMethod: getUnits
     * 获取地图单位。
     * 
     * Returns:
     * {Float} 地图单位。
     */
	getUnits: function() {
		
	},
	
	/**
     * APIMethod: getScale
     * 获取地图当前比例尺。
     * 
     * Returns:
     * {Float} 地图当前比例尺。
     */
	getScale: function() {
		//************************************新增示例需求功能************************************************/
		var scale = null;
		var res = this.swfObj.getCurrentResolution();
		var units = this.swfObj.getCurrentBaseLayerUnits();
		scale = OpenLayers.Util.getScaleFromResolution(parseFloat(res), units);
		return scale;
	},
	
	/**
	 * APIMethod: isTransitionEffect
	 * 设置地图是否平滑缩放。
	 * 
	 * Parameters:
     * isTransition - {Boolean} 是否平滑缩放，true表示是，false表示不是。
	 */
	isTransitionEffect: function(isTransition) {
		this.swfObj.setTransitionEffect(isTransition);
	},
	
	/**
     * APIMethod: getZoomForExtent
     * 根据指定范围获取对应的地图级别。
     * 
     * Parameters: 
     * bounds - {<Geo.Bounds>} 地图范围。
     * closest - {Boolean} 查找与指定范围最接近的级别。这会导致级别不包含在准确的范围内。默认是false。
     * 
     * Returns:
     * {Integer} 根据指定的范围返回合适的缩放级别。如果没有设置基础图层，返回null。
     */
	getZoomForExtent: function(bounds, closest) {
		
	},
	
	/**
     * APIMethod: getResolutionForZoom
     * 根据地图级别获取对应分辨率。
     * 
     * Parameter:
     * zoom - {Float} 级别。
     * 
     * Returns:
     * {Float} 返回与指定级别相对应的分辨率。如果没有设置基础图层将会返回null。  
     */
	getResolutionForZoom: function(zoom) {
		
	},
	
	/**
     * APIMethod: getZoomForResolution
     * 根据指定分辨率获取对应的级别。
     * 
     * Parameter:
     * resolution - {Float}
     * closest - {Boolean} 查找与分辨率相一致的级别。如果设置该属性为true,由于误差，将有可能导致得到的级别比实际要得到的级别要低。
     * 
     * Returns:
     * {Integer} 根据指定的分辨率返回适合的缩放级别。如果没有设置基础图层将会返回null。     
     */
	getZoomForResolution: function(resolution, closest) {
		var newZoom = this.swfObj.getZoomForResolution(resolution, closest);
		return newZoom;
	},
	
	/**
     * APIMethod: zoomTo
     * 缩放到指定地图缩放级别。
     * 
     * Parameter:
     * zoom - {Integer} 级别。
     */
	zoomTo: function(zoom) {
		this.swfObj.zoomTo('{"zoom":'+zoom+'}');
	},
	
	/**
     * APIMethod: zoomIn
     * 放大地图。
     */
	zoomIn: function() {
		this.swfObj.zoomIn();
	},
	
	/**
     * APIMethod: zoomOut
     * 缩小地图。
     */
	zoomOut: function() {
		this.swfObj.zoomOut();
	},
	
	/**
     * APIMethod: zoomToExtent
     * 缩放指定地图范围，根据范围确定最适当的级别。
     * 
     * Parameters: 
     * bounds - {<Geo.Bounds>} 地图范围。
     * closest - {Boolean} 查找与指定范围最接近的级别。这会导致级别不包含在准确的范围内。默认是false。
     */
	zoomToExtent: function(bounds, closest) {
		//************************************新增示例需求功能************************************************/
		var parameters = '{"bounds":"'+bounds.toBBOX()+'"}';
		this.swfObj.zoomToExtent(parameters);
		//alert("map::::"+parameters);
	},
	
	addFeaturesByGML: function(id,gmlStr) {
		var param = id.substr(1,id.length-2);
		this.swfObj.addFeaturesByGML('{'+param+',"gmlStr":"'+gmlStr+'"}');
	},
	
	/**
     * APIMethod: zoomToMaxExtent
     * 缩放地图最大范围，根据范围确定最适当的级别。
     * 
     */
	zoomToMaxExtent: function() {
		
	},
	
	/**
     * APIMethod: zoomToScale
     * 缩放指定地图比例尺。
     * 
     * Parameters: 
     * scale - {float} 比例尺。
     * closest - {Boolean} 如果设置为true，会产生一定的误差。
     */
	zoomToScale: function(scale, closest) {
		
	},
	
	_initMap: function() {
        var param = '{"projection":"EPSG:4326","minZoomLevel":"2","mapid":"'+this.id+'","maxZoomLevel":"18","maxExtent":"-180,-90,180,90"}';
        var result = this.swfObj.initMap(param);
		this.swfObj.setProxy(OpenLayers.ProxyHost);
    },

	/**
     * APIMethod: showControl
     * 显示地图中的控件。
     * 
     * Parameters:
     * control - {<Geo.ViewFl.Control>} 待显示的控件。
     */
    showControl: function(control){
        if ((control) && (control == this.getControl(control._flashObjId))) {
            this.swfObj.showControl(control._flashObjId);
        }
    },
	
	/**
     * APIMethod: hideControl
     * 隐藏地图中的控件。
     * 
     * Parameters:
     * control - {<Geo.ViewFl.Control>} 待隐藏的控件。
     */
    hideControl: function(control){
        if ((control) && (control == this.getControl(control._flashObjId))) {
            this.swfObj.hideControl(control._flashObjId);
        }
    },
	
	/**
     * APIMethod: showPopup
     * 显示地图中的浮云。
     * 
     * Parameters:
     * popup - {<Geo.ViewFl.Popup>} 待显示的浮云。
     */
    showPopup: function(popup){
        if (popup && popup.map) {
            this.swfObj.showPopup(popup._flashObjId);
        }
    },
	
	/**
     * APIMethod: hidePopup
     * 隐藏地图中的浮云。
     * 
     * Parameters:
     * popup - {<Geo.ViewFl.Popup>} 待隐藏的浮云。
     */
    hidePopup: function(popup){
		if (popup && popup.map) {
            this.swfObj.hidePopup(popup._flashObjId);
        }
    },
	
	/**
     * APIMethod: setPanZoomBarStyle
     * 设置级别导航条的样式。
     * 
     * Parameters:
     * styleName - {<String>} 这里提供两个样式的值："blue" 和  "default"。
     */
    setPanZoomBarStyle: function(styleName){
		if (styleName) {
            this.swfObj.setPanZoomBarStyle(styleName);
        }
    },
	
	/**
     * APIMethod: getViewPortPxFromLonLat
     * 获取根据地理坐标获取视口的像素。
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>} 地理坐标。
     * 
     * Returns:
     * {<Geo.Pixel>} 返回根据地理坐标转换的视口的像素。
     */
	getViewPortPxFromLonLat: function(lonlat) {
		var px = this.swfObj.getMapPxFromLocation(lonlat.lon, lonlat.lat);
		var arr = px.split(",");
		px = new OpenLayers.Pixel(arr[0].substr(2), arr[1].substr(2));
		return px;
	},
	
    /**
     * APIMethod: getViewPortPxFromLayerPx
     * 根据图层屏幕像素位置获取视图屏幕像素位置。
     * 
     * Parameters:
     * layerPx - {<Geo.Pixel>} 屏幕像素位置。
     * 
     * Returns:
     * {<Geo.Pixel>} 返回视图屏幕像素位置。
     */
    getViewPortPxFromLayerPx:function(layerPx) {
		//说明：本方法待验证
        var viewPortPx = null;
        if (layerPx != null) {
			/**
			 * 在openscales中图层起始点的像素位置和视口起始点的像素位置是一样的
			 * 所以无偏移，即dx,dy偏移值是0
			 */
            var dX = parseInt(0);
            var dY = parseInt(0);
            viewPortPx = layerPx;         
        }
        return viewPortPx;
    },

	/**
	 * 新增示例需求功能
	 */
	resizeEndFn: function(params){
		
	},
	zoomChangeFn: function(params){
		
	},
	mapCenterChangeFn:function(params){
		
	},
	featureClickFn:function(params){
	
	},
	/**
     * APIMethod: addKeyboardDefaultsControl
     * 键盘事件的操作。
     * 
     * Parameters:
     * value - {Boolean} 是否开启键盘事件。
     * 
     * Returns:
     * {Boolean} 操作是否成功的提示。
     */
	addKeyboardDefaultsControl:function (value){
		var result =  this.swfObj.addKeyboardDefaultsControl(value);
		return result;
	},
	/**
     * APIMethod: getLonLatFromMapPx
     * 获取根据像素获取地图坐标。
     * 
     * Parameters:
     * px - {<Geo.Pixel>} 屏幕像素位置。
     *
     * Returns:
     * {<Geo.LonLat>} 返回根据像素转换的地图坐标。  
     */
	getLonLatFromMapPx: function(px){
		var lonlatStr = this.swfObj.getLonLatFromMapPx(px.x, px.y);        
        var lon = Geo.ViewFl._jsonParser.read(lonlatStr).lon;
		var lat = Geo.ViewFl._jsonParser.read(lonlatStr).lat;
		var lonlat = new Geo.LonLat(lon, lat);
		return lonlat;
	},
		
	onReady: function() {
		
	},
	
    CLASS_NAME: "Geo.ViewFl.Map"

});
/**
 * Class: Geo.ViewFl.Layer
 * Flash视图下的图层基类。
 */
Geo.ViewFl.Layer = Geo.Class({
	
    /**
     * APIProperty: id
     * {String} 唯一标识符。
     */
    id: null,

    /** 
     * APIProperty: name
     * {String} 图层名称。
     */
    name: null,
	
    /**
     * Property: opacity
     * {Float} 图层的透明度，值在0.0与1.0之间。
     */
    opacity: null,
	
	/**
     * Property: alwaysInRange
     * {Float} 是否图层允许在全部范围（包括级别和最大范围）内有效。
     */
	alwaysInRange: null,
	
	/**
     * Property: RESOLUTION_PROPERTIES
     * {Array(String)}
     */
	RESOLUTION_PROPERTIES: ['scales', 'resolutions', 'maxScale', 'minScale',
        'maxResolution', 'minResolution', 'numZoomLevels', 'maxZoomLevel'],
	
    /**
     * APIProperty: map
     * {Geo.ViewFl.Map} 图层所在的地图对象。
     */
    map: null,
	
    /**
     * APIProperty: isBaseLayer
     * {Boolean} 是否是基础图层。默认值为false。
     */
    isBaseLayer: false,
	
    /** 
     * APIProperty: displayInLayerSwitcher
     * {Boolean} 是否显示在图层管理器中,默认值为true。
     */
    displayInLayerSwitcher: true,
	
	/**
	 * Property: isOnTop
	 * {Boolean} 图层是否在图层列表中置顶，默认值为false。
	 */
	isOnTop: false,

    /**
     * APIProperty: visibility
     * {Boolean} 图层是否在地图中可见，默认值为true。
     */
    visibility: true,
	
	/**
     * APIProperty: attribution
     * {String} 图层属性。
     *
     */
	attribution: null,
	
	/**
     * Property: inRange
     * {String} 是否在有效范围。
     */
	inRange: null,
	
	/**
     * Property: options
     * {String} 构造参数。
     */
	options: null,
	
	/**
     * APIProperty: eventListeners
     * {String} 事件监听定义。
     */
	eventListeners: null,
	
	/**
     * APIProperty: projection
     * {String} 投影类型。
     */
	projection:  "EPSG:4326",
	
	/**
     * APIProperty: units
     * {String} 单位。
     */
	units: "degrees",
	
	/**
     * APIProperty: scales
     * {String} 比例尺数组。
     */
	scales: null,
	
	/**
     * APIProperty: resolutions
     * {Array(Float)} 图层所有的分辨率列表。
     */
	resolutions: null,
	
	/**
     * APIProperty: maxExtent
     * {<Geo.Bounds>} 最大范围。
     */
	maxExtent: null,
	
	/**
     * APIProperty: minExtent
     * {<Geo.Bounds>} 最大范围。
     */
	minExtent: null,
	
	/**
     * APIProperty: maxResolution
     * {Float} 最大分辨率。
     */
	maxResolution: null,
	
	/**
     * APIProperty: minResolution
     * {Float} 最小分辨率。
     */
	minResolution: null,
	
	/**
     * APIProperty: numZoomLevels
     * {Float} 级别数。
     */
	numZoomLevels: null,
	
	/**
     * APIProperty: minScale
     * {Float} 最小比例尺。
     */
	minScale: null,
	
	/**
     * APIProperty: maxScale
     * {Float} 最大比例尺。
     */
	maxScale: null,
	
	/**
     * APIProperty: displayOutsideMaxExtent
     * {Float} 是否显示超出最大范围设置的数据。
     */
	displayOutsideMaxExtent: null,
	
	/**
     * Property: metadata
     * {Object} 用于保存服务元数据。
     */
	metadata: null,
	
    //swf内部图层对象标识
    _flashObjId: null,
    
    selectedFeatures:[],

    /**
     * Constant: EVENT_TYPES
     * {Array(String)} 图层对象所支持的事件类型定义。
     *
     * 本对象支持以下类型事件:
     * visibilitychanged - 可视状态改变事件。
     */
    EVENT_TYPES: ["loadstart", "loadend", "loadcancel", "visibilitychanged","move", "moveend", "added", "removed"],
	
	/**
     * APIProperty: events
     * {<Geo.View2D.Events>}事件管理器对象。
     */
    events: null,
	
	/**
	 * Constructor: Geo.ViewFl.Layer
	 * Geo.ViewFl.Layer构造函数。
	 *
	 * Parameters:
	 * name - {String} 图层名称。
	 * options - {Object} 选项。
	 */	 
    initialize: function(name, options) {
		this.addOptions(options);
		
        this.name = name;
        
        if (this.id == null) {
            this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
			
			this.events = new OpenLayers.Events(this, this.div, 
                                                this.EVENT_TYPES);
            if(this.eventListeners instanceof Object) {
                this.events.on(this.eventListeners);
            }
        }
        
        
    },

    /**
     * Method: destroy
     * 销毁图层对象。
     */
	destroy: function() {
		
	},
	
	 /**
     * Method: clone
     * 返回本对象的复本。
     */
	clone: function() {
		
	},
	
	/**
     * Method: getOptions
     * 获取构造选项参数。
     * 
     * Returns: 
     * {Object} 构造选项参数。
     */
	getOptions: function() {
		
	},
	
	/**
     * Method: setName
     * 设置图层名称，会触发"changelayer"事件。
     * 
     * Parameters:
     * newName - {String}新的图层名称。
     */
	setName: function(newName) {
		
	},
	
	/**
     * APIMethod: addOptions
     * 添加构造选项参数 。
     * 
     * Parameters:
     * newOptions - {Object} 参数选项。
     * 
     * Returns: 
     * {Object} 构造选项参数。
     */
	addOptions: function(newOptions) {
        if (this.options == null) {
	        this.options = {};
        }

        // update our copy for clone
        OpenLayers.Util.extend(this.options, newOptions);

        // add new options to this
        OpenLayers.Util.extend(this, newOptions);
	},
	
	/**
     * Method: onMapResize
     * 地图尺寸改变事件响应。
     */
	onMapResize: function() {
		
	},
	
	/**
     * Method: redraw
     * 图层重绘。
     * 
     * Returns: 
     * {Boolean}图层是否被重绘。
     */
	redraw: function() {
		
	},
	
	/**
     * Method: setMap
     * 将图层关联地图对象。
     * 
     * Parameters:
     * map - {<Geo.ViewFl.Map>}将图层关联地图对象。
     */
	setMap: function(map) {
		this.map = map;
	},
	
	/**
     * Method: removeMap
     * 将解除图层与地图的联系。
     * 
     * Parameters:
     * map - {<Geo.ViewFl.Map>}将解除图层与地图的联系。
     */
	removeMap: function(map) {
		
	},
	
	/**
     * Method: getVisibility
     * 获取图层的可见性。
     * 
     * Returns: 
     * {Boolean}图层是否可见。
     */
	getVisibility: function() {
		return this.visibility ;
	},
	
	/**
     * APIMethod: setVisibility
     * 设置图层是否可见。
     * 
     * Parameters:
     * visibility - {Boolean} 是否可见。
     */
	setVisibility: function(visibility) {
		if (visibility != this.visibility) {
            this.visibility = visibility;
            this.map.swfObj.setVisibility('{"layerId":"'+this._flashObjId+'","visible":'+visibility+'}');
        }
	},
	
	/**
     * Method: alculateInRange
     * 计算图层是否在有效范围内。
     * 
     * Returns: 
     * {Boolean} 
     */
	alculateInRange: function() {
		
	},
	
	/**
     * Method: initResolutions
     * 初始化图层分辨率设置。
     */
	initResolutions: function() {
		
	},
	
	/**
     * Method: resolutionsFromScales
     * 根据比例尺数组获取相应分辨率。
     * 
     * Parameters:
     * scales - {Array(Number)} 
     */
	resolutionsFromScales: function(scales) {
		
	},
	
	/**
     * Method: calculateResolutions
     * 计算分辨率。
     * 
     * Parameters:
     * props - {Object} Properties
     */
	calculateResolutions: function(props) {
		
	},
	
	/**
     * Method: getResolution
     * {Object} 获取当前分辨率。
     * 
     * Returns: 
     * {Number} 
     */
	getResolution: function() {
		var param = '{"layerId":"'+this._flashObjId+'"'+'}';
		var maxResolution = this.map.swfObj.getLayerMaxResolution(param);
		return maxResolution;
	},
	
	/**
     * Method: getExtent
     * 获取当前地图范围。
     * 
     * Returns: 
     * {<Geo.Bounds>}
     */
	getExtent: function() {
		var param = '{"layerId":"'+this._flashObjId+'"'+'}';
		var maxExtent = this.map.swfObj.getLayerMaxExtent(param);
		var eArr = maxExtent.split(",");
		var bounds = new Geo.Bounds(Number(eArr[0]),Number(eArr[1]),Number(eArr[2]),Number(eArr[3]));
		return bounds;
	},
	
	/**
     * Method: getZoomForExtent
     * 根据指定范围获取适合的级别。
     * 
     * Returns: 
     * {<Geo.Bounds>}
     */
	getZoomForExtent: function() {
		
	},
	
	/**
     * Method: getDataExtent
     * 获取图层数据范围。
     * 
     * Returns: 
     * {<Geo.Bounds>}
     */
	getDataExtent: function() {
		
	},
	
	/**
     * Method: getResolutionForZoom
     * 根据指定级别获取对应分辨率。
     * 
     * Returns: 
     * {Float}
     */
	getResolutionForZoom: function() {
		
	},
	
	/**
     * Method: getZoomForResolution
     * 根据指定分辨率获取对应级别。
     * 
     * Returns: 
     * {integer}
     */
	getZoomForResolution: function() {
		
	},
	
	/**
     * Method: setOpacity
     * 设置图层透明度。
     * 
     * Parameters:
     * opacity - {float} 透明度。
     */
	setOpacity: function(opacity) {
		this.map.swfObj.setOpacity('{"layerId":"'+this._flashObjId+'","alpha":'+opacity+'}');
		this.opacity = opacity;
	},
	
    CLASS_NAME: "Geo.ViewFl.Layer"
});
/**
 * Class: Geo.ViewFl.Layer.GlobeTile
 * Flash视图下的吉奥瓦片服务图层对象。
 * 
 * Inherits from:
 *  - <Geo.ViewFl.Layer>
 */
Geo.ViewFl.Layer.GlobeTile = Geo.Class(Geo.ViewFl.Layer, {
    
    /**
     * APIProperty: id
     * {String} 唯一标识符。
     */
    id: null,
			
	/**
     * APIProperty: url
     * {String} 服务地址。
     */
    url: null,
    
	/**
     * APIProperty: topLevel
     * {Integer} 图层顶层级别。
     */
	topLevel: null,

	/**
     * APIProperty: bottomLevel
     * {Integer} 图层底层级别。
     */
	bottomLevel: null,
	
	/**
     * APIProperty: maxParentSearch
     * {Integer} 放大操作时，保存前几级的瓦片
     * @default 2 
     */
	maxParentSearch:2,
	
	/**
     * APIProperty: maxParentSearch
     * {Integer} 缩小操作时，保存后几级的瓦片 
     * @default 2 
     */
	maxChildSearch:2,
    //swf内部图层对象标识
    _flashObjId: null,
	
	/**
	 * Constructor: Geo.ViewFl.Layer.GlobeTile
	 * Geo.ViewFl.Layer.GlobeTile构造函数。
	 *
	 * Parameters:
	 * name - {String} 服务名称。
	 * url - {String} 服务地址。
	 * options - {Object} 相关参数选项。
	 *  - topLevel 顶层级别。
	 *	- bottomLevel 底层级别。
	 *	- maxExtent 最大范围。
	 *	- pyramid 金字塔。
     *
	 */		      
    initialize: function(name, url, options) {
        Geo.ViewFl.Layer.prototype.initialize.apply(this,[name, options]);
        this.url = url;
    },

	/**
	 * Method: setMap
	 * 将图层关联地图对象。
	 *
	 * Parameters:
	 * map - {<Geo.ViewFl.Map>}Flash地图对象。
	 */	
    setMap: function(map) {
		Geo.ViewFl.Layer.prototype.setMap.apply(this,[map]);
	    var param = '{"name":"'+this.name+'","url":"'+this.url+'","topLevel":"'+this.topLevel+'","bottomLevel":"'+this.bottomLevel+'","maxParentSearch":"'+this.maxParentSearch+'","maxChildSearch":"'+this.maxChildSearch+'"}';
		var id = map.swfObj.addGlobeTileLayer(param);
		this._flashObjId = Geo.ViewFl._jsonParser.read(id).layerId;
    },

	/**
	 * Method: removeMap
	 * 将解除图层与地图的联系。
	 *
	 * Parameters:
	 * map - {<Geo.ViewFl.Map>} Flash地图对象。
	 */	
  	removeMap: function(map) {
       map.swfObj.removeLayer('{"layerId":"'+this._flashObjId+'"}');
    },
	 	
    CLASS_NAME: "Geo.ViewFl.Layer.GlobeTile"
});/**
 * Class: Geo.ViewFl.Layer.WMTS
 * Flash视图下的WMTS图层类。
 * 
 * Inherits from:
 *  - <Geo.ViewFl.Layer>
 */
Geo.ViewFl.Layer.WMTS = Geo.Class(Geo.ViewFl.Layer, {
    
    /** 
     * APIProperty: name
     * {String} 图层名称。
     */
	name: null,
	
	/** 
     * APIProperty: url
     * {String} 服务地址。
     */
	url: null,
	
	/** 
     * APIProperty: layer
     * {String} 图层标识。
     */
	layer:null,
	
	/** 
     * APIProperty: tileMatrixSet
     * {String} 矩阵集标识。
     */
	tileMatrixSet: null,
	
	/** 
     * APIProperty: format
     * {String} 图片的MIME类型。默认是"image/jpeg"。
     */
	format: "image/png",
	
    /** 
     * APIProperty: style
     * {String} WMTS服务图层样式，必选。
     */
	style: null,
	
	/**
     * Constructor: Geo.ViewFl.Layer.WMTS
     * 构造Geo.ViewFl.Layer.WMTS对象实例。
     * 
	 * Parameters:
	 * name - {String} 图层名称。
	 * url - {String} 服务地址。
	 * options - {Object} 构造参数。
	 *	  - layer
	 *	  - style
	 *	  - matrixSet
     *
     */  			  
    initialize: function(name, url, options) {
		Geo.ViewFl.Layer.prototype.initialize.apply(this,[name, options]);
        this.url = url;
    },
 	
	/**
	 * Method: setMap
	 * 将图层对象关联到地图。
	 *
	 * Parameters:
	 * map - {<Geo.ViewFl.Map>} Flash地图对象。
	 */	
    setMap: function(map) {
		Geo.ViewFl.Layer.prototype.setMap.apply(this,[map]);
		var param = '{"name":"'+this.name+'","url":"'+this.url+'","layer":"'+this.layer+'","tileMatrixSet":"'+
		this.tileMatrixSet+'","style":"'+this.style+'","format":"'+this.format+'"}';
		var objId = map.swfObj.addWMTSLayer(param);
		this._flashObjId = Geo.ViewFl._jsonParser.read(objId).layerId;
    },
	
	/**
     * APIMethod: setVisibility
     * 设置图层是否可见。此类由子类去覆盖。
     * 
     * Parameters:
     * visibility - {Boolean} 是否可见
     */
	setVisibility: function(visibility) {
		if (visibility != this.visibility) {
            this.visibility = visibility;
            this.map.swfObj.setVisibility('{"layerId":"'+this._flashObjId+'","visible":'+visibility+'}');
        }
	},
	
    /**
     * Method: removeMap
     * 移除Flash视图。
     *
     * Parameters:
	 * map - {<Geo.ViewFl.Map>} Flash视图对象。
     */
    removeMap: function(map) {
        map.swfObj.removeLayer('{"layerId":"'+this._flashObjId+'"}');
    },
	
    CLASS_NAME: "Geo.ViewFl.Layer.WMTS"
});/**
 * Class: Geo.ViewFl.Layer.WMS
 * Flash视图下的WMS图层类。
 * 
 * Inherits from:
 *  - <Geo.ViewFl.Layer>
 */
Geo.ViewFl.Layer.WMS = Geo.Class(Geo.ViewFl.Layer, {
    
	/** 
     * APIProperty: name
     * {String} 图层名称。
     */
	name: null,
	
	/** 
     * APIProperty: url
     * {String} 服务地址。
     */
	url: null,
	
	/** 
     * APIProperty: layers
     * {Array} 图层数组。
     */
	layers: null,
	
	/**
     * Constructor: Geo.ViewFl.Layer.WMS
     * 构造Geo.ViewFl.Layer.WMS对象实例。
     * 
	 * Parameters:
	 * options - {Object} 构造参数。
	 *		  - service:默认值为 "WMS",
	 *		  - version: 默认值为"1.1.1",
	 *		  - request: 默认值为"GetMap",
	 *		  - styles: 默认值为"",
	 *		  - exceptions: 默认值为"application/vnd.ogc.se_inimage",
	 *		  - format: 默认值为"image/jpeg"
     */  			  
    initialize: function(name, url, options) {
		Geo.ViewFl.Layer.prototype.initialize.apply(this,[name, options]);
        this.url = url;
    },
 	
	/**
	 * Method: setMap
	 * 将图层对象关联到地图。
	 *
	 * Parameters:
	 * map - {<Geo.ViewFl.Map>} Flash地图对象
	 */	
    setMap: function(map) {
		Geo.ViewFl.Layer.prototype.setMap.apply(this,[map]);
		var param = '{"name":"'+this.name+'","url":"'+this.url+'","layers":"'+this.layers+'"}';
		var objId = map.swfObj.addWMSLayer(param);
		this._flashObjId = Geo.ViewFl._jsonParser.read(objId).layerId;
    },
	
    /**
     * Method: removeMap
     * 移除Flash视图。
     *
     * Parameters:
	 * map - {<Geo.ViewFl.Map>} Flash视图对象。
     */
    removeMap: function(map) {
        map.swfObj.removeLayer('{"layerId":"'+this._flashObjId+'"}');
    },
	
    CLASS_NAME: "Geo.ViewFl.Layer.WMS"
});/**
 * Class: Geo.ViewFl.Layer.Vector
 * Flash视图下的矢量图层类。
 * 
 * Inherits from:
 *  - <Geo.ViewFl.Layer>
 */
Geo.ViewFl.Layer.Vector = Geo.Class(Geo.ViewFl.Layer, {
	
    /**
     * APIProperty: id
     * {String} 唯一标识符。
     */
    id: null,

    /** 
     * APIProperty: name
     * {String} 图层名称。
     */
    name: null,
	
    /** 
     * Property: features
     * {Array(<Geo.Feature.Vector>)} 图层上所有要素。
     */	
	features: null,
	
	/**
     * Constructor: Geo.ViewFl.Layer.Vector
     * 构造Geo.ViewFl.Layer.Vector对象实例。
     *
     * Parameters:
     * name - {String} 图层名称。
     * options - {Object} 选项。
     *
     */  			  
    initialize: function(name, options) {
		this.features = [];
		Geo.ViewFl.Layer.prototype.initialize.apply(this,[name, options]);
    },
 	
	/**
	 * Method: setMap
	 * 将图层对象关联到地图。
	 *
	 * Parameters:
	 * map - {<Geo.ViewFl.Map>} Flash地图对象。
	 */	
    setMap: function(map) {
		Geo.ViewFl.Layer.prototype.setMap.apply(this, [map]);
		//创建矢量图层
		var flashLayerId = map.swfObj.addVectorLayer('{"name":"'+this.name+'"}');
		this._flashObjId = Geo.ViewFl._jsonParser.read(flashLayerId).layerId;
    },
	
    /**
     * Method: removeMap
     * 移除Flash视图。
     *
     * Parameters:
	 * map - {<Geo.ViewFl.Map>} Flash视图对象。
     */
    removeMap: function(map) {
        map.swfObj.removeLayer('{"layerId":"'+this._flashObjId+'"}');
    },
	
	/**
	 * APIMethod: addFeatures
	 * 向图层中添加要素。
	 *
	 * Parameters:
	 * features - {Array(<Geo.Feature.Vector>)} 要素数组。
	 */	    
    addFeatures: function(features) {
        if (!(features instanceof Array)) {
            features = [features];
        }
        
        for (var i=0, len=features.length; i<len; i++) {
            var feature = features[i];
            
            if (!feature.style && this.style) {
                feature.style = OpenLayers.Util.extend({}, this.style);
            }
            this.features.push(feature);
            this.drawFeature(feature);
        }
        
    },
	
	/**
     * APIMethod: getFeatureBy
     * 通过给定的属性和值来查找要素。
     *
     * Parameters:
     * property - {String} 要素对象属性。
     * value - {String} 指定属性的值。
     *
     * Returns:
     * {<Geo.Feature.Vector>} 返回符合给定值的要素，如果无符合则返回null。
     */
    getFeatureBy: function(property, value) {
        var feature = null;
        for(var i=0, len=this.features.length; i<len; ++i) {
            if(this.features[i][property] == value) {
                feature = this.features[i];
                break;
            }
        }
        return feature;
    },

    /**
     * APIMethod: getFeatureById
     * 查找并返回指定id的要素。
     *
     * Parameters:
     * featureId - {String} 要素对象的id属性值。
     *
     * Returns:
     * {<Geo.Feature.Vector>} 
     */
    getFeatureById: function(featureId) {
        return this.getFeatureBy('id', featureId);
    },

    /**
     * APIMethod: getFeatureByFid
     * 查找并返回指定fid的要素。
     *
     * Parameters:
     * featureFid - {String} 要素对象的fid属性值。
     *
     * Returns:
     * {<Geo.Feature.Vector>} 
     */
    getFeatureByFid: function(featureFid) {
        return this.getFeatureBy('fid', featureFid);
    },
	
	/**
	 * APIMethod: getFeatureByFlashObjId
	 * 根据flash图层id得到图层。
	 * 
	 * Parameters:
	 * flashObjId - {String} flash图层id
	 */
	getFeatureByFlashObjId: function(flashObjId) {
        var features = this.features;
        for(var i=0; i<features.length; i++){
            if(flashObjId == features[i]._flashObjId){
                return features[i];
            }
        }
    },
	
	/**
	 * APIMethod: drawFeature
	 * 画要素图层。
	 * 
	 * Parameters:
	 * features - {Object} 要素。
	 */
	drawFeature: function(feature) {
    
		var map = this.map;
        if (map) {

            switch(feature.geometry.CLASS_NAME){
                case "OpenLayers.Geometry.Point":
                    this._drawIcon(feature);
                    break;
                case "OpenLayers.Geometry.LineString":
                case "OpenLayers.Geometry.Polygon":
                    this._drawFeature(feature);
                    break;
            }

			feature.layer = this;
		}
	},
	
    /**
     * APIMethod: removeFeatures
     * 移除图层中的要素。
     * 
     * Parameters:
     * features - {Array(<Geo.Feature.Vector>)} 要素数组。
     */    
    removeFeatures: function(features) {
        if(!features) {
            return;
        }
        if (!(features instanceof Array)) {
            features = [features];
        }
        
        for (var i = features.length - 1; i >= 0; i--) {
            var feature = features[i];
            var map = this.map;
            if (map) {
                this._removeFeature(feature);
            }
            this.features = OpenLayers.Util.removeItem(this.features, feature);
        }
    },

    _removeFeature: function(feature){
        var featureId = feature._flashObjId;
        var param = '[{"layerId":"' + this._flashObjId + '","featureId":"' + featureId + '"}]';
		this.map.swfObj.removeFeature(param);
    },
	
	_redrawFeature: function(feature) {
		if(!feature._flashObjId) {
			return false;
		}
		if(feature.geometry instanceof Geo.Geometry.Point) {//如果是线
			geometryType = "point";
		}else
		if(feature.geometry instanceof Geo.Geometry.LineString) {//如果是线
			geometryType = "line";
		}
		else 
		if(feature.geometry instanceof Geo.Geometry.Polygon) {//如果是面
			geometryType = "polygon";
		}
		var styleStr = this._setStyle(feature.style);
		styleStr =  styleStr === null ? "{}":styleStr;
		styleStr = styleStr.replace(/"/g,"\"");
		//是否重绘
		var paramTemp = '[{"layerId":"' + this._flashObjId + '","featureId":"' + feature._flashObjId + '"}]';
		var _flashObjId = this.map.swfObj.getFeatureById(paramTemp);
		//如果地图上存在该要素，则重绘它
		if(_flashObjId && feature._flashObjId == _flashObjId) {
			var param = '[{"layerId":"' + this._flashObjId + '","featureId":"' + feature._flashObjId + '","style":"'+ styleStr +'","geometryType":"'+geometryType+'"}]';
			var isRedraw = this.map.swfObj.redrawFeature(param);
			return isRedraw;
		}
		return false;
		
	},
	
    _drawFeature: function(feature) {
		//是否重绘
		if (this._redrawFeature(feature)) {
			return;
		}
        if(feature && feature.geometry){
            var geometryWKT = new Geo.Format.WKT().write(feature);
			
			var class_name = feature.geometry.CLASS_NAME;
			var featureLayerId = "";
			//featureType用于指定用户创建的要素类型，以便在as端创建相应的代码
			var featureType = "";
			//geometryType用于指定点线面类型，以便在as端设置点线面样式
			var geometryType = "";
			if(feature.geometry instanceof Geo.Geometry.LineString) {//如果是线
				featureLayerId = this._flashObjId;
				geometryType = "line";
				if(class_name === "OpenLayers.Geometry.LineString") {
					featureType = "org.openscales.core.feature.LineStringFeature";
				}else if(class_name === "OpenLayers.Geometry.MultiLineString") {
					featureType = "org.openscales.core.feature.MultiLineStringFeature";
				}
			}
			else 
			if(feature.geometry instanceof Geo.Geometry.Polygon) {//如果是面
				geometryType = "polygon";
				featureLayerId = this._flashObjId;//this._flashLayerIds["polygon"];
				if(class_name === "OpenLayers.Geometry.Polygon") {
					featureType = "org.openscales.core.feature.PolygonFeature";
				}else if(class_name === "OpenLayers.Geometry.MultiPolygonFeature") {
					featureType = "org.openscales.core.feature.MultiPolygonFeature";
				}
			}
			var styleStr = this._setStyle(feature.style);
            var param = '[{"layerId":"'+featureLayerId+'","geometry":"'+ geometryWKT +'","style":"'+ styleStr +'","type":"'+featureType+'","geometryType":"'+geometryType+'"}]';
            var result = this.map.swfObj.addFeature(param);
            var featureId = Geo.ViewFl._jsonParser.read(result).featureId;
            feature._flashObjId = featureId;
        }
    },
	
	_setStyle:function(style) {
			var styleObj = {};
			if(style) {
					var _style = OpenLayers.Util.extend({},Geo.Feature.Vector.style['default']);
					styleObj = OpenLayers.Util.extend(_style, style);
					styleObj = OpenLayers.Util.extend(styleObj, {
						fillColor: Geo.Util.getHexColor(styleObj.fillColor),
				        hoverFillColor: Geo.Util.getHexColor(styleObj.hoverFillColor),
				        strokeColor: Geo.Util.getHexColor(styleObj.strokeColor),
				        hoverStrokeColor: Geo.Util.getHexColor(styleObj.hoverStrokeColor)
					});
			}
			var styleStr = Geo.ViewFl._jsonParser.write(styleObj);
			styleStr =  styleStr === null ? "{}":styleStr;
			styleStr = styleStr.replace(/"/g,"\\\"");
			return styleStr;
	},
	
    _drawIcon: function(feature) {
		//是否重绘
		if (this._redrawFeature(feature)) {
			return;
		}
        var featureLayerId = this._flashObjId;
        if(feature && feature.geometry) {
            var geometryWKT = new Geo.Format.WKT().write(feature);
//			var style = {};
//			if(feature.style) {
//					var _style = OpenLayers.Util.extend({},Geo.Feature.Vector.style['default']);
//					style = OpenLayers.Util.extend(_style,feature.style);
//					style = OpenLayers.Util.extend(style, {
//						fillColor: Geo.Util.getHexColor(style.fillColor),
//				        hoverFillColor: Geo.Util.getHexColor(style.hoverFillColor),
//				        strokeColor: Geo.Util.getHexColor(style.strokeColor),
//				        hoverStrokeColor: Geo.Util.getHexColor(style.hoverStrokeColor),
//					});
//			}
//			var styleStr = Geo.ViewFl._jsonParser.write(style);
//			styleStr =  styleStr === null ? "{}":styleStr;
//			styleStr = styleStr.replace(/"/g,"\\\"");
			var styleStr = this._setStyle(feature.style);
            var param = '[{"layerId":"'+featureLayerId+'","geometry":"' + geometryWKT + '","style":"' + styleStr + '","type":"org.openscales.core.feature.PointFeature","geometryType":"point"}]';
            var result = this.map.swfObj.addFeature(param);
            var featureId = Geo.ViewFl._jsonParser.read(result).featureId;
            feature._flashObjId = featureId;
        }
		/*        		
		 * featureLayerId = featureLayerId.substr(1,featureLayerId.length-2);
		alert(featureLayerId);

		param = '[{'+featureLayerId+',"geometry":"-88.9453125 , 50.625"}]';
		featureId = window.FlashAPI.CallByJs("Facade","addCustomerMarkerFeatuer",param);*/
    },
	
	//************************************新增示例需求功能************************************************/
	/**
     * APIMethod: setFeatureHighlight
     * 设置要素高亮。
     * 
     * Parameters:
     * value - {Boolean} 设置是否高亮。
     */  
	setFeatureHighlight:function(value){
		var param = '[{"layerId":"'+this._flashObjId+'"}]';
		var result =  map.swfObj.setFeatureHighlight(param,value);
		
	},
	/**
     * APIMethod: setFeatureHighlight
     * 设置要素显示/隐藏
     * 
     * Parameters:
     * value - Boolean 设置要素显示/隐藏
     */  
	setFeatureIsVisible:function(featureId,value){
		var param = '[{"layerId":"'+this._flashObjId+'","featureId":"'+featureId+'"}]';
		var result =  this.map.swfObj.setFeatureIsVisible(param,value);
		
	},
	//************************************新增示例需求功能************************************************/
	/**
     * APIMethod: addCustomerMarkerFeatuer
     * 添加注记要素。
     * 
     * Parameters:
     * point - {<Geo.Geometry.Point>} 注记要素生成的点位置。
     * label - {String} 注记要素的内容。
     */  
	 addCustomerMarkerFeatuer:function (feature,label){
	 	var map = this.map;
        if (map) {
			//是否重绘
			if (this._redrawFeature(feature)) {
				return;
			}
	        var featureLayerId = this._flashObjId;
	        if (feature && feature.geometry) {
				var param = '[{"layerId":"'+this._flashObjId+'","geometry":"'+feature.geometry.x+','+feature.geometry.y+'","label":"'+label+'"}]';
				var result = map.swfObj.addCustomerMarkerFeatuer(param);
				var featureId = Geo.ViewFl._jsonParser.read(result).featureId;
		        feature._flashObjId = featureId;
			}
			feature.layer = this;
		}

	 },
	
    CLASS_NAME: "Geo.ViewFl.Layer.Vector"
});/**
 * Class: Geo.ViewFl.BaseLayerGroup
 * 二维视图的底图图层组对象，可以将多个图层对象组合在一起，进行统一的加载和卸载操作。该图层组中的图层
 * 将做为地图中的底图置于所有图层的最下方。
 */
Geo.ViewFl.BaseLayerGroup = Geo.Class({

    /**
     * Property: id
     * ｛String｝唯一标识符。
     */
    id: null,
    
    /**
     * APIProperty: layers
     * {Array} 图层集合。
     */
    layers: null,
    
    /**
     * APIProperty: map
     * 所属的地图对象。
     */
    map: null,
    
    /**
     * Constructor: Geo.ViewFl.BaseLayerGroup
     * Geo.ViewFl.BaseLayerGroup构造函数。
     * 
     * Parameters:
     * options - {Object} 相关选项设置。
     * 
     * 示例代码：
     * 
     * (code)
     * var vectorGroup = new Geo.ViewFl.BaseLayerGroup({
     *      layers: [new Geo.ViewFl.Layer.GlobeTile("全球1:100万矢量底图", "http://tile0.tianditu.com/services/A0512_EMap", {
     *          transitionEffect: "resize",
     *          topLevel: 2,
     *          bottomLevel: 10,
     *          maxExtent: new Geo.Bounds(-180, -90, 180, 90)
     *      }), new Geo.ViewFl.Layer.GlobeTile("全球1:100万矢量注记", "http://tile0.tianditu.com/services/AB0512_Anno", {
     *          topLevel: 2,
     *          bottomLevel: 12,
     *          maxExtent: new Geo.Bounds(-180, -90, 180, 90)
     *      })]
     *  });
     * (end)
     * 
     */
    initialize: function(options){
        this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
        this.layers = [];
        OpenLayers.Util.extend(this, options);
    },
    
    /**
     * Method: setMap
     * 将底图图层组关联到地图对象。
     *
     * Parameters:
     * map - {OpenLayers.Map} 地图对象。
     */
    setMap: function(map){
        if (map && !this.map) {
            this.map = map;
            for(var i=0; i<this.layers.length; i++){
                this.map.addLayer(this.layers[i],true);
            }
            
        }
    },
    
    /**
     * Method: removeMap
     * 解除底图图层组与地图对象的关联。
     */
    removeMap: function(){
        if (this.map) {
            for (var i = 0; i < this.layers.length; i++) {
                var layer = this.layers[i];
                //如果图层已经被移除地图了，则不再被移除
                if(layer.map){
                    this.map.removeLayer(this.layers[i]);
                }
            }
            this.map = null;
        }
    },
    
     
    /**
     * APIMethod: getMaxResolution
     * 获取底图图层组中最大分辨率。
     *
     * Returns:
     * {Float} 分辨率。
     */   
    getMaxResolution: function(){
        var layers = this.layers, res = null;
        for (var i = 0; i < layers.length; i++) {
            var layerOptions = layers[i].getOptions();
            var layerMaxRes = layerOptions.maxResolution;
            res = (res == null) ? layerMaxRes : Math.max(res, layerMaxRes);
        }
        return res;
    },
      
    /**
     * APIMethod: getMinResolution
     * 获取底图图层组中最小分辨率。
     *
     * Returns:
     * {Float} 分辨率。
     */      
    getMinResolution: function(){
        var layers = this.layers, res = null;
        for (var i = 0; i < layers.length; i++) {
            var layerOptions = layers[i].getOptions();
            var layerMinRes = layerOptions.minResolution;
            res = (res == null) ? layerMinRes : Math.min(res, layerMinRes);
        }
        return res;
    },
      
    /**
     * APIMethod: getMaxExtent
     * 获取底图图层组中最大范围。
     *
     * Returns:
     * {Float} 范围。
     */     
    getMaxExtent: function(){
        var bounds = null;
        for (var i = 0; i < this.layers.length; i++) {
            if (bounds) {
                bounds.extend(this.layers[i].getDataExtent());
            }
            else {
                bounds = this.layers[i].getDataExtent();
            }
        }
        return bounds;
    },
    
    /**
     * Method: destroy
     * 销毁本对象。
     *
     */
    destroy: function(){
		this.removeMap();
        for (var i = 0; i < layers.length; i++) {
            layers[i].destroy();
        }
		this.layers = null;
    },
    
    CLASS_NAME: "Geo.ViewFl.BaseLayerGroup"

});

Geo.ViewFl.BaseLayerGroup.getTianDiTuGroup = function(type, options){
    
    //TODO: 让Geo.ViewFl.BaseLayerGroup.getTianDiTuGroup支持更多设置选项
    //须将服务信息与图层对象的实例化分离
    
    /*
     * 服务相关信息定义
     * 1.影像层有缩放效果，标记层没有
     * 2.可以设置是否使用镜像服务地址，提高瓦片读取效率
     * 3.实际服务地址根据服务名和主机地址拼出
     */
    var serviceInfo = {
        "img":[
            {
                title:"全球影像底图(2-10)",
                serviceName: "sbsm0210",
                transitionEffect: "resize",
                topLevel: 2,
                bottomLevel: 10,
                maxExtent: new Geo.Bounds(-180, -90, 180, 90)
            },{
                title:"全球影像注记(2-10)",
                serviceName: "A0610_ImgAnno",
                topLevel: 2,
                bottomLevel: 10,
                maxExtent: new Geo.Bounds(-180, -90, 180, 90)
            }
            
        ],
        "dlg":[]
    };
    
    var typeMapping = {
        "img":[
            new Geo.ViewFl.Layer.GlobeTile("全球影像底图(2-10)", "http://tile0.tianditu.com/services/sbsm0210", {
                topLevel: 2,
                bottomLevel: 10,
                maxExtent: new Geo.Bounds(-180, -90, 180, 90)
            }),
            new Geo.ViewFl.Layer.GlobeTile("全球影像注记(2-10)", "http://tile0.tianditu.com/services/A0104_ImgAnnoE", {
                topLevel: 2,
                bottomLevel: 10,
                maxExtent: new Geo.Bounds(-180, -90, 180, 90)
            }),
            new Geo.ViewFl.Layer.GlobeTile("全国影像(14)", "http://tile0.tianditu.com/services/eastdawnall", {
                topLevel: 14,
                bottomLevel: 14,
                maxExtent: new Geo.Bounds(73.30078125,17.9296875,135.17578125,53.701171875)
            }),
            new Geo.ViewFl.Layer.GlobeTile("全球影像(15-18)", "http://tile0.tianditu.com/services/sbsm1518", {
                topLevel: 15,
                bottomLevel: 18,
                maxExtent: new Geo.Bounds(-180, -90, 180, 90)
            }),
            new Geo.ViewFl.Layer.GlobeTile("全国影像(13)", "http://tile0.tianditu.com/services/e13", {
                topLevel: 13,
                bottomLevel: 13,
                maxExtent: new Geo.Bounds(73.30078125,17.9736328125,135.1318359375,53.6572265625)
            }),
            new Geo.ViewFl.Layer.GlobeTile("全国影像(12)", "http://tile0.tianditu.com/services/e12", {
                topLevel: 12,
                bottomLevel: 12,
                maxExtent: new Geo.Bounds(73.30078125,17.9296875,135.17578125,53.701171875)
            }),
            new Geo.ViewFl.Layer.GlobeTile("全国影像(11)", "http://tile0.tianditu.com/services/e11", {
                topLevel: 11,
                bottomLevel: 11,
                maxExtent: new Geo.Bounds(73.30078125,17.9296875,135.17578125,53.7890625)
            }),
            new Geo.ViewFl.Layer.GlobeTile("全国影像注记(11-14)", "http://tile0.tianditu.com/services/B0530_eImgAnno", {
                topLevel: 11,
                bottomLevel: 14,
                maxExtent: new Geo.Bounds(73.4765625,2.8125,135.439453125,53.7890625)
            }),
            new Geo.ViewFl.Layer.GlobeTile("全国影像注记(15-18)", "http://tile0.tianditu.com/services/siweiAnno68", {
                topLevel: 15,
                bottomLevel: 18,
                maxExtent: new Geo.Bounds(73.4765625,2.8125,135.439453125,53.7890625)
            })
        ],"dlg":[
            new Geo.ViewFl.Layer.GlobeTile("全国矢量(2-10)", "http://tile0.tianditu.com/services/A0512_EMap", {
                topLevel: 2,
                bottomLevel: 10,
                maxExtent: new Geo.Bounds(-180,-90,180,90)
            }),
            new Geo.ViewFl.Layer.GlobeTile("全国矢量注记(2-10)", "http://tile0.tianditu.com/services/AB0512_Anno", {
                topLevel: 2,
                bottomLevel: 10,
                maxExtent: new Geo.Bounds(-180,-90,180,90)
            }),
            new Geo.ViewFl.Layer.GlobeTile("全国矢量(11-12)", "http://tile0.tianditu.com/services/B0627_EMap1112", {
                topLevel: 11,
                bottomLevel: 12,
                maxExtent: new Geo.Bounds(69.9609375,0.87890625,879.9609375,56.25)
            }),
            new Geo.ViewFl.Layer.GlobeTile("全国矢量(13-18)", "http://tile0.tianditu.com/services/siwei0608", {
                topLevel: 13,
                bottomLevel: 18,
                maxExtent: new Geo.Bounds(-180,-90,180,90)
            })
        ]
    };
    
    var layers = typeMapping[type];
    if(layers){
        return new Geo.ViewFl.BaseLayerGroup({layers: layers});
    }
    return null;
}
Geo.ViewFl.LayerGroup = Geo.ViewFl.BaseLayerGroup;/**
 * Class: Geo.ViewFl.Handler
 * flash视图事件监听对象。
 */
Geo.ViewFl.Handler = Geo.Class({

    /**
     * Property: id
     * {String} 唯一标识符。
     */  
    id: null,

    /**
     * Property: active
     * {String} 是否激活。
     */      
    active: false,

    /**
     * APIProperty: control
     * {String} 所属控件。
     */      
    control: null,

    /**
     * Property: map
     * {<Geo.ViewFl.Map>} 所属地图对象。
     */    
    map: null,

	 
	/**
	 * Constructor: Geo.ViewFl.Handler
	 * 构造函数。
	 *
	 * Parameters:
	 * control - {<Geo.ViewFl.Control>} 监听器所属的控件
	 * options - {Object} 选项。
	 */	    
    initialize: function(control, callbacks, options){
        
        OpenLayers.Util.extend(this, options);
        this.control = control;
		this.callbacks = callbacks;
		
		var map = this.map || control.map;
        if (map) {
            this.setMap(map); 
        }
		
		this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
    },
 	
	/**
	 * Method: setMap
	 * 将监听器关联到flash地图对象。
	 *
	 * Parameters:
	 * map - {<Geo.ViewFl.Map>} flash地图对象
	 */	    
    setMap: function (map) {
        if(map){
            this.map = map;
            this.map.handlers.push(this);
        }
    },
 	
   /**
    * Method: callback
    * 触发控件指定的回调方法。
    *
    * Parameters:
    * name - {String} 
    * args - {Array(*)} 
    */
    callback: function (name, args) {
        if (name && this.callbacks[name]) {
            this.callbacks[name].apply(this.control, args);
        }
    },

	/**
	 * Method: listener
	 * 监听鼠标事件。
	 *
	 * Parameters:
	 * e - {Object} flash对象鼠标事件对象
	 */	     
    listener:function(e){
        
    },

	/**
	 * APIMethod: activate
	 * 激活事件监听器，如果当前监听器已处于激活状态，则返回false。
	 *
	 * Return:
	 * {Boolean} 监听器是否被激活
	 */	    
    activate: function() {
        if(this.active) {
            return false;
        }
        this.active = true;
        return true;
    },

	/**
	 * APIMethod: deactivate
	 * 关闭事件监听器，如果当前监听器已处于关闭状态，则返回false。
	 *
	 * Return:
	 * {Boolean} 监听器是否被关闭
	 */    
    deactivate: function() {
        if(!this.active) {
            return false;
        }
        this.active = false;
        return true;
    },

    /**
     * Method: destroy
     * 监听器销毁
     */
    destroy: function () {
        this.deactivate();
		if(this.map){
			OpenLayers.Util.removeItem(this.map.handlers,this);
		}
        this.control = this.map = null;        
    },
	
    CLASS_NAME: "Geo.ViewFl.Handler"
});/**
 * Class: Geo.ViewFl.Handler.Point
 * flash视图点几何对象绘制操作事件监听器。该对象激活后，将在flash视图上监听绘制点的操作，
 * 完成后返回用户绘制的几何对象。该对象关闭后，将移除绘制图层。
 * 
 * Inherits from:
 *  - <Geo.ViewFl.Handler>
 */
Geo.ViewFl.Handler.Point = Geo.Class(Geo.ViewFl.Handler,{
	
	/**
     * Property: _flashObjId
     * flash内部对象标识，私有属性。
     */
	_flashObjId: null,
	
    /**
     * APIProperty: point
     * {<Geo.Feature.Vector>} 当前绘制的点要素。
     */
    point: null,

    /**
     * Property: layer
     * {<Geo.ViewFl.Layer.Vector>} 用于显示绘制要素的临时flash矢量图层。
     */
    layer: null,
	
    /**
     * APIProperty: persist
     * {Boolean} 是否立即销毁临时图层绘制的要素。
     */
    persist: false,
	
    /**
     * APIProperty: layerOptions
     * {Object} 临时绘制矢量要素图层对象构造选项。
     */
    layerOptions: null,

    /** 
     * Constructor: Geo.ViewFl.Handler.Point
     * Geo.ViewFl.Handler.Point构造函数。
     * 
     * Parameters:
     * control - {<Geo.ViewFl.Control>} flash控件对象。
     * options - {Object} 参数对象。
     */
    initialize: function(control, options) {
        if(!(options && options.layerOptions && options.layerOptions.styleMap)) {
            this.style = OpenLayers.Util.extend(Geo.Feature.Vector.style['default'], {});
        }

        Geo.ViewFl.Handler.prototype.initialize.apply(this, arguments);
    },
	
	/**
     * Method: setMap
     * 关联地图，私有。
     * 
     * Parameters:
     * map - {<Geo.ViewFl.Map>} Flash二维地图对象。
     */
    setMap: function(map){
        Geo.ViewFl.Handler.prototype.setMap.apply(this, arguments);
        this._flashObjId = this.map.swfObj.addDrawPointHandler();
    },
	
    /**
     * APIMethod: activate
     * 打开绘制点监听器。
     */
    activate: function() {
        if(!Geo.ViewFl.Handler.prototype.activate.apply(this, arguments)) {
            return false;
        }
		
		Geo.ViewFl.Handler.Point.callJS = OpenLayers.Function.bind(function(eventType, id, pointFeatureString){
            var wkt = new OpenLayers.Format.WKT();
            var feature = wkt.read(pointFeatureString);
			this.point = feature;
            //this.done(feature.geometry);
			if(this.persist){
				this.map.swfObj.destroyDrawLayerFeatures(this.layer._flashObjId);
			}
			this.callback("done", [feature.geometry]);
        }, this);
		
        var options = OpenLayers.Util.extend({
            displayInLayerSwitcher: false
        }, this.layerOptions);
		
		this.layer = new Geo.ViewFl.Layer.Vector(this.CLASS_NAME, options);
        this.map.addLayer(this.layer);
		
		// 设置矢量绘制图层与绘制控件关联
		this.map.swfObj.setDrawLayerInDrawHandler(this._flashObjId, this.layer._flashObjId);
		
		// 设置绘制要素的样式。
		var styleStr = "{}";
		if(this.layer.styleMap != undefined){
			styleStr = this.layer._setStyle(this.layer.styleMap.styles["default"].defaultStyle);
		}
		var geometryType = "point";
        var param = '[{"handlerId":"' + this._flashObjId + '","style":"' + styleStr + '","geometryType":"' + geometryType + '"}]';
        this.map.swfObj.setDrawFeaturesStyle(param);
		
		// 激活handler
		var result = this.map.swfObj.activateControl(this._flashObjId);
        return result;
    },	
				
    /**
     * APIMethod: deactivate
     * 关闭绘制点监听器。
     */
    deactivate: function() {
        if(!Geo.ViewFl.Handler.prototype.deactivate.apply(this, arguments)) {
            return false;
        }
        this.destroyFeature();
//        if (this.layer.map != null) {
//            this.layer.destroy(false);
//        }
        if (this.layer.map != null) {
            this.map.removeLayer(this.layer);
        }
        this.layer = null;
		
		var result = this.map.swfObj.deactivateControl(this._flashObjId);
		return result;
    },
    
    /**
     * Method: destroyFeature
     * 销毁临时绘制矢量要素。
     */
    destroyFeature: function() {
        if(this.layer) {
            //this.layer.destroyFeatures();
			this.map.swfObj.destroyDrawLayerFeatures(this.layer._flashObjId);
        }
        this.point = null;
    },
	
    CLASS_NAME: "Geo.ViewFl.Handler.Point"
});/**
 * Class: Geo.ViewFl.Handler.Path
 * flash视图点几何对象绘制操作事件监听器。该对象激活后，将在flash视图上监听绘制点的操作，
 * 完成后返回用户绘制的几何对象。该对象关闭后，将移除绘制图层。
 * 
 * Inherits from:
 *  - <Geo.ViewFl.Handler>
 */
Geo.ViewFl.Handler.Path = Geo.Class(Geo.ViewFl.Handler,{

	/**
     * Property: _flashObjId
     * flash内部对象标识，私有属性。
     */
	_flashObjId: null,
	
    /**
     * APIProperty: line
     * {<Geo.Feature.Vector>}当前绘制的线要素。
     */
    line: null,	    
	
    /**
     * Property: layer
     * {<Geo.ViewFl.Layer.Vector>} 用于显示绘制要素的临时flash矢量图层。
     */
    layer: null,
	
    /**
     * APIProperty: persist
     * {Boolean} 是否立即销毁临时图层绘制的要素。
     */
    persist: false,
	
    /**
     * APIProperty: layerOptions
     * {Object} 临时绘制矢量要素图层对象构造选项。
     */
    layerOptions: null,
	
	/**
	 * 标记线是否点击右键绘制完成。
	 */
	_isDone: false,
	
    /** 
     * Constructor: Geo.ViewFl.Handler.Path
     * Geo.ViewFl.Handler.Path构造函数。
     * 
     * Parameters:
     * control - {<Geo.ViewFl.Control>} flash控件对象。
     * options - {Object} 参数对象。
     */
    initialize: function(control, callbacks, options) {
        if(!(options && options.layerOptions && options.layerOptions.styleMap)) {
            this.style = OpenLayers.Util.extend(Geo.Feature.Vector.style['default'], {});
        }

        Geo.ViewFl.Handler.prototype.initialize.apply(this, arguments);
    },
	
	/**
     * Method: setMap
     * 关联地图，私有。
     * 
     * Parameters:
     * map - {<Geo.ViewFl.Map>} Flash二维地图对象。
     */
    setMap: function(map){
		
        Geo.ViewFl.Handler.prototype.setMap.apply(this, arguments);
        this._flashObjId = this.map.swfObj.addDrawPathHandler();
		
        
    },
	
    /**
     * APIMethod: activate
     * 打开绘制线监听器。
     */
    activate: function() {
        if(!Geo.ViewFl.Handler.prototype.activate.apply(this, arguments)) {
            return false;
        }
		
		Geo.ViewFl.Handler.Path.callJS = OpenLayers.Function.bind(function(eventType, id, pathFeatureString){
			var wkt = new OpenLayers.Format.WKT();
            var feature = wkt.read(pathFeatureString);
			this.line = feature;
            //this.done(feature.geometry);
			this._isDone = true;
			if(this.persist){
				this.map.swfObj.destroyDrawLayerFeatures(this.layer._flashObjId);
			}
			this.callback("done", [this.getGeometry()]);
			//this.line = null;
        }, this);
		
		Geo.ViewFl.Handler.Path.callJSaddPoint = OpenLayers.Function.bind(function(eventType, id, pointFeatureString){
			//结束当前线绘制后，再次点击清除前次绘制
			if(this._isDone){
				//this.layer.removeFeatures(this.layer.features);
				//this.map.swfObj.destroyDrawLayerFeatures(this.layer._flashObjId);
				this.line = null;
				this._isDone = false;
			}
			var wkt = new OpenLayers.Format.WKT();
            var feature = wkt.read(pointFeatureString);
			this.point = feature;
			if(!this.line){
				this.line = new OpenLayers.Feature.Vector(
					new OpenLayers.Geometry.LineString([this.point.geometry])
				);
			}
//			this.point = new OpenLayers.Feature.Vector(
//	            new OpenLayers.Geometry.Point(lonlat.lon, lonlat.lat)
//	        );

			// 在同一位置点击不会把几何点添加至几何线内。
			var tmp1 = this.line.geometry.components[this.line.geometry.components.length - 1];
			if( tmp1.x == this.point.geometry.x && tmp1.y == this.point.geometry.y){
				return;
			}
			
	        this.line.geometry.addComponent(
	            this.point.geometry, this.line.geometry.components.length
	        );
			
			this.callback("point", [this.point.geometry, this.getGeometry()]);
        }, this);
		
		
        var options = OpenLayers.Util.extend({
            displayInLayerSwitcher: false
        }, this.layerOptions);
		
		this.layer = new Geo.ViewFl.Layer.Vector(this.CLASS_NAME, options);
        this.map.addLayer(this.layer);
		
		// 设置矢量绘制图层与绘制控件关联
		this.map.swfObj.setDrawLayerInDrawHandler(this._flashObjId, this.layer._flashObjId);
		
		// 设置绘制要素的样式。
		var styleStr = "{}";
		if(this.layer.styleMap != undefined){
			styleStr = this.layer._setStyle(this.layer.styleMap.styles["default"].defaultStyle);
		}
		var geometryType = "line";
        var param = '[{"handlerId":"' + this._flashObjId + '","style":"' + styleStr + '","geometryType":"' + geometryType + '"}]';
		this.map.swfObj.setDrawFeaturesStyle(param);
		
		// 激活handler
		var result = this.map.swfObj.activateControl(this._flashObjId);
        return result;
    },	
				
    /**
     * APIMethod: deactivate
     * 关闭绘制线监听器。
     */
    deactivate: function() {
        if(!Geo.ViewFl.Handler.prototype.deactivate.apply(this, arguments)) {
            return false;
        }
        this.destroyFeature();
//        if (this.layer.map != null) {
//            this.layer.destroy(false);
//        }
        if (this.layer.map != null) {
			this.map.removeLayer(this.layer);
        }
        this.layer = null;
		
		var result = this.map.swfObj.deactivateControl(this._flashObjId);
		return result;
    },
	
	/**
     * Method: getGeometry
     * Return the sketch geometry.  If <multi> is true, this will return
     *     a multi-part geometry.
     *
     * Returns:
     * {<OpenLayers.Geometry.LineString>}
     */
    getGeometry: function() {
        var geometry = this.line && this.line.geometry;
        return geometry;
    },
	
    /**
     * Method: destroyFeature
     * 销毁临时绘制矢量要素。
     */
    destroyFeature: function() {
        if(this.layer) {
            //this.layer.destroyFeatures();
			this.map.swfObj.destroyDrawLayerFeatures(this.layer._flashObjId);
        }
        this.point = null;
		this.line = null;
    },
	
    CLASS_NAME: "Geo.ViewFl.Handler.Path"
});/**
 * Class: Geo.ViewFl.Handler.Polygon
 * flash视图点几何对象绘制操作事件监听器。该对象激活后，将在flash视图上监听绘制点的操作，
 * 完成后返回用户绘制的几何对象。该对象关闭后，将移除绘制图层。
 * 
 * Inherits from:
 *  - <Geo.ViewFl.Handler>
 */
Geo.ViewFl.Handler.Polygon = Geo.Class(Geo.ViewFl.Handler,{

	/**
     * Property: _flashObjId
     * flash内部对象标识，私有属性。
     */
	_flashObjId: null,

    /**
     * APIProperty: polygon
     * {<Geo.Feature.Vector>}当前绘制的面要素。
     */
    polygon: null,	    

    /**
     * Property: layer
     * {<Geo.ViewFl.Layer.Vector>} 用于显示绘制要素的临时flash矢量图层。
     */
    layer: null,
	
	/**
     * APIProperty: persist
     * {Boolean} 是否立即销毁临时图层绘制的要素。
     */
    persist: false,
	
    /**
     * APIProperty: layerOptions
     * {Object} 临时绘制矢量要素图层对象构造选项。
     */
    layerOptions: null,
	
    /**
	 * 标记线是否点击右键绘制完成。
	 */
	_isDone: false,
	
    /** 
     * Constructor: Geo.ViewFl.Handler.Polygon
     * Geo.ViewFl.Handler.Polygon构造函数。
     * 
     * Parameters:
     * control - {<Geo.ViewFl.Control>} flash控件对象。
     * options - {Object} 参数对象。
     */
    initialize: function(control, callbacks, options) {
        if(!(options && options.layerOptions && options.layerOptions.styleMap)) {
            this.style = OpenLayers.Util.extend(Geo.Feature.Vector.style['default'], {});
        }

        Geo.ViewFl.Handler.prototype.initialize.apply(this, arguments);

    },
    
	/**
     * Method: setMap
     * 关联地图，私有。
     * 
     * Parameters:
     * map - {<Geo.ViewFl.Map>} Flash二维地图对象。
     */
    setMap: function(map){
        Geo.ViewFl.Handler.prototype.setMap.apply(this, arguments);
        this._flashObjId = this.map.swfObj.addDrawPolygonHandler();
    },
	
    /**
     * APIMethod: activate
     * 打开绘制面监听器。
     */
    activate: function() {
        if(!Geo.ViewFl.Handler.prototype.activate.apply(this, arguments)) {
            return false;
        }
		
		Geo.ViewFl.Handler.Polygon.callJS = OpenLayers.Function.bind(function(eventType, id, polygonFeatureString){
            var wkt = new OpenLayers.Format.WKT();
            var feature = wkt.read(polygonFeatureString);
			this.polygon = feature;
			this._isDone = true;
			if(this.persist){
				this.map.swfObj.destroyDrawLayerFeatures(this.layer._flashObjId);
			}
            //this.done(feature.geometry);
			this.callback("done", [this.getGeometry()]);
//			this.line = null;
//			this.polygon = null;
        }, this);
		
		Geo.ViewFl.Handler.Polygon.callJSaddPoint = OpenLayers.Function.bind(function(eventType, id, pointFeatureString){
            //结束当前线绘制后，再次点击清除前次绘制
			if(this._isDone){
				//this.layer.removeFeatures(this.layer.features);
				//this.map.swfObj.destroyDrawLayerFeatures(this.layer._flashObjId);
				this.line = null;
				this.polygon = null;
				this._isDone = false;
			}
			var wkt = new OpenLayers.Format.WKT();
            var feature = wkt.read(pointFeatureString);
			this.point = feature;
			if(!this.polygon){
				this.line = new OpenLayers.Feature.Vector(
	            	new OpenLayers.Geometry.LinearRing([this.point.geometry])
		        );
		        this.polygon = new OpenLayers.Feature.Vector(
		            new OpenLayers.Geometry.Polygon([this.line.geometry])
		        );
			}
			
//			this.point = new OpenLayers.Feature.Vector(
//	            new OpenLayers.Geometry.Point(lonlat.lon, lonlat.lat)
//	        );

			// 在同一位置点击不会把几何点添加至几何线内。
			var tmp1 = this.line.geometry.components[this.line.geometry.components.length - 2];
			if( tmp1.x == this.point.geometry.x && tmp1.y == this.point.geometry.y){
				return;
			}
			
	        this.line.geometry.addComponent(
	            this.point.geometry, this.line.geometry.components.length
	        );
			
			this.callback("point", [this.point.geometry, this.getGeometry()]);
        }, this);
		
        var options = OpenLayers.Util.extend({
            displayInLayerSwitcher: false
        }, this.layerOptions);
		
		this.layer = new Geo.ViewFl.Layer.Vector(this.CLASS_NAME, options);
        this.map.addLayer(this.layer);
		
		// 设置矢量绘制图层与绘制控件关联
		this.map.swfObj.setDrawLayerInDrawHandler(this._flashObjId, this.layer._flashObjId);
		
		// 设置绘制要素的样式。
		var styleStr = "{}";
		if(this.layer.styleMap != undefined){
			styleStr = this.layer._setStyle(this.layer.styleMap.styles["default"].defaultStyle);
		}
		var geometryType = "polygon";
        var param = '[{"handlerId":"' + this._flashObjId + '","style":"' + styleStr + '","geometryType":"' + geometryType + '"}]';
        this.map.swfObj.setDrawFeaturesStyle(param);
		
		// 激活handler
		var result = this.map.swfObj.activateControl(this._flashObjId);
        return result;
    },	
	
    /**
     * APIMethod: deactivate
     * 关闭绘制面监听器。
     */
    deactivate: function() {
        if(!Geo.ViewFl.Handler.prototype.deactivate.apply(this, arguments)) {
            return false;
        }
        this.destroyFeature();
//        if (this.layer.map != null) {
//            this.layer.destroy(false);
//        }
        if (this.layer.map != null) {
            this.map.removeLayer(this.layer);
        }
        this.layer = null;
		
		var result = this.map.swfObj.deactivateControl(this._flashObjId);
		return result;
    },
    
	/**
     * Method: getGeometry
     * Return the sketch geometry.  If <multi> is true, this will return
     *     a multi-part geometry.
     *
     * Returns:
     * {<OpenLayers.Geometry.LineString>}
     */
    getGeometry: function() {
        var geometry = this.polygon && this.polygon.geometry;
        return geometry;
    },
	
    /**
     * Method: destroyFeature
     * 销毁临时绘制矢量要素。
     */
    destroyFeature: function() {
        if(this.layer) {
            //this.layer.destroyFeatures();
			this.map.swfObj.destroyDrawLayerFeatures(this.layer._flashObjId);
        }
        this.point = null;
        this.polygon = null;
    },
    
    CLASS_NAME: "Geo.ViewFl.Handler.Polygon"
});/**
 * Class: Geo.ViewFl.Handler.Click
 * flash视图点几何对象鼠标事件监听器。该对象激活后，将在flash视图上监听鼠标的操作，
 * 完成后返回用户鼠标点击的位置。该对象关闭后，将移除鼠标事件。
 * 
 * Inherits from:
 *  - <Geo.ViewFl.Handler>
 */
Geo.ViewFl.Handler.Click = Geo.Class(Geo.ViewFl.Handler,{
	
	/**
     * Property: _flashObjId
     * flash内部对象标识，私有属性。
     */
	_flashObjId: null,
	
   
    /** 
     * Constructor: Geo.ViewFl.Handler.Click
     * Geo.ViewFl.Handler.Click构造函数。
     * 
     * Parameters:
     * control - {<Geo.ViewFl.Control>} flash控件对象。
     * options - {Object} 参数对象。
     */
    initialize: function(control, callbacks) {
        Geo.ViewFl.Handler.prototype.initialize.apply(this, arguments);
    },
	
	/**
     * Method: setMap
     * 关联地图，私有。
     * 
     * Parameters:
     * map - {<Geo.ViewFl.Map>} Flash二维地图对象。
     */
    setMap: function(map){
        Geo.ViewFl.Handler.prototype.setMap.apply(this, arguments);
        this._flashObjId = this.map.swfObj.addClickHandler();
    },
	
    /**
     * APIMethod: activate
     * 打开绘制点监听器。
     */
    activate: function() {
        if(!Geo.ViewFl.Handler.prototype.activate.apply(this, arguments)) {
            return false;
        }
		
		Geo.ViewFl.Handler.Click.callJSmapClick = OpenLayers.Function.bind(function(eventType, id, pointString){
			
             this.callback("click", [pointString]);
        }, this);
		
		Geo.ViewFl.Handler.Click.callJSmapDoubleClick = OpenLayers.Function.bind(function(eventType, id, pointString){
             this.callback("doubleClick", [pointString])
        }, this);
		
		Geo.ViewFl.Handler.Click.callJSmapMouseDown = OpenLayers.Function.bind(function(eventType, id, pointString){
             this.callback("mouseDown", [pointString])
        }, this);
		
		Geo.ViewFl.Handler.Click.callJSmapMouseUp = OpenLayers.Function.bind(function(eventType, id, pointString){
             this.callback("mouseUp", [pointString])
        }, this);
		// 激活handler
		var result = this.map.swfObj.activateControl(this._flashObjId);
        return result;
    },	
			
    /**
     * APIMethod: deactivate
     * 关闭绘制点监听器。
     */
    deactivate: function() {
        if(!Geo.ViewFl.Handler.prototype.deactivate.apply(this, arguments)) {
            return false;
        }
		
		var result = this.map.swfObj.deactivateControl(this._flashObjId);
		return result;
    },

    CLASS_NAME: "Geo.ViewFl.Handler.Click"
});/**
 * Class: Geo.ViewFl.Control
 * Flash二维视图控件基类。Flash视图下所有的控件类都继承于本类，本类提供通用的控件属性和方法。
 */
Geo.ViewFl.Control = Geo.Class({
	
    /**
     * Property: id
     * {String} 唯一标识符。
     */      
    id: null,
	
	/**
     * Property: _flashObjId
     * flash内部对象标识，私有属性，默认值为null。
     */
    _flashObjId: null,
	
    /**
     * APIProperty: autoActivate
     * {Boolean} 控件加入地图后是否自动激活。
     */      
    autoActivate: false,

    /**
     * Property: active
     * {Boolean} 控件当前激活状态。
     */    
    active: false,

    /**
     * Property: handler
     * {Object} 事件监听对象。
     */      
    handler: null,
	
    /**
     * Property: eventListeners
     * {Object} 事件监听器。
     */      
    eventListeners: null,
	
    /**
     * Property: events
     * {Object} 事件管理。
     */      
    events: null,
	
    /**
     * Property: EVENT_TYPES
     * {Array} 控件基类所支持的事件类型。
     */     
    EVENT_TYPES: ["activate", "deactivate"],

    /**
     * Property: map
     * {<Geo.ViewFl.Map>} 控件所属地图对象。
     */
    map: null,

	/**
	 * Constructor: Geo.ViewFl.Control
	 * 构造一个新的<Geo.ViewFl.Control>对象实例。
	 *
	 * Parameters:
	 * options - {Object} 相关参数选项。
	 */    
    initialize: function(options){
		OpenLayers.Util.extend(this, options);
        
        this.events = new OpenLayers.Events(this, null, this.EVENT_TYPES);
        if(this.eventListeners instanceof Object) {
            this.events.on(this.eventListeners);
        }
        if (this.id == null) {
            this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
        }
    },

	/**
	 * APIMethod: setMap
	 * 将控件关联到地图对象。
	 *
	 * Parameters:
	 * map - {<Geo.ViewFl.Map>} Flash二维地图对象。
	 */	    
    setMap: function(map) {
		this.map = map;
        if (this.handler) {
            this.handler.setMap(map);
        }
    },
    
    /**
     * Method: draw
     * 控件绘制，由子类实现
     * Parameters:
     * px - {<Geo.Pixel>} 地图左上角位置的偏移像素距离。
     */
    draw: function(px){
        
    },

	/**
	 * Method: listener
	 * 鼠标事件监听器。
	 *
	 * Parameters:
	 * e - {Object} Flash二维地图鼠标事件对象。
	 */	     
    listener:function(e){
        
    },

	/**
	 * APIMethod: activate
	 * 激活控件。如果当前控件已经处于激活状态则返回false，否则激活该控件的事件监听器handler，并且触发该控件的"activate"事件，返回true。
	 */	     
    activate: function () {
		if (this.active) {
            return false;
        }
        if (this.handler) {
            this.handler.activate();
        }
        this.active = true;
        this.events.triggerEvent("activate");
        return true;
    },

	/**
	 * APIMethod: deactivate
	 * 关闭控件。如果当前控件已经处于关闭状态则返回false，否则关闭该控件的事件监听器handler，并且触发该控件的"deactivate"事件，返回true。
	 */	    
    deactivate: function () {
		if (this.active) {
            if (this.handler) {
                this.handler.deactivate();
            }
            this.active = false;
            this.events.triggerEvent("deactivate");
            return true;
        }
		return false;
    },
    
	/**
	 * Method: destroy
	 * 销毁控件。
	 */	  
    destroy: function () {
		if(this.events) {
            if(this.eventListeners) {
                this.events.un(this.eventListeners);
            }
            this.events.destroy();
            this.events = null;
        }
        this.eventListeners = null;

        // eliminate circular references
        if (this.handler) {
            this.handler.destroy();
            this.handler = null;
        }
        if(this.handlers) {
            for(var key in this.handlers) {
                if(this.handlers.hasOwnProperty(key) &&
                   typeof this.handlers[key].destroy == "function") {
                    this.handlers[key].destroy();
                }
            }
            this.handlers = null;
        }
        if (this.map) {
            this.map.removeControl(this);
            this.map = null;
        }
    },
	
	/**
     * Property: CLASS_NAME
     * {String} 类标识符。- "Geo.ViewFl.Control"
     */	  
    CLASS_NAME: "Geo.ViewFl.Control"
});/**
 * Class: Geo.ViewFl.Control.Navigation
 * Flash二维视图导航控件。
 *
 * Inherits from:
 *  - <Geo.ViewFl.Control>
 */
Geo.ViewFl.Control.Navigation = Geo.Class(Geo.ViewFl.Control, {

    /**
     * Property: autoActivate
     * {Boolean} 控件加入地图后是否自动激活，默认值为true。
     */
    autoActivate: true,
    
    /**
     * Property: _flashObjId
     * flash内部对象标识，私有属性，默认值为null。
     */
    _flashObjId: null,
    
    /**
     * Constructor: Geo.ViewFl.Control.Navigation
     * 构造一个新的<Geo.ViewFl.Control.Navigation>对象实例。该实例是一个Flash二维视图导航控件对象。
     *
     * Parameters:
     * options - {Object} 选项参数
     */
    initialize: function(options){
		Geo.ViewFl.Control.prototype.initialize.apply(this, arguments);
    },
    
	/**
	 * Method: destroy
	 * 控件销毁，私有。
	 */	 
    destroy: function(){
		Geo.ViewFl.Control.prototype.destroy.apply(this, arguments);
    },
    
	/**
     * Method: setMap
     * 关联地图，私有。
     * Parameters:
     * map - {<Geo.ViewFl.Map>} Flash二维地图对象。
     */
    setMap: function(map){
		Geo.ViewFl.Control.prototype.setMap.apply(this, arguments);
		this._flashObjId = map.swfObj.addNavigationControl();
    },
    
	/**
     * Method: draw
     * 控件绘制，私有。
     * Parameters:
     * px - {<Geo.Pixel>} 地图左上角位置的偏移像素距离。
     */
    draw: function(px){
		Geo.ViewFl.Control.prototype.draw.apply(this, arguments);
    },
    
	/**
	 * Method: activate
	 * 激活控件。如果当前控件已经处于激活状态则返回false，否则激活该控件的事件监听器handler，并且触发该控件的"activate"事件，返回true。
	 */	
    activate: function(){
		if (Geo.ViewFl.Control.prototype.activate.apply(this, arguments)) {
			var result = this.map.swfObj.activateControl(this._flashObjId);
			return result;
		}
		return false;
    },
    
	/**
	 * Method: deactivate
	 * 关闭控件。如果当前控件已经处于关闭状态则返回false，否则关闭该控件的事件监听器handler，并且触发该控件的"deactivate"事件，返回true。
	 */
    deactivate: function(){
		if (Geo.ViewFl.Control.prototype.deactivate.apply(this, arguments)) {
			var result = this.map.swfObj.deactivateControl(this._flashObjId);
			//关闭拖拽平滑效果
			this.map.isTransitionEffect(false);
			return result;
		}
		return false;
    },
    
	/**
     * Property: CLASS_NAME
     * {String} 类标识符。- "Geo.ViewFl.Control.Navigation"
     */	 
    CLASS_NAME: "Geo.ViewFl.Control.Navigation"
});
/**
 * Class: Geo.ViewFl.Control.PanZoom
 * Flash二维视图下平移缩放控件类。
 * 
 * Inherits from:
 *  - <Geo.ViewFl.Control>
 */
Geo.ViewFl.Control.PanZoom = Geo.Class(Geo.ViewFl.Control, {
	
    /**
     * Property: _flashObjId
     * flash内部对象标识，私有属性。
     */
    _flashObjId: null,
	
    /** 
     * Property: slideRatio
     * {Number} 地图宽与高的比值，是我们通过点击箭头按钮来平移地图的数量。
     */
    slideRatio: null,

    /**
     * Constructor: Geo.ViewFl.Control.PanZoom
     * 构造一个新的<Geo.ViewFl.Control.PanZoom>对象实例。
     * 
     * Parameters:
     * options - {Object}
     */
    initialize: function(options) {
		Geo.ViewFl.Control.prototype.initialize.apply(this, arguments);
    },

    /**
     * Method: destroy
     * 销毁本对象。
     */
    destroy: function() {
		Geo.ViewFl.Control.prototype.destroy.apply(this, arguments);
    },

	/**
     * Method: setMap
     * 关联地图，私有。
     * Parameters:
     * map - {<Geo.ViewFl.Map>} Flash二维地图对象。
     */
    setMap: function(map){
		Geo.ViewFl.Control.prototype.setMap.apply(this, arguments);
    },
	
    /**
     * Method: draw
     * 控件绘制，私有。
     * Parameters:
     * px - {<Geo.Pixel>} 地图左上角位置的偏移像素距离。
     */
    draw: function(px) {
		Geo.ViewFl.Control.prototype.draw.apply(this, arguments);
		this._flashObjId = this.map.swfObj.addPanZoomControl();
    },
	
	/**
     * Property: CLASS_NAME
     * {String} 类标识符。- "Geo.ViewFl.Control.PanZoom"
     */
    CLASS_NAME: "Geo.ViewFl.Control.PanZoom"
});

/**
 * Class: Geo.ViewFl.Control.PanZoomBar
 * Flash二维视图下带级别调整的平移缩放控件，继承自Geo.ViewFl.Control控件基类。
 *
 * Inherits from:
 *  - <Geo.ViewFl.Control>
 */
Geo.ViewFl.Control.PanZoomBar = Geo.Class(Geo.ViewFl.Control, {
	
	/**
     * Property: autoActivate
     * {Boolean} 控件加入地图后是否自动激活，默认值为true。
     */
    autoActivate: true,
	
    /**
     * Property: _flashObjId
     * flash内部对象标识，私有属性，默认值为null。
     */
    _flashObjId: null,
    
	/** 
     * Property: position
     * {<Geo.Pixel>} 地图左上角位置的偏移像素距离。
     */
    position: null,
	
    /**
     * Constructor: Geo.ViewFl.Control.PanZoomBar
     * 构造一个新的<Geo.ViewFl.Control.PanZoomBar>对象实例。
     * 
     * Parameters:
     * options - {Object} 选项参数
     */
    initialize: function(){
		this.position = new OpenLayers.Pixel(Geo.ViewFl.Control.PanZoomBar.X,
                                             Geo.ViewFl.Control.PanZoomBar.Y);
		Geo.ViewFl.Control.prototype.initialize.apply(this, arguments);
    },
    
    /**
	 * Method: destroy
	 * 控件销毁，私有。
	 */
    destroy: function(){
		Geo.ViewFl.Control.prototype.destroy.apply(this, arguments);
    },
    
    /**
     * Method: setMap
     * 关联地图，私有。
     * Parameters:
     * map - {<Geo.ViewFl.Map>} Flash二维地图对象。
     */
    setMap: function(map){
		Geo.ViewFl.Control.prototype.setMap.apply(this, arguments);
    },
    
    /**
     * Method: draw
     * 控件绘制，私有。
     * Parameters:
     * px - {<Geo.Pixel>} 地图左上角位置的偏移像素距离。
     */
    draw: function(px){
		Geo.ViewFl.Control.prototype.draw.apply(this, arguments);
		px = this.position;
		var pxParam = '{"x":"'+px.x+'","y":"'+px.y+'"}';
		this._flashObjId = this.map.swfObj.addPanZoomBarControl(pxParam);
    },
	//************************************新增示例需求功能************************************************/
	/**
	 * Method: activate
	 * 激活控件。如果当前控件已经处于激活状态则返回false，否则激活该控件的事件监听器handler，并且触发该控件的"activate"事件，返回true。
	 */	
    activate: function(){
		if (Geo.ViewFl.Control.prototype.activate.apply(this, arguments)) {
			var result = this.map.swfObj.activateControl(this._flashObjId);
			return result;
		}
		return false;
    },
    //************************************新增示例需求功能************************************************/
	/**
	 * Method: deactivate
	 * 关闭控件。如果当前控件已经处于关闭状态则返回false，否则关闭该控件的事件监听器handler，并且触发该控件的"deactivate"事件，返回true。
	 */
    deactivate: function(){
		if (Geo.ViewFl.Control.prototype.deactivate.apply(this, arguments)) {
			var result = this.map.swfObj.deactivateControl(this._flashObjId);
			return result;
		}
		return false;
    },
    
	/**
     * Property: CLASS_NAME
     * {String} 类标识符。- "Geo.ViewFl.Control.PanZoomBar"
     */
    CLASS_NAME: "Geo.ViewFl.Control.PanZoomBar"
});

/**
 * Constant: X
 * {Integer} 距离X轴的偏移像素值。
 */
Geo.ViewFl.Control.PanZoomBar.X = 4;

/**
 * Constant: Y
 * {Integer} 距离Y轴的偏移像素值。
 */
Geo.ViewFl.Control.PanZoomBar.Y = 4;/**
 * Class: Geo.ViewFl.Control.ScaleLine
 * Flash二维视图下比例尺线控件类，该类的实例显示带刻度的线，用来代表当前地图的比例尺。默认情况下被画在地图的左下角。
 *
 * Inherits from:
 *  - <Geo.ViewFl.Control>
 */
Geo.ViewFl.Control.ScaleLine = Geo.Class(Geo.ViewFl.Control, {
	
    /**
     * Property: _flashObjId
     * flash内部对象标识，私有属性。
     */
    _flashObjId: null,
	
    /**
     * Constructor: Geo.ViewFl.Control.ScaleLine
     * 构造一个新的<Geo.ViewFl.Control.ScaleLine>对象实例。
     *
     * Parameters:
     * options - {Object} 参数选项。
     */
    initialize: function(options){
    },
    
    /**
     * Method: destroy
     * 销毁本对象。
     */
    destroy: function() {
		Geo.ViewFl.Control.prototype.destroy.apply(this, arguments);
    },

	/**
     * Method: setMap
     * 关联地图，私有。
     * Parameters:
     * map - {<Geo.ViewFl.Map>} Flash二维地图对象。
     */
    setMap: function(map){
		Geo.ViewFl.Control.prototype.setMap.apply(this, arguments);
    },
	
    /**
     * Method: draw
     * 控件绘制，私有。
     * Parameters:
     * px - {<Geo.Pixel>} 地图左上角位置的偏移像素距离。
     */
    draw: function(px) {
		Geo.ViewFl.Control.prototype.draw.apply(this, arguments);
		this._flashObjId = this.map.swfObj.addScaleLineControl();
    },
    
	/**
     * Property: CLASS_NAME
     * {String} 类标识符。- "Geo.ViewFl.Control.ScaleLine"
     */
    CLASS_NAME: "Geo.ViewFl.Control.ScaleLine"
});

/**
 * Class: Geo.ViewFl.Control.MousePosition
 * Flash二维视图下鼠标位置控件类，此类用于显示鼠标箭头的地址坐标，无论鼠标移动与否，在地图上面都生效。
 * 
 * Inherits from:
 *  - <Geo.ViewFl.Control>
 */
Geo.ViewFl.Control.MousePosition = Geo.Class(Geo.ViewFl.Control, {
    /**
     * Property: _flashObjId
     * flash内部对象标识，私有属性。
     */
    _flashObjId: null,
	
    /**
     * Property: autoActivate
     * {Boolean} 是否自动激活。
     */
    autoActivate: true,

    /**
     * Constructor: Geo.ViewFl.Control.MousePosition
     * 构造一个新的<Geo.ViewFl.Control.MousePosition>对象实例。
     * Parameters:
     * options - {Object} 参数选项。
     */
    initialize: function(options) {
		Geo.ViewFl.Control.prototype.initialize.apply(this, arguments);
    },

    /**
     * Method: destroy
     * 销毁本对象。
     */
    destroy: function() {
		Geo.ViewFl.Control.prototype.destroy.apply(this, arguments);
    },

	/**
     * Method: setMap
     * 关联地图，私有。
     * Parameters:
     * map - {<Geo.ViewFl.Map>} Flash二维地图对象。
     */
    setMap: function(map){
		Geo.ViewFl.Control.prototype.setMap.apply(this, arguments);
    },
	
    /**
     * Method: draw
     * 控件绘制，私有。
     * Parameters:
     * px - {<Geo.Pixel>} 地图左上角位置的偏移像素距离。
     */
    draw: function(px) {
		Geo.ViewFl.Control.prototype.draw.apply(this, arguments);
		this._flashObjId = this.map.swfObj.addMousePositionControl();
    },

    /**
	 * Method: activate
	 * 激活控件。如果当前控件已经处于激活状态则返回false，否则激活该控件的事件监听器handler，并且触发该控件的"activate"事件，返回true。
	 */	
    activate: function(){
		if (Geo.ViewFl.Control.prototype.activate.apply(this, arguments)) {
			var result = this.map.swfObj.activateControl(this._flashObjId);
			return result;
		}
		return false;
    },
    
	/**
	 * Method: deactivate
	 * 关闭控件。如果当前控件已经处于关闭状态则返回false，否则关闭该控件的事件监听器handler，并且触发该控件的"deactivate"事件，返回true。
	 */
    deactivate: function(){
		if (Geo.ViewFl.Control.prototype.deactivate.apply(this, arguments)) {
			var result = this.map.swfObj.deactivateControl(this._flashObjId);
			return result;
		}
		return false;
    },

	/**
     * Property: CLASS_NAME
     * {String} 类标识符。- "Geo.ViewFl.Control.MousePosition"
     */	
    CLASS_NAME: "Geo.ViewFl.Control.MousePosition"
});
/**
 * Class: Geo.ViewFl.Control.OverviewMap
 * Flash二维视图下鹰眼图控件，继承自Geo.ViewFl.Control控件基类。
 * 可在地图的右下角创建一个可以进行伸缩的窗口，窗口里包含一个地图。
 * 
 * Inerits from:
 *  - <Geo.ViewFl.Control>
 */
Geo.ViewFl.Control.OverviewMap = Geo.Class(Geo.ViewFl.Control, {
	
    /**
     * Property: _flashObjId
     * flash内部对象标识，私有属性。
     */
    _flashObjId: null,
	
    /**
     * Property: size
     * {<Geo.Size>} 鹰眼图的大小。
     */
    size: new Geo.Size(100, 100),

    /**
     * Property: layers
     * {Array(<Geo.ViewFl.Layer>)} 鹰眼图中的图层列表。如果在构造器中不设置此项，将会启用主地图的基础图层。
     */
    layers: null,
    
    /**
     * Property: mapOptions
     * {Object} 构造地图时需要配置的可选参数。
 
     */
    mapOptions: null,

    /**
     * Constructor: Geo.ViewFl.Control.OverviewMap
     * 构造一个新的<Geo.ViewFl.Control.OverviewMap>对象实例。
     *
     * Parameters:
     * options - {Object} 参数选项。
     */
    initialize: function(options) {
		Geo.ViewFl.Control.prototype.initialize.apply(this, arguments);
    },
    
	/**
     * Method: destroy
     * 销毁本对象。
     */
    destroy: function() {
		Geo.ViewFl.Control.prototype.destroy.apply(this, arguments);
    },

	/**
     * Method: setMap
     * 关联地图，私有。
     * Parameters:
     * map - {<Geo.ViewFl.Map>} Flash二维地图对象。
     */
    setMap: function(map){
		Geo.ViewFl.Control.prototype.setMap.apply(this, arguments);
    },
	
    /**
     * Method: draw
     * 控件绘制，私有。
     * Parameters:
     * px - {<Geo.Pixel>} 地图左上角位置的偏移像素距离。
     */
    draw: function(px) {
		Geo.ViewFl.Control.prototype.draw.apply(this, arguments);
		this._flashObjId = this.map.swfObj.addOverViewMapControl();
    },
    
	/**
     * Property: CLASS_NAME
     * {String} 类标识符。- "Geo.ViewFl.Control.OverviewMap"
     */
    CLASS_NAME: 'Geo.ViewFl.Control.OverviewMap'
});
/**
 * Class: Geo.ViewFl.Control.DrawFeature
 * Flash二维视图下绘制要素的控件类，当绘制要素控件激活的时候，它能绘制点、线、面矢量要素到一个矢量图层上。
 * 
 * Inherits from:
 *  - <Geo.ViewFl.Control>
 */
Geo.ViewFl.Control.DrawFeature = Geo.Class(Geo.ViewFl.Control, {
    
	/**
     * Property: _flashObjId
     * flash内部对象标识，私有属性。
     */
    _flashObjId: null,
	
    /**
     * APIProperty: layer
     * {<Geo.ViewFl.Layer.Vector>} Flash视图下的矢量图层。
     */
    layer: null,

    /**
     * APIProperty: callbacks
     * {Object} 回调函数。
     */
    callbacks: null,
    
    /**
     * Constant: EVENT_TYPES
     * {Array(String)} 本对象所支持的事件类型定义。
     * featureadded - 要素被添加后触发。
     */
    EVENT_TYPES: ["featureadded"],
    
    /**
     * APIProperty: featureAdded
     * {Function} 每一个要素被添加以后会触发这个方法上。
     */
    featureAdded: function() {},

    /**
     * APIProperty: handlerOptions
     * {Object} 监听器的构造参数。
     */
    handlerOptions: null,
    
    /**
     * Constructor: Geo.ViewFl.Control.DrawFeature
     * 构造一个新的<Geo.ViewFl.Control.DrawFeature>对象实例。
     * 
     * Parameters:
     * layer - {<Geo.ViewFl.Layer.Vector>} 矢量图层。
     * handler - {<Geo.ViewFl.Handler>} 控件动作监听对象。
     * options - {Object} 可选参数。
     */
    initialize: function(layer, handler, options) {
		this.EVENT_TYPES =
            OpenLayers.Control.DrawFeature.prototype.EVENT_TYPES.concat(
            OpenLayers.Control.prototype.EVENT_TYPES
        );
		Geo.ViewFl.Control.prototype.initialize.apply(this, [options]);
        this.callbacks = OpenLayers.Util.extend({
            "done": this.drawFeature
        }, this.callbacks);
		this.layer = layer;
        this.handlerOptions = this.handlerOptions || {};
		
		var sketchStyle = this.layer.styleMap && this.layer.styleMap.styles.temporary;
        if(sketchStyle) {
            this.handlerOptions.layerOptions = OpenLayers.Util.applyDefaults(
                this.handlerOptions.layerOptions,
                {styleMap: new OpenLayers.StyleMap({"default": sketchStyle})}
            );
        }
        this.handler = new handler(this, this.callbacks, this.handlerOptions);
		
    },

    /**
     * APIMethod: drawFeature
     * 绘制要素。
     */
    drawFeature: function(geometry) {
		var feature = new Geo.Feature.Vector(geometry);
        this.layer.addFeatures([feature]);
        this.featureAdded(feature);
        this.events.triggerEvent("featureadded",{feature : feature});
    },

    CLASS_NAME: "Geo.ViewFl.Control.DrawFeature"
});
/**
 * Class: Geo.ViewFl.Control.LayerScroll
 * Flash二维视图下图层卷帘控件，继承自Geo.ViewFl.Control控件基类。
 *
 * Inherits from:
 *  - <Geo.ViewFl.Control>
 */
Geo.ViewFl.Control.LayerScroll = Geo.Class(Geo.ViewFl.Control, {

    /**
     * Property: _flashObjId
     * flash内部对象标识，私有属性。
     */
    _flashObjId: null,
    
	/** 
     * APIProperty: position
     * {<Geo.Pixel>} 地图左上角位置的偏移像素距离。
     */
    position: null,
	
	/** 
     * APIProperty: size 
     * {<Geo.Size>} 图层卷帘控件的尺寸。
     */
    size: null,  
	
    /**
     * Constructor: Geo.ViewFl.Control.LayerScroll
     * 构造一个新的<Geo.ViewFl.Control.LayerScroll>对象实例。
     * 
     * Parameters:
     * options - {Object} 选项参数
     */
    initialize: function(){
		Geo.ViewFl.Control.prototype.initialize.apply(this, arguments);
		this.size = (this.size != null) ? this.size 
                                  : new Geo.Size(
                                                   Geo.ViewFl.Control.LayerScroll.WIDTH,
                                                   Geo.ViewFl.Control.LayerScroll.HEIGHT);
        this.position = (this.position != null) ? this.position : new Geo.Pixel(0, 0);
    },
    
    /**
	 * Method: destroy
	 * 控件销毁，私有。
	 */
    destroy: function(){
		Geo.ViewFl.Control.prototype.destroy.apply(this, arguments);
    },
    
    /**
     * Method: setMap
     * 关联地图，私有。
     * Parameters:
     * map - {<Geo.ViewFl.Map>} Flash二维地图对象。
     */
    setMap: function(map){
		Geo.ViewFl.Control.prototype.setMap.apply(this, arguments);
    },
    
    /**
     * Method: draw
     * 控件绘制，私有。
     * Parameters:
     * px - {<Geo.Pixel>} 地图左上角位置的偏移像素距离。
     */
    draw: function(px){
		if(!px){
			px = this.position;
		}
        var param = '{"x":"' + px.x + '","y":"' + px.y + '","width":"' + this.size.w + '","height":"' + this.size.h + '"}';
		Geo.ViewFl.Control.prototype.draw.apply(this, arguments);
		this._flashObjId = this.map.swfObj.addMaskControl(param);
    },
    
	/**
     * Property: CLASS_NAME
     * {String} 类标识符。- "Geo.ViewFl.Control.LayerScroll"
     */	
    CLASS_NAME: "Geo.ViewFl.Control.LayerScroll"
});

/**
 * 宽度
 */
Geo.ViewFl.Control.LayerScroll.WIDTH = 300;

/**
 * 高度
 */
Geo.ViewFl.Control.LayerScroll.HEIGHT = 300;/**
 * Class: Geo.ViewFl.Control.Measure
 * 测量控件类，此类允许对要素进行距离面积等测量。
 *
 * Inherits from:
 *  - <Geo.ViewFl.Control>
 */
Geo.ViewFl.Control.Measure = Geo.Class(Geo.ViewFl.Control, {

    /**
     * Constant: EVENT_TYPES
     * {Array(String)} 本对象所支持的事件类型，注册监听事件语法如下：
     * (code)
     * control.events.register(type, obj, listener);
     * (end)
     *
     * 监听器会与事件对象管理起来。事件的属性依赖于发生的事件。
     * 当量算完成的时候触发。监听器会接受到 measure, units, order以及geometry属性。
     */
    EVENT_TYPES: ['measure', 'measurepartial'],

    /**
     * APIProperty: handlerOptions
     * {Object} 在控件的动作监听上设置属性。
     */
    handlerOptions: null,
    
    /**
     * Property: callbacks
     * {Object} The functions that are sent to the handler for callback
     */
    callbacks: null,
    
    /**
     * Property: displaySystem
     * {String} Display system for output measurements.  Supported values
     *     are 'english', 'metric', and 'geographic'.  Default is 'metric'.
     */
    displaySystem: 'metric',
    
    /**
     * Property: geodesic
     * {Boolean} Calculate geodesic metrics instead of planar metrics.  This
     *     requires that geometries can be transformed into Geographic/WGS84
     *     (if that is not already the map projection).  Default is false.
     */
    geodesic: false,
    
    /**
     * Property: displaySystemUnits
     * {Object} Units for various measurement systems.  Values are arrays
     *     of unit abbreviations (from OpenLayers.INCHES_PER_UNIT) in decreasing
     *     order of length.
     */
    displaySystemUnits: {
        geographic: ['dd'],
        english: ['mi', 'ft', 'in'],
        metric: ['km', 'm']
    },

    /**
     * Property: delay
     * {Number} Number of milliseconds between clicks before the event is
     *     considered a double-click.  The "measurepartial" event will not
     *     be triggered if the sketch is completed within this time.  This
     *     is required for IE where creating a browser reflow (if a listener
     *     is modifying the DOM by displaying the measurement values) messes
     *     with the dblclick listener in the sketch handler.
     */
    partialDelay: 300,

    /**
     * Property: delayedTrigger
     * {Number} Timeout id of trigger for measurepartial.
     */
    delayedTrigger: null,
    
    /**
     * APIProperty: persist
     * {Boolean} 是否保留绘制上次绘制的要素，默认值为false。
     * 如果设置为true，重新开始一个新绘制时，上次绘制的要素仍将保留。
     */
    persist: false,

    /**
     * Constructor: Geo.ViewFl.Control.Measure
     * 构造一个新的<Geo.ViewFl.Control.Measure>对象实例。
     * 
     * Parameters:
     * handler - {<Geo.ViewFl.Handler>} 
     * options - {Object} 
     */
    initialize: function(handler, options) {
        // concatenate events specific to measure with those from the base
        this.EVENT_TYPES =
            OpenLayers.Control.Measure.prototype.EVENT_TYPES.concat(
            OpenLayers.Control.prototype.EVENT_TYPES
        );
        OpenLayers.Control.prototype.initialize.apply(this, [options]);
        this.callbacks = OpenLayers.Util.extend(
            {done: this.measureComplete, point: this.measurePartial},
            this.callbacks
        );

        // let the handler options override, so old code that passes 'persist' 
        // directly to the handler does not need an update
        this.handlerOptions = OpenLayers.Util.extend(
            {persist: this.persist}, this.handlerOptions
        );
		
        this.handler = new handler(this, this.callbacks, this.handlerOptions);
    },
    
    /**
     * APIMethod: cancel
     * 停止控件量算。如果<persist>设置为true,临时的测量将会被清掉。
     */
    cancel: function() {
        this.handler.cancel();
    },
    
    /**
     * Method: updateHandler
     *
     * Parameters:
     * handler - {Function} One of the sketch handler constructors.
     * options - {Object} Options for the handler.
     */
    updateHandler: function(handler, options) {
        var active = this.active;
        if(active) {
            this.deactivate();
        }
        this.handler = new handler(this, this.callbacks, options);
        if(active) {
            this.activate();
        }
    },

    /**
     * Method: measureComplete
     * Called when the measurement sketch is done.
     *
     * Parameters:
     * geometry - {<OpenLayers.Geometry>}
     */
    measureComplete: function(geometry) {
        if(this.delayedTrigger) {
            window.clearTimeout(this.delayedTrigger);
        }
        this.measure(geometry, "measure");
    },
    
    /**
     * Method: measurePartial
     * Called each time a new point is added to the measurement sketch.
     *
     * Parameters:
     * point - {<OpenLayers.Geometry.Point>} The last point added.
     * geometry - {<OpenLayers.Geometry>} The sketch geometry.
     */
    measurePartial: function(point, geometry) {
        if (geometry.getLength() > 0) {
            geometry = geometry.clone();
            this.delayedTrigger = window.setTimeout(
                OpenLayers.Function.bind(function() {
                    this.measure(geometry, "measurepartial");
                }, this),
                this.partialDelay
            );
        }
    },

    /**
     * Method: measure
     *
     * Parameters:
     * geometry - {<OpenLayers.Geometry>}
     * eventType - {String}
     */
    measure: function(geometry, eventType) {
        var stat, order;
        if(geometry.CLASS_NAME.indexOf('LineString') > -1) {
            stat = this.getBestLength(geometry);
            order = 1;
        } else {
            stat = this.getBestArea(geometry);
            order = 2;
        }
        this.events.triggerEvent(eventType, {
            measure: stat[0],
            units: stat[1],
            order: order,
            geometry: geometry
        });
    },
    
    /**
     * Method: getBestArea
     * Based on the <displaySystem> returns the area of a geometry.
     *
     * Parameters:
     * geometry - {<OpenLayers.Geometry>}
     *
     * Returns:
     * {Array([Float, String])}  Returns a two item array containing the
     *     area and the units abbreviation.
     */
    getBestArea: function(geometry) {
        var units = this.displaySystemUnits[this.displaySystem];
        var unit, area;
        for(var i=0, len=units.length; i<len; ++i) {
            unit = units[i];
            area = this.getArea(geometry, unit);
            if(area > 1) {
                break;
            }
        }
        return [area, unit];
    },
    
    /**
     * Method: getArea
     *
     * Parameters:
     * geometry - {<OpenLayers.Geometry>}
     * units - {String} Unit abbreviation
     *
     * Returns:
     * {Float} The geometry area in the given units.
     */
    getArea: function(geometry, units) {
        var area, geomUnits;
        if(this.geodesic) {
            area = geometry.getGeodesicArea(this.map.getProjectionObject());
            geomUnits = "m";
        } else {
            area = geometry.getArea();
            geomUnits = "degrees";//this.map.getUnits();
        }
        var inPerDisplayUnit = OpenLayers.INCHES_PER_UNIT[units];
        if(inPerDisplayUnit) {
            var inPerMapUnit = OpenLayers.INCHES_PER_UNIT[geomUnits];
            area *= Math.pow((inPerMapUnit / inPerDisplayUnit), 2);
        }
        return area;
    },
    
    /**
     * Method: getBestLength
     * Based on the <displaySystem> returns the length of a geometry.
     *
     * Parameters:
     * geometry - {<OpenLayers.Geometry>}
     *
     * Returns:
     * {Array([Float, String])}  Returns a two item array containing the
     *     length and the units abbreviation.
     */
    getBestLength: function(geometry) {
        var units = this.displaySystemUnits[this.displaySystem];
        var unit, length;
        for(var i=0, len=units.length; i<len; ++i) {
            unit = units[i];
            length = this.getLength(geometry, unit);
            if(length > 1) {
                break;
            }
        }
        return [length, unit];
    },

    /**
     * Method: getLength
     *
     * Parameters:
     * geometry - {<OpenLayers.Geometry>}
     * units - {String} Unit abbreviation
     *
     * Returns:
     * {Float} The geometry length in the given units.
     */
    getLength: function(geometry, units) {
        var length, geomUnits;
        if(this.geodesic) {
            length = geometry.getGeodesicLength(this.map.getProjectionObject());
            geomUnits = "m";
        } else {
            length = geometry.getLength();
            geomUnits = "degrees";//this.map.getUnits();
        }
        var inPerDisplayUnit = OpenLayers.INCHES_PER_UNIT[units];
        if(inPerDisplayUnit) {
            var inPerMapUnit = OpenLayers.INCHES_PER_UNIT[geomUnits];
            length *= (inPerMapUnit / inPerDisplayUnit);
        }
        return length;
    },

    CLASS_NAME: "Geo.ViewFl.Control.Measure"
});
/**
 * Class: Geo.ViewFl.Control.SelectFeature
 * Flash二维视图下要素选择控件。
 *
 * Inherits from:
 *  - <Geo.ViewFl.Control>
 */
Geo.ViewFl.Control.SelectFeature = Geo.Class(Geo.ViewFl.Control, {
	
    /**
     * Property: _flashObjId
     * flash内部对象标识，私有属性。
     */
    _flashObjId: null,
	
	/**
     * Property: EVENT_TYPES
     * {Array} 控件所支持的事件类型。
     */ 
    EVENT_TYPES: ["beforefeaturehighlighted", "featurehighlighted", "featureunhighlighted"],
	
	/**
     * Property: layer
     * {<Geo.ViewFl.Layer.Vector>} 要素选择控件所对应的矢量图层。
     */
    layer: null,
    /**
     * Property: scope
     * {Object} onBeforeSelect, onSelect, onUnselect等回调方法的上下文，即this的指向。
     * 如果为null值，则指向要素选择控件本身。
     */
    scope: null,
    
    /**
     * Property: onBeforeSelect 
     * {Function} 要素被选中之前将触发此方法，用户可以用自定义方法代替。
     */
    onBeforeSelect: function() {},
    
    /**
     * Property: onSelect 
     * {Function} 要素被选中后触发此方法，用户可以用自定义方法代替。
     */
    onSelect: function() {},

    /**
     * Property: onUnselect
     * {Function} 要素取消选择后触发此方法，用户可以用自定义方法代替。
     */
    onUnselect: function() {},
    
    /**
     * Constructor: Geo.ViewFl.Control.SelectFeature
     * Geo.ViewFl.Control.SelectFeature构造函数。
     *
     * Parameters:
     * layer - {<Geo.ViewFl.Layer.Vector>} 要素选择控件所对应的矢量图层。
     * options - {Object} 构造参数。
     */
    initialize: function(layer, options) {
		this.EVENT_TYPES =
            Geo.ViewFl.Control.SelectFeature.prototype.EVENT_TYPES.concat(
            Geo.ViewFl.Control.prototype.EVENT_TYPES
        );
        Geo.ViewFl.Control.prototype.initialize.apply(this, [options]);
        this.layer = layer;
    },

    highlight: function(feature) {
		var layer = feature.layer;
    },

    unhighlight: function(feature) {
		var layer = feature.layer;
    },
    
    /**
     * Method: select
     * 选择要素，将指定要素添加到矢量图层的selectedFeatures数组中，重新以被选中样式绘制要素，
     * 并且调用onSelect方法。
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 
     */
    select: function(feature) {
		var cont = this.onBeforeSelect.call(this.scope, feature);
        var layer = feature.layer;
        if(cont !== false) {
            cont = layer.events.triggerEvent("beforefeatureselected", {
                feature: feature
            });
            if(cont !== false) {
                layer.selectedFeatures.push(feature);
                this.highlight(feature);
                
                layer.events.triggerEvent("featureselected", {feature: feature});
                this.onSelect.call(this.scope, feature);
            }
        }
    },

    /**
     * Method: unselect
     * 取消选择要素。
     *
     * Parameters:
     * feature - {<Geo.Feature.Vector>}
     */
    unselect: function(feature) {
		var layer = feature.layer;
        this.unhighlight(feature);
        OpenLayers.Util.removeItem(layer.selectedFeatures, feature);
    },
	
	/**
     * Method: unselectAll
     * 取消所有被选择要素。
     */
    unselectAll: function() {
		var layer = this.layer, feature;
        for(var i=layer.selectedFeatures.length-1; i>=0; --i) {
            feature = layer.selectedFeatures[i];
        }
    },
	
    /**
     * Method: setMap
     * 关联地图，私有。
     * 
     * Parameters:
     * map - {<Geo.ViewFl.Map>} Flash二维地图对象。
     */
    setMap: function(map) {
		Geo.ViewFl.Control.prototype.setMap.apply(this, arguments);
		var layerId = "";
		var optionString = '[]';
		this._flashObjId = this.map.swfObj.addSelectFeatureControl(layerId, optionString);
    },

	/**
	 * Method: activate
	 * 激活控件。如果当前控件已经处于激活状态则返回false，否则激活该控件的事件监听器handler，并且触发该控件的"activate"事件，返回true。
	 */	
    activate: function(){
		if (Geo.ViewFl.Control.prototype.activate.apply(this, arguments)) {
			Geo.ViewFl.Control.SelectFeature.callJS = OpenLayers.Function.bind(function(eventType, featureId, layerId){
				if (layerId == this.layer._flashObjId) {
		            var feature = this.layer.getFeatureByFlashObjId(featureId);
		            this.onSelect(feature);
		        }
		    }, this);
			var result = this.map.swfObj.activateControl(this._flashObjId);
			return result;
		}
		return false;
    },
	
	/**
	 * Method: deactivate
	 * 关闭控件。如果当前控件已经处于关闭状态则返回false，否则关闭该控件的事件监听器handler，并且触发该控件的"deactivate"事件，返回true。
	 */
    deactivate: function(){
		if (Geo.ViewFl.Control.prototype.deactivate.apply(this, arguments)) {
			var result = this.map.swfObj.deactivateControl(this._flashObjId);
			return result;
		}
		return false;
    },

	/**
     * Method: destroy
     * 销毁方法。
     */
    destroy: function() {
    },
	
    CLASS_NAME: "Geo.ViewFl.Control.SelectFeature"
});/**
 * Class: Geo.ViewFl.Control.ModifyFeature
 * Flash二维视图下要素修改控件类，该类的实例是一个修改要素的控件。当控件激活的时候，一次点击会渲染一个要素的顶点-顶点能够被拖动。
 * 默认情况下，删除键将会删除鼠标下的顶点。拖拽两点之间的“虚拟点”，将会产生新的点。
 * 
 * Inherits From:
 *  - <Geo.ViewFl.Control>
 */
Geo.ViewFl.Control.ModifyFeature = Geo.Class(Geo.ViewFl.Control, {
	
    /**
     * Property: _flashObjId
     * flash内部对象标识，私有属性。
     */
    _flashObjId: null,
	
    /**
     * APIProperty: layer
     * {<Geo.ViewFl.Layer.Vector>} 绘制图层。
     */
    layer: null,
    
    /**
     * APIProperty: feature
     * {<Geo.Feature.Vector>} 被修改的要素对象。
     */
    feature: null,

    /**
     * Constructor: Geo.ViewFl.Control.ModifyFeature
     * 构造一个新的Geo.ViewFl.Control.ModifyFeature对象实例。
     *
     * Parameters:
     * layer - {<Geo.ViewFl.Layer.Vector>} 
     * options - {Object} 参数选项。
     */
    initialize: function(layer, options) {
        Geo.ViewFl.Control.prototype.initialize.apply(this, [options]);
        this.layer = layer;
    },

    /**
     * Method: destroy
     * 销毁本对象。
     */
    destroy: function() {
		Geo.ViewFl.Control.prototype.destroy.apply(this, arguments);
    },

	/**
     * Method: setMap
     * 关联地图，私有。
     * 
     * Parameters:
     * map - {<Geo.ViewFl.Map>} Flash二维地图对象。
     */
    setMap: function(map){
		Geo.ViewFl.Control.prototype.setMap.apply(this, arguments);
        this._flashObjId = map.swfObj.addModifyFeatureControl(this.layer._flashObjId);
//        Geo.ViewFl.Control.ModifyFeature.callJS = OpenLayers.Function.bind(function(eventType, featureId, layerId){
//			this.onSelect(featureId+layerId);
//        }, this);
    },
	
    /**
	 * Method: activate
	 * 激活控件。如果当前控件已经处于激活状态则返回false，否则激活该控件的事件监听器handler，并且触发该控件的"activate"事件，返回true。
	 */	
    activate: function(){
		if (Geo.ViewFl.Control.prototype.activate.apply(this, arguments)) {
			// 图层上的要素与控件关联
			this.map.swfObj.layerToEditHandler(this._flashObjId, this.layer._flashObjId);
			var result = this.map.swfObj.activateControl(this._flashObjId);
			return result;
		}
		return false;
    },
	
	/**
	 * Method: deactivate
	 * 关闭控件。如果当前控件已经处于关闭状态则返回false，否则关闭该控件的事件监听器handler，并且触发该控件的"deactivate"事件，返回true。
	 */
    deactivate: function(){
		if (Geo.ViewFl.Control.prototype.deactivate.apply(this, arguments)) {
			var result = this.map.swfObj.deactivateControl(this._flashObjId);
			return result;
		}
		return false;
    },
    
    CLASS_NAME: "Geo.ViewFl.Control.ModifyFeature"
});
/**
 * Class: Geo.ViewFl.Control.ZoomBox
 * Flash二维视图下拉框控件。
 *
 * Inherits from:
 *  - <Geo.ViewFl.Control>
 */
Geo.ViewFl.Control.ZoomBox = Geo.Class(Geo.ViewFl.Control, {
	
    /**
     * Property: _flashObjId
     * flash内部对象标识，私有属性。
     */
    _flashObjId: null,
	
	/**
     * APIProperty: callbacks
     * {Object} 回调函数。
     */
    callbacks: null,
	
	/**
     * Constructor: Geo.ViewFl.Control.ZoomBox
     * 构造一个新的Geo.ViewFl.Control.ZoomBox对象实例。该实例是一个Flash二维视图拉框控件。
     *
     * Parameters:
     * options - {Object} 选项参数。
     */
    initialize: function(options){
		Geo.ViewFl.Control.prototype.initialize.apply(this, arguments);
		this.callbacks = OpenLayers.Util.extend({
            "done": this.getBounds
        }, this.callbacks);
    },
	
	/**
	 * Method: destroy
	 * 控件销毁，私有。
	 */	 
    destroy: function(){
		Geo.ViewFl.Control.prototype.destroy.apply(this, arguments);
    },
	
	
	/**
     * Method: setMap
     * 关联地图，私有。
     * 
     * Parameters:
     * map - {<Geo.ViewFl.Map>} Flash二维地图对象。
     */
    setMap: function(map){
		Geo.ViewFl.Control.prototype.setMap.apply(this, arguments);
		this._flashObjId = map.swfObj.addZoomBoxControl();
        Geo.ViewFl.Control.ZoomBox.callJS = OpenLayers.Function.bind(function(eventType, id, bounds){
            if (bounds) {
				var xmin = bounds.split(",")[0];
				var ymin = bounds.split(",")[1];
				var xmax = bounds.split(",")[2];
				var ymax = bounds.split(",")[3];
				var geoBounds = new Geo.Bounds(xmin, ymin, xmax, ymax);
				this.getBounds(geoBounds);
            }
        }, this);
    },
	
    
	/**
     * Method: draw
     * 控件绘制，私有。
     * 
     * Parameters:
     * px - {<Geo.Pixel>} 地图左上角位置的偏移像素距离。
     */
    draw: function(px){
		Geo.ViewFl.Control.prototype.draw.apply(this, arguments);
    },

    /**
     * APIMethod: getBounds
     * 获取范围。
     * 
     * Parameters:
     * bounds - {<Geo.Bounds>}
     */
    getBounds: function (bounds) {
    },
	
	/**
	 * Method: activate
	 * 激活控件。如果当前控件已经处于激活状态则返回false，否则激活该控件的事件监听器handler，并且触发该控件的"activate"事件，返回true。
	 */	
    activate: function(){
		if (Geo.ViewFl.Control.prototype.activate.apply(this, arguments)) {
			var result = this.map.swfObj.activateControl(this._flashObjId);
			return result;
		}
		return false;
    },
    
	/**
	 * Method: deactivate
	 * 关闭控件。如果当前控件已经处于关闭状态则返回false，否则关闭该控件的事件监听器handler，并且触发该控件的"deactivate"事件，返回true。
	 */
    deactivate: function(){
		if (Geo.ViewFl.Control.prototype.deactivate.apply(this, arguments)) {
			var result = this.map.swfObj.deactivateControl(this._flashObjId);
			return result;
		}
		return false;
    },
	
    CLASS_NAME: "Geo.ViewFl.Control.ZoomBox"
});
/**
 * Geo.ViewFl.Control.Control.Mouse
 * flash视图鼠标动作类。使用本控件可以实现通过鼠标左键，右键以及鼠标移动动作来捕捉到flash的鼠标事件对象
 * 说明：本类与鼠标拉框动作功能是分开的
 * Inherits from:
 *  - <Geo.ViewFl.Control>
 */
Geo.ViewFl.Control.Mouse = Geo.Class(Geo.ViewFl.Control,{
	
	 /**
     * APIProperty: handlerOptions
     * {Object} 监听器的构造参数
     */
    handlerOptions: null,

    /**
     * APIProperty: callbacks
     * {Object} 回调函数定义
     */    
    callbacks: null,
	
    /**
     * Constructor: Geo.ViewFl.Control.Mouse
     * Geo.ViewFl.Control.Mouse构造函数。
     */
    initialize: function(options){
		Geo.ViewFl.Control.prototype.initialize.apply(this, [options]);
		this.callbacks = OpenLayers.Util.extend(
            {
                "click": this.onClick,
				"doubleClick": this.doubleClick,
				"mouseDown":this.mouseDown,
				"mouseUp":this.mouseUp
				
            },
            this.callbacks
        );
		this.handlerOptions = this.handlerOptions || {};
    	this.handler = new Geo.ViewFl.Handler.Click( this,
                            this.callbacks, this.handlerOptions);
    },	
	
	/*
	 * APIMethod: onClick
	 * 鼠标左键点击动作，由用户覆盖
	 * Parameters:
     * e - {Object} flash地图的鼠标事件对象
	 */
	onClick: function(params) {
		
	},
	
	/*
	 * APIMethod: onRightClick
	 * 鼠标右键双击动作，由用户覆盖
	 * Parameters:
     * e - {Object} flash地图的鼠标事件对象
	 */
	doubleClick: function(params) {
	
	},
	
	/*
	 * APIMethod: onClick
	 * 鼠标左键按下动作，由用户覆盖
	 * Parameters:
     * e - {Object} flash地图的鼠标事件对象
	 */
	mouseDown: function(params) {
	
	},
	
	/*
	 * APIMethod: onRightClick
	 * 鼠标右键按上动作，由用户覆盖
	 * Parameters:
     * e - {Object} flash地图的鼠标事件对象
	 */
	mouseUp: function(params) {
	
	},
	

	
	/**
     * Property: CLASS_NAME
     * {String} 类名标识 - "Geo.ViewFl.Control.Mouse"
     */	  
	CLASS_NAME: "Geo.ViewFl.Control.Mouse"
});/**
 * Class: Geo.ViewFl.Control.SituationControl
 * Flash二维视图下态势标绘控件，继承自Geo.ViewFl.Control控件基类。
 *
 * Inherits from:
 *  - <Geo.ViewFl.Control>
 */
Geo.ViewFl.Control.SituationControl = Geo.Class(Geo.ViewFl.Control, {

    /**
     * Property: _flashObjId
     * flash内部对象标识，私有属性。
     */
    _flashObjId: null,
    
	/** 
     * APIProperty: position
     * {<Geo.Pixel>} 地图左上角位置的偏移像素距离。
     */
    position: null,
	
	/** 
     * APIProperty: size 
     * {<Geo.Size>} 态势标绘控件的尺寸。
     */
    size: null,  
	
    /**
     * Constructor: Geo.ViewFl.Control.SituationControl
     * 构造一个新的<Geo.ViewFl.Control.SituationControl>对象实例。
     * 
     * Parameters:
     * options - {Object} 选项参数
     */
    initialize: function(){
		Geo.ViewFl.Control.prototype.initialize.apply(this, arguments);
		this.size = (this.size != null) ? this.size 
                                  : new Geo.Size(
                                                   Geo.ViewFl.Control.LayerScroll.WIDTH,
                                                   Geo.ViewFl.Control.LayerScroll.HEIGHT);
        this.position = (this.position != null) ? this.position : new Geo.Pixel(0, 0);
    },
    
    /**
	 * Method: destroy
	 * 控件销毁，私有。
	 */
    destroy: function(){
		Geo.ViewFl.Control.prototype.destroy.apply(this, arguments);
    },
    
    /**
     * Method: setMap
     * 关联地图，私有。
     * Parameters:
     * map - {<Geo.ViewFl.Map>} Flash二维地图对象。
     */
    setMap: function(map){
		Geo.ViewFl.Control.prototype.setMap.apply(this, arguments);
    },
    
    /**
     * Method: draw
     * 控件绘制，私有。
     * Parameters:
     * px - {<Geo.Pixel>} 地图左上角位置的偏移像素距离。
     */
    draw: function(px){
		if(!px){
			px = this.position;
		}
        var param = '{"x":"' + px.x + '","y":"' + px.y + '","width":"' + this.size.w + '","height":"' + this.size.h + '"}';
		Geo.ViewFl.Control.prototype.draw.apply(this, arguments);
		this._flashObjId = this.map.swfObj.addSituationControl(param);
    },
    
	/**
     * Property: CLASS_NAME
     * {String} 类标识符。- "Geo.ViewFl.Control.SituationControl"
     */	
    CLASS_NAME: "Geo.ViewFl.Control.SituationControl"
});

/**
 * 宽度
 */
Geo.ViewFl.Control.LayerScroll.WIDTH = 214;

/**
 * 高度
 */
Geo.ViewFl.Control.LayerScroll.HEIGHT = 285;/**
 * Class: Geo.ViewFl.Control.GeoLayerManager
 * Flash二维视图下图层管理控件，继承自Geo.ViewFl.Control控件基类。
 *
 * Inherits from:
 *  - <Geo.ViewFl.Control>
 */
Geo.ViewFl.Control.GeoLayerManager = Geo.Class(Geo.ViewFl.Control, {

    /**
     * Property: _flashObjId
     * flash内部对象标识，私有属性。
     */
    _flashObjId: null,
    
	/** 
     * APIProperty: position
     * {<Geo.Pixel>} 地图左上角位置的偏移像素距离。
     */
    position: null,
	
	/** 
     * APIProperty: size 
     * {<Geo.Size>} 图层管理控件的尺寸。
     */
    size: null,  
	
    /**
     * Constructor: Geo.ViewFl.Control.GeoLayerManager
     * 构造一个新的<Geo.ViewFl.Control.GeoLayerManager>对象实例。
     * 
     * Parameters:
     * options - {Object} 选项参数
     */
    initialize: function(){
		Geo.ViewFl.Control.prototype.initialize.apply(this, arguments);
		this.size = (this.size != null) ? this.size 
                                  : new Geo.Size(
                                                   Geo.ViewFl.Control.GeoLayerManager.WIDTH,
                                                   Geo.ViewFl.Control.GeoLayerManager.HEIGHT);
        this.position = (this.position != null) ? this.position : new Geo.Pixel(0, 0);
    },
    
    /**
	 * Method: destroy
	 * 控件销毁，私有。
	 */
    destroy: function(){
		Geo.ViewFl.Control.prototype.destroy.apply(this, arguments);
    },
    
    /**
     * Method: setMap
     * 关联地图，私有。
     * Parameters:
     * map - {<Geo.ViewFl.Map>} Flash二维地图对象。
     */
    setMap: function(map){
		Geo.ViewFl.Control.prototype.setMap.apply(this, arguments);
    },
    
    /**
     * Method: draw
     * 控件绘制，私有。
     * Parameters:
     * px - {<Geo.Pixel>} 地图左上角位置的偏移像素距离。
     */
    draw: function(px){
		if(!px){
			px = this.position;
		}
        var param = '{"x":"' + px.x + '","y":"' + px.y + '","width":"' + this.size.w + '","height":"' + this.size.h + '"}';
		Geo.ViewFl.Control.prototype.draw.apply(this, arguments);
		this._flashObjId = this.map.swfObj.addGeoLayerManager(param);
    },
    
	/**
     * Property: CLASS_NAME
     * {String} 类标识符。- "Geo.ViewFl.Control.GeoLayerManager"
     */	
    CLASS_NAME: "Geo.ViewFl.Control.GeoLayerManager"
});

/**
 * 宽度
 */
Geo.ViewFl.Control.LayerScroll.WIDTH = 250;

/**
 * 高度
 */
Geo.ViewFl.Control.LayerScroll.HEIGHT = 200;/**
 * Class: Geo.ViewFl.Control.MeasureToolControl
 * Flash二维视图下测量角度控件，继承自Geo.ViewFl.Control控件基类。
 *
 * Inherits from:
 *  - <Geo.ViewFl.Control>
 */
Geo.ViewFl.Control.MeasureToolControl = Geo.Class(Geo.ViewFl.Control, {

    /**
     * Property: _flashObjId
     * flash内部对象标识，私有属性。
     */
    _flashObjId: null,
    
	/** 
     * APIProperty: position
     * {<Geo.Pixel>} 地图左上角位置的偏移像素距离。
     */
    position: null,
	
	/** 
     * APIProperty: size 
     * {<Geo.Size>} 测量角度控件的尺寸。
     */
    size: null,  
	
    /**
     * Constructor: Geo.ViewFl.Control.MeasureToolControl
     * 构造一个新的<Geo.ViewFl.Control.MeasureToolControl>对象实例。
     * 
     * Parameters:
     * options - {Object} 选项参数
     */
    initialize: function(){
		Geo.ViewFl.Control.prototype.initialize.apply(this, arguments);
		this.size = (this.size != null) ? this.size 
                                  : new Geo.Size(
                                                   Geo.ViewFl.Control.MeasureToolControl.WIDTH,
                                                   Geo.ViewFl.Control.MeasureToolControl.HEIGHT);
        this.position = (this.position != null) ? this.position : new Geo.Pixel(0, 0);
    },
    
    /**
	 * Method: destroy
	 * 控件销毁，私有。
	 */
    destroy: function(){
		Geo.ViewFl.Control.prototype.destroy.apply(this, arguments);
    },
    
    /**
     * Method: setMap
     * 关联地图，私有。
     * Parameters:
     * map - {<Geo.ViewFl.Map>} Flash二维地图对象。
     */
    setMap: function(map){
		Geo.ViewFl.Control.prototype.setMap.apply(this, arguments);
    },
    
    /**
     * Method: draw
     * 控件绘制，私有。
     * Parameters:
     * px - {<Geo.Pixel>} 地图左上角位置的偏移像素距离。
     */
    draw: function(px){
		if(!px){
			px = this.position;
		}
        var param = '{"x":"' + px.x + '","y":"' + px.y + '","width":"' + this.size.w + '","height":"' + this.size.h + '"}';
		Geo.ViewFl.Control.prototype.draw.apply(this, arguments);
		this._flashObjId = this.map.swfObj.addMeasureToolControl(param);
    },
    
	/**
     * Property: CLASS_NAME
     * {String} 类标识符。- "Geo.ViewFl.Control.MeasureToolControl"
     */	
    CLASS_NAME: "Geo.ViewFl.Control.MeasureToolControl"
});

/**
 * 宽度
 */
Geo.ViewFl.Control.MeasureToolControl.WIDTH = 240;

/**
 * 高度
 */
Geo.ViewFl.Control.MeasureToolControl.HEIGHT = 180;/**
 * Class: Geo.ViewFl.Popup
 * 浮云基类。本类只能在flex视图模式下使用，用户可以选择Geo.ViewFl.Popup或Geo.ViewFl.PopupFl其中之一来创建浮云，
 * 它们的区别是Geo.ViewFl.Popup生成的浮云可以嵌入html代码和js代码，而Geo.ViewFl.PopupFl生成的浮云不能嵌入js代码。
 * 
 * Example:
 * (code)
 * popup = new Geo.ViewFl.Popup("chicken", 
 *                    new OpenLayers.LonLat(5,40),
 *                    new OpenLayers.Size(200,200),
 *                    "example popup",
 *                    true);
 *       
 * map.addPopup(popup);
 * (end)
 */
Geo.ViewFl.Popup = OpenLayers.Class({

    /** 
     * Property: events  
     * {<Geo.View2D.Events>} custom event manager 
     */
    events: null,
	
    /** Property: id
     * {String} the unique identifier assigned to this popup.
     */
    id: "",

    /** 
     * Property: lonlat 
     * {<Geo.LonLat>} the position of this popup on the map
     */
    lonlat: null,

    /** 
     * Property: div 
     * {DOMElement} the div that contains this popup.
     */
    div: null,

    /** 
     * Property: contentSize 
     * {<Geo.Size>} the width and height of the content.
     */
    contentSize: null,    

    /** 
     * Property: size 
     * {<Geo.Size>} the width and height of the popup.
     */
    size: null,    

    /** 
     * Property: contentHTML 
     * {String} An HTML string for this popup to display.
     */
    contentHTML: null,
    
    /** 
     * Property: backgroundColor 
     * {String} the background color used by the popup.
     */
    backgroundColor: "",
    
    /** 
     * Property: opacity 
     * {float} the opacity of this popup (between 0.0 and 1.0)
     */
    opacity: "",

    /** 
     * Property: border 
     * {String} the border size of the popup.  (eg 2px)
     */
    border: "",
    
    /** 
     * Property: contentDiv 
     * {DOMElement} a reference to the element that holds the content of
     *              the div.
     */
    contentDiv: null,
    
    /** 
     * Property: groupDiv 
     * {DOMElement} First and only child of 'div'. The group Div contains the
     *     'contentDiv' and the 'closeDiv'.
     */
    groupDiv: null,

    /** 
     * Property: closeDiv
     * {DOMElement} the optional closer image
     */
    closeDiv: null,

    /** 
     * APIProperty: autoSize。
     * {Boolean} 根据内容自动调整浮云的大小，默认为false。
     */
    autoSize: false,

    /**
     * APIProperty: minSize。
     * {<Geo.Size>} 允许窗口显示的最小尺寸。
     */
    minSize: null,

    /**
     * APIProperty: maxSize。
     * {<Geo.Size>} 允许窗口显示的最大尺寸。
     */
    maxSize: null,

    /** 
     * Property: displayClass
     * {String} The CSS class of the popup.
     */
    displayClass: "olPopup",

    /** 
     * Property: contentDisplayClass
     * {String} The CSS class of the popup content div.
     */
    contentDisplayClass: "olPopupContent",

    /** 
     * Property: padding 
     * {int or <Geo.Bounds>} An extra opportunity to specify internal 
     *     padding of the content div inside the popup. This was originally
     *     confused with the css padding as specified in style.css's 
     *     'olPopupContent' class. We would like to get rid of this altogether,
     *     except that it does come in handy for the framed and anchoredbubble
     *     popups, who need to maintain yet another barrier between their 
     *     content and the outer border of the popup itself. 
     * 
     *     Note that in order to not break API, we must continue to support 
     *     this property being set as an integer. Really, though, we'd like to 
     *     have this specified as a Bounds object so that user can specify
     *     distinct left, top, right, bottom paddings. With the 3.0 release
     *     we can make this only a bounds.
     */
    padding: 0,

    /** 
     * Property: disableFirefoxOverflowHack
     * {Boolean} The hack for overflow in Firefox causes all elements 
     *     to be re-drawn, which causes Flash elements to be 
     *     re-initialized, which is troublesome.
     *     With this property the hack can be disabled.
     */
    disableFirefoxOverflowHack: false,

    /**
     * Method: fixPadding
     * To be removed in 3.0, this function merely helps us to deal with the 
     *     case where the user may have set an integer value for padding, 
     *     instead of an <OpenLayers.Bounds> object.
     */
    fixPadding: function() {
        if (typeof this.padding == "number") {
            this.padding = new OpenLayers.Bounds(
                this.padding, this.padding, this.padding, this.padding
            );
        }
    },

    /**
     * APIProperty: panMapIfOutOfView
     * {Boolean} 当绘制和地图的上下左右移动时，整个弹出框在当前视口是可见的。默认为false。
     */
    panMapIfOutOfView: false,
    
    /**
     * APIProperty: keepInMap 
     * {Boolean} 将弹出框保存在地图对象里，默认为false。
     */
    keepInMap: false,

    /**
     * APIProperty: closeOnMove
     * {Boolean} 当地图平移时，关闭弹出框。默认为false。
     */
    closeOnMove: false,
    
    /** 
     * Property: map 
     * {<Geo.ViewFl.Map>} this gets set in Map.js when the popup is added to the map
     */
    map: null,

    /** 
    * Constructor: Geo.ViewFl.Popup
    * Geo.ViewFl.Popup构造函数。
    * 
    * Parameters: 
    * id - {String} 编号id。
    * lonlat - {<Geo.LonLat>} 地理坐标。
    * contentSize - {<Geo.Size>} 浮云框大小。
    * contentHTML - {String} 浮云框显示的html内容。
    * closeBox - {Boolean} 是否有关闭按钮。
    * closeBoxCallback - {Function} 浮云关闭回调函数。注意在关闭浮云的时候，请调用map.removePopup(popup)移除浮云，否则添加浮云可能出现浮云无法
    * 移动的情况
    * 
    */
    initialize:function(id, lonlat, contentSize, contentHTML, closeBox, closeBoxCallback) {
        if (id == null) {
            id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
        }

        this.id = id;
        this.lonlat = lonlat;

        this.contentSize = (contentSize != null) ? contentSize 
                                  : new OpenLayers.Size(
                                                   OpenLayers.Popup.WIDTH,
                                                   OpenLayers.Popup.HEIGHT);
        if (contentHTML != null) { 
             this.contentHTML = contentHTML;
        }
        this.backgroundColor = OpenLayers.Popup.COLOR;
        this.opacity = OpenLayers.Popup.OPACITY;
        this.border = OpenLayers.Popup.BORDER;

        this.div = OpenLayers.Util.createDiv(this.id, null, null, 
                                             null, null, null, "hidden");
        this.div.className = this.displayClass;
        
        var groupDivId = this.id + "_GroupDiv";
        this.groupDiv = OpenLayers.Util.createDiv(groupDivId, null, null, 
                                                    null, "relative", null,
                                                    "hidden");

        var id = this.div.id + "_contentDiv";
        this.contentDiv = OpenLayers.Util.createDiv(id, null, this.contentSize.clone(), 
                                                    null, "relative");
        this.contentDiv.className = this.contentDisplayClass;
        this.groupDiv.appendChild(this.contentDiv);
        this.div.appendChild(this.groupDiv);

        if (closeBox) {
            this.addCloseBox(closeBoxCallback);
        } 

        this.registerEvents();
    },

    /** 
     * Method: destroy
     * nullify references to prevent circular references and memory leaks
     */
    destroy: function() {

        this.id = null;
        this.lonlat = null;
        this.size = null;
        this.contentHTML = null;
        
        this.backgroundColor = null;
        this.opacity = null;
        this.border = null;
        
        if (this.closeOnMove && this.map) {
            this.map.events.unregister("movestart", this, this.hide);
        }

        this.events.destroy();
        this.events = null;
        
        if (this.closeDiv) {
            OpenLayers.Event.stopObservingElement(this.closeDiv); 
            this.groupDiv.removeChild(this.closeDiv);
        }
        this.closeDiv = null;
        
        this.div.removeChild(this.groupDiv);
        this.groupDiv = null;

        if (this.map != null) {
            this.map.removePopup(this);
        }
        this.map = null;
        this.div = null;
        
        this.autoSize = null;
        this.minSize = null;
        this.maxSize = null;
        this.padding = null;
        this.panMapIfOutOfView = null;
    },

    /** 
    * Method: draw
    * Constructs the elements that make up the popup.
    *
    * Parameters:
    * px - {<Geo.Pixel>} the position the popup in pixels.
    * 
    * Returns:
    * {DOMElement} Reference to a div that contains the drawn popup
    */
    draw: function(px) {
        if (px == null) {
            if ((this.lonlat != null) && (this.map != null)) {
               px = this.map.getViewPortPxFromLonLat(this.lonlat);
            }
        }

        // this assumes that this.map already exists, which is okay because 
        // this.draw is only called once the popup has been added to the map.
        if (this.closeOnMove) {
            this.map.events.register("movestart", this, this.hide);
        }
		
        //listen to movestart, moveend to disable overflow (FF bug)
        if (!this.disableFirefoxOverflowHack && OpenLayers.Util.getBrowserName() == 'firefox') {
            this.map.events.register("movestart", this, function() {
                var style = document.defaultView.getComputedStyle(
                    this.contentDiv, null
                );
                var currentOverflow = style.getPropertyValue("overflow");
                if (currentOverflow != "hidden") {
                    this.contentDiv._oldOverflow = currentOverflow;
                    this.contentDiv.style.overflow = "hidden";
                }
            });
            this.map.events.register("moveend", this, function() {
                var oldOverflow = this.contentDiv._oldOverflow;
                if (oldOverflow) {
                    this.contentDiv.style.overflow = oldOverflow;
                    this.contentDiv._oldOverflow = null;
                }
            });
        }

        this.moveTo(px);
        if (!this.autoSize && !this.size) {
            this.setSize(this.contentSize);
        }
        this.setBackgroundColor();
        this.setOpacity();
        this.setBorder();
        this.setContentHTML();
        
        if (this.panMapIfOutOfView) {
            this.panIntoView();
        }    

        return this.div;
    },

    /** 
     * Method: updatePosition
     * if the popup has a lonlat and its map members set, 
     * then have it move itself to its proper position
     */
    updatePosition: function() {
        if ((this.lonlat) && (this.map)) {
			var px = this.map.getViewPortPxFromLonLat(this.lonlat);
            if (px) {
                this.moveTo(px);           
            }    
        }
    },
	
    /**
     * Method: moveTo
     * 
     * Parameters:
     * px - {<Geo.Pixel>} the top and left position of the popup div. 
     */
    moveTo: function(px) {
        if ((px != null) && (this.div != null)) {
            this.div.style.left = px.x + "px";
            this.div.style.top = px.y + "px";
        }
    },

    /**
     * Method: visible
     *
     * Returns:      
     * {Boolean} Boolean indicating whether or not the popup is visible
     */
    visible: function() {
        return OpenLayers.Element.visible(this.div);
    },

    /**
     * Method: toggle
     * Toggles visibility of the popup.
     */
    toggle: function() {
        if (this.visible()) {
            this.hide();
        } else {
            this.show();
        }
    },

    /**
     * Method: show
     * Makes the popup visible.
     */
    show: function() {
        OpenLayers.Element.show(this.div);

        if (this.panMapIfOutOfView) {
            this.panIntoView();
        }    
    },

    /**
     * Method: hide
     * Makes the popup invisible.
     */
    hide: function() {
        OpenLayers.Element.hide(this.div);
    },

    /**
     * Method: setSize
     * Used to adjust the size of the popup. 
     *
     * Parameters:
     * contentSize - {<Geo.Size>} the new size for the popup's 
     *     contents div (in pixels).
     */
    setSize:function(contentSize) { 
        this.size = contentSize.clone(); 
        
        // if our contentDiv has a css 'padding' set on it by a stylesheet, we 
        //  must add that to the desired "size". 
        var contentDivPadding = this.getContentDivPadding();
        var wPadding = contentDivPadding.left + contentDivPadding.right;
        var hPadding = contentDivPadding.top + contentDivPadding.bottom;

        // take into account the popup's 'padding' property
        this.fixPadding();
        wPadding += this.padding.left + this.padding.right;
        hPadding += this.padding.top + this.padding.bottom;

        // make extra space for the close div
        if (this.closeDiv) {
            var closeDivWidth = parseInt(this.closeDiv.style.width);
            wPadding += closeDivWidth + contentDivPadding.right;
        }

        //increase size of the main popup div to take into account the 
        // users's desired padding and close div.        
        this.size.w += wPadding;
        this.size.h += hPadding;

        //now if our browser is IE, we need to actually make the contents 
        // div itself bigger to take its own padding into effect. this makes 
        // me want to shoot someone, but so it goes.
        if (OpenLayers.Util.getBrowserName() == "msie") {
            this.contentSize.w += 
                contentDivPadding.left + contentDivPadding.right;
            this.contentSize.h += 
                contentDivPadding.bottom + contentDivPadding.top;
        }

        if (this.div != null) {
            this.div.style.width = this.size.w + "px";
            this.div.style.height = this.size.h + "px";
        }
        if (this.contentDiv != null){
            this.contentDiv.style.width = contentSize.w + "px";
            this.contentDiv.style.height = contentSize.h + "px";
        }
    },  

    /**
     * APIMethod: updateSize
     * 更新尺寸大小。
     */
    updateSize: function() {
        
        // determine actual render dimensions of the contents by putting its
        // contents into a fake contentDiv (for the CSS) and then measuring it
        var preparedHTML = "<div class='" + this.contentDisplayClass+ "'>" + 
            this.contentDiv.innerHTML + 
            "</div>";
 
        var containerElement = (this.map) ? this.map.layerContainerDiv
        								  : document.body;
        var realSize = OpenLayers.Util.getRenderedDimensions(
            preparedHTML, null,	{
                displayClass: this.displayClass,
                containerElement: containerElement
            }
        );

        // is the "real" size of the div is safe to display in our map?
        var safeSize = this.getSafeContentSize(realSize);

        var newSize = null;
        if (safeSize.equals(realSize)) {
            //real size of content is small enough to fit on the map, 
            // so we use real size.
            newSize = realSize;

        } else {

            //make a new OL.Size object with the clipped dimensions 
            // set or null if not clipped.
            var fixedSize = new OpenLayers.Size();
            fixedSize.w = (safeSize.w < realSize.w) ? safeSize.w : null;
            fixedSize.h = (safeSize.h < realSize.h) ? safeSize.h : null;
        
            if (fixedSize.w && fixedSize.h) {
                //content is too big in both directions, so we will use 
                // max popup size (safeSize), knowing well that it will 
                // overflow both ways.                
                newSize = safeSize;
            } else {
                //content is clipped in only one direction, so we need to 
                // run getRenderedDimensions() again with a fixed dimension
                var clippedSize = OpenLayers.Util.getRenderedDimensions(
                    preparedHTML, fixedSize, {
                        displayClass: this.contentDisplayClass,
                        containerElement: containerElement
                    }
                );
                
                //if the clipped size is still the same as the safeSize, 
                // that means that our content must be fixed in the 
                // offending direction. If overflow is 'auto', this means 
                // we are going to have a scrollbar for sure, so we must 
                // adjust for that.
                //
                var currentOverflow = OpenLayers.Element.getStyle(
                    this.contentDiv, "overflow"
                );
                if ( (currentOverflow != "hidden") && 
                     (clippedSize.equals(safeSize)) ) {
                    var scrollBar = OpenLayers.Util.getScrollbarWidth();
                    if (fixedSize.w) {
                        clippedSize.h += scrollBar;
                    } else {
                        clippedSize.w += scrollBar;
                    }
                }
                
                newSize = this.getSafeContentSize(clippedSize);
            }
        }                        
        this.setSize(newSize);     
    },    

    /**
     * Method: setBackgroundColor
     * Sets the background color of the popup.
     *
     * Parameters:
     * color - {String} the background color.  eg "#FFBBBB"
     */
    setBackgroundColor:function(color) { 
        if (color != undefined) {
            this.backgroundColor = color; 
        }
        
        if (this.div != null) {
            this.div.style.backgroundColor = this.backgroundColor;
        }
    },  
    
    /**
     * Method: setOpacity
     * Sets the opacity of the popup.
     * 
     * Parameters:
     * opacity - {float} A value between 0.0 (transparent) and 1.0 (solid).   
     */
    setOpacity:function(opacity) { 
        if (opacity != undefined) {
            this.opacity = opacity; 
        }
        
        if (this.div != null) {
            // for Mozilla and Safari
            this.div.style.opacity = this.opacity;

            // for IE
            this.div.style.filter = 'alpha(opacity=' + this.opacity*100 + ')';
        }
    },  
    
    /**
     * Method: setBorder
     * Sets the border style of the popup.
     *
     * Parameters:
     * border - {String} The border style value. eg 2px 
     */
    setBorder:function(border) { 
        if (border != undefined) {
            this.border = border;
        }
        
        if (this.div != null) {
            this.div.style.border = this.border;
        }
    },      
    
    /**
     * Method: setContentHTML
     * Allows the user to set the HTML content of the popup.
     *
     * Parameters:
     * contentHTML - {String} HTML for the div.
     */
    setContentHTML:function(contentHTML) {

        if (contentHTML != null) {
            this.contentHTML = contentHTML;
        }
       
        if ((this.contentDiv != null) && 
            (this.contentHTML != null) &&
            (this.contentHTML != this.contentDiv.innerHTML)) {
       
            this.contentDiv.innerHTML = this.contentHTML;
       
            if (this.autoSize) {
                
                //if popup has images, listen for when they finish
                // loading and resize accordingly
                this.registerImageListeners();

                //auto size the popup to its current contents
                this.updateSize();
            }
        }    

    },
    
    /**
     * Method: registerImageListeners
     * Called when an image contained by the popup loaded. this function
     *     updates the popup size, then unregisters the image load listener.
     */   
    registerImageListeners: function() { 

        // As the images load, this function will call updateSize() to 
        // resize the popup to fit the content div (which presumably is now
        // bigger than when the image was not loaded).
        // 
        // If the 'panMapIfOutOfView' property is set, we will pan the newly
        // resized popup back into view.
        // 
        // Note that this function, when called, will have 'popup' and 
        // 'img' properties in the context.
        //
        var onImgLoad = function() {
            
            this.popup.updateSize();
     
            if ( this.popup.visible() && this.popup.panMapIfOutOfView ) {
                this.popup.panIntoView();
            }

            OpenLayers.Event.stopObserving(
                this.img, "load", this.img._onImageLoad
            );
    
        };

        //cycle through the images and if their size is 0x0, that means that 
        // they haven't been loaded yet, so we attach the listener, which 
        // will fire when the images finish loading and will resize the 
        // popup accordingly to its new size.
        var images = this.contentDiv.getElementsByTagName("img");
        for (var i = 0, len = images.length; i < len; i++) {
            var img = images[i];
            if (img.width == 0 || img.height == 0) {

                var context = {
                    'popup': this,
                    'img': img
                };

                //expando this function to the image itself before registering
                // it. This way we can easily and properly unregister it.
                img._onImgLoad = OpenLayers.Function.bind(onImgLoad, context);

                OpenLayers.Event.observe(img, 'load', img._onImgLoad);
            }    
        } 
    },

    /**
     * APIMethod: getSafeContentSize
     * 弹出浮云框的尺寸既不小于最小尺寸，也不大于最大尺寸，而是计算相对于视口的合适尺寸大小。
     * 
     * Parameters:
     * size - {<Geo.Size>} 所需区域的大小。
     * 
     * Returns:
     * {<Geo.Size>} 返回合适的尺寸。
     */
    getSafeContentSize: function(size) {

        var safeContentSize = size.clone();

        // if our contentDiv has a css 'padding' set on it by a stylesheet, we 
        //  must add that to the desired "size". 
        var contentDivPadding = this.getContentDivPadding();
        var wPadding = contentDivPadding.left + contentDivPadding.right;
        var hPadding = contentDivPadding.top + contentDivPadding.bottom;

        // take into account the popup's 'padding' property
        this.fixPadding();
        wPadding += this.padding.left + this.padding.right;
        hPadding += this.padding.top + this.padding.bottom;

        if (this.closeDiv) {
            var closeDivWidth = parseInt(this.closeDiv.style.width);
            wPadding += closeDivWidth + contentDivPadding.right;
        }

        // prevent the popup from being smaller than a specified minimal size
        if (this.minSize) {
            safeContentSize.w = Math.max(safeContentSize.w, 
                (this.minSize.w - wPadding));
            safeContentSize.h = Math.max(safeContentSize.h, 
                (this.minSize.h - hPadding));
        }

        // prevent the popup from being bigger than a specified maximum size
        if (this.maxSize) {
            safeContentSize.w = Math.min(safeContentSize.w, 
                (this.maxSize.w - wPadding));
            safeContentSize.h = Math.min(safeContentSize.h, 
                (this.maxSize.h - hPadding));
        }
        
        //make sure the desired size to set doesn't result in a popup that 
        // is bigger than the map's viewport.
        //
        if (this.map && this.map.size) {
            
            var extraX = 0, extraY = 0;
            if (this.keepInMap && !this.panMapIfOutOfView) {
                var px = this.map.getPixelFromLonLat(this.lonlat);
                switch (this.relativePosition) {
                    case "tr":
                        extraX = px.x;
                        extraY = this.map.size.h - px.y;
                        break;
                    case "tl":
                        extraX = this.map.size.w - px.x;
                        extraY = this.map.size.h - px.y;
                        break;
                    case "bl":
                        extraX = this.map.size.w - px.x;
                        extraY = px.y;
                        break;
                    case "br":
                        extraX = px.x;
                        extraY = px.y;
                        break;
                    default:    
                        extraX = px.x;
                        extraY = this.map.size.h - px.y;
                        break;
                }
            }    
          
            var maxY = this.map.size.h - 
                this.map.paddingForPopups.top - 
                this.map.paddingForPopups.bottom - 
                hPadding - extraY;
            
            var maxX = this.map.size.w - 
                this.map.paddingForPopups.left - 
                this.map.paddingForPopups.right - 
                wPadding - extraX;
            
            safeContentSize.w = Math.min(safeContentSize.w, maxX);
            safeContentSize.h = Math.min(safeContentSize.h, maxY);
        }
        
        return safeContentSize;
    },
    
    /**
     * Method: getContentDivPadding
     * Glorious, oh glorious hack in order to determine the css 'padding' of 
     *     the contentDiv. IE/Opera return null here unless we actually add the 
     *     popup's main 'div' element (which contains contentDiv) to the DOM. 
     *     So we make it invisible and then add it to the document temporarily. 
     *
     *     Once we've taken the padding readings we need, we then remove it 
     *     from the DOM (it will actually get added to the DOM in 
     *     Map.js's addPopup)
     *
     * Returns:
     * {<Geo.Bounds>}
     */
    getContentDivPadding: function() {

        //use cached value if we have it
        var contentDivPadding = this._contentDivPadding;
        if (!contentDivPadding) {

        	if (this.div.parentNode == null) {
	        	//make the div invisible and add it to the page        
	            this.div.style.display = "none";
	            document.body.appendChild(this.div);
	    	}
	            
            //read the padding settings from css, put them in an OL.Bounds        
            contentDivPadding = new OpenLayers.Bounds(
                OpenLayers.Element.getStyle(this.contentDiv, "padding-left"),
                OpenLayers.Element.getStyle(this.contentDiv, "padding-bottom"),
                OpenLayers.Element.getStyle(this.contentDiv, "padding-right"),
                OpenLayers.Element.getStyle(this.contentDiv, "padding-top")
            );
    
            //cache the value
            this._contentDivPadding = contentDivPadding;

            if (this.div.parentNode == document.body) {
	            //remove the div from the page and make it visible again
	            document.body.removeChild(this.div);
	            this.div.style.display = "";
            }
        }
        return contentDivPadding;
    },

    /**
     * Method: addCloseBox
     * 
     * Parameters:
     * callback - {Function} The callback to be called when the close button
     *     is clicked.
     */
    addCloseBox: function(callback) {

        this.closeDiv = OpenLayers.Util.createDiv(
            this.id + "_close", null, new OpenLayers.Size(17, 17)
        );
        this.closeDiv.className = "olPopupCloseBox"; 
        
        // use the content div's css padding to determine if we should
        //  padd the close div
        var contentDivPadding = this.getContentDivPadding();
         
        this.closeDiv.style.right = contentDivPadding.right + "px";
        this.closeDiv.style.top = contentDivPadding.top + "px";
        this.groupDiv.appendChild(this.closeDiv);

        var closePopup = callback || function(e) {
            this.hide();
            OpenLayers.Event.stop(e);
        };
        OpenLayers.Event.observe(this.closeDiv, "click", 
                OpenLayers.Function.bindAsEventListener(closePopup, this));
    },

    /**
     * Method: panIntoView
     * Pans the map such that the popup is totaly viewable (if necessary)
     */
    panIntoView: function() {
        
        var mapSize = this.map.getSize();
    
        //start with the top left corner of the popup, in px, 
        // relative to the viewport
        var origTL = this.map.getViewPortPxFromLayerPx( new OpenLayers.Pixel(
            parseInt(this.div.style.left),
            parseInt(this.div.style.top)
        ));
        var newTL = origTL.clone();
    
        //new left (compare to margins, using this.size to calculate right)
        if (origTL.x < this.map.paddingForPopups.left) {
            newTL.x = this.map.paddingForPopups.left;
        } else 
        if ( (origTL.x + this.size.w) > (mapSize.w - this.map.paddingForPopups.right)) {
            newTL.x = mapSize.w - this.map.paddingForPopups.right - this.size.w;
        }
        
        //new top (compare to margins, using this.size to calculate bottom)
        if (origTL.y < this.map.paddingForPopups.top) {
            newTL.y = this.map.paddingForPopups.top;
        } else 
        if ( (origTL.y + this.size.h) > (mapSize.h - this.map.paddingForPopups.bottom)) {
            newTL.y = mapSize.h - this.map.paddingForPopups.bottom - this.size.h;
        }
        
        var dx = origTL.x - newTL.x;
        var dy = origTL.y - newTL.y;
        
        this.map.pan(dx, dy);
    },

    /** 
     * Method: registerEvents
     * Registers events on the popup.
     *
     * Do this in a separate function so that subclasses can 
     *   choose to override it if they wish to deal differently
     *   with mouse events
     * 
     *   Note in the following handler functions that some special
     *    care is needed to deal correctly with mousing and popups. 
     *   
     *   Because the user might select the zoom-rectangle option and
     *    then drag it over a popup, we need a safe way to allow the
     *    mousemove and mouseup events to pass through the popup when
     *    they are initiated from outside.
     * 
     *   Otherwise, we want to essentially kill the event propagation
     *    for all other events, though we have to do so carefully, 
     *    without disabling basic html functionality, like clicking on 
     *    hyperlinks or drag-selecting text.
     */
     registerEvents:function() {
        this.events = new OpenLayers.Events(this, this.div, null, true);
		
        this.events.on({
            "mousedown": this.onmousedown,
            "mousemove": this.onmousemove,
            "mouseup": this.onmouseup,
            "click": this.onclick,
            "mouseout": this.onmouseout,
            "dblclick": this.ondblclick,
            scope: this
        });
     },

    /** 
     * Method: onmousedown 
     * When mouse goes down within the popup, make a note of
     *   it locally, and then do not propagate the mousedown 
     *   (but do so safely so that user can select text inside)
     * 
     * Parameters:
     * evt - {Event} 
     */
    onmousedown: function (evt) {
        this.mousedown = true;
        OpenLayers.Event.stop(evt, true);
    },

    /** 
     * Method: onmousemove
     * If the drag was started within the popup, then 
     *   do not propagate the mousemove (but do so safely
     *   so that user can select text inside)
     * 
     * Parameters:
     * evt - {Event} 
     */
    onmousemove: function (evt) {
        if (this.mousedown) {
            OpenLayers.Event.stop(evt, true);
        }
    },

    /** 
     * Method: onmouseup
     * When mouse comes up within the popup, after going down 
     *   in it, reset the flag, and then (once again) do not 
     *   propagate the event, but do so safely so that user can 
     *   select text inside
     * 
     * Parameters:
     * evt - {Event} 
     */
    onmouseup: function (evt) {
        if (this.mousedown) {
            this.mousedown = false;
            OpenLayers.Event.stop(evt, true);
        }
    },

    /**
     * Method: onclick
     * Ignore clicks, but allowing default browser handling
     * 
     * Parameters:
     * evt - {Event} 
     */
    onclick: function (evt) {
        OpenLayers.Event.stop(evt, true);
    },

    /** 
     * Method: onmouseout
     * When mouse goes out of the popup set the flag to false so that
     *   if they let go and then drag back in, we won't be confused.
     * 
     * Parameters:
     * evt - {Event} 
     */
    onmouseout: function (evt) {
        this.mousedown = false;
    },
    
    /** 
     * Method: ondblclick
     * Ignore double-clicks, but allowing default browser handling
     * 
     * Parameters:
     * evt - {Event} 
     */
    ondblclick: function (evt) {
        OpenLayers.Event.stop(evt, true);
    },

    CLASS_NAME: "Geo.ViewFl.Popup"
});

Geo.ViewFl.Popup.WIDTH = 200;
Geo.ViewFl.Popup.HEIGHT = 200;
Geo.ViewFl.Popup.COLOR = "white";
Geo.ViewFl.Popup.OPACITY = 1;
Geo.ViewFl.Popup.BORDER = "0px";
/**
 * Class: Geo.ViewFl.PopupFl
 * popup是可以在Flash二维视图上打开和关闭的小型弹出窗口，通常是用于在选中一个矢量要素时，显示该要素的详细信息。
 * popup通过<Geo.ViewFl.Map.addPopup>方法添加到Flash二维视图中。
 */
Geo.ViewFl.PopupFl = Geo.Class({
    
    /** Property: id
     * {String} 唯一标识。
     */
    id: "",
	
	/**
     * Property: _flashObjId
     * flash内部对象标识，私有属性。
     */
    _flashObjId: null,

    /** 
     * APIProperty: lonlat 
     * {<Geo.LonLat>} 弹出框在地图中的坐标。
     */
    lonlat: null,

    /** 
     * APIProperty: size 
     * {<Geo.Size>} 弹出框的尺寸。
     */
    size: null,    

    /** 
     * APIProperty: contentHTML 
     * {String} 弹出框内显示的内容。
     */
    contentHTML: null,
    
    /** 
     * APIProperty: title 
     * {String} 弹出框内显示的内容。
     */
    title: null,
	
    /** 
     * Property: backgroundColor 
     * {String} the background color used by the popup.
     */
    backgroundColor: "",
	
    /** 
     * Property: titleBackgroundColor 
     * {String} the title's BackgroundColor color used by the popup.
     */
    titleBackgroundColor: "",
    
    /** 
     * APIProperty: opacity 
     * {float} 透明度设置。 (在 0.0 到 1.0之间)
     */
    opacity: "",

    /** 
     * Property: border 
     * {String} 弹出框的边框值。例如 "2"
     */
    border: "",
	
    /** 
     * APIProperty: map 
     * {<Geo.ViewFl.Map>} 控件所属的地图对象的引用。
     */
    map: null,
	
    /**
     * Constructor: Geo.ViewFl.PopupFl
     * 构造一个新的<Geo.ViewFl.PopupFl>对象实例。
     *
     * Parameters:
     * id - {Object} 编号
     * lonlat - {Object} 经纬度信息
     * contentSize - {Object} 尺寸大小
     * contentHTML - {Object} HTML代码
     * closeBox - {Boolean} 是否显示关闭按钮
     * closeBoxCallback - {Object} 点击关闭按钮的回调函数
     */
    initialize:function(id, lonlat, contentSize, contentHTML, title, closeBox, closeBoxCallback) {
		if (id == null) {
            id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
        }

        this.id = id;
        this.lonlat = lonlat;

        this.contentSize = (contentSize != null) ? contentSize 
                                  : new Geo.Size(
                                                   Geo.ViewFl.PopupFl.WIDTH,
                                                   Geo.ViewFl.PopupFl.HEIGHT);
        if (contentHTML != null) { 
             this.contentHTML = contentHTML;
        }
        if (title != null) { 
             this.title = title;
        }
		
		this._closeBox = true;
		if (closeBox != null) {
			this._closeBox = closeBox;
		}
		
    },
	
    /**
     * Method: draw
     * 绘制弹出框
     *
     * Parameters:
     * px - {<Geo.Pixel>} 地图左上角位置的偏移像素距离。
     */
    draw: function(px) {
		if(px){
			this.moveTo(px);
			return;
		}
		this._draw();
    },
	
	/**
	 * Method: _draw
	 * 绘制弹出框，私有方法。
	 */ 
	_draw: function(){
		var map = this.map;
		if(map && map.swfObj){
			var swfObj = map.swfObj;
            var lonlatParam = this.lonlat.lon + "," + this.lonlat.lat;
			var sizeParam = this.contentSize.w + "," + this.contentSize.h;
            this._flashObjId = swfObj.addPopup(lonlatParam, sizeParam, this.contentHTML, this.title, this._closeBox);
		}
	},
	
	/**
     * Method: moveTo
     * 移动弹出框。
     * 
     * Parameters:
     * px - {<Geo.Pixel>} 地图左上角位置的偏移像素距离。
     */
    moveTo: function(px){
        if (px != null) {
            var map = this.map;
            if (map && map.swfObj) {
                var swfObj = map.swfObj;
                var pxParam = px.x + "," + px.y;
                swfObj.popMoveTo(this._flashObjId, pxParam);
            }
        }
    },
	
	/**
     * Method: setBackgroundColor
     * 设置弹出框内容的背景色。
     *
     * Parameters:
     * color - {String} 背景色。例如： "0xFFFFFF"。
     */
    setBackgroundColor:function(color) { 
        if (color != undefined) {
            this.backgroundColor = color + ""; 
        }
		var map = this.map;
        if (map && map.swfObj) {
            var swfObj = map.swfObj;
            swfObj.setPopupBackgroundColor(this._flashObjId, this.backgroundColor);
        }
    },  
	
	/**
     * Method: setTitleBackgroundColor
     * 设置弹出框标题的背景色。
     *
     * Parameters:
     * color - {String} 背景色。例如： "0xFFFFFF"。
     */
    setTitleBackgroundColor:function(color) { 
        if (color != undefined) {
            this.titleBackgroundColor = color + ""; 
        }
		var map = this.map;
        if (map && map.swfObj) {
            var swfObj = map.swfObj;
            swfObj.setPopupTitleBackgroundColor(this._flashObjId, this.titleBackgroundColor);
        }
    },  
    
    /**
     * APIMethod: setOpacity
     * 设置弹出框透明度。
     * 
     * Parameters:
     * opacity - {float} 透明度的值在 0.0 和 1.0 之间。
     */
    setOpacity:function(opacity) { 
        if (opacity != undefined) {
            this.opacity = opacity + ""; 
        }
        var map = this.map;
        if (map && map.swfObj) {
            var swfObj = map.swfObj;
            swfObj.setPopupOpacity(this._flashObjId, this.opacity);
        }
    },  
    
    /**
     * Method: setBorder
     * 设置弹出框的边框大小。
     *
     * Parameters:
     * border - {String} 边框值。例如 "2"。
     */
    setBorder:function(border) { 
        if (border != undefined) {
            this.border = border + "";
        }
        var map = this.map;
        if (map && map.swfObj) {
            var swfObj = map.swfObj;
            swfObj.setPopupBorder(this._flashObjId, this.border);
        }
    },      
    
    /**
     * APIMethod: setContentHTML
     * 设置浮云内容。
     *
     * Parameters:
     * contentHTML - {String} 内容。
     */
    setContentHTML:function(contentHTML) {

        if (contentHTML != null) {
            this.contentHTML = contentHTML;
        }
        var map = this.map;
        if (map && map.swfObj) {
            var swfObj = map.swfObj;
            swfObj.setPopupContentHTML(this._flashObjId, this.contentHTML);
        }
    },
	
	/**
     * APIMethod: setSize
     * 设置弹出框的大小。
     *
     * Parameters:
     * contentSize - {<Geo.Size>} 
     */
    setSize:function(contentSize) {
		if (contentSize != null) {
            this.contentSize = contentSize;
        }
		var map = this.map;
        if (map && map.swfObj) {
            var swfObj = map.swfObj;
			var sizeParam = this.contentSize.w + "," + this.contentSize.h;
            swfObj.setPopupSize(this._flashObjId, sizeParam);
        }
	},
	/**
	 * Method: _clear
	 * 清除弹出框，私有方法。
	 */
	_clear: function(){
		var map = this.map;
		if(map && map.swfObj){
			var swfObj = map.swfObj;
            swfObj.removePopup(this._flashObjId);
		}
	},
	
    CLASS_NAME: "Geo.ViewFl.PopupFl"
});
Geo.ViewFl.PopupFl.WIDTH = 280;//570;
Geo.ViewFl.PopupFl.HEIGHT = 76;//152;
Geo.ViewFl.PopupFl.COLOR = "white";
Geo.ViewFl.PopupFl.OPACITY = 1;
Geo.ViewFl.PopupFl.BORDER = "2px";/**
 * @requires OpenLayers/Popup.js
 */

/**
 * Class: Geo.ViewFl.Popup.Anchored
 * 
 * Inherits from:
 *  - <Geo.ViewFl.Popup>
 */
Geo.ViewFl.Popup.Anchored = 
  Geo.Class(Geo.ViewFl.Popup, {

    /** 
     * Parameter: relativePosition
     * {String} Relative position of the popup ("br", "tr", "tl" or "bl").
     */
    relativePosition: null,
    /*

*/
    /**
     * APIProperty: keepInMap 
     * {Boolean}如果属性panMapIfOutOfView是假的，则此属性为true。默认为true。
     */
    keepInMap: true,

    /**
     * Parameter: anchor
     * {Object} 必须包含'size' (<OpenLayers.Size>) 与 'offset' (<OpenLayers.Pixel>)
     * 的键值对对象。
     */
    anchor: null,

    /** 
	 * Constructor: Geo.ViewFl.Popup.Anchored
     * 创建一个弹出的浮云。
     * 
     * Parameters:
     * id - {String}  浮云框的唯一标识，如果没有设置将会自动生成一个。
     * lonlat - {<Geo.LonLat>} 浮云显示的位置。
     * contentSize - {<Geo.Size>} 浮云的尺寸。
     * contentHTML - {String} 浮云框内容。
     * anchor - {Object} 锚。必须包含'size' (<Geo.Size>) 与 'offset' (<Geo.Pixel>)的键值对对象。
     * closeBox - {Boolean} 是否显示关闭窗口。
     * closeBoxCallback - {Function} 点击关闭窗口时的回调方法。
     */
    initialize:function(id, lonlat, contentSize, contentHTML, anchor, closeBox,
                        closeBoxCallback) {
        var newArguments = [
            id, lonlat, contentSize, contentHTML, closeBox, closeBoxCallback
        ];
        Geo.ViewFl.Popup.prototype.initialize.apply(this, newArguments);

        this.anchor = (anchor != null) ? anchor 
                                       : { size: new OpenLayers.Size(0,0),
                                           offset: new OpenLayers.Pixel(0,0)};
    },

    /**
     * APIMethod: destroy
     * 销毁本对象。
     */
    destroy: function() {
        this.anchor = null;
        this.relativePosition = null;
        
        Geo.ViewFl.Popup.prototype.destroy.apply(this, arguments);        
    },

    /**
     * APIMethod: show
     * 显示在更新的相对位置上。
     */
    show: function() {
        this.updatePosition();
        Geo.ViewFl.Popup.prototype.show.apply(this, arguments);
    },

    /**
     * Method: moveTo
     * Since the popup is moving to a new px, it might need also to be moved
     *     relative to where the marker is. We first calculate the new 
     *     relativePosition, and then we calculate the new px where we will 
     *     put the popup, based on the new relative position. 
     * 
     *     If the relativePosition has changed, we must also call 
     *     updateRelativePosition() to make any visual changes to the popup 
     *     which are associated with putting it in a new relativePosition.
     * 
     * Parameters:
     * px - {<Geo.Pixel>}
     */
    moveTo: function(px) {
        var oldRelativePosition = this.relativePosition;
        this.relativePosition = this.calculateRelativePosition(px);
        
        var newPx = this.calculateNewPx(px);
        
        var newArguments = new Array(newPx);        
        Geo.ViewFl.Popup.prototype.moveTo.apply(this, newArguments);
        
        //if this move has caused the popup to change its relative position, 
        // we need to make the appropriate cosmetic changes.
        if (this.relativePosition != oldRelativePosition) {
            this.updateRelativePosition();
        }
    },

    /**
     * APIMethod: setSize
     * 设置尺寸大小。
     * 
     * Parameters:
     * contentSize - {<Geo.Size>} 弹出区域的大小。
     */
    setSize:function(contentSize) { 
        Geo.ViewFl.Popup.prototype.setSize.apply(this, arguments);

        if ((this.lonlat) && (this.map)) {
			var px = this.map.getViewPortPxFromLonLat(this.lonlat);
            this.moveTo(px);
        }
    },  
    
    /** 
     * Method: calculateRelativePosition
     * 
     * Parameters:
     * px - {<Geo.Pixel>}
     * 
     * Returns:
     * {String} The relative position ("br" "tr" "tl" "bl") at which the popup
     *     should be placed.
     */
    calculateRelativePosition:function(px) {
        var lonlatStr = this.map.swfObj.getLonLatFromMapPx(px.x, px.y);        
        var lon = Geo.ViewFl._jsonParser.read(lonlatStr).lon;
		var lat = Geo.ViewFl._jsonParser.read(lonlatStr).lat;
		var lonlat = new Geo.LonLat(lon, lat);
        var extent = this.map.getExtent();
        var quadrant = extent.determineQuadrant(lonlat);
        
        return OpenLayers.Bounds.oppositeQuadrant(quadrant);
    }, 

    /**
     * Method: updateRelativePosition
     * The popup has been moved to a new relative location, so we may want to 
     *     make some cosmetic adjustments to it. 
     * 
     *     Note that in the classic Anchored popup, there is nothing to do 
     *     here, since the popup looks exactly the same in all four positions.
     *     Subclasses such as the AnchoredBubble and Framed, however, will 
     *     want to do something special here.
     */
    updateRelativePosition: function() {
        //to be overridden by subclasses
    },

    /** 
     * Method: calculateNewPx
     * 
     * Parameters:
     * px - {<Geo.Pixel>}
     * 
     * Returns:
     * {<Geo.Pixel>} The the new px position of the popup on the screen
     *     relative to the passed-in px.
     */
    calculateNewPx:function(px) {
        var newPx = px.offset(this.anchor.offset);
        
        //use contentSize if size is not already set
        var size = this.size || this.contentSize;

        var top = (this.relativePosition.charAt(0) == 't');
        newPx.y += (top) ? -(size.h + this.anchor.size.h) : this.anchor.size.h;
        
        var left = (this.relativePosition.charAt(1) == 'l');
        newPx.x += (left) ? -(size.w + this.anchor.size.w) : this.anchor.size.w;

        return newPx;   
    },

    CLASS_NAME: "Geo.ViewFl.Popup.Anchored"
});
/**
 * Class: Geo.ViewFl.Popup.AnchoredBubble
 * 
 * Inherits from: 
 *  - <Geo.ViewFl.Popup.Anchored>
 */
Geo.ViewFl.Popup.AnchoredBubble = 
  Geo.Class(Geo.ViewFl.Popup.Anchored, {

    /**
     * Property: rounded
     * {Boolean} Has the popup been rounded yet?
     */
    rounded: false, 
    
    /** 
     * Constructor: Geo.ViewFl.Popup.AnchoredBubble
     * 创建一个冒泡形状的浮云框。
     * 
     * Parameters:
     * id - {String}  浮云框的唯一标识，如果没有设置将会自动生成一个。
     * lonlat - {<Geo.LonLat>} 浮云显示的位置。
     * contentSize - {<Geo.Size>} 浮云的尺寸。
     * contentHTML - {String} 浮云框内容。
     * anchor - {Object} 锚。必须包含'size' (<Geo.Size>) 与 'offset' (<Geo.Pixel>)的键值对对象。
     * closeBox - {Boolean} 是否显示关闭窗口。
     * closeBoxCallback - {Function} 点击关闭窗口时的回调方法。
     */
    initialize:function(id, lonlat, contentSize, contentHTML, anchor, closeBox,
                        closeBoxCallback) {
        
        this.padding = new OpenLayers.Bounds(
            0, Geo.ViewFl.Popup.AnchoredBubble.CORNER_SIZE,
            0, Geo.ViewFl.Popup.AnchoredBubble.CORNER_SIZE
        );
        Geo.ViewFl.Popup.Anchored.prototype.initialize.apply(this, arguments);
    },

    /** 
     * Method: draw
     * 
     * Parameters:
     * px - {<Geo.Pixel>}
     * 
     * Returns:
     * {DOMElement} Reference to a div that contains the drawn popup.
     */
    draw: function(px) {
        
        Geo.ViewFl.Popup.Anchored.prototype.draw.apply(this, arguments);

        this.setContentHTML();
        
        //set the popup color and opacity           
        this.setBackgroundColor(); 
        this.setOpacity();

        return this.div;
    },

    /**
     * Method: updateRelativePosition
     * The popup has been moved to a new relative location, in which case
     *     we will want to re-do the rico corners.
     */
    updateRelativePosition: function() {
        this.setRicoCorners();
    },

    /**
     * APIMethod: setSize
     * 设置尺寸大小。
     * 
     * Parameters:
     * contentSize - {<Geo.Size>} 弹出区域的大小。
     */
    setSize:function(contentSize) { 
        Geo.ViewFl.Popup.Anchored.prototype.setSize.apply(this, arguments);

        this.setRicoCorners();
    },  

    /**
     * APIMethod: setBackgroundColor
     * 设置背景颜色。
     * 
     * Parameters:
     * color - {String}
     */
    setBackgroundColor:function(color) { 
        if (color != undefined) {
            this.backgroundColor = color; 
        }
        
        if (this.div != null) {
            if (this.contentDiv != null) {
                this.div.style.background = "transparent";
                OpenLayers.Rico.Corner.changeColor(this.groupDiv, 
                                                   this.backgroundColor);
            }
        }
    },  
    
    /**
     * APIMethod: setOpacity
     * 设置透明度。
     * 
     * Parameters: 
     * opacity - {float}
     */
    setOpacity:function(opacity) { 
        Geo.ViewFl.Popup.Anchored.prototype.setOpacity.call(this, opacity);
        
        if (this.div != null) {
            if (this.groupDiv != null) {
                OpenLayers.Rico.Corner.changeOpacity(this.groupDiv, 
                                                     this.opacity);
            }
        }
    },  
 
    /** 
     * Method: setBorder
     * Always sets border to 0. Bubble Popups can not have a border.
     * 
     * Parameters:
     * border - {Integer}
     */
    setBorder:function(border) { 
        this.border = 0;
    },      
 
    /** 
     * Method: setRicoCorners
     * Update RICO corners according to the popup's current relative postion.
     */
    setRicoCorners:function() {
    
        var corners = this.getCornersToRound(this.relativePosition);
        var options = {corners: corners,
                         color: this.backgroundColor,
                       bgColor: "transparent",
                         blend: false};

        if (!this.rounded) {
            OpenLayers.Rico.Corner.round(this.div, options);
            this.rounded = true;
        } else {
            OpenLayers.Rico.Corner.reRound(this.groupDiv, options);
            //set the popup color and opacity
            this.setBackgroundColor(); 
            this.setOpacity();
        }
    },

    /** 
     * Method: getCornersToRound
     *  
     * Returns:
     * {String} The proper corners string ("tr tl bl br") for rico to round.
     */
    getCornersToRound:function() {

        var corners = ['tl', 'tr', 'bl', 'br'];

        //we want to round all the corners _except_ the opposite one. 
        var corner = OpenLayers.Bounds.oppositeQuadrant(this.relativePosition);
        OpenLayers.Util.removeItem(corners, corner);

        return corners.join(" ");
    },

    CLASS_NAME: "Geo.ViewFl.Popup.AnchoredBubble"
});

/**
 * Constant: CORNER_SIZE
 * {Integer} 5。边框角的空间大小。
 */
Geo.ViewFl.Popup.AnchoredBubble.CORNER_SIZE = 5;

/**
 * Class: Geo.ViewFl.Popup.Framed
 * 浮云窗体类。
 * 
 * Inherits from:
 *  - <Geo.ViewFl.Popup.Anchored>
 */
Geo.ViewFl.Popup.Framed =
  Geo.Class(Geo.ViewFl.Popup.Anchored, {

    /**
     * Property: imageSrc
     * {String} location of the image to be used as the popup frame
     */
    imageSrc: null,

    /**
     * Property: imageSize
     * {<Geo.Size>} Size (measured in pixels) of the image located
     *     by the 'imageSrc' property.
     */
    imageSize: null,

    /**
     * APIProperty: isAlphaImage
     * {Boolean} 是否为Alpha图像。默认为false。
     */
    isAlphaImage: false,

    /**
     * Property: positionBlocks
     * {Object} Hash of different position blocks (Object/Hashs). Each block 
     *     will be keyed by a two-character 'relativePosition' 
     *     code string (ie "tl", "tr", "bl", "br"). Block properties are 
     *     'offset', 'padding' (self-explanatory), and finally the 'blocks'
     *     parameter, which is an array of the block objects. 
     * 
     *     Each block object must have 'size', 'anchor', and 'position' 
     *     properties.
     * 
     *     Note that positionBlocks should never be modified at runtime.
     */
    positionBlocks: null,

    /**
     * Property: blocks
     * {Array[Object]} Array of objects, each of which is one "block" of the 
     *     popup. Each block has a 'div' and an 'image' property, both of 
     *     which are DOMElements, and the latter of which is appended to the 
     *     former. These are reused as the popup goes changing positions for
     *     great economy and elegance.
     */
    blocks: null,

    /** 
     * APIProperty: fixedRelativePosition
     * {Boolean} 让窗体显示在一个适当的位置，默认为false。
     */
    fixedRelativePosition: false,

    /** 
     * Constructor: Geo.ViewFl.Popup.Framed
     * 构造一个新的Geo.ViewFl.Popup.Framed对象实例。
     * 
     * Parameters:
     * id - {String}  浮云框的唯一标识，如果没有设置将会自动生成一个。
     * lonlat - {<Geo.LonLat>} 浮云显示的位置。
     * contentSize - {<Geo.Size>} 浮云的尺寸。
     * contentHTML - {String} 浮云框内容。
     * anchor - {Object} 锚。必须包含'size' (<Geo.Size>) 与 'offset' (<Geo.Pixel>)的键值对对象。
     * closeBox - {Boolean} 是否显示关闭窗口。
     * closeBoxCallback - {Function} 点击关闭窗口时的回调方法。
     */
    initialize:function(id, lonlat, contentSize, contentHTML, anchor, closeBox, 
                        closeBoxCallback) {

        Geo.ViewFl.Popup.Anchored.prototype.initialize.apply(this, arguments);

        if (this.fixedRelativePosition) {
            //based on our decided relativePostion, set the current padding
            // this keeps us from getting into trouble 
            this.updateRelativePosition();
            
            //make calculateRelativePosition always return the specified
            // fixed position.
            this.calculateRelativePosition = function(px) {
                return this.relativePosition;
            };
        }

        this.contentDiv.style.position = "absolute";
        this.contentDiv.style.zIndex = 1;

        if (closeBox) {
            this.closeDiv.style.zIndex = 1;
        }

        this.groupDiv.style.position = "absolute";
        this.groupDiv.style.top = "0px";
        this.groupDiv.style.left = "0px";
        this.groupDiv.style.height = "100%";
        this.groupDiv.style.width = "100%";
    },

    /** 
     * APIMethod: destroy
     * 销毁本对象。
     */
    destroy: function() {
        this.imageSrc = null;
        this.imageSize = null;
        this.isAlphaImage = null;

        this.fixedRelativePosition = false;
        this.positionBlocks = null;

        //remove our blocks
        for(var i = 0; i < this.blocks.length; i++) {
            var block = this.blocks[i];

            if (block.image) {
                block.div.removeChild(block.image);
            }
            block.image = null;

            if (block.div) {
                this.groupDiv.removeChild(block.div);
            }
            block.div = null;
        }
        this.blocks = null;

        Geo.ViewFl.Popup.Anchored.prototype.destroy.apply(this, arguments);
    },

    /**
     * Method: setBackgroundColor
     * 设置背景颜色。此方法什么也不做，因为整个弹出框是基于一个图片的，改变背景颜色没有任何意义。
     */
    setBackgroundColor:function(color) {
        //does nothing since the framed popup's entire scheme is based on a 
        // an image -- changing the background color makes no sense. 
    },

    /**
     * Method: setBorder
     * 设置边框。此方法什么也不做，因为整个弹出框是基于一个图片的，改变边框没有任何意义。
     */
    setBorder:function() {
        //does nothing since the framed popup's entire scheme is based on a 
        // an image -- changing the popup's border makes no sense. 
    },

    /**
     * Method: setOpacity
     * 设置透明度。
     * 
     * Parameters:
     * opacity - {float} 从0到1的浮点数。0表示透明，1表示完全不透明  
     */
    setOpacity:function(opacity) {
        //does nothing since we suppose that we'll never apply an opacity
        // to a framed popup
    },

    /**
     * APIMethod: setSize
     * 设置尺寸大小。
     * 
     * Parameters:
     * contentSize - {<Geo.Size>} 弹出区域的大小。
     */
    setSize:function(contentSize) { 
        Geo.ViewFl.Popup.Anchored.prototype.setSize.apply(this, arguments);

        this.updateBlocks();
    },

    /**
     * Method: updateRelativePosition
     * When the relative position changes, we need to set the new padding 
     *     BBOX on the popup, reposition the close div, and update the blocks.
     */
    updateRelativePosition: function() {

        //update the padding
        this.padding = this.positionBlocks[this.relativePosition].padding;

        //update the position of our close box to new padding
        if (this.closeDiv) {
            // use the content div's css padding to determine if we should
            //  padd the close div
            var contentDivPadding = this.getContentDivPadding();

            this.closeDiv.style.right = contentDivPadding.right + 
                                        this.padding.right + "px";
            this.closeDiv.style.top = contentDivPadding.top + 
                                      this.padding.top + "px";
        }

        this.updateBlocks();
    },

    /** 
     * Method: calculateNewPx
     * Besides the standard offset as determined by the Anchored class, our 
     *     Framed popups have a special 'offset' property for each of their 
     *     positions, which is used to offset the popup relative to its anchor.
     * 
     * Parameters:
     * px - {<Geo.Pixel>}
     * 
     * Returns:
     * {<Geo.Pixel>} The the new px position of the popup on the screen
     *     relative to the passed-in px.
     */
    calculateNewPx:function(px) {
        var newPx = Geo.ViewFl.Popup.Anchored.prototype.calculateNewPx.apply(
            this, arguments
        );

        newPx = newPx.offset(this.positionBlocks[this.relativePosition].offset);

        return newPx;
    },

    /**
     * Method: createBlocks
     */
    createBlocks: function() {
        this.blocks = [];

        //since all positions contain the same number of blocks, we can 
        // just pick the first position and use its blocks array to create
        // our blocks array
        var firstPosition = null;
        for(var key in this.positionBlocks) {
            firstPosition = key;
            break;
        }
        
        var position = this.positionBlocks[firstPosition];
        for (var i = 0; i < position.blocks.length; i++) {

            var block = {};
            this.blocks.push(block);

            var divId = this.id + '_FrameDecorationDiv_' + i;
            block.div = OpenLayers.Util.createDiv(divId, 
                null, null, null, "absolute", null, "hidden", null
            );

            var imgId = this.id + '_FrameDecorationImg_' + i;
            var imageCreator = 
                (this.isAlphaImage) ? OpenLayers.Util.createAlphaImageDiv
                                    : OpenLayers.Util.createImage;

            block.image = imageCreator(imgId, 
                null, this.imageSize, this.imageSrc, 
                "absolute", null, null, null
            );

            block.div.appendChild(block.image);
            this.groupDiv.appendChild(block.div);
        }
    },

    /**
     * Method: updateBlocks
     * Internal method, called on initialize and when the popup's relative
     *     position has changed. This function takes care of re-positioning
     *     the popup's blocks in their appropropriate places.
     */
    updateBlocks: function() {
        if (!this.blocks) {
            this.createBlocks();
        }
        
        if (this.size && this.relativePosition) {
            var position = this.positionBlocks[this.relativePosition];
            for (var i = 0; i < position.blocks.length; i++) {
    
                var positionBlock = position.blocks[i];
                var block = this.blocks[i];
    
                // adjust sizes
                var l = positionBlock.anchor.left;
                var b = positionBlock.anchor.bottom;
                var r = positionBlock.anchor.right;
                var t = positionBlock.anchor.top;
    
                //note that we use the isNaN() test here because if the 
                // size object is initialized with a "auto" parameter, the 
                // size constructor calls parseFloat() on the string, 
                // which will turn it into NaN
                //
                var w = (isNaN(positionBlock.size.w)) ? this.size.w - (r + l) 
                                                      : positionBlock.size.w;
    
                var h = (isNaN(positionBlock.size.h)) ? this.size.h - (b + t) 
                                                      : positionBlock.size.h;
    
                block.div.style.width = (w < 0 ? 0 : w) + 'px';
                block.div.style.height = (h < 0 ? 0 : h) + 'px';
    
                block.div.style.left = (l != null) ? l + 'px' : '';
                block.div.style.bottom = (b != null) ? b + 'px' : '';
                block.div.style.right = (r != null) ? r + 'px' : '';            
                block.div.style.top = (t != null) ? t + 'px' : '';
    
                block.image.style.left = positionBlock.position.x + 'px';
                block.image.style.top = positionBlock.position.y + 'px';
            }
    
            this.contentDiv.style.left = this.padding.left + "px";
            this.contentDiv.style.top = this.padding.top + "px";
        }
    },

    CLASS_NAME: "Geo.ViewFl.Popup.Framed"
});
/**
 * Class: Geo.ViewFl.Popup.FramedCloud
 * 浮云类。
 * 
 * Inherits from: 
 *  - <Geo.ViewFl.Popup.Framed>
 */
Geo.ViewFl.Popup.FramedCloud = 
  Geo.Class(Geo.ViewFl.Popup.Framed, {

    /** 
     * Property: contentDisplayClass
     * {String} The CSS class of the popup content div.
     */
    contentDisplayClass: "olFramedCloudPopupContent",

    /**
     * APIProperty: autoSize
     * {Boolean} 默认情况下，浮云框是自动设置尺寸大小的，默认为true。
     */
    autoSize: true,

    /**
     * APIProperty: panMapIfOutOfView
     * {Boolean} 当绘制和地图的上下左右移动时，整个弹出框浮云在当前视口是可见的，默认为true。
     */
    panMapIfOutOfView: true,

    /**
     * APIProperty: imageSize
     * {<Geo.Size>} 图片大小。
     */
    imageSize: new OpenLayers.Size(1276, 736),

    /**
     * APIProperty: isAlphaImage
     * {Boolean} 浮云框是否使用一个alpha图像。默认为false。
     */
    isAlphaImage: false,

    /** 
     * APIProperty: fixedRelativePosition
     * {Boolean} 显示在一个适当的位置。默认为false。
     */
    fixedRelativePosition: false,

    /**
     * Property: positionBlocks
     * {Object} Hash of differen position blocks, keyed by relativePosition
     *     two-character code string (ie "tl", "tr", "bl", "br")
     */
    positionBlocks: {
        "tl": {
            'offset': new OpenLayers.Pixel(44, 0),
            'padding': new OpenLayers.Bounds(8, 40, 8, 9),
            'blocks': [
                { // top-left
                    size: new OpenLayers.Size('auto', 'auto'),
                    anchor: new OpenLayers.Bounds(0, 51, 22, 0),
                    position: new OpenLayers.Pixel(0, 0)
                },
                { //top-right
                    size: new OpenLayers.Size(22, 'auto'),
                    anchor: new OpenLayers.Bounds(null, 50, 0, 0),
                    position: new OpenLayers.Pixel(-1238, 0)
                },
                { //bottom-left
                    size: new OpenLayers.Size('auto', 19),
                    anchor: new OpenLayers.Bounds(0, 32, 22, null),
                    position: new OpenLayers.Pixel(0, -631)
                },
                { //bottom-right
                    size: new OpenLayers.Size(22, 18),
                    anchor: new OpenLayers.Bounds(null, 32, 0, null),
                    position: new OpenLayers.Pixel(-1238, -632)
                },
                { // stem
                    size: new OpenLayers.Size(81, 35),
                    anchor: new OpenLayers.Bounds(null, 0, 0, null),
                    position: new OpenLayers.Pixel(0, -688)
                }
            ]
        },
        "tr": {
            'offset': new OpenLayers.Pixel(-45, 0),
            'padding': new OpenLayers.Bounds(8, 40, 8, 9),
            'blocks': [
                { // top-left
                    size: new OpenLayers.Size('auto', 'auto'),
                    anchor: new OpenLayers.Bounds(0, 51, 22, 0),
                    position: new OpenLayers.Pixel(0, 0)
                },
                { //top-right
                    size: new OpenLayers.Size(22, 'auto'),
                    anchor: new OpenLayers.Bounds(null, 50, 0, 0),
                    position: new OpenLayers.Pixel(-1238, 0)
                },
                { //bottom-left
                    size: new OpenLayers.Size('auto', 19),
                    anchor: new OpenLayers.Bounds(0, 32, 22, null),
                    position: new OpenLayers.Pixel(0, -631)
                },
                { //bottom-right
                    size: new OpenLayers.Size(22, 19),
                    anchor: new OpenLayers.Bounds(null, 32, 0, null),
                    position: new OpenLayers.Pixel(-1238, -631)
                },
                { // stem
                    size: new OpenLayers.Size(81, 35),
                    anchor: new OpenLayers.Bounds(0, 0, null, null),
                    position: new OpenLayers.Pixel(-215, -687)
                }
            ]
        },
        "bl": {
            'offset': new OpenLayers.Pixel(45, 0),
            'padding': new OpenLayers.Bounds(8, 9, 8, 40),
            'blocks': [
                { // top-left
                    size: new OpenLayers.Size('auto', 'auto'),
                    anchor: new OpenLayers.Bounds(0, 21, 22, 32),
                    position: new OpenLayers.Pixel(0, 0)
                },
                { //top-right
                    size: new OpenLayers.Size(22, 'auto'),
                    anchor: new OpenLayers.Bounds(null, 21, 0, 32),
                    position: new OpenLayers.Pixel(-1238, 0)
                },
                { //bottom-left
                    size: new OpenLayers.Size('auto', 21),
                    anchor: new OpenLayers.Bounds(0, 0, 22, null),
                    position: new OpenLayers.Pixel(0, -629)
                },
                { //bottom-right
                    size: new OpenLayers.Size(22, 21),
                    anchor: new OpenLayers.Bounds(null, 0, 0, null),
                    position: new OpenLayers.Pixel(-1238, -629)
                },
                { // stem
                    size: new OpenLayers.Size(81, 33),
                    anchor: new OpenLayers.Bounds(null, null, 0, 0),
                    position: new OpenLayers.Pixel(-101, -674)
                }
            ]
        },
        "br": {
            'offset': new OpenLayers.Pixel(-44, 0),
            'padding': new OpenLayers.Bounds(8, 9, 8, 40),
            'blocks': [
                { // top-left
                    size: new OpenLayers.Size('auto', 'auto'),
                    anchor: new OpenLayers.Bounds(0, 21, 22, 32),
                    position: new OpenLayers.Pixel(0, 0)
                },
                { //top-right
                    size: new OpenLayers.Size(22, 'auto'),
                    anchor: new OpenLayers.Bounds(null, 21, 0, 32),
                    position: new OpenLayers.Pixel(-1238, 0)
                },
                { //bottom-left
                    size: new OpenLayers.Size('auto', 21),
                    anchor: new OpenLayers.Bounds(0, 0, 22, null),
                    position: new OpenLayers.Pixel(0, -629)
                },
                { //bottom-right
                    size: new OpenLayers.Size(22, 21),
                    anchor: new OpenLayers.Bounds(null, 0, 0, null),
                    position: new OpenLayers.Pixel(-1238, -629)
                },
                { // stem
                    size: new OpenLayers.Size(81, 33),
                    anchor: new OpenLayers.Bounds(0, null, null, 0),
                    position: new OpenLayers.Pixel(-311, -674)
                }
            ]
        }
    },

    /**
     * APIProperty: minSize
     * {<Geo.Size>} 最小尺寸。
     */
    minSize: new OpenLayers.Size(105, 10),

    /**
     * APIProperty: maxSize
     * {<Geo.Size>} 最大尺寸。
     */
    maxSize: new OpenLayers.Size(1200, 660),

    /** 
     * Constructor: Geo.ViewFl.Popup.FramedCloud
     * 构造一个新的Geo.ViewFl.Popup.FramedCloud对象实例。
     * 
     * Parameters:
     * id - {String}  浮云框的唯一标识，如果没有设置将会自动生成一个。
     * lonlat - {<Geo.LonLat>} 浮云显示的位置。
     * contentSize - {<Geo.Size>} 浮云的尺寸。
     * contentHTML - {String} 浮云框内容。
     * anchor - {Object} 锚。必须包含'size' (<Geo.Size>) 与 'offset' (<Geo.Pixel>)的键值对对象。
     * closeBox - {Boolean} 是否显示关闭窗口。
     * closeBoxCallback - {Function} 点击关闭窗口时的回调方法。
     */
    initialize:function(id, lonlat, contentSize, contentHTML, anchor, closeBox, 
                        closeBoxCallback) {

        this.imageSrc = OpenLayers.Util.getImagesLocation() + 'cloud-popup-relative.png';
        Geo.ViewFl.Popup.Framed.prototype.initialize.apply(this, arguments);
        this.contentDiv.className = this.contentDisplayClass;
    },

    /** 
     * APIMethod: destroy
     * 销毁本对象。
     */
    destroy: function() {
        Geo.ViewFl.Popup.Framed.prototype.destroy.apply(this, arguments);
    },

    CLASS_NAME: "Geo.ViewFl.Popup.FramedCloud"
});
/**
 * Class: Geo.ViewFl.Popup.FramedCloudFl
 * Flash二维视图浮云框。
 *
 * Inherits from:
 *  - <Geo.ViewFl.PopupFl>
 */
Geo.ViewFl.Popup.FramedCloudFl = Geo.Class(Geo.ViewFl.PopupFl,{
	
	/** 
     * Constructor: Geo.ViewFl.Popup.FramedCloudFl
     * 构造一个新的<Geo.ViewFl.Popup.FramedCloudFl>对象实例。
     * 
     * Parameters:
     * id - {String}  浮云框的唯一标识，如果没有设置将会自动生成一个。
     * lonlat - {<Geo.LonLat>} 浮云显示的位置。
     * contentSize - {<Geo.Size>} 浮云的尺寸。
     * contentHTML - {String} 浮云框内容。
     * title - {String} 标题。
     * closeBox - {Boolean} 是否显示关闭按钮。
     * closeBoxCallback - {Function} 点击关闭按钮的回调函数。
     */
    initialize: function(id, lonlat, contentSize, contentHTML, title, closeBox, closeBoxCallback){
        var newArguments = [id, lonlat, contentSize, contentHTML, title, closeBox, closeBoxCallback];
        Geo.ViewFl.PopupFl.prototype.initialize.apply(this, newArguments);
    },

    CLASS_NAME: "Geo.ViewFl.Popup.FramedCloudFl"
});/**
 * Class: Geo.View3D.Map
 * 三维地图对象。
 */
Geo.View3D.Map = Geo.Class({

    /**
     * APIProperty: id
     * {String} 唯一标识符。
     */
    id: null,
    
    /**
     * APIProperty: div
     * {DOMElement} 三维地图所在的div容器。
     */
    div: null,
    
    /**
     * APIProperty: activexObj
     * {DOMElement} 三维地图的ActiveX对象引用。
     */
    activexObj: null,
    
    /**
     * APIProperty: layers
     * {Array} 地图中所有图层。
     */
    layers: null, 
   
    /**
     * APIProperty: overLayers
     * {Array} 所有的覆盖图层。
     */
    overLayers: null,
    
    /**
     * APIProperty: controls
     * {Array} 地图中所有控件。
     */
    controls: null,
	
	/**
     * APIProperty: popups
     * {Array(<Geo.View3D.Popup>)} 添加到地图上的弹出框。
     */
    popups: null,
    
	/**
	 * Property: handlers
	 * {Object} 地图中所有鼠标事件监听器。
	 */
    handlers:null,
	
	/**
     * APIProperty: BaseLayerGroup
     * {Geo.View3D.BaseLayerGroup} 基础图层组。
     */
	baseLayerGroup: null,
    
	_auxStatus: null,
	
    /**
     * APIProperty: zoomRatio
     * {Number} 调用地图缩放方法zoomIn和zoomOut方法时的缩放比率值。
     */
    zoomRatio: 1,
    
    /**
     * APIProperty: EVENT_TYPES
     * {Array} 支持的事件类型。
     */
    EVENT_TYPES: ["unloadLayerGroup", "loadlayergroup"],
    
    /**
     * APIProperty: pyramid
     * {<Geo.Pyramid>} 地图的金字塔方案对象，在三维地图中只能为360度金字塔方案。
     */
    pyramid: null,
        
    events: null,
	
	// 图层移动方式的枚举变量
	_enumMoveLayerType: {
		"MOVE_TO_TOP": 0, //移动图层到顶层显示
		"MOVE_TO_BOTTOM": 1, //移动图层到底层显示
		"MOVE_UP": 2, //向上移动一层
		"MOVE_DOWN": 3 //向下移动一层
	},
	
	//三维球元素类型枚举
	_enumScreenElementType: {
		LATLONGGRID: 0,//经纬网格
		COMPASS: 1,//罗盘
		ATMOSPHERE: 2,//大气圈
		COODINFO: 3,//坐标信息
		CROSSHAIR: 5 //十字丝
	},
	
	/**
     * APIProperty: projection
     * {String} 地图投影,默认 "EPSG:4326".
     */
    projection: "EPSG:4326",    
        
    /**
     * APIProperty: units
     * {String} 地图单位，默认为'degrees'. 
     */
    units: 'degrees',	
    
    /** 
     * Constructor: Geo.View3D.Map
     * Geo.View3D.Map构造方法。
     *
     * Parameters:
     * div - {DOMElement|String} DIV元素。
     * options - {Object} 选项。
     * (code)
     * var map = new Geo.View3D.Map("simpleMap");
     * (end)
     *
     */
    initialize: function(div, options){
    
        if (typeof(div) == "string") {
            this.div = document.getElementById(div);
        }
        else {
            this.div = div;
        }
        this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME);
        
        //初始化插件
        var initResult = Geo.View3D.Map.getActivex(this.id + "_Activex");
        this.activexObj = initResult.obj;
        var version = initResult.version;
        
        //检查三维插件是否安装
//        if (!this.activexObj || initResult.version < Geo.View3D.Map.ACTIVEX_DEFAULT_VERSION) {
//            this.div.innerHTML = Geo.View3D.Map.activexErrorInfo;
//            return;
//        }        
        
        this.div.appendChild(this.activexObj);
		
		//this.setFocus(true);
		/*
		this.activexObj.onfocus = function(){
			this.parentNode.onfocus = "true";
		}
		*/
        this.setScenario("no server", 2);
        
        this.events = new OpenLayers.Events(this, 
                                            this.div, 
                                            this.EVENT_TYPES, 
                                            this.fallThrough, 
                                            {includeXY: true});
        //金字塔对象                                    
		this.pyramid = new Geo.Pyramid();                                            
        this.layers = [];
        this.overLayers = [];
        this.handlers = [];
		this.popups = [];
		
		//辅助图层状态信息初始化
    	this._auxStatus = {
	        latLongGrid: false,
	        compass:true,
	        coodInfo:true,
	        atmosphere:true,
	        crossHair:true
	    };
//        
//		this._initGeoRaster();
//        
//        //绑定量算事件
//        var measureHandler = OpenLayers.Function.bind(function(eventObj){
//            this._measureHandler(eventObj);
//        }, this);
//        this.activexObj.attachEvent("GGMeasureEvent", measureHandler);
//
		//绑定鼠标事件
        var mouseEventHandler = OpenLayers.Function.bind(function(eventObj){
			
            this._mouseEventHandler(eventObj);
        }, this);
        this.activexObj.attachEvent("OnMouseEvent", mouseEventHandler);
		
		//绑定键盘事件
//        var keyEventHandler = OpenLayers.Function.bind(function(eventObj){KeyCode,keyState
        var keyEventHandler = OpenLayers.Function.bind(function(keyCode,keyState){
        	var eventObj = {};
        	eventObj.keyCode = keyCode;
        	eventObj.keyState = keyState;
            this._keyEventHandler(eventObj);
        }, this);
        this.activexObj.attachEvent("OnKeyEvent", keyEventHandler);
//		
//		//修正页面后退，刷新三维插件对不销毁问题
//		this.unloadDestroy = OpenLayers.Function.bind(this.destroy, this);
//        OpenLayers.Event.observe(window, 'unload', this.unloadDestroy);
// 
 		//如果未在构造地图对象时指定加载控件，则加载默认控件（键盘控制控件）
        if (this.controls == null) {
			
			//如果不存在Control也不加载控件
            if (Geo.View3D.Control != null) { 
                this.controls = [new Geo.View3D.Control.KeyboardDefaults()];
            }
            else {
                this.controls = [];
            }
        }
        for(var i=0, len=this.controls.length; i<len; i++) {
            this.addControlToMap(this.controls[i]);
        }
//		
//		//坐标信息显示设置为红色字体
//        var options = {
//            fontColor: 0x00ff0000
//        };
//		this.setCoodInfo(options);
    },

    /**
     * APIMethod: zoomTo
     * 缩放到指定的级别。
     * 
     * Parameters:
     * zoom - {Integer}
     */    
    zoomTo: function(zoom){
       if (zoom != null && zoom >= 0) {
            this.setCenter(null, zoom);
        }
    },
    
    /**
     * APIMethod: zoomIn
     * 放大地图级别。
     */    
    zoomIn: function(){
        this.zoom(this.zoomRatio);
    },
    
    /**
     * APIMethod: zoomOut
     * 缩小地图级别。
     */
    zoomOut: function(){
        this.zoom(-this.zoomRatio);
    },
    
    /**
     * APIMethod: zoom
     * 按指定比率缩放地图。
     */
    zoom: function(ratio){
        ratio = ratio ? ratio : 1;
        var camera = this.activexObj.Camera;
        camera.Zoom(ratio);
    },
	
	/**
     * APIMethod: pan
     * 允许用户根据屏幕的像素值来进行平移。
     * 
     * Parameters:
     * dx - {Integer}
     * dy - {Integer}
     */
    pan: function(dx, dy) {
		if ( (dx == null) || (dy == null) ) {
            var msg = OpenLayers.i18n("pixelAddError");
            OpenLayers.Console.error(msg);
            return null;
        }
        var globe = this.activexObj;
		if (globe) {
			globe.SceneBox.PanByScreen(dx, dy);
        }
	},
	
    /**
     * APIMethod: panTo
     * 根据坐标信息参数，将地图平移相应的距离。
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>} 
     */
    panTo: function(lonlat){
        if(!lonlat){
            return;
        }
        // center will not change, don't do nothing
        var center = map.getCenter();
        if (lonlat.equals(center)) {
            return;
        }
		//经纬度各偏移1度
        var globe = this.activexObj;
        var lat = parseFloat(lonlat.lat - center.lat);
        var lon = parseFloat(lonlat.lon - center.lon);
        if (globe) {
			globe.SceneBox.Pan(lat, lon);
        } 
    },   
    
    /**
     * APIMethod: setCenter
     * 设置三维地图中心点和地图级别(没有飞行过程)。
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>} 中心点。
     * level - {Integer} 地图级别。
     * isFly - {Boolean} 是否开启飞行动画效果。
     */
    setCenter: function(lonlat, level, isFly){
    	if(level === undefined){
	        level = this.getZoom();
	    }
	
	    isFly = isFly || false;
	    this._gotoPosition({
	        lon: lonlat.lon,
	        lat: lonlat.lat,
	        level: level
	    }, isFly);
    },
    
    /**
     * APIMethod: flyTo
     * 飞到三维地图中心点和海拨高度。
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>} 中心点。
     * alt - {Integer} 海拨高度(单位为米) 。
     */
    flyTo: function(lonlat, alt){
        this._gotoPosition({
            lon: lonlat.lon,
            lat: lonlat.lat,
            alt: alt
        }, true);
    },

	/**
     * APIMethod: zoomToExtent
     * 缩放到指定地图范围。
     * 
     * Parameters:
     * bounds - {<Geo.Bounds>} 范围。
     * isFlyTo - {Boolean} 是否飞行过去。
     */
    zoomToExtent: function(bounds, isFlyTo) {
    	var center = bounds.getCenterLonLat();
	    var viewSize = this.getSize();
	    var idealResolution = Math.max( bounds.getWidth()  / viewSize.w,
	                                    bounds.getHeight() / viewSize.h );
		var p360 = this.pyramid;	                                    
	    var zoom = p360.getLevelForResolution(idealResolution);
	    if(zoom > Geo.View3D.Map.ZOOMTOEXTENT_MINILEVEL){
	        zoom = Geo.View3D.Map.ZOOMTOEXTENT_MINILEVEL;
	    }
	    this.setCenter(center,zoom,isFlyTo);
    },
        
    //定位到指定位置,可以指定是否飞行方式
    _gotoPosition: function(position, isFlyTo){
        var globe = this.activexObj;
        if(!globe){
            return;
        }
        
        var lon = position.lon;
        var lat = position.lat;
        var level = position.level;
        
        //如果未指定海拨高度,则用默认高度
        var alt = (typeof(position.alt) == "undefined") ? Geo.View3D.Map.DEFAULT_ALT : position.alt;
        
        //如果有指定级别则优先以级别换算高度
        alt = (typeof(level) != "undefined") ? Geo.View3D.Map.getZfromLevel(level) : alt;
        
		// 如果当前高度大于等于目标高度（alt）并且小于目标高度前一级别换算的高度，则不改变定位的高度。
        if (this.getAltitude() >= alt && level != 0 && this.getAltitude() < Geo.View3D.Map.getZfromLevel(level - 1)) {
			alt = this.getAltitude();
        }
		// 如果当前高度大于等于目标高度（alt）并且目标级别为0，则不改变定位的高度。
        if (this.getAltitude() >= alt && level == 0) {
			alt = this.getAltitude();
        }
		
        if (isFlyTo) {
	   		globe.SceneBox.ParabolaFlyTo(lon, lat, alt);
        }
        else {
			globe.SceneBox.PutCameraPosition(lon, lat, alt);
        }
    },
    
    /**
     * APIMethod: addLayer
     * 添加单个图层对象到地图中。
     * 
     * Parameters:
     * layer - {<Geo.View3D.Layer>} 图层对象。
     */
    addLayer: function(layer){
        var layers = this.layers;
        if(!layer){
            return false;
        }
        for(var i=0, len=layers.length; i<len; i++) {
            if (this.layers[i] == layer) {
                var msg = OpenLayers.i18n('layerAlreadyAdded', 
                                                      {'layerName':layer.name});
                OpenLayers.Console.warn(msg);
                return false;
            }
        }
        this.layers.push(layer);
        layer.setMap(this);
    },
    
    /**
     * APIMethod: addLayers
     * 添加多个图层到地图中。
     * 
     * Parameters:
     * layers - {Array(<Geo.View3D.Layer>)}图层对象数组。
     */
    addLayers: function(layers){
        if (!(layers instanceof Array)) {
            layers = [layers];
        }
        for (var i = 0; i < layers.length; i++) {
            this.addLayer(layers[i]);
        }
    },

    /**
	 * APIMethod: addOverLayer
	 * 将指定图层作为覆盖层添加。与addLayer方法不同的是，该图层的引用除了保存到地图对象的layers数组中，还将保存到overLayers数组。
	 * 覆盖层在基础图层组切换时，叠加顺序不受基础图层加载、卸载的影响，始终保持在所有基础图层的上方。
	 *
	 * Parameters: 
	 * layer - {Geo.View3D.Layer} 三维视图图层对象。
	 */		
    addOverLayer: function(layer){
        this.addLayer(layer);
        this.overLayers.push(layer);
    },
        
    /**
     * APIMethod: removeLayer
     * 从地图中移除图层。
     * 
     * Parameters:
     * layer - {<Geo.View3D.Layer>} 图层对象。
     */
    removeLayer: function(layer){
        OpenLayers.Util.removeItem(this.overLayers, layer);
        OpenLayers.Util.removeItem(this.layers, layer);
        layer.removeMap();
        layer.map = null;
    },

    /**
     * APIMethod: getNumLayers
     * 获取当前地图中的图层个数。
     * 
     * Returns:
     * {Number} 图层个数。
     */
    getNumLayers:function(){
        return this.layers.length;
    },
    
    /**
     * APIMethod: getLayerByIndex
     * 获取指定图层在地图所有图层中的位置。
     * 
     * Parameters:
     * layer - {<Geo.View3D.Layer>} 图层对象。
     * 
     * Returns:
     * {Number} 图层所在位置。
     */
    getLayerIndex: function (layer) {
        return OpenLayers.Util.indexOf(this.layers, layer);
    },
    
    /**
     * APIMethod: getLayer
     * 根据指定图层ID获取指定图层对象的引用。
     * 
     * Parameters:
     * id - {String} 编号。
     * 
     * Returns:
     * {<Geo.View3D.Layer>} 图层对象。
     */
    getLayer: function(id) {
        var foundLayer = null;
        
        //在数据图层中查询
        for (var i=0, len=this.layers.length; i<len; i++) {
            var layer = this.layers[i];
            if (layer.id == id) {
                foundLayer = layer;
                break;
            }
        }
        return foundLayer;
    },
    
    /**
     * APIMethod: raiseLayer
     * 移动指定图层，正数为下移，负数为上移。
     * 
     * Parameters:
     * layer - {Object} 图层对象。
     * delta - {}
     * 
     */
    raiseLayer: function (layer, delta) {
		//要移动图层的当前位置
		var currentIndex = this.getLayerIndex(layer);
		//delta表示移动几位
	    var tempDelta = Math.abs(delta);
		if(delta > 0) {
			for (var i = currentIndex, len=this.layers.length; i<len; i++) {
				//若起大于0
				if(tempDelta == 0 || len <= i+1) {
					break;
				}
				if(!this.layers[i+1].displayInLayerSwitcher) {
					delta ++;
				}else {
					tempDelta--;
				}
        		
        	}
		}else if(delta < 0) {
			for (var i = currentIndex, len=this.layers.length;i >= 0; i--) {
        		if(tempDelta == 0 || i - 1 < 0) {
					break;
				}
				if(!this.layers[i-1].displayInLayerSwitcher) {
					delta = delta - 1;
				}else {
					tempDelta--;
				}
        	}
		}
        var idx = this.getLayerIndex(layer) + delta;
        this.setLayerIndex(layer, idx);
    },

	
    /**
	 * APIMethod: resetTopLayer
	 * 将置顶图层重新排列。
	 */	
    resetTopLayer: function(){
        var layersNum = this.layers.length;
		var topIndex = layersNum - 1;
        for (var i = layersNum - 1; i >= 0; i--) {
            var layer = this.layers[i];
            if (layer.isOnTop) {
                this.setLayerIndex(layer, topIndex--);
            }
        }
    },
	
	/**
	 * APIMethod: resetOverLayer
	 * 将覆盖图层重新排列。
	 */	
	resetOverLayer:function(){
		var layersNum = this.layers.length;
		var topIndex = layersNum - 1;
        for (var i = layersNum - 1; i >= 0; i--) {
            var layer = this.layers[i];
            
            //如果不是覆盖图层则视为底图图层将之移到最底层
            if (OpenLayers.Util.indexOf(this.overLayers,layer) != -1) {
                this.setLayerIndex(layer, topIndex--);
            }
        }
	},
    
    /**
     * APIMethod: setLayerIndex
     * 改变图层所在位置。
     * 
     * Parameters:
     * layer - {Object} 图层对象。
     * idx - {Integer}
     * 
     */
    setLayerIndex: function (layer, idx) {
        var base = this.getLayerIndex(layer);
		/***/
		// 该图层前一个索引图层
		var aLayer = null;
		// 该图层后一个索引图层
		var bLayer = null;
		if(base == 0){
			var bLayer = this.layers[base + 1];
		}else if(base == this.layers.length - 1){
			var aLayer = this.layers[base - 1];
		}else{
			var aLayer = this.layers[base - 1];
			var bLayer = this.layers[base + 1];
		}
        var alayerData = null;
        var blayerData = null;
        
        if (aLayer && aLayer._layerData) {
            alayerData = aLayer._layerData;
            //针对前一个索引图层为WMS图层中会有多个指定子图层
            if (!(aLayer._layerData instanceof Array)) {
                alayerData = [aLayer._layerData];
            }
        }
        if (bLayer && bLayer._layerData) {
            blayerData = bLayer._layerData;
            //针对后一个索引图层为WMS图层中会有多个指定子图层
            if (!(bLayer._layerData instanceof Array)) {
                blayerData = [bLayer._layerData];
            }
        }
        
		/***/
        if (idx < 0) {
            idx = 0;
        } else if (idx > this.layers.length) {
            idx = this.layers.length;
        }
        if (base != idx) {
            this.layers.splice(base, 1);
            this.layers.splice(idx, 0, layer);
            
            //根据偏移量，移动插件中的图层
            var delta = base - idx;
			var layerData = layer._layerData;
			/***/
			//针对前一个索引图层为WMS图层中会有多个指定子图层，则偏移量多加上（图层个数-1（默认个数））
			if (alayerData && delta > 0) {
				delta += alayerData.length -1;
			}
			//针对后一个索引图层为WMS图层中会有多个指定子图层，则偏移量多减去（图层个数-1（默认个数））
			if (blayerData && delta < 0) {
				delta -= blayerData.length -1;
			}
			/***/
			if (layerData) {
				//针对WMS图层中会有多个指定子图层
				if (!(layerData instanceof Array)) {
					layerData = [layerData];
				}
				for (var i = 0; i < Math.abs(delta); i++) {
					for (var m = 0; m < layerData.length; m++) {
						if (delta < 0) {
							this._moveLayerUp(layerData[m]);
						}
						if (delta > 0) {
							// 如果是需要置顶的图层（绘制图层）中如果包含标注图层则下移（置顶）
							if (layer.isOnTop && layer._markerLayer) {
								this._moveLayerDown(layer._markerLayer);
							}
							this._moveLayerDown(layerData[layerData.length - m - 1]);
						}
					}
				}
			}
        }
    },

    //图层组相关------------------------------------------------------------
    /**
     * APIMethod: loadLayerGroup
     * 加载图层组到地图中。
     * 
     * Parameters:
     * layerGroup - {Geo.View3D.BaseLayerGroup} 图层组对象。
     * 
     */
    loadLayerGroup: function(layerGroup){
		
        if (this.baseLayerGroup == layerGroup) {
            msg = "不能重复加载图层组到地图中！";
            OpenLayers.Console.warn(msg);
            return false;
        }
        this.unloadLayerGroup();

        layerGroup.setMap(this);
        this.baseLayerGroup = layerGroup;
        
        this.resetOverLayer();
        this.resetTopLayer();
        
        this.events.triggerEvent("loadlayergroup", {
            layerGroup: layerGroup,
			map : this
        });
    },
	
    /**
     * APIMethod: unloadLayerGroup
     * 卸载图层组。
     */
    unloadLayerGroup: function(){
		var layerGroup = this.baseLayerGroup;
        if (!layerGroup) {
			return false;
		}
        var layers = layerGroup.layers;
        for (var i = 0; i < layers.length; i++) {
            var layer = layers[i];
            this.removeLayer(layer);
        }
        layerGroup.map = null;
        this.baseLayerGroup = null;
        this.events.triggerEvent("unloadLayerGroup", {
            layerGroup: layerGroup,
			map : this
        });
    },
    
    /**
     * APIMethod: addControl
     * 添加单个控件到地图中。
     * 
     * Parameters:
     * control - {Object} 控件对象。
     * 
     */
    addControl: function(control){
        this.controls.push(control);
        this.addControlToMap(control);
    },
    
    /**
     * APIMethod: addControls
     * 添加多个控件到地图中。
     * 
     * Parameters:
     * controls - {Object} 控件组。
     * 
     */
    addControls: function (controls) {
        for (var i=0, len=controls.length; i<len; i++) {
            var ctrl = controls[i];
            this.addControl(ctrl);
        }
    },
	
    //添加控件到地图中
    addControlToMap: function(control,px){
        control.setMap(this);
        control.draw(px);
        if(control.autoActivate) {
            control.activate();
        }
    },
    
    /**
     * APIMethod: getControl
     * 根据给定ID获取控件对象的引用。
     * 
	 * Parameters:
     * id - {String} 控件唯一标识。
     * 
     * Returns:
     * {<Geo.View3D.Control>} 控件对象。
     */
    getControl: function(id){
        var returnControl = null;
        for (var i = 0, len = this.controls.length; i < len; i++) {
            var control = this.controls[i];
            if (control.id == id) {
                returnControl = control;
                break;
            }
        }
        return returnControl;
    },
    
	/**
     * APIMethod: removeControl
     * 删除地图中的控件。移除的控件来自于地图对象的控件列表。
     * 
     * Parameters:
     * control - {<Geo.View3D.Control>} 移除的控件。
     */
    removeControl: function(control){
        if ((control) && (control == this.getControl(control.id))) {
            OpenLayers.Util.removeItem(this.controls, control);
			control.deactivate();
        }
    },
    
    /** 
     * APIMethod: addPopup
     * 添加浮云框。
     * 
     * Parameters:
     * popup - {<Geo.View3D.Popup>}
     * exclusive - {Boolean} 是否关闭其他的浮云框。
     */
    addPopup: function(popup, exclusive) {

        if (exclusive) {
            //remove all other popups from screen
            for (var i = this.popups.length - 1; i >= 0; --i) {
                this.removePopup(this.popups[i]);
            }
        }

        popup.map = this;
        this.popups.push(popup);
        popup.draw();
    },

    /** 
    * APIMethod: removePopup
    * 移除浮云框。
    * 
    * Parameters:
    * popup - {<Geo.View3D.Popup>}
    */
    removePopup: function(popup) {
		//如果参数为空，清除全部
		if(!popup){
			popup = this.popups;
		}
		if (!(popup instanceof Array)) {
            popup = [popup];
        }
		for(var i = popup.length - 1; i >= 0; i--){
	        if (popup[i].map) {
	            popup[i]._clear();
	        }
	        popup[i].map = null;
			OpenLayers.Util.removeItem(this.popups, popup[i]);
		}
    },  
   
   /**
    * APIMethod: getAuxStatus
    * 获取指定辅助图层状态,如果为"all"则返回所有辅助图层的状态。
    * 
    * Parameters:
    * type - {Object}
    */
    getAuxStatus: function(type){
        return type == "all" ? this._auxStatus : this._auxStatus[type];
    },
	
    /**
     * APIMethod: showLatLongGrid
     * 设置是否显示经纬网格。
     * 
     * Parameters:
     * isShow - {Boolean}
     */
    showLatLongGrid: function(isShow){
        var globe = this.activexObj;
        if (globe) {
            //auxTools = globe.GetAuxTools();
            //auxTools.ShowLatLongGrid(isShow);
			globe.ScreenBox.ChangeScreenElementVisible(this._enumScreenElementType.LATLONGGRID,isShow);
            this._auxStatus["latLongGrid"] = isShow;
        }
        
    },
	
    /**
     * APIMethod: showCompass
     * 设置是否显示罗盘。
     * 
     * Parameters:
     * isShow - {Boolean}
     */
    showCompass: function(isShow){
        var globe = this.activexObj;
        if (globe) {
            //参数1表示罗盘
			globe.ScreenBox.ChangeScreenElementVisible(this._enumScreenElementType.COMPASS,isShow);
            this._auxStatus["compass"] = isShow;
        }
        
    },
    
    /**
     * APIMethod: showCoodInfo
     * 设置是否显示坐标信息。
     * 
     * Parameters:
     * isShow - {Boolean}
     */
    showCoodInfo: function(isShow){
        var globe = this.activexObj;
        if (globe) {
            //参数3表示坐标信息
			globe.ScreenBox.ChangeScreenElementVisible(this._enumScreenElementType.COODINFO,isShow);
            this._auxStatus["coodInfo"] = isShow;
        }
        
    },

    /**
     * APIMethod: setCoodInfo
     * 设置坐标信息相关选项，可以改变坐标信息的屏幕位置、文本对齐方式、字体颜色、字体名称、是否加粗、字号。
     * 
     * Parameters:
     * options - {<Object>} 参数对象，支持以下属性：
     *  - screenPosition 屏幕位置，可以为以下值：
     *      0：屏幕左下（默认）
     *      2：屏幕中下
     *      4：屏幕右下
     *      6：屏幕中央
     *      8：屏幕右上
     *      10：屏幕中上
     *      12：屏幕左上
     *  - textAlignment 文本对齐方式，可以为以下值：
     *      0：左对齐（默认）
     *      1：居中对齐
     *      2：右对齐
     *  - fontColor 字体颜色(默认0x000000ff)。
     *  - fontName 字体名称（默认"宋体"）。
     *  - fontBold 字体是否加粗。
     *  - fontSize 字号（默认14）。
     *  
     *  示例：
     *  (code)
     *  map.setCoodInfo({
     *     screenPosition: 2,
     *     fontSize: 18
     *  });
     *  (end)
     */    
    setCoodInfo:function(options){
        var defaultOption = {
            screenPosition: 0,
            textAlignment: 0, 
            fontColor: 0x000000ff, 
            fontName: "宋体", 
            fontBold: true, 
            fontSize: 14
        };
        
        OpenLayers.Util.applyDefaults(options,defaultOption);
        options.fontColor = Geo.Util.ToArgb(options.fontColor,255);
        var globe = this.activexObj;
		var coodInfo = globe.ScreenBox.QueryScreenElement(this._enumScreenElementType.COODINFO);
		coodInfo.ScreenPosition = options.screenPosition;
		coodInfo.TextAlignment = options.textAlignment;
		coodInfo.FontColor = options.fontColor;
		coodInfo.FontName = options.fontName;
		coodInfo.FontBold = options.fontBold;
		coodInfo.FontSize = options.fontSize;
	//	globe.ConfigBox.SaveConfigItem(8, options.screenPosition);
//        globe.GetAuxTools().SetPositionInfoParam(
//            options.screenPosition,
//            options.textAlignment,
//            options.fontColor,
//            options.fontName,
//            options.fontBold,
//            options.fontSize
//        )
    },
    

    /**
     * APIMethod: showAtmosphere
     * 设置是否显示大气圈。
     * 
     * Parameters:
     * isShow - {Boolean}
     */
    showAtmosphere: function(isShow){
        var globe = this.activexObj;
        if (globe) {
			 //参数2表示大气圈
			globe.ScreenBox.ChangeScreenElementVisible(this._enumScreenElementType.ATMOSPHERE,isShow);
            this._auxStatus["atmosphere"] = isShow;
        }
    },
    
    /**
     * APIMethod: showCrossHair
     * 设置是否显示十字丝。
     * 
     * Parameters:
     * isShow - {Boolean}
     */
    showCrossHair: function(isShow){
        var globe = this.activexObj;
        if (globe) {
			//参数5表示十字丝
			globe.ScreenBox.ChangeScreenElementVisible(this._enumScreenElementType.CROSSHAIR,isShow);
            this._auxStatus["crossHair"] = isShow;
        }
        
    },
	
    /**
     * APIMethod: setCompassPosition
     * 设置罗盘在屏幕上显示的位置。
     * 
     * Parameters:
     * positoin - {String} 罗盘的屏幕位置，目前只支持"left"或"right"，表示设置罗盘显示在屏幕右上或屏幕左上。
     * 
     */
    setCompassPosition: function(positoin){
        var globe = this.activexObj;
        if (globe) {
			switch(positoin){
				case "left" :
				   //第二个参数12表示罗盘在地图右上角；第一个参数7表示设置罗盘位置
					globe.ConfigBox.SaveConfigItem(7, 12);
					break;
				case "right" :
					globe.ConfigBox.SaveConfigItem(7, 8);
					break;
				default:
					return;
			}
        }
    },

    
    /**
     * APIMethod: setExaggeration
     * 设置地形夸张系数。
     * 
     * Parameters:
     * num - {Number} 为夸张的系数。
     */
    setExaggeration:function(num){
        num = (num < 0) ? 0 : num;
        num = (num > 5) ? 5 : num;
        
        var globe = this.activexObj;
        if (globe) {
            //globe.GetLayerBox().TerrainExaggeration(num);
			globe.Camera.TerrainExaggeration = num;
        }
    },    
    
    /**
     * APIMethod: resetNorth
     * 重新设置三维视图的指北方向。
     */
	resetNorth: function(){
		var globe = this.activexObj;
		if(globe){
//			globe.Camera.SetNorth();
			globe.Camera.Rotate(0, 0, 0.01 - globe.Camera.Heading); 
		}
	},

    /**
     * APIMethod: cameraRotation
     * 场景旋转。参数分别代表XYZ三个轴的偏移量。
     * 
     * Parameters:
     * dYaw - {Object}
     * dPitch - {Object}
     * dRoll - {Object}
     */
    cameraRotation: function(dYaw, dPitch, dRoll){
        var globe = this.activexObj;
        if (globe) {
            //参数分别代表XYZ三个轴的偏移量   
            globe.SceneBox.Rotate(dYaw, dPitch, dRoll);
        }
    },
    /**
     * APIMethod: getZoom
     * 获取当前海拨高度转换后的地图级别。
     * 
     * Returns:
     * {Integer} 地图级别。
     */
    getZoom: function(){
		var alt = this.getAltitude();
        return Geo.View3D.Map.getZoomfromAlt(Math.round(alt));
    },
    /**
    * APIMethod: getGeography
    * 获取当前中心点三维地理坐标。
    * 
    * Returns:
    * {Array} 三维地理坐标。
    */
    getGeography:function(){
    	return eval(this.activexObj.SceneBox.CameraLookAtScript);
    },
     /**
     * APIMethod: lonlatToScreen
     * 经纬度转屏幕像素。
     * 
     * Parameters:
     * lon - {Number} 经度。
     * lat - {Number} 纬度。
     * z - {Number} 
     * Returns:
     * {Pixel} 屏幕坐标。
     */
    lonlatToScreen: function(lon,lat,z){
    	var box = this.activexObj.AnalysisBox;
		//第三个参数为1的时候表示精确的坐标转换，里面有地形参与计算 
		var screenScript = eval(box.GeographyToScreenScript(lon, lat,z, 1));
		return new Geo.Pixel(parseFloat(screenScript[0]),parseFloat(screenScript[1]));
    },
     /**
     * APIMethod: lonlatToScreen
     * 屏幕像素转经纬度。
     * 
     * Parameters:
     * pX - {Number} 屏幕X坐标。
     * pX - {Number} 屏幕Y坐标。
     * Returns:
     * {LonLat} 经纬度。
     */
    screenToLonlat: function(pX,pY){
    	var box = this.activexObj.AnalysisBox;
		//第三个参数为1的时候表示精确的坐标转换，里面有地形参与计算 
		var geographyScript = eval(box.ScreenToGeographyScript(pX, pY,1));
		return new Geo.LonLat(parseFloat(geographyScript[0]),parseFloat(geographyScript[1]));
    },
    
    /**
     * APIMethod: getViewPortPxFromLonLat
     * 经纬度转屏幕像素.
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>}
     * 
     * Returns:
     * {<Geo.Pixel>} 屏幕坐标.
     */
    getViewPortPxFromLonLat: function (lonlat) {
        var box = this.activexObj.AnalysisBox;
        var geography = this.getGeography();
        var z = parseFloat(geography[2]);
		//第三个参数为1的时候表示精确的坐标转换，里面有地形参与计算 
		var screenScript = eval(box.GeographyToScreenScript(lonlat.lon, lonlat.lat,z, 1));
		return new Geo.Pixel(parseFloat(screenScript[0]),parseFloat(screenScript[1]));
    },
    
    /**
     * Method: getLonLatFromViewPortPx
     * 屏幕像素转经纬度.
     * 
     * Parameters:
     * viewPortPx - {<Geo.Pixel>}
     * 
     * Returns:
     * {<Geo.LonLat>} 经纬度.
     */
    getLonLatFromViewPortPx: function (viewPortPx) {
    	var box = this.activexObj.AnalysisBox;
		//第三个参数为1的时候表示精确的坐标转换，里面有地形参与计算 
		var geographyScript = eval(box.ScreenToGeographyScript(pX, pY,1));
		return new Geo.LonLat(parseFloat(geographyScript[0]),parseFloat(geographyScript[1]));
    },
    
    /**
     * APIMethod: getCenter
     * 获取当前中心点地理坐标。
     */
    getCenter: function(){
        var cameraLookAtScript = eval(this.activexObj.SceneBox.CameraLookAtScript);
    	return new Geo.LonLat(parseFloat(cameraLookAtScript[0]),parseFloat(cameraLookAtScript[1]));
    },   
    
    /**
     * APIMethod: getAltitude
     * 获取当前中心点海拨高度，单位为米。
     */    
    getAltitude: function(){
		return this.activexObj.SceneBox.MaxCameraAltitude;
    }, 
    
    /**
     * APIMethod: setTasService
     * 设置地形分析服务。
     * 
     * Parameters:
     * url - {String} 地形分析服务地址。
     */
    setTasService: function(url){
        var globe = this.activexObj;
        if (globe) {
            globe.SetTerrainAnalysisService(url);
        }
    },
	
	/**
	 * APIMethod: getExtent
	 * 获取三维视图下的视口范围。
	 * 
     * Returns:
     * {Geo.Bounds} 视口范围
	 */
	getExtent:function() {
		var globe = this.activexObj;
		var range = globe.SceneBox.SceneViewRangeScript;
		var range = range.replace("[", "");
		var range = range.replace("]", "");
		var bbox = range.replace("]", "");
		var arr = bbox.split(",");
		var extent = new Geo.Bounds(parseFloat(arr[0]), parseFloat(arr[1]), parseFloat(arr[2]), parseFloat(arr[3]));
		return extent;
	},
	
	/**
     * APIMethod: getResolution
     * 获取当前地图的分辨率。
     * 
     * Returns:
     * {Float} 分辨率
     */
	getResolution : function(){
	    var currentZoom = this.getZoom();
	    var p360 = this.pyramid;
	    return p360.getResolutionForLevel(currentZoom);
	},
	
	/**
     * APIMethod: getResolutionForZoom
     * 根据地图级别获取分辨率。
     * 
     * Parameter:
     * zoom - {Float}
     * 
     * Returns:
     * {Float} 分辨率
     */
	getResolutionForZoom : function(zoom){
    	var p360 = this.pyramid;
    	return p360.getResolutionForLevel(zoom);
	},
	
	/**
     * APIMethod: getZoomForResolution
     * 根据地图分辨率获取地图级别。
     * 
     * Parameter:
     * resolution - {Float}
     * 
     * Returns:
     * {Integer} 地图级别
     */
	getZoomForResolution : function(resolution){
    	var p360 = this.pyramid;
    	return p360.getLevelForResolution(resolution);
	},
	
	/**
     * APIMethod: getSize
     * 获取三维控件尺寸大小。
     * 
     * Returns:
     * {<Geo.Size>} 控件尺寸
     */
	getSize : function(){
		var globe = this.activexObj;
	    if(globe){
	        return new Geo.Size(parseInt(globe.offsetWidth),
	                              parseInt(globe.offsetHeight));
	    }
	},
	
	/**
      * APIMethod: getScale
      * 获取当前地图的比例尺。
      * 
      * Returns:
      * {Float} 比例尺 
      */
    getScale: function () {
        var scale = null;
        var res = this.getResolution();
        var units = this.units;
        scale = OpenLayers.Util.getScaleFromResolution(res, units);
        return scale;
    },
	
//    /**
//     * APIMethod: setFocus
//     * 设置球体容器的焦点。参数flag为true表示焦点在三维球体上时，则容器获得焦点。
//     * 
//     * Parameter:
//     * flag - {Boolean}
//     */	 
//	setFocus: function(flag){
//		if(flag){
//			this.activexObj.onfocus = function(){
//				this.parentNode.onfocus = "true";
//			}
//		}else{
//			this.activexObj.onfocus = "true";
//		}
//	},
	
	/**
     * Method: destroy
     * 销毁地图对象。
     */
    destroy:function() {
        for(var i=(this.layers.length-1); i>=0; i--){
            this.removeLayer(this.layers[i]);
        }
		if(this.activexObj){
			this.div.removeChild(this.activexObj);
		}
		this.activexObj = null;
    },	
    
    /**
     * Method: setScenario
     * 连接服务（应有加新服务和老服务之分，目前未处理）。
     *
     * Parameters:
     * scenario - {String} 方案地址。
     */
    setScenario: function(scenario){
        if (scenario) {
            this.activexObj.ConnectServer(scenario, 1);
        }
    },
	
	//初始化光栅对象
	_initGeoRaster: function(){
		this._geoRaster = this.activexObj.CreateGeoRasterObj();
		//设置为1绘制的几何对象贴地		
		this._geoRaster.GeoRasterType = 1;
	},
        
	//鼠标事件监听
    _mouseEventHandler: function(e){
//		if (e.MouseButton === 0 && e.MouseState === 3) {
//            return true;
//        }
		//e.Cancel=true;
//        for (var i = 0; i < this.handlers.length; i++) {
//            var handler = this.handlers[i];
//            if (handler instanceof Geo.View3D.Handler.KeybordDefaults) {
//                continue;
//            }
//            if (handler.active) {
//                handler.listener(e);
//            }
//        }
		//记录鼠标键按下位置，用以区分点击与拖拽行为
	    if(Geo.View3D.Event.MouseEvent.isMouseDown(e)){
	        Geo.View3D.Event.MouseEvent._mouseDownPos = {
	            x:e.ScreenX,
	            y:e.ScreenY
	        };
	    };
	
	    for (var i = 0; i < this.handlers.length; i++) {
	        var handler = this.handlers[i];
	        if (handler instanceof Geo.View3D.Handler.KeybordDefaults) {
	            continue;
	        }
	        if (handler.active) {
	            handler.listener(e);
	        }
	    };
	
	    //鼠标键抬起后清除位置记录
	    if(Geo.View3D.Event.MouseEvent.isMouseUp(e)){
	        Geo.View3D.Event.MouseEvent._mouseDownPos = null;
	    };
    },
	
	//键盘事件监听
    _keyEventHandler: function(e){
        for (var i = 0; i < this.handlers.length; i++) {
            var handler = this.handlers[i];
            if (handler instanceof Geo.View3D.Handler.KeybordDefaults || handler instanceof Geo.View3D.Handler.Keyboard) {
                if (handler.active) {
                    handler.listener(e);
                }
            }
        }
    },
    
    //量算事件监听
    _measureHandler: function(e){
        
    },
    
    //添加GLOBE瓦片服务
    _addGlobeTileService: function(url,version,type){
        var globe = this.activexObj;
		//创建吉奥瓦片图层，第二个参数是版本,第三个参数是数据源类型，6表示数据源来自于吉奥瓦片
		var geoGlobeTileLayer = globe.DataSourceBox.CreateDataLayer(url, version, type);
		//吉奥瓦片图层对象
		globe.LayerBox.UserGroupLayer.AddLayer(geoGlobeTileLayer);
		return geoGlobeTileLayer;
    },
    
    //删除GLOBE瓦片服务
    _removeLayerData: function(layer){
        var globe = this.activexObj;
        if (globe && layer) {
			globe.LayerBox.UserGroupLayer.RemoveLayer(layer);
        }
    },
    
     //获取点的坐标值
    _getPointGeometryArr:function (strPoints){
        var start = strPoints.indexOf("(") + 1;
		var end = strPoints.indexOf(")");
		var points = strPoints.slice(start,end).split(" ");
        return points;
    },
	
	//数字唯一标示计数器
	_i: 0,
	
	//生成数字唯一表示其
	_createUniqueID: function() {
		var i = this._i;
		i++;
		if(i == 1.7976931348623157E+308) {
			i = 0;
		}
		this._i = i;
		return i;
	},
	
    //在指定图层上绘制给定几何对象
    //featureid, rastLayer, strPoints, type, style
    _drawGeometry: function(options){
        var globe = this.activexObj;
        if (globe) {
            var drawBox = options.drawBox;
            var wkt = options.strPoints;
			var _style = OpenLayers.Util.extend({},Geo.Feature.Vector.style['default']);
			var style = OpenLayers.Util.extend(_style,options.style);
			options.feature.style = style;
            switch (options.type) {
                case 0:
					//如果要素样式中有外部图片的地址，则以标注方式创建点要素
					if(style.externalGraphic){
						var dynamicLayer = options.dynamicLayer;
						var fontColor = style.fontColor ? this._convertColorValue(style.fontColor) : 0x00ff0000;
						var fontSize = style.fontSize ? style.fontSize : 12;
						var fontFamily = style.fontFamily ? style.fontFamily : "宋体"
						var label = style.label?style.label : "";
						var lonlat = options.strPoints.split(" ");
//						var fid = this._createUniqueID();
//						options.feature.fid = fid;
						var id = options.feature.id;
						//var markpoint = globe.DrawBox.AddPOIDrawObject(fid, options.strPoints, "", label, style.externalGraphic, 12, 12, "12");
						var markpoint = globe.DrawBox.AddPOIDrawObject(id, options.strPoints, "", label, style.externalGraphic, fontColor, fontSize, fontFamily);
						dynamicLayer.AddPOI(markpoint);
						globe.DrawBox.RemoveObject(markpoint);
					} else {
						//创建三维geometry
						var geometry = globe.DrawBox.CreateGeometryObject(wkt, "", 1, 1);
						//geometry的唯一标示，删除要素需要使用这个唯一标示来进行删除
						geometry.Key = options.featureid;
						//0表示贴地,注意，如果设成成贴地必须要有矢量或影像图层作为底图才能显示贴地的要素
			            geometry.ZType = 0;
						//样式
						var rgb = style.fillColor.replace("#","");
						var argb = Geo.Util.ToArgb(rgb,parseInt(style.strokeOpacity * 255));
						//第一个参数是线的宽度，第二个参数是ARGB值
			            var style = globe.DrawBox.CreatePointSymbolObject(style.pointRadius, argb);
						drawBox.AddOrReplaceGeometry(geometry, style);	
//						var geometry = drawBox.CreateGeometryObject(wkt,null,1,1);
//						var pointSybol = drawBox.CreatePointSymbolObject(10, -65536);
//						geometry.ZType= 0;
//						geometry.Key = OpenLayers.Util.createUniqueID("point" + "_");
//						options.feature.geometry._3dGeometry = geometry;
//						var points = this._getPointGeometryArr(options.strPoints);
//						drawBox.AddDrawObject(geometry,pointSybol);				
					}
                    break;
                case 1:
					//第三个参数1表示point ,2表示lineString,3表示Ring,4表示Model，5表示 Box
					var geometry = globe.DrawBox.CreateGeometryObject(wkt, "", 2, 1);
		            geometry.Key = options.featureid;
		            geometry.ZType = 0;//0表示贴地， 1 表示贴近海平面， 2表示相对于地标，3表示绝对坐标(相对于海平面)
					var rgb = style.strokeColor.replace("#","");
					var argb = Geo.Util.ToArgb(rgb,parseInt(style.strokeOpacity * 255));
					//第一个参数是线的宽度，第二个参数是ARGB值
		            var style = globe.DrawBox.CreateLineSymbolObject(style.strokeWidth, argb);
		            drawBox.AddOrReplaceGeometry(geometry, style);
	                break;
                case 2:
					var geometry = globe.DrawBox.CreateGeometryObject(wkt, "", 3, 1);
		            geometry.Key =  options.featureid;
		            geometry.ZType = 0; //0表示贴地， 1 表示贴近海平面， 2表示相对于地标(相对地面)，3表示绝对坐标(相对于海平面)
					var rgb = style.strokeColor.replace("#","");
					//rgb和透明度转ARGB
					var argb = Geo.Util.ToArgb(rgb,parseInt(style.strokeOpacity * 255));
					//第一个参数是线的宽度，第二个参数是ARGB值
					var sym2 = globe.DrawBox.CreateLineSymbolObject(style.strokeWidth, argb);
					//面的填充色
					var fillrgb = style.fillColor.replace("#","");
					var fillargb = Geo.Util.ToArgb(fillrgb,parseInt(style.fillOpacity * 255));
            		var style = globe.DrawBox.CreateFillSymbolObject(fillargb, sym2);
		            drawBox.AddOrReplaceGeometry(geometry, style);
                    break;
                default:
                    return;            
			}
			
        };
    },
    
    _delGeometryByName: function(geometry,drawBox){
		//根据key删除要素
		drawBox.DeleteGeometry(geometry);
    },
	
	_delBookMark: function(geometry,drawBox){
		drawBox.RemovePOI(geometry);            
	},
            
    //删除矢量图层对象
    _removeVectorLayerData: function(ILayerWrapper){
        var globe = this.activexObj;
        if(globe){
    		globe.GetSceneGroup().RemoveLayer(ILayerWrapper);
        }
    },
    
    //上移图层
	/*
	 * // 图层移动方式的枚举变量
	_enumMoveLayerType: {
		MOVE_TO_TOP:0, //移动图层到顶层显示
		MOVE_TO_BOTTOM:1, //移动图层到底层显示
		MOVE_UP:2, //向上移动一层
		MOVE_DOWN:3 //向下移动一层
	},
	 */
    _moveLayerUp:function(layerData){
        var globe = this.activexObj;
        if (globe) {
            globe.LayerBox.UserGroupLayer.MoveLayer(layerData, this._enumMoveLayerType["MOVE_UP"]);
        }
    },
    
    //下移图层
    _moveLayerDown:function(layerData){
        var globe = this.activexObj;
        if (globe) {
            globe.LayerBox.UserGroupLayer.MoveLayer(layerData, this._enumMoveLayerType["MOVE_DOWN"]);
        }
    },
    
    //跳转到指定图层
    _gotoLayer: function(layerData){
        var globe = this.activexObj;
        if (layerData && globe) {
			var bounds = this._createLayerOperate(this._enumLayerOperateType["layerBounds"], layerData, {});
			this.zoomToExtent(bounds,true);
        };
    },

    //设置图层透明度
    //layer为要调整透明度的图层对象（之所以用图层对象而不用图层名称，是为了在需要时能调整无名图层的透明度）
    //三维插件透明度的值的范围是0-255
    _setLayerOpacity: function(layerData, opacity){
        var globe = this.activexObj;
        if (globe) {
			this._createLayerOperate(this._enumLayerOperateType["opacity"], layerData, {opacity : opacity});
        }
    },
	
	_setLayerVisibility: function(layerData,display) {
		 var globe = this.activexObj;
        if (globe) {
			this._createLayerOperate(this._enumLayerOperateType["visible"], layerData, {visible : display});
        }
	},

	//添加WMTS服务
    _addWMTSService: function(url, layerName){
    
        var globe = this.activexObj;
        if (globe) {
            var wmsObj = globe.GetLayerBox();
            if(null == url || undefined == url){
                url = "";
			}
            var layerBox = wmsObj.GetWmtsInfo(url);//传入服务地址
            var ILayerWrapperArr = [];
            var i = layerBox.GetCount(); //得到图层的个数
            for (var j = 0; j < i; j++) {
                var layerinfo = layerBox.GetResByIndex(j);//得到里面的一个图层
                // 根据图层名称和传进参数的图层名称相同则加载至场景中
                if (!layerName || layerinfo.Name == layerName) {
                    var layerdata = wmsObj.AddOneWmtsLayer(layerinfo, "");//添加一个图层到场景中
                    globe.GetCameraWrapper().GoToLayer(layerdata);//定位到图层
                    ILayerWrapperArr.push(layerdata);
                }
            }
            return ILayerWrapperArr;
        }
    },
    
	//添加WMS服务
    _addWMSService: function(url, layerName){
		var layerArr = layerName.split(",");
        if (!layerName) {
            return;
        };
        var globe = this.activexObj;
        if (globe) {
            var wmsObj = globe.GetOGCBox();//得到IWmsConMng对象
            if(null == url || undefined == url){
                url = "";
			}
            //设置wms服务地址并返回图层信息
            var layerBox = wmsObj.GetWmsLayersInfo(url);
            
            //遍历每一个图层信息  wmsObj.AddWmsInfoData();
			var ILayerWrapperArr = [];
            for (var j = 0,len = layerBox.GetWmsInfoCount(); j < len; j++) {
                var layerinfo = layerBox.GetWmsInfoByIndex(j);
                for(var m = 0;m < layerArr.length; m++) {
					if (layerinfo.Name == layerArr[m]) {
	                    var ILayerWrapper = wmsObj.ConSelecedLayers(false, 200, 1, 20, true, 255, "image/png", layerinfo);
	                    ILayerWrapper.Name = layerinfo.Name;
	                    globe.GetLayerBox().AddLayerData(ILayerWrapper);
						ILayerWrapperArr.push(ILayerWrapper);
                	};
				}
                
            };
			return ILayerWrapperArr;
        };
    },
    
	//添加WCS服务
    _addWCSService: function(url){
        var globe = this.activexObj;
		var ILayerWrapper = null;
        if (globe) {
			if(null == url || undefined == url){
                url = "";
			}
            var ILayerBox = globe.GetOGCBox().ConnectWCS(url);
			ILayerWrapper= ILayerBox.GetLayerByIndex(0);
        };
        return ILayerWrapper;
    },
	
	//添加矢量图层
	_addVectorLayer:function(){
		var activexObj =  this.activexObj;
		//创建矢量图层对象 GeometryLayer = 0; DynamicLayer = 1; ElementLayer = 2
		var geometryLayer = activexObj.ObjectFactory.CreateObject(0);
		//将矢量图层添加到地图
		activexObj.LayerBox.UserGroupLayer.AddLayer(geometryLayer);
		return geometryLayer;
	},
	
	_addDynamicLayer: function() {
		//创建矢量图层对象
		var activexObj = this.activexObj;
		var dynamicLayer = activexObj.ObjectFactory.CreateObject(1);
		//将矢量图层添加到地图
		activexObj.LayerBox.UserGroupLayer.AddLayer(dynamicLayer);
		return dynamicLayer;
	},
	
	//添加自定义图层
	_addCustomLayer: function(strJson){
		//创建自定义图层
		var activexObj = this.activexObj;
		var customLayer = activexObj.DataSourceBox.CreateLayerFromJson(strJson);
		//将自定义图层加到地图
		activexObj.LayerBox.UserGroupLayer.AddLayer(customLayer);
		return customLayer;
	},
	
	//转换颜色字符串为十进制
	_convertColorValue: function(webcolor){
		return new Number("0x00" + webcolor.replace("#",""));
	},
	
	//图层操作枚举
	_enumLayerOperateType: {
		"visible" : 1,
	//	"type" : 3,
		"opacity" : 2,
		"object" : 4,
		"layerBounds" : 3,//获取图层范围
		"wmsLayerinfo" : 6,
		"wmtsLayerinfo" : 7
		
	},
	
	/*
	 * 对图层相关属性进行操作
	 * 
	 */
	_createLayerOperate: function(number,layer,options) {
		var layerOperate = this.activexObj.LayerBox.CreateLayerOperate(layer);
		switch(number) {
			case this._enumLayerOperateType["visible"]:
			//	layerOperate.LayerProperty(number) = options.visible;
				layerOperate.ChangeLayerProperty(number, options.visible);
				break;
			case this._enumLayerOperateType["opacity"]:
//				layerOperate.LayerProperty(number) = parseInt(options.opacity * 255);
				layerOperate.ChangeLayerProperty(number, parseInt(options.opacity * 255));
			break;
			case this._enumLayerOperateType["layerBounds"]:
				var bbox = layerOperate.LayerProperty(number);
				bbox = eval(bbox);
				var bounds = new Geo.Bounds(bbox[2],bbox[1],bbox[3],bbox[0]);
				return bounds;
			break;
		}
		
	},	
	
    /**
     * Method: unloadDestroy
     * 窗口关闭时销毁地图对象的方法
     */	 
	unloadDestroy: function(){
	},

    CLASS_NAME: "Geo.View3D.Map"

});

//缺省海拨高度(米)
Geo.View3D.Map.DEFAULT_ALT = 2500000;

Geo.View3D.Map.getActivex = function(id){
    var version = "";
    var activexObj = null;
    try {
        //初始化插件
        activexObj = document.createElement("object");
        activexObj.classid = "CLSID:535CEBE1-7D19-4203-AA3B-B1B40167BF86";
        activexObj.width = "100%";
        activexObj.height = "100%"; 
        if(id){
            activexObj.id = id;
        }
        version = activexObj.Version;
    } 
    catch (e) {
    }
    return {
        obj:activexObj,
        version:version
    };
};

Geo.View3D.Map.getActivexVersion = function(){
	if(Geo.View3D.Map.activexVersion){
		return Geo.View3D.Map.activexVersion;
	}
	
    var GeoControlVersion;
    try{
        GeoControlVersion = new ActiveXObject("GeoSpace3D.ControlVersion.1");
		Geo.View3D.Map.activexVersion = GeoControlVersion.Version;
    }catch(e){
        return null;
    }
    return Geo.View3D.Map.activexVersion;
};

Geo.View3D.Map.ACTIVEX_DEFAULT_VERSION = "1.3.1.55185";

//图层级别换算成高度
Geo.View3D.Map.zoomMaping = [];
Geo.View3D.Map.zoomMaping[0] = 23000000;
Geo.View3D.Map.zoomMaping[1] = 15000000;
Geo.View3D.Map.zoomMaping[2] = 10000000;
Geo.View3D.Map.zoomMaping[3] = 9000000;
Geo.View3D.Map.zoomMaping[4] = 5916173;
Geo.View3D.Map.zoomMaping[5] = 2958087;
Geo.View3D.Map.zoomMaping[6] = 1479044;
Geo.View3D.Map.zoomMaping[7] = 739522;
Geo.View3D.Map.zoomMaping[8] = 369761;
Geo.View3D.Map.zoomMaping[9] = 184881;
Geo.View3D.Map.zoomMaping[10] = 92441;
Geo.View3D.Map.zoomMaping[11] = 46221;
Geo.View3D.Map.zoomMaping[12] = 23111;
Geo.View3D.Map.zoomMaping[13] = 11556;
Geo.View3D.Map.zoomMaping[14] = 5778;
Geo.View3D.Map.zoomMaping[15] = 2889;
Geo.View3D.Map.zoomMaping[16] = 1445;
Geo.View3D.Map.zoomMaping[17] = 723;
Geo.View3D.Map.zoomMaping[18] = 362;
Geo.View3D.Map.zoomMaping[19] = 181;
Geo.View3D.Map.zoomMaping[20] = 1;

/**
 * APIMethod: getZoomfromAlt
 * 根据高度返回金字塔级别。
 * 
 * Parameters:
 * alt - {Number} 海拔高度
 * Returns:
 * {Number} 金字塔级别 
 */
Geo.View3D.Map.getZoomfromAlt = function(alt){
    for (var i = 0; i < Geo.View3D.Map.zoomMaping.length; i++) {
    	// 如果当前高度大于等于级别为0的高度，则返回0。
    	if (alt >= Geo.View3D.Map.zoomMaping[0]) {
       		return i;
    	}
    	// 如果当前高度大于等于当前级别的高度并且小于前一级别换算的高度，则返回当前级别。
    	if (alt >= Geo.View3D.Map.zoomMaping[i] && i != 0 && alt < Geo.View3D.Map.zoomMaping[i - 1]) {
        	return i;
    	}
    	// 如果当前高度小于等于级别为20的高度，则返回20。
    	if (alt < Geo.View3D.Map.zoomMaping[Geo.View3D.Map.zoomMaping.length - 1]) {
        	return Geo.View3D.Map.zoomMaping.length - 1;
    	}
	}
};

/**
 * APIMethod: getAltfromZoom
 * 根据金字塔级别返回对应的三维海拔高度。
 * 
 * Parameters:
 * zoom - {Number} 金字塔级别
 * Returns:
 * {Number} 海拔高度
 */
Geo.View3D.Map.getAltfromZoom = function(zoom){
    var z = Geo.View3D.Map.zoomMaping[zoom];
    return z ? z : 0;
};

//根据金字塔级别返回对应的三维海拔高度
Geo.View3D.Map.getZfromLevel = Geo.View3D.Map.getAltfromZoom;

/**
 * APIProperty: activexErrorInfo
 * {String} 缺省三维插件错误提示信息。
 */	    
// Geo.View3D.Map.activexErrorInfo = "对不起，您电脑上未安装三维视图所需插件或插件版本不适合本系统，请重新安装适当版本后重新刷新本页面。";
Geo.View3D.Map.activexErrorInfo = "";

//为修复三维定位在某些地点，因海拨高度而撞地，限定到一定级别
Geo.View3D.Map.ZOOMTOEXTENT_MINILEVEL = 17;
/**
 * Class: Geo.View3D.Layer
 * 三维视图下的图层基类。本类不直接使用,需要由子类继承。
 */
Geo.View3D.Layer = Geo.Class({
	
    /**
     * APIProperty: id
     * {String} 唯一标识符。
     */
    id: null,

    /** 
     * APIProperty: name
     * {String} 图层名称。
     */
    name: null,
	
    /**
     * APIProperty: opacity
     * {Float} 图层的透明度，值在0.0与1.0之间。
     */
    opacity: null,
	
    /**
     * APIProperty: map
     * {Geo.View3D.Map} 图层所在的地图对象。
     */
    map: null,
	
    /** 
     * APIProperty: displayInLayerSwitcher
     * {Boolean} 图层名称是否在图层列表中显示,默认值为true。
     */
    displayInLayerSwitcher: true,
	
	/**
	 * APIProperty: isOnTop
	 * {Boolean} 图层是否在图层列表中置顶，默认值为false。
	 */
	isOnTop: false,
	
	/**
     * APIProperty: events
     * {<Geo.Events>} 事件对象。
     */
    events: null,	

    /**
     * APIProperty: visibility
     * {Boolean} 图层是否在地图中可见，默认值为true。
     */
    visibility: true,

    /**
     * Constant: EVENT_TYPES
     * {Array(String)} 图层对象所支持的事件类型。
     * 
     * 本对象支持以下事件类型：
     * visibilitychanged - 可视状态改变事件。
     */
    EVENT_TYPES: ["visibilitychanged"],
	
	/**
	 * Constructor: Geo.View3D.Layer
	 * Geo.View3D.Layer构造函数。
	 *
	 * Parameters:
	 * name - {String} 图层名称。
	 * options - {Object} 选项。
	 */	 
    initialize: function(name, options) {
		
		this.addOptions(options);
		
        this.name = name;
        
        if (this.id == null) {
            this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
			
			this.events = new OpenLayers.Events(this, this.div, 
                                                this.EVENT_TYPES);
            if(this.eventListeners instanceof Object) {
                this.events.on(this.eventListeners);
            }
        }
        
        this.opacity = 1.0;

    },

	/**
	 * Method: setMap
	 * 将图层关联到地图对象，如果该图层已经关联到地图对象了则不做任何操作。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>)} 地图对象。
	 */	
    setMap: function(map) {
        if (this.map != null) {
            return;
        }
        this.map = map;
		var activexObj = this.map.activexObj;
		//通过DataSourceBox可以获得图层对象
		this.dataSourceBox = activexObj.DataSourceBox;
		//通过LayerBox可以将图层添加到地图，也可以实现图层的显示隐藏删除等操作
		this.layerBox = activexObj.LayerBox;
    },

	/**
	 * APIMethod: removeMap
	 * 解除图层与地图对象的关联。
	 */	    
    removeMap: function() {
        //此方法由子类覆盖
    },

	/**
	 * APIMethod: getVisibility
	 * 获取图层可视状态。
	 * 
     * Returns:
     * {Boolean} 图层可视状态。
	 */	
    getVisibility: function() {
        return this.visibility;
    },

    /**
     * APIMethod: setVisibility
     * 设置图层是否可视。
     * 
	 * Parameters:
	 * visibility - {Boolean} 是否可见。
     */
    setVisibility: function(visibility) {
        if (visibility != this.visibility) {
            this.visibility = visibility;
            this.display(visibility);
        }
    },

    /**
     * Method: display
     * 显示或隐藏图层，此方法由子类覆盖。
     * 
	 * Parameters:
	 * display - {Boolean} 是否可见 。
     */
    display: function(display) {
        //此方法由子类覆盖
    },
	
    /**
     * APIMethod: setOpacity
     * 仅对透明度的值进行判断，如果与当前透明度相同则返回。
     * 
	 * Parameters:
	 * opacity - {Float} 
     */
    setOpacity: function(opacity) {
        if (opacity === this.opacity) {
            return;
        }
    },
	
    /**
     * APIMethod: getOptions
     * 获取图层构造参数。
     * 
     * Returns:
     * {Object} 图层构造参数。
     */
    getOptions: function() {
        var options = {};
        for(var o in this.options) {
            options[o] = this[o];
        }
        return options;
    },
	
    /**
     * APIMethod: addOptions
     * 添加图层构造参数。
     */
    addOptions: function (newOptions) {

        if (this.options == null) {
            this.options = {};
        }

        // update our copy for clone
        OpenLayers.Util.extend(this.options, newOptions);

        // add new options to this
        OpenLayers.Util.extend(this, newOptions);

    },
	
    /**
     * APIMethod: destroy
     * 销毁图层。
     */
	destroy: function(){
        this.map = null;
        this.name = null;
        this.dataSourceBox = null;
		this.layerBox = null;
        this.options = null;

        if (this.events) {
            if(this.eventListeners) {
                this.events.un(this.eventListeners);
            }
            this.events.destroy();
        }
        this.eventListeners = null;
        this.events = null;
	},
	
    CLASS_NAME: "Geo.View3D.Layer"
});
﻿/**
 * Class: Geo.View3D.BaseLayerGroup
 * 三维视图的底图图层组对象，可以将多个图层对象组合在一起，进行统一的加载和卸载操作。该图层组中的图层
 * 将做为地图中的底图置于所有图层的最下方。
 */
Geo.View3D.BaseLayerGroup = Geo.Class({

    /**
     * APIProperty: id
     * ｛String｝唯一标识符。
     */
    id: null,
    
    /**
     * APIProperty: layers
     * {Array} 图层集合。
     */
    layers: null,
    
    /**
     * APIProperty: map
     * 图层所在地图对象的引用。
     */
    map: null,
    
    /**
     * Constructor: Geo.View3D.BaseLayerGroup
     * Geo.View3D.LayerGroup构造函数。
     * 
     * Parameters:
     * options - {Object} 相关选项设置
     * 
     * 示例代码：
     * 
     * (code)
     * var vectorGroup = new Geo.View3D.BaseLayerGroup({
     *      layers: [
     *          new Geo.View3D.Layer.GlobeTile("全球1:100万矢量底图", "http://tile0.tianditu.com/services/A0512_EMap"), 
     *          new Geo.View3D.Layer.GlobeTile("全球1:100万矢量注记", "http://tile0.tianditu.com/services/AB0512_Anno")
     *      ]
     *  });
     * (end)
     */
    initialize: function(options){
        this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
        OpenLayers.Util.extend(this, options);
        if (!this.layers) 
            this.layers = [];
    },
    
    /**
     * APIMethod: setMap
     * 将图层组关联到地图
     *
     * Parameters:
     * map - {OpenLayers.Map} 设置地图对象
     */
    setMap: function(map){
        if (map && !this.map) {
            this.map = map;
            this.map.addLayers(this.layers);
        }
    },
    
    CLASS_NAME: "Geo.View3D.BaseLayerGroup"

});

Geo.View3D.BaseLayerGroup.getTianDiTuGroup = function(type){
    
    var typeMapping = {
        "img":[
            new Geo.View3D.Layer.GlobeTile("全球影像底图(2-10)", "http://tile0.tianditu.com/services/sbsm0210"),
            new Geo.View3D.Layer.GlobeTile("全球影像注记(2-10)", "http://tile0.tianditu.com/services/A0104_ImgAnnoE"),
            new Geo.View3D.Layer.GlobeTile("全国影像(14)", "http://tile0.tianditu.com/services/eastdawnall"),
            new Geo.View3D.Layer.GlobeTile("全球影像(15-18)", "http://tile0.tianditu.com/services/sbsm1518"),
            new Geo.View3D.Layer.GlobeTile("全国影像(13)", "http://tile0.tianditu.com/services/e13"),
            new Geo.View3D.Layer.GlobeTile("全国影像(12)", "http://tile0.tianditu.com/services/e12"),
            new Geo.View3D.Layer.GlobeTile("全国影像(11)", "http://tile0.tianditu.com/services/e11"),
            new Geo.View3D.Layer.GlobeTile("全国影像注记(11-14)", "http://tile0.tianditu.com/services/B0530_eImgAnno"),
            new Geo.View3D.Layer.GlobeTile("全国影像注记(15-18)", "http://tile0.tianditu.com/services/siweiAnno68")
        ],
        "dlg":[
            new Geo.View3D.Layer.GlobeTile("全国矢量(2-10)", "http://tile0.tianditu.com/services/A0512_EMap"),
            new Geo.View3D.Layer.GlobeTile("全国矢量注记(2-10)", "http://tile0.tianditu.com/services/AB0512_Anno"),
            new Geo.View3D.Layer.GlobeTile("全国矢量(11-12)", "http://tile0.tianditu.com/services/B0627_EMap1112"),
            new Geo.View3D.Layer.GlobeTile("全国矢量(13-18)", "http://tile0.tianditu.com/services/siwei0608")
        ]
    };
    
    var layers = typeMapping[type];
    if(layers){
        return new Geo.View3D.BaseLayerGroup({layers: layers});
    }
    return null;
}﻿//此类已被废弃，推荐使用Geo.View3D.BaseLayerGroup代替
Geo.View3D.LayerGroup = Geo.View3D.BaseLayerGroup;﻿/**
 * Class: Geo.View3D.Layer.ArcgisRest
 * 三维视图下的ArcGis REST服务图层对象。在三维视图下，添加ArcGis REST服务，请使用本类。
 * 
 * Inherits from:
 *  - <Geo.View3D.Layer>
 */
Geo.View3D.Layer.ArcgisRest = Geo.Class(Geo.View3D.Layer,{
    /**
     * APIProperty: id
     * {String} 唯一标识符。
     */
    id: null,
	
	/**
     * APIProperty: url
     * {String} 服务地址。
     */
    url: null,
    
    _layerData: null,
    
	/**
     * Constructor: Geo.View3D.Layer.ArcgisRest
     * 构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 选项。
  	 * 例如：
  	 * (code)
	 * 	  var layer = new Geo.View3D.Layer.ArcgisRest("arcgisRest", 
	 * 	  "http://services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/export",
	 *     {
	 *      	format:"png",//请求的图片格式，默认：jpeg,必填
	 *      	transparent: "TRUE"//请求的瓦片背景区域是否透明,默认：TRUE	
	 *     },
	 *     {	
	 *      	//支持级别，分辨率，比例的用法，任一选择
	 *      	topLevel:0,//顶层级别，默认：0
	 *      	bottomLevel:20,//底层级别，默认：20
	 *       	opacity : 1,//图层透明度设置，可以设置：0-1，默认：1
	 *      	projection: "EPSG:4326",//当前图层使用的投影,默认EPSG:4326
	 *       	width:"256",//图片宽度，默认：256
	 *       	height:"256",//图片高度，默认：256
	 *       	//图层范围,默认为全球范围：-180,-90,180,90,必填
	 *       	maxExtent:Geo.Bounds.fromString("73.446960,6.318641,135.085830,53.557926")	
	 *		    //支持分辨率
	 *		    //maxResolution :0.000005364418029785156,//最大分辨率
	 *  		//minResolution :0.703125//最小分辨率
	 *   		//支持比例尺
	 *   		//minScale : 2.958293554545656E8,
	 *   		//maxScale : 2256.998866688275
	 *     });。
	 * (end)           
     */	      
    initialize: function(name, url, params, options) {
       //与二维一致的新的三维图层加载方式
    	params = params || {};
    	params.pyramid = params.pyramid ? params.pyramid : new Geo.Pyramid();
//    	if(typeof params.projection == "string") {
//            this.projection = new Geo.Projection(params.projection);
//        }
//        if(this.projection && this.projection.getUnits()) {
//            this.units = this.projection.getUnits();
//        }
		if(options.maxResolution){
			params.bottomLevel = params.pyramid.getLevelForResolution(options.maxResolution);
		}
		if(options.minResolution){
			params.topLevel = params.pyramid.getLevelForResolution(options.minResolution);
		}
		
		if(options.maxScale){
			params.bottomLevel = params.pyramid.getLevelForScale(options.maxScale);
		}
		if(options.minScale){
			params.topLevel = params.pyramid.getLevelForScale(options.minScale);
		}
    	var args = [name, url, options];
    	this.params = params;
        Geo.View3D.Layer.GlobeTile.prototype.initialize.apply(this, args);
    },

	/**
	 * APIMethod: setMap
	 * 将图层关联到指定三维视图对象。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维视图对象。
	 */	
    setMap: function(map) {
		this._createLayerFromJson(map);
	},

	//自定义图层方式
    _createLayerFromJson : function(map){
    	var DEFAULT_PARAMS = 
		{ 
	      request: "GetTile",
	      styles: "",
	      format: "png"
	     };
	    /**所有的服务的公共参数**/ 
	    //默认为影像：ImageDataType，矢量：VectorDataType，模型数据：ModelDataType， Lod模型数据：LodModelDataType，POI数据：POIDataType
	    var dataType= this.params.dataType ? this.params.dataType : "ImageDataType";    
	    //设置图层透明度，默认:100，可以设置:0-100
	    var renderTransparency = this.params.opacity >= 0 ? this.params.opacity * 100 : 100;
	    //顶层级别，默认:0
	    var dataSetStartLevel = this.params.topLevel ? this.params.topLevel : 0;
	    //底层级别，默认:20
	    var dataSetEndLevel = this.params.bottomLevel ? this.params.bottomLevel : 20;
	    //图层地理范围，默认:-180,-90,180,90
	    var xMin = this.options.maxExtent ? this.options.maxExtent.left : -180;
	    var yMin = this.options.maxExtent ? this.options.maxExtent.bottom : -90;
	    var xMax = this.options.maxExtent ? this.options.maxExtent.right : 180;
	    var yMax = this.options.maxExtent ? this.options.maxExtent.top : 90;
	    //服务地址
	    var url = this.url;
	    //请求的图片格式
	    var format = this.params.format ? this.params.format : DEFAULT_PARAMS.format;
	    //请求的瓦片背景区域是否透明,默认为TURE
	    var transparent = this.params.transparent ? this.params.transparent : "TRUE";
	    //请求的图片宽度
	    var width = this.params.width ? this.params.width : 256;
	    //请求的图片高度
	    var height = this.params.height ? this.params.height : 256;
	    //获取投影
	    var projection = this.options.projection ? this.options.projection : "EPSG:4326";
	    //获取空间参数
	    var arr = projection.split(":");
	    var spatialReference = DEFAULT_PARAMS.spatialReference;
	    if(arr.length == 2){
	    	spatialReference = arr[1];
	    } else {
	    	spatialReference = arr[0];
	    }
	    //拼图层请求串
	    var layerJson = '{'+
		'"DataType":"'+dataType+'",'+
		'"DataSourceType":"Customer",'+
		'"StartLevel":'+dataSetStartLevel+','+
		'"EndLevel":'+dataSetEndLevel+','+
		'"XMin":'+xMin+','+
		'"YMin":'+yMin+','+
		'"XMax":'+xMax+','+
		'"YMax":'+yMax+','+
		'"SpatialReference":"'+spatialReference+'",' +
		'"RenderTransparency":'+renderTransparency+',' +
		'"ServerUrl":"'+ url +
		'?dpi=96&transparent='+transparent+'&format='+format+'&bbox=${TileXMin}%2C${TileYMin}%2C${TileXMax}%2C${TileYMax}' +
		'&size='+width+'%2C'+height+'&f=image';
		layerJson +='"}';
	    Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
	    var layer = this.dataSourceBox.CreateLayerFromJson(layerJson);
	    this.layerBox.UserGroupLayer.AddLayer(layer);
	    this._layerData = layer;
    },
	
	/**
	 * APIMethod: removeMap
	 * 取消三维视图对象与图层关联。
	 *
	 */	    
    removeMap: function() {
        var map = this.map;
        if(map){
            map._removeLayerData(this._layerData);
			this._layerData = null;
        }
		this.map = null;
    },


	/**
	 * APIMethod: setVisibility
	 * 设置图层是否可见。
	 *
	 * Parameters:
	 * visibility - {Boolean} 是否可见
	 */	
    setVisibility: function(visibility) {
        if (visibility != this.visibility) {
            this.visibility = visibility;
            this.display(visibility);
        }
    },

	/**
	 * APIMethod: display
	 *
	 * Parameters:
	 * display - {Boolean} 
	 */	
    display: function(display) {
        if(display != this._layerData.LayerData.Visible){
            this._layerData.LayerData.Visible = display;
        }
    },

	/**
	 * APIMethod: setOpacity
	 * 设置图层不透明度，数值在0-1.0之间。
	 *
	 * Parameters:
	 * opacity - {Float} 透明度。
	 */	
    setOpacity: function(opacity) {
        Geo.View3D.Layer.prototype.setOpacity.apply(opacity);
        var map = this.map;
        if(map){
            map._setLayerOpacity(this._layerData,opacity);
            this.opacity = opacity;
        }
    },

	/**
	 * APIMethod: gotoCenter
	 * 定位到图层中心点。
	 * 图层定位的方法是通过图层的范围大小，计算一个相机高度，来实现定位的。 
	 * 在实际应用过程中，存在通过范围定位的高度换算成金字塔层级会高于/低于当前瓦片显示的金字塔范围。 
	 * 有可能存在定位准了，但是相机高度不对，有时候需要往下缩小或者往上放大才能看到图层的现象。 
	 */	    
    gotoCenter:function(){
        var map = this.map;
        if(map){
            map._gotoLayer(this._layerData);
        }
    },
	 	
    CLASS_NAME: "Geo.View3D.Layer.ArcgisRest"
});/**
 * Class: Geo.View3D.Layer.GlobeTile
 * 三维视图下的吉奥瓦片服务图层对象。在三维视图下，添加瓦片服务，请使用本类。
 * 
 * Inherits from:
 *  - <Geo.View3D.Layer>
 */
Geo.View3D.Layer.GlobeTile = Geo.Class(Geo.View3D.Layer,{
    
    /**
     * APIProperty: id
     * {String} 唯一标识符。
     */
    id: null,
			
	/**
     * APIProperty: url
     * {String} 服务地址。
     */
    url: null,
	
	//吉奥瓦片图层类型
	_LAYER_TYPE_GLOBETILE:6,
	
    //私有图层对象
    _layerData: null,
    
	//判断用户使用的什么版本的api，由构造参数个数判断
	_oldLoad: null,
	/**
	 * Constructor: Geo.View3D.Layer.GlobeTile
	 * 构造函数。
	 *
	 * Parameters:
	 * name - {String} 服务名称。
	 * url - {String} 服务地址。
	 * options - {Object} 相关参数选项。
	 * 例如：
	 * (code)
	 * 	  var globeTile = new Geo.View3D.Layer.GlobeTile("globeTile", "http://192.168.40.69:9010/dlgtile0319/services/tile",
     *       	{
     *       		topLevel:1,//顶层级别，默认:0
	 *				bottomLevel:20,//底层级别，默认:20
	 *				maxExtent:Geo.Bounds.fromString("45,0,180,90"),//图层范围,默认范围:-180,-90,180,90，必填
     *       		opacity : 1,//图层透明度设置，可以设置：0-1，默认：1
     *       		projection: "EPSG:4326",//当前图层使用的投影,默认EPSG:4326
     *       		version:"5.0",//请求的服务版本，默认：2.0.0
	 *				//支持分辨率
	 *				//maxResolution :0.000005364418029785156,//最大分辨率
     *       		//minResolution :0.703125//最小分辨率
     *       		//支持比例尺
     *       		//minScale : 2.958293554545656E8,
     *       		//maxScale : 2256.998866688275      
     *       	});
     * (end)
	 */		      
    initialize: function(name, url, options) {
        //判断用户使用api版本
    	if(arguments.length < 3){
    		this._oldLoad = true;
    		Geo.View3D.Layer.prototype.initialize.apply(this,[name, options]);
        	this.url = url;
        	return;
    	}
    	//与二维一致的新的三维图层加载方式
    	options = options || {};
        options.pyramid = options.pyramid ? options.pyramid : new Geo.Pyramid();
		if(options.maxResolution){
			options.bottomLevel = options.pyramid.getLevelForResolution(options.maxResolution);
		}
		if(options.minResolution){
			options.topLevel = options.pyramid.getLevelForResolution(options.minResolution);
		}
		if(options.maxScale){
			options.bottomLevel = options.pyramid.getLevelForScale(options.maxScale);
		}
		if(options.minScale){
			options.topLevel = options.pyramid.getLevelForScale(options.minScale);
		}
		if(typeof options.projection == "string") {
        	this.projection = new Geo.Projection(options.projection);
        }
        if(this.projection && this.projection.getUnits()) {
            this.units = this.projection.getUnits();
        }
        Geo.View3D.Layer.prototype.initialize.apply(this,[name, options]);
        this.url = url;
    },

	/**
	 * Method: setMap
	 * 将图层关联到指定三维视图对象。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维视图对象。
	 */	
	setMap: function(map){
    	if(this._oldLoad){
    		this._oldSetMap(map);
    		return;
    	}
    	this._createLayerFromJson(map);
    },
    
    //老版本,参数内部构造
    _oldSetMap: function(map) {
        Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
		this._layerData = map._addGlobeTileService(this.url,"",this._LAYER_TYPE_GLOBETILE);
		this.display(this.visibility);
    },
    
     //自定义图层方式
    _createLayerFromJson : function(map){
    	var DEFAULT_PARAMS = 
		{ 
	      version: "2.0.0",
	      request: "GetTile",
	      styles: "",
	      format: "image/png",
	      spatialReference : "4326"
	     };
	    /**所有的服务的公共参数**/ 
	    //默认为影像：ImageDataType，矢量：VectorDataType，模型数据：ModelDataType， Lod模型数据：LodModelDataType，POI数据：POIDataType
	    var dataType= this.options.dataType ? this.options.dataType : "ImageDataType";    
	    //设置图层透明度，默认:100，可以设置:0-100
	    var renderTransparency = this.options.opacity >= 0 ? this.options.opacity * 100 : 100;
	    //顶层级别，默认:0
	    var dataSetStartLevel = this.options.topLevel ? this.options.topLevel : 0;
	    //底层级别，默认:20
	    var dataSetEndLevel = this.options.bottomLevel ? this.options.bottomLevel : 20;
	    //图层地理范围，默认:-180,-90,180,90
	    var xMin = this.options.maxExtent ? this.options.maxExtent.left : -180;
	    var yMin = this.options.maxExtent ? this.options.maxExtent.bottom : -90;
	    var xMax = this.options.maxExtent ? this.options.maxExtent.right : 180;
	    var yMax = this.options.maxExtent ? this.options.maxExtent.top : 90;
	    //服务地址
	    var url = this.url;
	    //请求的服务版本号，version版本为2.1的暂时不支持
	    var version = this.options.version ? this.options.version : DEFAULT_PARAMS.version;
	    //获取投影
	    var projection = this.options.projection ? this.options.projection : "EPSG:4326";
	    //获取空间参数
	    var arr = projection.split(":");
	    var spatialReference = DEFAULT_PARAMS.spatialReference;
	    if(arr.length == 2){
	    	spatialReference = arr[1];
	    } else {
	    	spatialReference = arr[0];
	    }
	    //拼图层请求串
	    var layerJson = '{'+
		'"DataType":"'+dataType+'",'+
		'"DataSourceType":"GeoTile",'+
		'"StartLevel":'+dataSetStartLevel+','+
		'"EndLevel":'+dataSetEndLevel+','+
		'"XMin":'+xMin+','+
		'"YMin":'+yMin+','+
		'"XMax":'+xMax+','+
		'"YMax":'+yMax+','+
		'"SpatialReference":"'+spatialReference+'",' +
		'"RenderTransparency":'+renderTransparency+',' +
		'"ServerUrl":"'+ url+'",' +
		'"Version":"'+ version;
		layerJson +='"}';
	    Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
	    var layer = this.dataSourceBox.CreateLayerFromJson(layerJson);
	    this.layerBox.UserGroupLayer.AddLayer(layer);
	    this._layerData = layer;	
    },

	/**
	 * Method: removeMap
	 * 取消三维视图对象与图层关联。
	 *
	 */	    
    removeMap: function() {
        var map = this.map;
        if(map){
            map._removeLayerData(this._layerData);
        }
		this.map = null;
    },


	/**
	 * Method: setVisibility
	 * 设置图层是否可见。
	 *
	 * Parameters:
	 * visibility - {Boolean} 是否可见。
	 */	
    setVisibility: function(visibility) {
        if (visibility != this.visibility) {
        	this.visibility = visibility;
            this.display(visibility);
        }
    },

	/**
	 * Method: display
	 *
	 * Parameters:
	 * display - {Boolean} 
	 */	
    display: function(display) {
		if(!this._layerData){
			return;
		}
        if(display != this._layerData.Visible){
			var map = this.map;
			map._setLayerVisibility(this._layerData,display);
        }
    },

	/**
	 * Method: setOpacity
	 * 设置图层不透明度，数值在0-1.0之间。
	 *
	 * Parameters:
	 * opacity - {Float} 透明度。
	 */	
    setOpacity: function(opacity) {
        Geo.View3D.Layer.prototype.setOpacity.apply(opacity);
        var map = this.map;
        if(map){
            if (this._layerData) {
                map._setLayerOpacity(this._layerData,opacity);
            }
            this.opacity = opacity;
        }
    },

	/**
	 * Method: gotoCenter
	 * 定位到图层中心点。
	 * 图层定位的方法是通过图层的范围大小，计算一个相机高度，来实现定位的。 
	 * 在实际应用过程中，存在通过范围定位的高度换算成金字塔层级会高于/低于当前瓦片显示的金字塔范围。 
	 * 有可能存在定位准了，但是相机高度不对，有时候需要往下缩小或者往上放大才能看到图层的现象。 
	 */	    
    gotoCenter:function(){
        var map = this.map;
        if(map){
            if (this._layerData) {
                map._gotoLayer(this._layerData);
            }
        }
    },
	 	
    CLASS_NAME: "Geo.View3D.Layer.GlobeTile"
});/**
 * Class: Geo.View3D.Layer.Shape
 * 本地SHAPE文件图层对象。
 *
 * Inherits from:
 *  - <Geo.View3D.Layer>
 */
Geo.View3D.Layer.Shape = Geo.Class(Geo.View3D.Layer, {
	
	_LAYER_TYPE_Shape : 3,	
	
    /**
     * Constructor: Geo.View3D.Layer.Shape
     * 构造函数。
     *
     * Parameters:
     * name - {String} 图层名称。
     * url - {String} 文件地址。
     * options - {Object} 选项。
     */
    initialize: function(name, url, options){
        Geo.View3D.Layer.prototype.initialize.apply(this, [name, options]);
        this.url = url;
    },
	
	/**
	 * Method: setMap
	 * 将图层关联到指定三维视图对象。
	 *
	 * Parameters:
	 * map - {Geo.View3D.Map} 三维视图对象。
	 */	
    setMap: function(map){
        Geo.View3D.Layer.prototype.setMap.apply(this, [map]);
        this._layerData = this._addShpDate(this.url);
    },
    
    //添加本地数据
    _addShpDate: function(path){
		var shapeLayer = this.dataSourceBox.CreateDataLayer(
                            this.url, null,
                          0);
		this.layerBox.UserGroupLayer.AddLayer(shapeLayer);
		this._layerData = shapeLayer;
    },
    
    CLASS_NAME: "Geo.View3D.Layer.Shape"
});
/**
 * Class: Geo.View3D.Layer.Terrain
 * 三维地形图层对象。
 *
 * Inherits from:
 *  - <Geo.View3D.Layer.GlobeTile>
 */
Geo.View3D.Layer.Terrain = Geo.Class(Geo.View3D.Layer.GlobeTile, {
	/**
     * APIProperty: id
     * {String} 唯一标识符。
     */
    id: null,
    
	/**
     * APIProperty: url
     * {String} 服务地址。
     */
    url: null,
	
	//私有图层对象
    _layerData: null,
    
	//判断用户使用的什么版本的api，由构造参数个数判断
	_oldLoad: null,
	
	/**
	 * Constructor: Geo.View3D.Layer.Terrain
	 * 构造函数。
	 *
	 * Parameters:
	 * name - {String} 服务名称。
	 * url - {String} 服务地址。
	 * options - {Object} 相关参数选项。
	 * 例如：
	 * (code)
	 * 	  var globeTile = new Geo.View3D.Layer.Terrain("Terrain", 
	 * 			"http://192.168.40.69:9010/dlgtile0319/services/tile",
     *       	{
     *       		topLevel:1,//顶层级别，默认:0
	 *				bottomLevel:20,//底层级别，默认:20
	 *				maxExtent:Geo.Bounds(45,0,180,90),//图层范围,默认范围:-180,-90,180,90，必填
     *       	});
     * (end)
	 */		      
    initialize: function(name, url, options) {
        //判断用户使用api版本
    	if(arguments.length < 3){
    		this._oldLoad = true;
    		Geo.View3D.Layer.prototype.initialize.apply(this,[name, options]);
        	this.url = url;
        	return;
    	}
    	//与二维一致的新的三维图层加载方式
    	options = options || {};
        options.pyramid = options.pyramid ? options.pyramid : new Geo.Pyramid();
		if(options.maxResolution){
			options.bottomLevel = options.pyramid.getLevelForResolution(options.maxResolution);
		}
		if(options.minResolution){
			options.topLevel = options.pyramid.getLevelForResolution(options.minResolution);
		}
		if(options.maxScale){
			options.bottomLevel = options.pyramid.getLevelForScale(options.maxScale);
		}
		if(options.minScale){
			options.topLevel = options.pyramid.getLevelForScale(options.minScale);
		}
		if(typeof options.projection == "string") {
        	this.projection = new Geo.Projection(options.projection);
        }
        if(this.projection && this.projection.getUnits()) {
            this.units = this.projection.getUnits();
        }
        Geo.View3D.Layer.prototype.initialize.apply(this,[name, options]);
        this.url = url;
    },	
			
	/**
	 * Method: setMap
	 * 将图层关联到指定三维视图对象。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维视图对象。
	 */	
    setMap: function(map) {
		if(this._oldLoad){
    		this._oldSetMap(map);
    		return;
    	}
    	this._createLayerFromJson(map);
    },
	
	/**
	 * Method: _oldSetMap
	 * 老版本，将图层关联到指定三维视图对象。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维视图对象。
	 */	
    _oldSetMap: function(map) {
        Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
		var TerrainDataset=this.dataSourceBox.CreateTerrainDataset(this.url);
	   	this.dataSourceBox.AddTerrainDataset(TerrainDataset);
		this._layerData = TerrainDataset;
	//	this.display(this.visibility);
    },	
	
	/**
	 * Method: _createLayerFromJson
	 * 自定义图层方式
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维视图对象。
	 */	
    _createLayerFromJson : function(map){
    	var DEFAULT_PARAMS = 
		{ 
	      version: "2.0.0",
	      request: "GetTile",
	      styles: "",
	      format: "image/png",
	      spatialReference : "4326"
	     };
	    //顶层级别，默认:0
	    var dataSetStartLevel = this.options.topLevel ? this.options.topLevel : 0;
	    //底层级别，默认:20
	    var dataSetEndLevel = this.options.bottomLevel ? this.options.bottomLevel : 20;
	    //图层地理范围，默认:-180,-90,180,90
	    var xMin = this.options.maxExtent ? this.options.maxExtent.left : -180;
	    var yMin = this.options.maxExtent ? this.options.maxExtent.bottom : -90;
	    var xMax = this.options.maxExtent ? this.options.maxExtent.right : 180;
	    var yMax = this.options.maxExtent ? this.options.maxExtent.top : 90;
	    //服务地址
	    var url = this.url;
	    //拼图层请求串
	    var layerJson = '{'+
		'"StartLevel":'+dataSetStartLevel+','+
		'"EndLevel":'+dataSetEndLevel+','+
		'"XMin":'+xMin+','+
		'"YMin":'+yMin+','+
		'"XMax":'+xMax+','+
		'"YMax":'+yMax+','+
		'"ServerUrl":"'+ url;
		layerJson +='"}';
	    Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
	    var layer = this.dataSourceBox.CreateTerrainDatasetFromJson(layerJson);
	    this.dataSourceBox.AddTerrainDataset(layer);
	    this._layerData = layer;	
    },	
    
    /**
	 * Method: removeMap
	 * 取消三维视图对象与图层关联。
	 *
	 */
    removeMap: function() {
		if (!this._layerData){
			return;
		}else{
			this._removeMap();
		}
    },
	
    /**
	 * Method: _removeMap
	 * 取消三维视图对象与图层关联。
	 *
	 */
    _removeMap: function() {
		if(this._oldLoad){
			//老版本的删除方法
	    	var map = this.map;
	    	if(map){
	    		var globe = map.activexObj;
	    		var camera = globe.Camera;
	    		var terrainAccessor	= camera.TerrainAccessor;
	    		terrainAccessor.remove(this._layerData);
	    	}
	    	this.map = null;
    	}else{
    		//新版本的删除方法
    		this.dataSourceBox.RemoveTerrainDataset(this._layerData);
    	}    	
    },
    
    /**
	 * Method: setVisibility
	 * 设置图层是否可见。
	 *
	 * Parameters:
	 * visibility - {Boolean} 是否可见。
	 */	
    setVisibility: function(visibility) {
        this.visibility = visibility;
        this.display(visibility);   	 
    },    
	
    /**
	 * Method: display
	 * 显示或者隐藏图层
	 * 
	 * Parameters:
	 * display - {Boolean} 
	 */	
    display: function(display) {
		if (!this._layerData){
			return;
		}else{
			this._display(display);
		}
    },
	
    /**
	 * Method: _display
	 * 显示或者隐藏图层
	 * 
	 * Parameters:
	 * display - {Boolean} 
	 */	
    _display: function(display) {
		this.map.activexObj.ConfigBox.SaveConfigItem(19, display);
		return;
    },	
	
    CLASS_NAME: "Geo.View3D.Layer.Terrain"
});
/**
 * Class: Geo.View3D.Layer.Vector
 * 三维视图下的矢量图层类。本类主要用于在三维地图上对矢量要素(点,线,面)进行操作。
 * 
 * Inherits from:
 *  - <Geo.View3D.Layer>
 */
Geo.View3D.Layer.Vector = Geo.Class(Geo.View3D.Layer,{
    
	//三维插件用的矢量图层。
  	_geometryLayer:null,
	
	//三维插件用的标注图层。
	_dynamicLayer: null,
    
    
    /** 
     * APIProperty: features
     * {Array(<Geo.Feature.Vector>)} 图层上所有要素。
     */	
    features: null,
    
    /** 
     * APIProperty: selectedFeatures
     * {Array(<Geo.Feature.Vector>)}  被选择的要素。
     */	
	selectedFeatures: null,

    /** 
     * APIProperty: style
     * {Object} 图层缺省样式。
     */
    style: null,
	
    /**
     * Property: styleMap
     * {<Geo.StyleMap>}
     */
    styleMap: null,

    /**
     * APIProperty: EVENT_TYPES
     * {Array(String)} 对象所支持的事件类型，使用以下方式可以为特定事件注册一个事件监听器。
     * (code)
     * layer.events.register(type, obj, listener);
     * (end)
     *
     */
    EVENT_TYPES: ["beforefeatureadded", "beforefeaturesadded",
                  "featureadded", "featuresadded", "beforefeatureremoved",
                  "beforefeaturesremoved", "featureremoved", "featuresremoved",
                  "beforefeatureselected", "featureselected", "featureunselected", 
                  "beforefeaturemodified", "featuremodified", "afterfeaturemodified",
                  "vertexmodified", "sketchstarted", "sketchmodified",
                  "sketchcomplete", "refresh"],
	
	/**
     * Constructor: Geo.View3D.Layer.Vector
     * 构造Geo.View3D.Layer.Vector对象实例。
     *
     * Parameters:
     * name - {String}  图层名称。
     * options - {Object} 选项。
     *
     */  			  
    initialize: function(name, options) {
		
        this.EVENT_TYPES =
            Geo.View3D.Layer.Vector.prototype.EVENT_TYPES.concat(
            Geo.View3D.Layer.prototype.EVENT_TYPES
        );
				
        this.features = [];
		this.selectedFeatures = [];
        Geo.View3D.Layer.prototype.initialize.apply(this,[name, options]);
    },
 	
	/**
	 * Method: setMap
	 * 将图层对象关联到地图。
	 *
	 * Parameters:
	 * map - {Geo.View3D.Map} 三维地图对象。
	 */	
    setMap: function(map) {
        Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
		this._geometryLayer = map._addVectorLayer();
		this._dynamicLayer = map._addDynamicLayer();
		this._layerData = this._geometryLayer;
    },

	/**
	 * APIMethod: addFeatures
	 * 向图层中添加要素。说明：三维中添加的要素的颜色设置只能设置为#开头的样式。
	 *
	 * Parameters:
	 * features - {Array(<Geo.Feature.Vector>)} 要素数组。
	 */	    
    addFeatures: function(features) {
        if (!(features instanceof Array)) {
            features = [features];
        }
        
        for (var i=0, len=features.length; i<len; i++) {
            var feature = features[i];
            
            if (!feature.style && this.style) {
                feature.style = OpenLayers.Util.extend({}, this.style);
            }
            this.features.push(feature);
            this.drawFeature(feature);
        }
        
    },
	
	/**
	 * APIMethod: drawFeature
	 * 画要素图层。
	 * 
	 * Parameters:
	 * features - {Object} 要素。
	 */
	drawFeature: function(feature) {
		var map = this.map;
        if (map) {
			map._drawGeometry({
				vectorLayerObj: this,
				featureid: feature.id,
				feature:feature,
				dynamicLayer: this._dynamicLayer,
				drawBox:this._geometryLayer,
				strPoints: this._getGeometryStr(feature.geometry),
				type: this._getGeometryType(feature.geometry),
				style: feature.style
			});
			feature.layer = this;
		}
	},

    /**
     * APIMethod: removeFeatures
     * 移除图层中的要素。
     * 
     * Parameters:
     * features - {Array(<Geo.Feature.Vector>)} 要素数组。
     */    
    removeFeatures: function(features) {
        if(!features) {
            return;
        }
        if (!(features instanceof Array)) {
            features = [features];
        }
        
        for (var i = features.length - 1; i >= 0; i--) {
            var feature = features[i];
            var map = this.map;
            if (map) {
				//如果是点要素，并且样式指定为图片渲染，则删除标注
				if(feature.style && feature.geometry.CLASS_NAME == "OpenLayers.Geometry.Point" 
							&& feature.style.externalGraphic){
					map._delBookMark(feature.id,this._dynamicLayer);
				} else {
					map._delGeometryByName(feature.id,this._geometryLayer);
				}
            }
            this.features = OpenLayers.Util.removeItem(this.features, feature);
        }
    },

    /**
     * APIMethod: destroyFeatures
     * 删除并且销毁图层上的要素。
     *
     * Parameters:
     * features - {Array(<Geo.Feature.Vector>)} 要销毁的要素数组，此项可选，如果无此项则销毁图层上所有要素。
     * options - {Object}
     */
    destroyFeatures: function(features, options) {
        var all = (features == undefined); // evaluates to true if
                                           // features is null
        if(all) {
            features = this.features;
        }
        if(features) {
            this.removeFeatures(features, options);
            for(var i=features.length-1; i>=0; i--) {
                features[i].destroy();
            }
        }
    },

    /**
     * Method: removeMap
     * 移除3D视图。
     *
     * Parameters:
	 * map - {Geo.View3D.Map} 三维视图对象。
     */
    removeMap: function(map) {
		var map = this.map;
        if(map){
			this.destroyFeatures(this.features);
			this._geometryLayer = null;
			this._dynamicLayer = null;
        }
		this.map = null;
    },


    /**
     * Method: setVisibility
     * 设置图层是否可见。
     * 
     * Parameters:
     * visibility - {Boolean} 图层是否可见
     */  
    setVisibility: function(visibility) {
        if (visibility != this.visibility) {
            this.visibility = visibility;
            this.display(visibility);
        }
    },

    /**
     * Method: display
     * 
     * Parameters:
     * display - {Boolean} 
     */  
    display: function(display) {
		var map = this.map;
        if(map){
			map._setLayerVisibility(this._layerData, display);
			map._setLayerVisibility(this._dynamicLayer, display);
        }
    },

    //得到几何对象的类型。
    _getGeometryType: function(geometry){
        var maping = {
            "OpenLayers.Geometry.Point": 0,
            "OpenLayers.Geometry.LineString": 1,
            "OpenLayers.Geometry.Polygon": 2
        }
        
        return maping[geometry.CLASS_NAME];
    },
	
    /**
     * APIMethod: getFeatureBy
     * 通过给定的属性和值来查找要素。
     *
     * Parameters:
     * property - {String} 要素对象属性。
     * value - {String} 指定属性的值。
     *
     * Returns:
     * {<Geo.Feature.Vector>} 返回符合给定值的要素，如果无符合则返回null。
     */
    getFeatureBy: function(property, value) {
        var feature = null;
        for(var i=0, len=this.features.length; i<len; ++i) {
            if(this.features[i][property] == value) {
                feature = this.features[i];
                break;
            }
        }
        return feature;
    },

    /**
     * APIMethod: getFeatureById
     * 查找并返回指定id的要素。
     *
     * Parameters:
     * featureId - {String} 要素对象的id属性值。
     *
     * Returns:
     * {<Geo.Feature.Vector>} 
     */
    getFeatureById: function(featureId) {
        return this.getFeatureBy('id', featureId);
    },

     //获取几何对象相应字符串
    _getGeometryStr:function (geometry){
        //替换所有指定字符串
        String.prototype.replaceAll = function(s1, s2){
            return this.replace(new RegExp(s1, "gm"), s2);
        }
        
        var str = geometry.toString();
        var start = str.indexOf("(") + 1;
        var end = str.indexOf(")");
//		if(geometry instanceof OpenLayers.Geometry.Point) {
//			return "POINT("+str.slice(start,end)+" 100000"+")";
//		}
		if(geometry instanceof OpenLayers.Geometry.LineString){
           var lineArr = str.slice(start,end).split(",");
		   for(var i = 0; i < lineArr.length; i++) {
	   	      lineArr[i] = (lineArr[i] + " 100000");
		   }
		   var line = lineArr.join(",");
		   return "LINESTRING("+line+")";
        }
        if(geometry instanceof OpenLayers.Geometry.Polygon){
			 var polygonArr = str.slice(start+1,end).split(",");
		   for(var i = 0; i < polygonArr.length; i++) {
	   	      polygonArr[i] = (polygonArr[i] + " 100000");
		   }
		   var line = polygonArr.join(",");
		   return "Ring("+line+")";
        }
        return str;
    },
	
    /** 
     * APIMethod: getDataExtent
     * 计算图层上所有要素的最大范围。
     * 
     * Returns:
     * {<Geo.Bounds>} 所有要素的范围。
     */
    getDataExtent: function () {
        var maxExtent = null;
        var features = this.features;
        if(features && (features.length > 0)) {
            maxExtent = new Geo.Bounds();
            var geometry = null;
            for(var i=0, len=features.length; i<len; i++) {
                geometry = features[i].geometry;
                if (geometry) {
                    maxExtent.extend(geometry.getBounds());
                }
            }
        }
        return maxExtent;
    },
	
    CLASS_NAME: "Geo.View3D.Layer.Vector"
});/**
 * Class: Geo.View3D.Layer.WMS
 * 三维视图中的WMS服务图层对象。
 * 
 * Inherits from:
 *  - <Geo.View3D.Layer.GlobeTile>
 */
Geo.View3D.Layer.WMS = Geo.Class(Geo.View3D.Layer.GlobeTile,{
    /**
     * APIProperty: id
     * {String} 唯一标识符。
     */
    id: null,
			
	/**
     * APIProperty: url
     * {String} 服务地址。
     */
    url: null,    

	_LAYER_TYPE_OGCWMS : 2,		
	/**
     * APIProperty: params
     * {String} WMS服务请求参数。
     */    
    params: null,
	
    //私有图层对象
    _layerData: null,

    //判断用户使用的什么版本的api，由构造参数个数判断
	_oldLoad: null,
						
	/**
	 * Constructor: Geo.View3D.Layer.WMS
	 * 构造函数。
	 *
	 * Parameters:
	 * name - {String} 服务名称。
	 * url - {String} 服务地址。
	 * params - {Object} 服务请求参数。
	 * options - {Object} 选项。
     * 例如：
     * (code)
	 * 	  var wmsLayer = new Geo.View3D.Layer.WMS("wms", "http://192.168.40.69:9010/wms0319/wms",
	 *          {
	 *           	version:"1.1.1"//请求的服务版本，如果为1.1.1对应srs,1.3.0对应crs，默认：1.1.1
	 *           	layers: "China400w",//请求的图层名称，必填
	 *           	format:"image/jpeg",//请求的图片格式，默认：image/jpeg
	 *           	transparent: "FALSE",//请求的瓦片背景区域是否透明,默认：TRUE		
	 *           },
	 *           {	
	 *           	//支持级别，分辨率，比例的用法，任一选择
	 *           	topLevel:0,//顶层级别，默认：0
	 *           	bottomLevel:20,//底层级别，默认：20
	 *           	opacity : 1,//图层透明度设置，可以设置：0-1，默认：1
	 *           	projection: "EPSG:4326",//当前图层使用的投影,默认EPSG:4326
	 *           	tileSize: new Geo.Size(256,256),//瓦片宽度，瓦片高度，默认：256，256
	 *           	//图层范围,默认为全球范围：-180,-90,180,90,必填
	 *           	maxExtent:Geo.Bounds.fromString("73.446960,6.318641,135.085830,53.557926"),	
	 *				//支持分辨率
	 *				//maxResolution :0.000005364418029785156,//最大分辨率
     *       		//minResolution :0.703125//最小分辨率
     *       		//支持比例尺
     *       		//minScale : 2.958293554545656E8,
     *       		//maxScale : 2256.998866688275
	 *           });。
	 *  (end)         
	 */	    
    initialize: function(name, url, params, options) {
        this.url = url;
     	//判断用户使用api版本
    	if(arguments.length < 4){
    		this._oldLoad = true;
    		Geo.View3D.Layer.GlobeTile.prototype.initialize.apply(this,[name, url, options]);
			if(params && !params.version){
				params.version = "1.3.0";
			}
	        this.params = params;
	        return;
    	}
    	//与二维一致的新的三维图层加载方式
    	params = params || {};
    	params.pyramid = params.pyramid ? params.pyramid : new Geo.Pyramid();
		if(options.maxResolution){
			options.bottomLevel = params.pyramid.getLevelForResolution(options.maxResolution);
		}
		if(options.minResolution){
			options.topLevel = params.pyramid.getLevelForResolution(options.minResolution);
		}
		
		if(params.maxScale){
			options.bottomLevel = params.pyramid.getLevelForScale(options.maxScale);
		}
		if(params.minScale){
			options.topLevel = params.pyramid.getLevelForScale(options.minScale);
		}
    	var args = [name, url, options];
    	this.params = params;
        Geo.View3D.Layer.GlobeTile.prototype.initialize.apply(this, args);
    },

    /**
     * Method: setMap
     * 将图层关联到指定三维视图对象。
     *
     * Parameters:
     * map - {Geo.View3D.Map} 三维视图对象。
     */
    setMap: function(map){
    	if(this._oldLoad){
    		this._oldSetMap(map);
    		return;
    	}
    	this._createLayerFromJson(map);
    },
    
	//老版本,参数内部构造
    _oldSetMap: function(map) {
        Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
		var wmsLayer = this.dataSourceBox.CreateDataLayer(this.url, this.params.version, this._LAYER_TYPE_OGCWMS);
		this.layerBox.UserGroupLayer.AddLayer(wmsLayer);
        this._layerData = wmsLayer;
    },
    
	//自定义图层方式
    _createLayerFromJson : function(map){
    	//默认参数
		var DEFAULT_PARAMS =
		{
		  service: "WMS",
	      version: "1.1.1",
	      request: "GetMap",
	      styles: "",
	      format: "image/jpeg",
	      spatialReference: "4326"
	     };
	    //服务数据类型，有两种类型，影像数据：ImageDataType，矢量数据：VectorDataType，默认：ImageDataType
	    var dataType= this.options.dataType ? this.options.dataType : "ImageDataType";
	    //设置图层透明度，默认:100，可以设置:0-100
	    var renderTransparency = this.options.opacity >= 0 ? this.options.opacity * 100 : 100;
	    //顶层级别，默认:0
	    var dataSetStartLevel = this.options.topLevel ? this.options.topLevel : 0;
	    //底层级别，默认:20
	    var dataSetEndLevel = this.options.bottomLevel ? this.options.bottomLevel : 20;
	    //图层地理范围，默认:-180,-90,180,90
	    var xMin = this.options.maxExtent ? this.options.maxExtent.left : -180;
	    var yMin = this.options.maxExtent ? this.options.maxExtent.bottom : -90;
	    var xMax = this.options.maxExtent ? this.options.maxExtent.right : 180;
	    var yMax = this.options.maxExtent ? this.options.maxExtent.top : 90;
	    //服务地址
	    var url = this.url;
	    //请求的服务版本号
	    var version = this.params.version ? this.params.version : DEFAULT_PARAMS.version;
	    /**私有参数**/
	    //请求的图层名称
	    var layers = this.params.layers ? this.params.layers : "";
	    //请求的图片格式
	    var format = this.params.format ? this.params.format : DEFAULT_PARAMS.format;
	    //请求的瓦片背景区域是否透明,默认为TURE
	    var transparent = this.params.transparent ? this.params.transparent : "TRUE";
	    //请求的图层样式
	    var styles = this.options.styles ? this.options.styles : DEFAULT_PARAMS.styles;
	    //获取瓦片大小
	    var tileSize =  this.options.tileSize ? this.options.tileSize : new Geo.Size(256,256);
	    //请求的图片宽度
	    var width = tileSize.w ? tileSize.w : 256;
	    //请求的图片高度
	    var height = tileSize.h ? tileSize.h : 256;
	    //获取投影
	    var projection = this.options.projection ? this.options.projection : "EPSG:4326";
	    //获取空间参数
	    var arr = projection.split(":");
	    var spatialReference = DEFAULT_PARAMS.spatialReference;
	    if(arr.length == 2){
	    	spatialReference = arr[1];
	    } else {
	    	spatialReference = arr[0];
	    }
	    //拼图层请求串
	    var layerJson = '{'+
		'"DataType":"'+dataType+'",'+
		'"DataSourceType":"Customer",'+
		'"StartLevel":'+dataSetStartLevel+','+
		'"EndLevel":'+dataSetEndLevel+','+
		'"XMin":'+xMin+','+
		'"YMin":'+yMin+','+
		'"XMax":'+xMax+','+
		'"YMax":'+yMax+','+
		'"SpatialReference":"'+spatialReference+'",' +
		'"RenderTransparency":'+renderTransparency+',' +
		'"ServerUrl":"'+url+''+
		'?SERVICE='+DEFAULT_PARAMS.service+'&Request=GetMap&VERSION='+version+'' +
		'&LAYERS='+layers+'&STYLES='+styles+'&FORMAT='+format+''+
		'&WIDTH='+width+'&HEIGHT='+height;
		//如果请求的服务版本为1.3，请求的投影设置为CRS,否则其它情况时，设置请求投影为SRS
		var srs = projection;
	    var crs = "";
		if(parseFloat(version) >= 1.3){
			layerJson += '&CRS='+srs+'';
			crs = srs;
		}else{
			layerJson += '&SRS='+srs+'';
		}
		//如果CRS不为空，并且开始字答串为EPSG，并且请求服务版本为1.3时，BBOX的请求串为ymin,xmin,ymax,xmax;否则都为xmin,ymin,xmax,ymax.
		if(crs != "" && parseFloat(version) == 1.3){
			layerJson += '&BBox=${TileYMin},${TileXMin},${TileYMax},${TileXMax}';
		}else{
			layerJson += '&BBox=${TileXMin},${TileYMin},${TileXMax},${TileYMax}';
		}
		layerJson +='"}';
	    Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
	    //根据拼好的请求字答串调用三维接口进行服务请求
	    var layer = this.dataSourceBox.CreateLayerFromJson(layerJson);
	    this.layerBox.UserGroupLayer.AddLayer(layer);
	    this._layerData = layer;
    },
    
	/**
	 * Method: display
	 *
	 * Parameters:
	 * display - {Boolean} 
	 */	
    display: function(display) {
    	var map = this.map;
		if(this._layerData && display != this._layerData.Visible){
			map._setLayerVisibility(this._layerData, display);
    	}
    },
	
	/**
	 * Method: setOpacity
	 * 设置图层不透明度，数值在0-1.0之间。
	 *
	 * Parameters:
	 * opacity - {Float} 透明度。
	 */	
    setOpacity: function(opacity) {
        Geo.View3D.Layer.prototype.setOpacity.apply(opacity);
        var map = this.map;
        if(map){
			map._setLayerOpacity(this._layerData,opacity);
	    	this.opacity = opacity;
        }
    },
	
	/**
	 * Method: gotoCenter
	 * 定位到图层中心点。
	 *
	 */	    
    gotoCenter:function(){
        var map = this.map;
        if(map){
            map._gotoLayer(this._layerData);
        }
    },
	
	/**
	 * Method: removeMap
	 * 取消三维视图对象与图层关联。
	 *
	 */	    
    removeMap: function() {
        var map = this.map;
        if(map){
			map._removeLayerData(this._layerData);
        }
		this.map = null;
    },
	 	
    CLASS_NAME: "Geo.View3D.Layer.WMS"
});/**
 * Class: Geo.View3D.Layer.WMTS
 * 三维视图OGC-WMTS服务图层对象。
 *
 * Inherits from:
 *  - <Geo.View3D.Layer.GlobeTile>
 */
Geo.View3D.Layer.WMTS = Geo.Class(Geo.View3D.Layer.GlobeTile, {

    /**
     * APIProperty: layerName
     * {String} 图层名称。
     */
    layerName: null,
	
    //图层类型
	_LAYER_TYPE_OGCWMTS : 4,
    
	//判断用户使用的什么版本的api，由构造参数个数判断
	_oldLoad: null,
	
    /**
     * Constructor: Geo.View3D.Layer.WMTS
     * 构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 选项。
     * 例如：
     * (code)
	 * 	  var wmtsLayer = new Geo.View3D.Layer.WMTS(
	 *          {
	 *           	name:"1-18级WMTS影像底图",//图层名称，必填
	 *           	url:"http://t0.tianditu.com/img_c/wmts",//服务URL地址，必填
	 *           	matrixSet:"c",//瓦片矩阵集，必填
	 *           	style:"default",//请求的样式，默认：""，必填
	 *           	layer: "img",//请求的图层名称，必填
	 *           	attribution:"1-18级WMTS影像底图",//图层信息
	 *           	format:"tiles",//请求的图片格式，默认：image/jpeg，必填
	 *           	//支持级别，分辨率，比例的用法，任一选择
	 *           	topLevel:0,//顶层级别，默认：0
	 *           	bottomLevel:20,//底层级别，默认：20
	 *           	tileFullExtent:Geo.Bounds.fromString("-180.0,-90.0,180.0,90.0"),//图层范围,缺省范围：-180,-90,180,90
	 *           	projection: "EPSG:4326",//当前图层使用的投影,默认EPSG:4326
	 *           	opacity : 1,//图层透明度设置，可以设置：0-1，默认：1
	 *           	version:"1.1.1"//服务版号，本默认为1.0.0
	 *				//支持分辨率
	 *				//maxResolution :0.000005364418029785156,//最大分辨率
     *       		//minResolution :0.703125//最小分辨率
     *       		//支持比例尺
     *       		//minScale : 2.958293554545656E8,
     *       		//maxScale : 2256.998866688275
	 *           });。
	 * (end)           
     */
    initialize: function(name, url, options){
        //判断用户使用api版本
    	if(typeof(arguments[0]) == "string"){
    		//老的三维图层加载方式传参为Name、URL
    		this._oldLoad = true;
    		Geo.View3D.Layer.GlobeTile.prototype.initialize.apply(this, [name, url, options]);
	        this.url = url;
	        options = options || {};
	        this.layerName = options.layer;
	        return;
    	}
    	
    	//与二维一致的新的三维图层加载方式
        var required = {
            url: true,
            layer: true,
            style: true,
            matrixSet: true
        };
        options = arguments[0] || {};
		/*
        for (var prop in required) {
            if (!(prop in options)) {
                throw new Error("Missing property '" + prop + "' in layer configuration.");
            }
        }
        */
        options.pyramid = options.pyramid ? options.pyramid : new Geo.Pyramid();
		if(options.maxResolution){
			options.bottomLevel = options.pyramid.getLevelForResolution(options.maxResolution);
		}
		if(options.minResolution){
			options.topLevel = options.pyramid.getLevelForResolution(options.minResolution);
		}
		
		if(options.maxScale){
			options.bottomLevel = options.pyramid.getLevelForScale(options.maxScale);
		}
		if(options.minScale){
			options.topLevel = options.pyramid.getLevelForScale(options.minScale);
		}
    	var args = [options.name, options.url, options];
        Geo.View3D.Layer.GlobeTile.prototype.initialize.apply(this, args);
    },
    
     /**
     * Method: setMap
     * 将图层关联到指定三维视图对象。
     *
     * Parameters:
     * map - {Geo.View3D.Map} 三维视图对象。
     */
    setMap: function(map){
    	if(this._oldLoad){
    		this._oldSetMap(map);
    		return;
    	}
    	this._createLayerFromJson(map);
    },
    
    //老版本,参数内部构造
    _oldSetMap: function(map){
        Geo.View3D.Layer.prototype.setMap.apply(this, [map]);
	 	var wmtsLayer = this.dataSourceBox.CreateDataLayer(this.url, "", this._LAYER_TYPE_OGCWMTS);
		//吉奥瓦片图层对象
		this.layerBox.UserGroupLayer.AddLayer(wmtsLayer);
		this._layerData = wmtsLayer;
		this.display(this.visibility);
    },
    
    //自定义图层方式
    _createLayerFromJson : function(map){
    	//默认参数值
    	var DEFAULT_PARAMS =
		{ 
		  service: "WMTS",
	      version: "1.0.0",
	      request: "GetTile",
	      styles: "",
	      format: "image/png",
	      spatialReference: "4326",
	      hasTemporal:"false"
	     };
	    //服务数据类型，有两种类型，影像数据：ImageDataType，矢量数据：VectorDataType，默认：ImageDataType
	    var dataType= this.options.dataType ? this.options.dataType : "ImageDataType";
	    //设置图层透明度，默认:100，可以设置:0-100
	    var renderTransparency = this.options.opacity >= 0 ? this.options.opacity * 100 : 100;
	    //顶层级别，默认:0
	    var dataSetStartLevel = this.options.topLevel ? this.options.topLevel : 0;
	    //底层级别，默认:20
	    var dataSetEndLevel = this.options.bottomLevel ? this.options.bottomLevel : 20;
	    //图层地理范围，默认:-180,-90,180,90
	    var xMin = this.options.tileFullExtent ? this.options.tileFullExtent.left : -180;
	    var yMin = this.options.tileFullExtent ? this.options.tileFullExtent.bottom : -90;
	    var xMax = this.options.tileFullExtent ? this.options.tileFullExtent.right : 180;
	    var yMax = this.options.tileFullExtent ? this.options.tileFullExtent.top : 90;
	    //服务地址
	    var url = this.url;
	    //请求的服务版本号
	    var version = this.options.version ? this.options.version : DEFAULT_PARAMS.version;
	    //请求的图层名称
	    var layer = this.options.layer ? this.options.layer : "";
	    //请求的图片格式
	    var format = this.options.format ? this.options.format : DEFAULT_PARAMS.format;
	    //请求的图层样式
	    var style = this.options.style ? this.options.style : "";
	    //瓦片矩阵集
	    var matrixSet = this.options.matrixSet ? this.options.matrixSet:"";
	    //获取投影
	    var projection = this.options.projection ? this.options.projection : "EPSG:4326";
	    //获取空间参数
	    var arr = projection.split(":");
	    var spatialReference = DEFAULT_PARAMS.spatialReference;
	    if(arr.length == 2){
	    	spatialReference = arr[1];
	    } else {
	    	spatialReference = arr[0];
	    }
	    //是否加载多时相服务
	    var hasTemporal = this.options.hasTemporal ? this.options.hasTemporal : DEFAULT_PARAMS.hasTemporal;
	    //拼图层请求串
	    var layerJson = '{'+
		'"DataType":"'+dataType+'",'+
		'"DataSourceType":"WMTS",'+
		'"StartLevel":'+dataSetStartLevel+','+
		'"EndLevel":'+dataSetEndLevel+','+
		'"XMin":'+xMin+','+
		'"YMin":'+yMin+','+
		'"XMax":'+xMax+','+
		'"YMax":'+yMax+','+
		'"SpatialReference":"'+spatialReference+'",' +
		'"RenderTransparency":'+renderTransparency+',' +
		'"HasTemporal":"'+ hasTemporal +'",'+
		'"ServerUrl":"'+ url+'",'+
		'"Version":"'+ version+'",'+
		'"Layers":"' + layer + '",' +
		'"Styles":"' + style + '",' +
		'"ImageFormat":"' + format + '",' +
		'"TileMatrixSet":"' + matrixSet;
		layerJson +='"}';
	    Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
	    var layer = this.dataSourceBox.CreateLayerFromJson(layerJson);
	    this.layerBox.UserGroupLayer.AddLayer(layer);
	    //是否启用多时相功能
	    this.layerBox.EnableTemporal=hasTemporal;
	    this._layerData = layer;
    },
    
     /**
     * Method: changeTemporal
     * 通过时间轴显示多时相数据。
     *
     * Parameters:
     * @param {String} varTime。
     */
	changeTemporal : function(varTime) {
		this.layerBox.ChangeTemporal(varTime);
	},
    
    /**
     * Method: removeMap
     * 取消三维视图对象与图层关联。
     *
     */
    removeMap: function(){
        var map = this.map;
        if (map) {
        	map._removeLayerData(this._layerData);
        }
        this.map = null;
    },
    
    /**
     * Method: display
     *
     * Parameters:
     * display - {Boolean}
     */
    display: function(display){
    	var map = this.map;
		if(!this._layerData){
			return;
		}
        if (display != this._layerData.Visible) {
			map._setLayerVisibility(this._layerData, display);
        }
    },
    
    /**
     * Method: gotoCenter
     * 定位到图层中心点。
     *
     */
    gotoCenter: function(){
        var map = this.map;
        if (map) {
			if(this._layerData){
				map._gotoLayer(this._layerData);
			}
        }
    },
    
    /**
     * Method: setOpacity
     * 设置图层不透明度，数值在0-1.0之间。
     *
     * Parameters:
     * opacity - {Float} 透明度。
     */
    setOpacity: function(opacity){
        Geo.View3D.Layer.prototype.setOpacity.apply(opacity);
        var map = this.map;
        if (map) {
            if (this._layerData) {
                map._setLayerOpacity(this._layerData, opacity);
                this.opacity = opacity;
            }
        }
    },
	
     /**
     * Method: showHistory
     * 显示多时相时间轴。
     *
     * Parameters:
     * visible - {Boolean} 是否显示时间轴，true为显示，false为不显示。
     * locationX - {Number} 时间轴在球体上的显示的横坐标位置。
     * locationY - {Number} 时间轴在球体上的显示的纵坐标位置。
     */
	showHistory: function(visible,locationX,locationY){
		 var map = this.map;
         if (map) {
		 	var varHis = map.activexObj.SceneBox.TemporalRuler;
			if(locationX)varHis.LocationX = locationX;
            if(locationY)varHis.LocationY = locationY;
		 	varHis.Visible = visible;
		 }
    },
	
    CLASS_NAME: "Geo.View3D.Layer.WMTS"
});
/**
 * Class: Geo.View3D.Layer.WTFS
 * 三维视图下的吉奥三维地名服务图层对象
 *
 * Inherits from:
 *  - <Geo.View3D.Layer.GlobeTile>
 */
Geo.View3D.Layer.WTFS = Geo.Class(Geo.View3D.Layer.GlobeTile, {
	/**
     * APIProperty: id
     * {String} 唯一标识符。
     */
    id: null,
    
	/**
     * APIProperty: url
     * {String} 服务地址。
     */
    url: null,
	
	//吉奥瓦片图层类型
	_LAYER_TYPE_GLOBETILE:6,
    
	//私有图层对象
    _layerData: null,
    
	//判断用户使用的什么版本的api，由构造参数个数判断
	_oldLoad: null,
	
	/**
	 * Constructor: Geo.View3D.Layer.WTFS
	 * 构造函数。
	 *
	 * Parameters:
	 * name - {String} 服务名称。
	 * url - {String} 服务地址。
	 * options - {Object} 相关参数选项。
	 * 例如：
	 * (code)
	 * 	  var wtfsLayer = new Geo.View3D.Layer.WTFS("wtfs", "http://192.168.40.69:9010/wtfs0319/wtfs",
	 *          {
	 *           	maxExtent:Geo.Bounds.fromString("-180,-90,180,90"),//图层范围,默认范围：-180,-90,180,90,必填
	 *           	opacity : 1,//图层透明度设置，可以设置：0-1，默认：1
	 *           	projection: "EPSG:4326",//当前图层使用的投影,默认EPSG:4326
	 *           	version:"1.1.1"//服务版号，本默认为1.1.1
	 *           	//支持级别，分辨率，比例的用法，任一选择
	 *           	topLevel:0,//顶层级别，默认：0
	 *				bottomLevel:20//底层级别，默认：20
	 *				//支持分辨率
	 *				//maxResolution :0.000005364418029785156,//最大分辨率
     *       		//minResolution :0.703125//最小分辨率
     *       		//支持比例尺
     *       		//minScale : 2.958293554545656E8,
     *       		//maxScale : 2256.998866688275
	 *           });。
	 *  (end)
	 */		      
    initialize: function(name, url, options) {
    	//判断用户使用api版本
    	if(arguments.length < 3){
    		this._oldLoad = true;
    		Geo.View3D.Layer.prototype.initialize.apply(this,[name, options]);
        	this.url = url;
        	return;
    	}
    	//与二维一致的新的三维图层加载方式
    	options = options || {};
        options.pyramid = options.pyramid ? options.pyramid : new Geo.Pyramid();
		if(options.maxResolution){
			options.bottomLevel = options.pyramid.getLevelForResolution(options.maxResolution);
		}
		if(options.minResolution){
			options.topLevel = options.pyramid.getLevelForResolution(options.minResolution);
		}
		if(options.maxScale){
			options.bottomLevel = options.pyramid.getLevelForScale(options.maxScale);
		}
		if(options.minScale){
			options.topLevel = options.pyramid.getLevelForScale(options.minScale);
		}
		if(typeof options.projection == "string") {
        	this.projection = new Geo.Projection(options.projection);
        }
        if(this.projection && this.projection.getUnits()) {
            this.units = this.projection.getUnits();
        }
        Geo.View3D.Layer.prototype.initialize.apply(this,[name, options]);
        this.url = url;
    },

	/**
	 * Method: setMap
	 * 将图层关联到指定三维视图对象。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维视图对象。
	 */	
	setMap: function(map){
    	if(this._oldLoad){
    		this._oldSetMap(map);
    		return;
    	}
    	this._createLayerFromJson(map);
    },
    
    //老版本,参数内部构造
    _oldSetMap: function(map) {
       Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
		this._layerData = map._addGlobeTileService(this.url,"",this._LAYER_TYPE_GLOBETILE);
		this.display(this.visibility);
    },
    
     //自定义图层方式
    _createLayerFromJson : function(map){
    	var DEFAULT_PARAMS = 
		{ 
	      version: "1.1.1",
	      request: "GetTile",
	      styles: "",
	      format: "image/png",
	      spatialReference : "4326"
	     };
	    /**所有的服务的公共参数**/ 
	    //设置图层透明度，默认:100，可以设置:0-100
	    var renderTransparency = this.options.opacity >= 0 ? this.options.opacity * 100 : 100;
	    //顶层级别，默认:0
	    var dataSetStartLevel = this.options.topLevel ? this.options.topLevel : 0;
	    //底层级别，默认:20
	    var dataSetEndLevel = this.options.bottomLevel ? this.options.bottomLevel : 20;
	    //图层地理范围，默认:-180,-90,180,90
	    var xMin = this.options.maxExtent ? this.options.maxExtent.left : -180;
	    var yMin = this.options.maxExtent ? this.options.maxExtent.bottom : -90;
	    var xMax = this.options.maxExtent ? this.options.maxExtent.right : 180;
	    var yMax = this.options.maxExtent ? this.options.maxExtent.top : 90;
	    //服务地址
	    var url = this.url;
	    //请求的服务版本号，version版本为2.1的暂时不支持
	    var version = this.options.version ? this.options.version : DEFAULT_PARAMS.version;
	    //获取投影
	    var projection = this.options.projection ? this.options.projection : "EPSG:4326";
	    //获取空间参数
	    var arr = projection.split(":");
	    var spatialReference = DEFAULT_PARAMS.spatialReference;
	    if(arr.length == 2){
	    	spatialReference = arr[1];
	    } else {
	    	spatialReference = arr[0];
	    }
	    //拼图层请求串
	    var layerJson = '{'+
		'"DataType":"POIDataType",'+
		'"DataSourceType":"GeoTile",'+
		'"StartLevel":'+dataSetStartLevel+','+
		'"EndLevel":'+dataSetEndLevel+','+
		'"XMin":'+xMin+','+
		'"YMin":'+yMin+','+
		'"XMax":'+xMax+','+
		'"YMax":'+yMax+','+
		'"SpatialReference":"'+spatialReference+'",' +
		'"RenderTransparency":'+renderTransparency+',' +
		'"ServerUrl":"'+ url+'",' +
		'"Version":"'+ version;
		layerJson +='"}';
	    Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
	    var layer = this.dataSourceBox.CreateLayerFromJson(layerJson);
	    this.layerBox.UserGroupLayer.AddLayer(layer);
	    this._layerData = layer;	
    },
    
    CLASS_NAME: "Geo.View3D.Layer.WTFS"
});
/**
 * Class: Geo.View3D.Layer.Solid
 * 立方体图层对象。
 *
 * Inherits from:
 *  - <Geo.View3D.Layer>
 */
Geo.View3D.Layer.Solid = Geo.Class(Geo.View3D.Layer, {

    /**
     * APIProperty: geometry
     * {Object} 当前绘制的几何对象。
     */
    geometry: null,
    
    /**
     * APIProperty: height
     * {String} 当前绘制的几何对象的高度。
     */
    height: null,
    
    /**
     * APIProperty: faceColor
     * {Object}当前绘制的几何对象的颜色属性。
     */
    faceColor: null,
    
    _localDataBox: null,
    
    _layerData: null,
    
    /**
     * Constructor: Geo.View3D.Layer.Solid
     * Geo.View3D.Layer.Solid的构造函数。
     *
     * Parameters:
     * name - {String} 图层名称。
     * geometry - {Geo.Geometry} 绘制的集合对象。
     * height - {String} 海拔高度。
     * options - {Object} 选项。
     *
     * 示例:
     * (code)
     *
     *   solidLayer = new Geo.View3D.Layer.Solid("solid", polygon, 30000);
     *  
     *   //设置正方体中心点
     *     1.WKT字符串 2.暂时不用 3.//第三个参数1表示point ,2表示lineString,3表示Ring,4表示Model，5表示 Box
            a2 = GlobeCtrl.DrawBox.CreateGeometryObject("POINT(110 35 100)", "", 1, 1);
            //设置符号
            var b = GlobeCtrl.DrawBox.CreateSymbolObject(1);
            b.Color = -13660459;
            //设置正方体棱长
            b.Box = GlobeCtrl.DrawBox.CreateGeometryObject("", "", 5, 1);
            b.Size=200;
            GlobeCtrl.DrawBox.AddDrawObject(a2, b);
     *
     *  (end)
     */
    initialize: function(name, geometry, height, options){
//        this.faceColor = {
//            top: 0x7fffffff,
//            bottom: 0x7fffffff,
//            round: 0x7fffffff
//        };
		this.faceColor = {
            Color: -13660459,
            Size: 200
        };
        
        this.geometry = geometry;
        this.height = height;
        Geo.View3D.Layer.prototype.initialize.apply(this, [name, options]);
    },
	
	_getSolidSymbol: function() {
		//设置符号
        this._localDataBox = this._drawBox.CreateSymbolObject(1);
        this._localDataBox.Color = this.faceColor.Color;
        //设置正方体棱长
        this._localDataBox.Box = this._drawBox.CreateGeometryObject("", "", 5, 1);
        this._localDataBox.Size = this.faceColor.Size;
		return this._localDataBox;
	},
	
    /**
     * Method: setMap
     * 将图层关联到指定三维视图对象。
     *
     * Parameters:
     * map - {Geo.View3D.Map} 三维视图对象。
     *
     * 示例:
     * (code)
     *  var map = new Geo.View3D.Map("simpleMap");
     *  solidLayer = new Geo.View3D.Layer.Solid("solid", polygon, 30000);
     *  solidLayer.setMap(map);
     *  (end)
     */
    setMap: function(map){
        Geo.View3D.Layer.prototype.setMap.apply(this, [map]);
		this._drawBox = this.map.activexObj.DrawBox;
        this._layerData = this._createBoxLayer(this.geometry, this.height);
    },
    
    /**
     * Method: removeMap
     * 取消三维视图对象与图层关联。
     *
     * 示例:
     * (code)
     *  var map = new Geo.View3D.Map("simpleMap");
     *  solidLayer = new Geo.View3D.Layer.Solid("solid", polygon, 30000);
     *  solidLayer.setMap(map);
     *  solidLayer.removeMap();
     *  (end)
     */
    removeMap: function(){
        var map = this.map;
        if (map) {
            this._clearBoxLayer();
        }
        this.map = null;
    },
    
    /**
     * APIMethod: setHeight
     * 设置盒子高度。
     *
     * Parameters:
     * height - {Number} 海拔高度。
     *
     * 示例:
     * (code)
     *  solidLayer = new Geo.View3D.Layer.Solid("solid", polygon, 30000);
     *  solidLayer.setHeight(3000);
     *  (end)
     */
    setHeight: function(height){
		if (this._localDataBox && height) {
	        this._localDataBox.Box.Width = height;
	    }
//        if (this._localDataBox) {
//            this._localDataBox.setPolyGonHeight(this._layerData.Name, height);
//        }
    },
    
    /**
     * APIMethod: setFaceColor
     * 设置盒子颜色。
     *
     * Parameters:
     * colorParams - {Object} 颜色参数。
     * 
     * 示例:
     * (code)
     *  solidLayer = new Geo.View3D.Layer.Solid("solid", polygon, 30000);
     *  solidLayer.setFaceColor({
     *  top: 0x7f1760bf,
     *  bottom: 0x7f1760bf,
     *  round: 0x7f1760bf
     *  });
     *  (end)
     */
    setFaceColor: function(colorParams){
        this.faceColor = OpenLayers.Util.extend(this.faceColor, colorParams);
//        if (this._localDataBox) {
//            var boxLayerId = this._layerData.Name;
//            this._localDataBox.SetBoxFaceColor(boxLayerId, this.faceColor.top, this.faceColor.bottom, this.faceColor.round);
//        }
		//目前只支持设置立方体的一种颜色，不支持立方体的上面，下面和周边颜色的设置
		
		if(this.faceColor.top) {
			this._localDataBox.Color = Geo.Util.ToArgb(this.faceColor.top,255);
		}else if(this.faceColor.bottom) {
			this._localDataBox.Color = Geo.Util.ToArgb(this.faceColor.bottom,255);
		}else if(this.faceColor.round) {
			this._localDataBox.Color = Geo.Util.ToArgb(this.faceColor.round,255);
		}
    },
    
    
    // 画盒子图层
    _createBoxLayer: function(polygonGeometry, height){
		var centerPoint = polygonGeometry.getBounds().getCenterLonLat();
		var pointGeometry  = new Geo.Geometry.Point(centerPoint.lon, centerPoint.lat);
		var str = pointGeometry.toString();
        var start = str.indexOf("(") + 1;
        var end = str.indexOf(")");
		var point = str.slice(start,end);
		var pointWkt = "POINT(" + point + " " + height + ")";
    	this._layerData = this._drawBox.CreateGeometryObject(pointWkt, "", 1, 1);
		var symbol = this._getSolidSymbol();
		this._drawBox.AddDrawObject(this._layerData, symbol);
		this.map.activexObj.SceneBox.ParabolaFlyTo(centerPoint.lon, centerPoint.lat, 1000);
		return this._layerData;
//        var Globe = this.map.activexObj;
//        
//        // 画盒子用接口
//        if (!this._localDataBox) {
//            this._localDataBox = Globe.CreateAddLocalDataObj();
//        }
//        
//        var pointstr = this._getPointsThreeDegreeSpaceSplitStr(polygonGeometry, 0);
//        
//        
//        var boxLayerId = this.id + "_boxLayer";
//        
//        var layerdata = this._localDataBox.AddPolyGon(boxLayerId, pointstr);
//        layerdata.Name = boxLayerId;
//        this._localDataBox.setPolyGonHeight(boxLayerId, height);
//        this._localDataBox.SetBoxFaceColor(boxLayerId, this.faceColor.top, this.faceColor.bottom, this.faceColor.round);
        
    },
    
    // 删除盒子图层
    _clearBoxLayer: function(){
		this._drawBox.RemoveObject(this._layerData);
		this._layerData = null;
//        var Globe = this.map.activexObj;
//        var layer = Globe.GetSceneGroup().GetLayerByName(this.id + "_boxLayer");
//        if (layer != null) {
//            Globe.GetSceneGroup().RemoveLayer(layer);
//        }
    },
    
    //将二维点数组，加上指高度形成三维点数组转换成空格分隔的字符串
    _getPointsThreeDegreeSpaceSplitStr: function(polygonGeometry, height){
        var linearRing = polygonGeometry.components[0];
        var allPoints = linearRing.components;
        
        var points = [];
        for (var i = 0; i < allPoints.length; i++) {
            points.push(allPoints[i].x);
            points.push(allPoints[i].y);
            points.push(height);
        }
        return points.join(" ");
    },
    
    CLASS_NAME: "Geo.View3D.Layer.Solid"
});
/**
 * Class: Geo.View3D.Layer.WCS
 * 三维视图OGC-WCS服务图层对象。
 * 
 * Inherits from:
 *  - <Geo.View3D.Layer.GlobeTile>
 */
Geo.View3D.Layer.WCS = Geo.Class(Geo.View3D.Layer.GlobeTile, {

    setMap: function(map){
        Geo.View3D.Layer.prototype.setMap.apply(this, [map]);
        this._layerData = map._addWCSService(this.url);
		this.display(this.visibility);
    },
    
    CLASS_NAME: "Geo.View3D.Layer.WCS"
});
/**
 * Class: Geo.View3D.Layer.Grid
 * 三维下的自定义图层。
 * 
 * Inherits from:
 *  - <Geo.View3D.Layer>
 */
Geo.View3D.Layer.Grid = Geo.Class(Geo.View3D.Layer,{
	/**
	 * APIProperty: id
	 * {String} 唯一标识符。
	 */
	id:null,
	/**
	 * APIProperty: topLevel
	 * {Number} 顶层级别 默认为0。
	 */
	topLevel:0,
	/**
	 * APIProperty: buttomLevel
	 * {Number} 底层级别 默认为0。
	 */
	buttomLevel:0,
	/**
	 *  APIProperty: maxExtent
	 * {Object} 图层范围，缺省范围是-180,-90,180,90。
	 */
	maxExtent:null,
	/**
	 * APIProperty: dataType
	 * {String} 默认值为"ImageDataType"。
	 */
	dataType:"ImageDataType",
	/**
	 * APIProperty: url
	 * {String} 用户自定义服务，必须填写。
	 */
	url:null,
	/**
	* APIProperty: pyramid
	* {String} 默认为360°金字塔信息，一个xml字符串。
	*/
	pyramid:null,
	/**
	* APIProperty: spatialReference
	* {String} 默认为"4326"，字符串。
	*/
	spatialReference:"4326",
	/**
	 * APIProperty: dataSourceType
	 * {String} 当此值为"Customer"时，最好填写范围和层级，字符串。
	 */
	dataSourceType:"Customer",
	/**
	 * APIProperty: height
	 * {Number} 距离地面高度
	 */
	height:300,
	//私有图层对象
	_layerData:null,
	/**
	 * Constructor: Geo.View3D.Layer.Grid
	 * 构造函数。
	 * 
	 * Parameters:
	 * name - {String} 服务名称。
	 * url - {String} 服务地址。
	 * options - {Object} 相关参数选项。
	 */
	initialize:function(name, url, options){
		Geo.View3D.Layer.prototype.initialize.apply(this,[name,options]);
		this.url = url;
		var options = options || {};
		this.topLevel = options.topLevel?options.topLevel:this.topLevel;
		this.buttomLevel = options.buttomLevel?options.buttomLevel:this.buttomLevel;
		this.maxExtent = options.maxExtent?options.maxExtent:new Geo.Bounds(-180,-90,180,90);
		this.dataType = options.dataType?options.dataType:this.dataType;
		this.pyramid = options.pyramid?options.pyramid:"";
		this.spatialReference = options.spatialReference?options.spatialReference:this.spatialReference;
		this.dataSourceType = options.dataSourceType?options.dataSourceType:this.dataSourceType;
		this.height = options.height?options.height:this.height;
	},
	/**
	 * Method: setMap
	 * 将图层关联到指定三维视图对象。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维视图对象。
	 */
	setMap:function(map){
		Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
		var layerJson = '{'+
		'"DataType":"'+this.dataType+'",'+
		'"DataSourceType":"'+this.dataSourceType+'",'+
		'"StartLevel":'+this.topLevel+','+
		'"EndLevel":'+this.buttomLevel+','+
		'"XMin":'+this.maxExtent.left+','+
		'"YMin":'+this.maxExtent.bottom+','+
		'"XMax":'+this.maxExtent.right+','+
		'"YMax":'+this.maxExtent.top+','+
		'"SpatialReference":"'+this.spatialReference+'",'+
		'"ServerUrl":"'+this.url + '"}';
        this._layerData = this.map.activexObj.DataSourceBox.CreateLayerFromJson(layerJson);
		this.map.activexObj.LayerBox.UserGroupLayer.AddLayer(this._layerData);
		this.display(this.visibility);
	},
	/**
	 * Method: removeMap
	 * 取消三维视图对象与图层关联。
	 */
	removeMap:function(){
		var map =  this.map;
		if(map){
			map._removeLayerData(this._layerData);
			this._layerData = null;
		}
		this.map = null;
	},
	/**
	 * Method: setVisibility
	 * 设置图层是否可见。
	 *
	 * Parameters:
	 * visibility - {Boolean} 是否可见。
	 */	
    setVisibility: function(visibility) {
        if (visibility != this.visibility) {
        	this.visibility = visibility;
            this.display(visibility);
        }
    },
	/**
	 * Method: display
	 *
	 * Parameters:
	 * display - {Boolean} 
	 */	
    display: function(display) {
		if(!this._layerData){
			return;
		}
        if(display != this._layerData.Visible){
			var map = this.map;
			map._setLayerVisibility(this._layerData,display);
        }
    },
	/**
	 * Method: setOpacity
	 * 设置透明度。
	 * 
	 * Parameters:
	 * opacity - {Number} 透明度。
	 */
	setOpacity:function(opacity){
		Geo.View3D.Layer.prototype.setOpacity.apply(opacity);
		var map = this.map;
		if(map){
			map._setLayerOpacity(this._layerData,opacity);
			this.opacity = opacity;
		}
	},
	/**
	 * Method: gotoCenter
	 * 定位到图层中心点。
	 */
	gotoCenter:function(){
		var map = this.map;
		if(map){
			map._gotoLayer(this._layerData);
		}
	},
	
	CLASS_NAME:"Geo.View3D.Layer.Grid"
});/**
 * Class: Geo.View3D.Layer.Model
 * 三维视图模型图层对象
 *
 * Inherits from:
 *  - <Geo.View3D.Layer.Grid>
 */
Geo.View3D.Layer.Model = Geo.Class(Geo.View3D.Layer.Grid, {
	//判断用户使用的什么版本的api，由构造参数个数判断
	_oldLoad: null,
	
	/**
	 * Constructor: Geo.View3D.Layer.Model
	 * 构造函数。
	 * 
	 * Parameters:
	 * name - {String} 服务名称。
	 * url - {String} 服务地址。
	 * options - {Object} 相关参数选项。
	 * 例如：
	 * (code)
	 * 	  var modelLayer = new Geo.View3D.Layer.Model("model", "http://192.168.42.56:9010/model/services/tile",
     *    {
     *       topLevel:1,//顶层级别，默认:0
	 *		 bottomLevel:20,//底层级别，默认:20
	 *       //图层范围,默认范围:-180,-90,180,90，必填
	 *		 maxExtent:Geo.Bounds.fromString("117.1966552734375,34.1839599609375,117.2845458984375,34.2828369140625"),
     *       layerType : "model",  //可选，图层类型值为model，设置此参数值表示让三维插件用新方式创建模型图层
     *       opacity : 1,//图层透明度设置,// 可以设置：0-1，默认：1
     *       projection: "EPSG:4326",//当前图层使用的投影,默认EPSG:4326
     *       version:"5.0",//请求的服务版本，默认：1.1.1
	 *		 //支持分辨率
	 *		 //maxResolution :0.000005364418029785156,//最大分辨率
     *       //minResolution :0.703125//最小分辨率
     *       //支持比例尺
     *       //minScale : 2.958293554545656E8,
     *       //maxScale : 2256.998866688275      
     *    });
	 * (end) 
	 */
	initialize:function(name, url, options){
		options = options || {};
		//通过读取用户创建模型时传入的参数，判断接口的版本
		// true代表老方式，false代表新方式
		var oldFlag = typeof(options.layerType) == "undefined" ? true : false;
    	if(oldFlag){
    		this._oldLoad = true;
    		Geo.View3D.Layer.GlobeTile.prototype.initialize.apply(this,[name,url, options]);
        	this.url = url;
        	return;
    	}
    	//与二维一致的新的三维图层加载方式
        options.pyramid = options.pyramid ? options.pyramid : new Geo.Pyramid();
		if(options.maxResolution){
			options.bottomLevel = options.pyramid.getLevelForResolution(options.maxResolution);
		}
		if(options.minResolution){
			options.topLevel = options.pyramid.getLevelForResolution(options.minResolution);
		}
		if(options.maxScale){
			options.bottomLevel = options.pyramid.getLevelForScale(options.maxScale);
		}
		if(options.minScale){
			options.topLevel = options.pyramid.getLevelForScale(options.minScale);
		}
		if(typeof options.projection == "string") {
        	this.projection = new Geo.Projection(options.projection);
        }
        if(this.projection && this.projection.getUnits()) {
            this.units = this.projection.getUnits();
        }
        Geo.View3D.Layer.prototype.initialize.apply(this,[name, options]);
        this.url = url;
	},
	
	/**
	 * Method: setMap
	 * 将图层关联到指定三维视图对象。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维视图对象。
	 */	
	setMap: function(map){
    	if(this._oldLoad){
    		this._oldSetMap(map);
    		return;
    	}
    	this._createLayerFromJson(map);
    },
    
    //老版本,参数内部构造
    _oldSetMap: function(map) {
        Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
		this._layerData = map._addGlobeTileService(this.url,"",this._LAYER_TYPE_GLOBETILE);
		this.display(this.visibility);
    },
    
     //自定义图层方式
    _createLayerFromJson : function(map){
    	var DEFAULT_PARAMS = 
		{ 
	      version: "5.0",
	      request: "GetTile",
	      styles: "",
	      format: "image/png",
	      spatialReference : "4326"
	     };
	    /**所有的服务的公共参数**/ 
	    //默认为影像：ImageDataType，矢量：VectorDataType，模型数据：ModelDataType， Lod模型数据：LodModelDataType，POI数据：POIDataType
	    var dataType= "LodModelDataType";    
	    //设置图层透明度，默认:100，可以设置:0-100
	    var renderTransparency = this.options.opacity >= 0 ? this.options.opacity * 100 : 100;
	    //顶层级别，默认:0
	    var dataSetStartLevel = this.options.topLevel ? this.options.topLevel : 0;
	    //底层级别，默认:20
	    var dataSetEndLevel = this.options.bottomLevel ? this.options.bottomLevel : 20;
	    //图层地理范围，默认:-180,-90,180,90
	    var xMin = this.options.maxExtent ? this.options.maxExtent.left : -180;
	    var yMin = this.options.maxExtent ? this.options.maxExtent.bottom : -90;
	    var xMax = this.options.maxExtent ? this.options.maxExtent.right : 180;
	    var yMax = this.options.maxExtent ? this.options.maxExtent.top : 90;
	    //服务地址
	    var url = this.url;
	    //请求的服务版本号，version版本为2.1的暂时不支持
	    var version = this.options.version ? this.options.version : DEFAULT_PARAMS.version;
	    //获取投影
	    var projection = this.options.projection ? this.options.projection : "EPSG:4326";
	    //获取空间参数
	    var arr = projection.split(":");
	    var spatialReference = DEFAULT_PARAMS.spatialReference;
	    if(arr.length == 2){
	    	spatialReference = arr[1];
	    } else {
	    	spatialReference = arr[0];
	    }
	    //拼图层请求串
	    var layerJson = '{'+
		'"DataType":"'+dataType+'",'+
		'"DataSourceType":"GeoTile",'+
		'"StartLevel":'+dataSetStartLevel+','+
		'"EndLevel":'+dataSetEndLevel+','+
		'"XMin":'+xMin+','+
		'"YMin":'+yMin+','+
		'"XMax":'+xMax+','+
		'"YMax":'+yMax+','+
		'"SpatialReference":"'+spatialReference+'",' +
		'"RenderTransparency":'+renderTransparency+',' +
		'"ServerUrl":"'+ url+'",' +
		'"Version":"'+ version;
		layerJson +='"}';
	    Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
	    var layer = this.dataSourceBox.CreateLayerFromJson(layerJson);
	    this.layerBox.UserGroupLayer.AddLayer(layer);
	    this._layerData = layer;	
    },
    
    CLASS_NAME: "Geo.View3D.Layer.Model"
});
/**
 * Namespace: Geo.View3D.Event.KeyEvent
 * 三维键盘事件对象。
 */
Geo.View3D.Event.KeyEvent = {

    /**
     * Constant: KEY_SPACE
     * {Number} 空格键代码。
     */
    KEY_SPACE: 32,
    
    /** 
     * Constant: KEY_LEFT
     * {Number} 左方向键代码。
     */
    KEY_LEFT: 37,
    
    /** 
     * Constant: KEY_UP
     * {Number} 上方向键代码。
     */
    KEY_UP: 38,
    
    /** 
     * Constant: KEY_RIGHT
     * {Number} 右方向键代码。
     */
    KEY_RIGHT: 39,
    
    /** 
     * Constant: KEY_DOWN
     * {Number} 下方向键代码。
     */
    KEY_DOWN: 40,
    
    /** 
     * Constant: KEY_PLUS
     * {Number} 加号键代码。
     */
    KEY_PLUS: 187,
    
    /** 
     * Constant: KEY_MINUS
     * {Number} 减号键代码。
     */
    KEY_MINUS: 189,
    
     /** 
     * Constant: KEY_MINUS
     * {Number} 小键盘加号键代码。
     */
    KEY_NUM_PLUS: 107,
    /** 
     * Constant: KEY_MINUS
     * {Number} 小键盘减号键代码。
     */
    KEY_NUM_MINUS: 109,
    
     /**
     * APIMethod: isKeyDown
     * 判断是否键盘按键按下。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isKeyDown: function(e){
        if (e.EventType === 6) {
            return true;
        }
     },
			
	/**
     * APIMethod: isKeyUp
     * 判断是否键盘按键弹起。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isKeyUp: function(e){
        if (e.EventType === 7) {
            return true;
        }
    },
    
    /**
     * APIMethod: isKeyboardDown
     * 判断是否键盘按键按下。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isKeyboardDown: function(e){
        if (e.keyState === 0) {
            return true;
        }
     },
			
	/**
     * APIMethod: isKeyboardUp
     * 判断是否键盘按键弹起。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isKeyboardUp: function(e){
        if (e.keyState === 1) {
            return true;
        }
    },
    
    CLASS_NAME: "Geo.View3D.Event.KeyEvent"
};
/**
 * Namespace: Geo.View3D.Event.MouseEvent
 * 三维鼠标事件对象。本事件对象用于判断三维视图下鼠标是否触发了鼠标动作，包括鼠标左键点击，鼠标移动，鼠标
 * 右键点击等动作，以及鼠标所在的像素位置，经纬度和海拔高度信息。
 */
Geo.View3D.Event.MouseEvent = {

    /**
     * APIMethod: isMousemove
     * 判断是否鼠标移动。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMousemove: function(e){
		//if (e.MouseButton === -1 && e.MouseState === 1) 
        if (e.MouseButton === 0 && e.MouseState === 3) {
            return true;
        }
    },
    
    /**
     * APIMethod: isMouseDown
     * 判断是否鼠标左键按下。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseDown: function(e){
        //if (e.MouseButton === 0 && e.MouseState === 0) {
		if (e.MouseButton === 1 && e.MouseState === 0) {
            return true;
        }
	},
    
    /**
     * APIMethod: isLeftClick
     * 判断是否鼠标点击。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isLeftClick: function(e){
//        if (e.MouseButton === 0 && e.MouseState === 0) {
//		if (e.MouseButton === 1 && e.MouseState === 1) {
//            return true;
//        }
    	if (e.MouseButton !== 1 || e.MouseState !== 1) {
            return false;
        };
        if(Geo.View3D.Event.MouseEvent._mouseDownPos){
            var xOffset = Math.abs(Geo.View3D.Event.MouseEvent._mouseDownPos.x - e.ScreenX);
            var yOffset = Math.abs(Geo.View3D.Event.MouseEvent._mouseDownPos.y - e.ScreenY);
            var pixelTolerance = Geo.View3D.Event.MouseEvent.pixelTolerance;

            if(xOffset > pixelTolerance || yOffset > pixelTolerance){
                return false;
            };
        };
        return true;
	},
    
    /**
     * APIMethod: isMouseUp
     * 判断是否鼠标左键弹起。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseUp: function(e){
        //if (e.MouseButton === 0 && e.MouseState === 2) {
		if (e.MouseButton === 1 && e.MouseState === 1) {
            return true;
        }
	},
    
	/**
     * APIMethod: isMouseDownMove
     * 判断是否鼠标左键按住移动。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseDownMove: function(e){
        //if (e.MouseButton === 0 && e.MouseState === 0) {
		if (e.MouseButton === 1 && e.MouseState === 3) {
            return true;
        }
	},
	
	/**
     * APIMethod: isMouseLeftDoubleClick
     * 判断是否鼠标左键双击。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseLeftDoubleClick: function(e){
		if (e.MouseButton === 1 && e.MouseState === 4) {
            return true;
        }
	},
	
	/**
     * APIMethod: isMouseRightDown
     * 判断是否鼠标右键按下。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseRightDown: function(e){
		if (e.MouseButton === 2 && e.MouseState === 0) {
            return true;
        }
	},
	
    /**
     * APIMethod: isRightClick
     * 判断是否鼠标右键点击。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isRightClick: function(e){
        //if (e.MouseButton === 2 && e.MouseState === 2) {
        if (e.MouseButton === 2 && e.MouseState === 1) {
            return true;
        }
	},
    
	/**
     * APIMethod: isMouseRightUp
     * 判断是否鼠标右键弹起。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseRightUp: function(e){
        //if (e.MouseButton === 0 && e.MouseState === 2) {
		if (e.MouseButton === 2 && e.MouseState === 1) {
            return true;
        }
	},
	
	/**
     * APIMethod: isMouseRightDownMove
     * 判断是否鼠标右键按住移动。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseRightDownMove: function(e){
		if (e.MouseButton === 2 && e.MouseState === 3) {
            return true;
        }
	},
	
	/**
     * APIMethod: isMouseRightDoubleClick
     * 判断是否鼠标右键双击。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseRightDoubleClick: function(e){
		if (e.MouseButton === 2 && e.MouseState === 4) {
            return true;
        }
	},
	
	/**
     * APIMethod: isMouseWheel
     * 判断是否鼠标滚轮。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseWheel: function(e){
		if (e.MouseButton === 0 && e.MouseState === 5) {
            return true;
        }
	},
	
	/**
     * APIMethod: isMouseOut
     * 判断是否鼠标离开三维球体区域。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseOut: function(e){
        if (e.MouseButton === 0 && e.MouseState === 6) {
            return true;
        }
    },
    
    /**
     * APIMethod: isMouseOver
     * 判断是否鼠标进入三维球体区域。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseOver: function(e){
        if (e.MouseButton === 0 && e.MouseState === 7) {
            return true;
        }
    },
	
    /**
     * APIMethod: isMouseRightUp
     * 判断是否鼠标右键弹起。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseRightUp: function(e){
        //if (e.MouseButton === 0 && e.MouseState === 2) {
		if (e.MouseButton === 2 && e.MouseState === 1) {
            return true;
        }
	},
	
    /**
     * APIMethod: getMouseScreen
     * 获取屏幕坐标。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    getMouseScreen: function(e){
        return {
            x: e.ScreenX,
            y: e.ScreenY
        };
    },
    
    /**
     * APIMethod: getMouseLocation
     * 获取地理位置包括经纬度、海拨高度。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    getMouseLocation: function(e){
        return {
            lon: e.X,//e.Longitude,
            lat: e.Y,//e.Latitude,
            alt: e.Altitude
        };
    },
	
//    /**
//     * APIMethod: isKeyDown
//     * 判断是否键盘按键按下。
//     *
//     * Paramters:
//     * e - {Object} 事件对象。
//     */
//    isKeyDown: function(e){
//        if (e.EventType === 6) {
//            return true;
//        }
//     },
//			
//	/**
//     * APIMethod: isKeyUp
//     * 判断是否键盘按键弹起。
//     *
//     * Paramters:
//     * e - {Object} 事件对象。
//     */
//    isKeyUp: function(e){
//        if (e.EventType === 7) {
//            return true;
//        }
//    },
					
    /**
     * Constant: KEY_SPACE
     * {int} 空格键代码。
     */
    KEY_SPACE: 32,
    
    /** 
     * Constant: KEY_LEFT
     * {int} 左方向键代码。
     */
    KEY_LEFT: 37,
    
    /** 
     * Constant: KEY_UP
     * {int} 上方向键代码。
     */
    KEY_UP: 38,
    
    /** 
     * Constant: KEY_RIGHT
     * {int} 右方向键代码。
     */
    KEY_RIGHT: 39,
    
    /** 
     * Constant: KEY_DOWN
     * {int} 下方向键代码。
     */
    KEY_DOWN: 40,
    
    /** 
     * Constant: KEY_PLUS
     * {int} 加号键代码。
     */
    KEY_PLUS: 187,
    
    /** 
     * Constant: KEY_MINUS
     * {int} 减号键代码。
     */
    KEY_MINUS: 189,
    
    CLASS_NAME: "Geo.View3D.Event.MouseEvent"
};
/**
 * Class: Geo.View3D.Handler
 * 三维视图事件监听对象。
 */
Geo.View3D.Handler = Geo.Class({

    /**
     * APIProperty: id
     * {String} 唯一标识符。
     */  
    id: null,

    /**
     * APIProperty: active
     * {String} 是否激活。
     */      
    active: false,

    /**
     * APIProperty: control
     * {String} 所属控件。
     */      
    control: null,

    /**
     * APIProperty: map
     * {<Geo.View3D.Map>} 所属地图对象。
     */    
    map: null,

	 
	/**
	 * Constructor: Geo.View3D.Handler
	 * Geo.View3D.Handler构造函数。
	 *
	 * Parameters:
	 * control - {<Geo.View3D.Control>} 监听器所属的控件。
	 * options - {Object} 选项。
	 */	    
    initialize: function(control, callbacks, options){
        
        OpenLayers.Util.extend(this, options);
        this.control = control;
		this.callbacks = callbacks;
		
		var map = this.map || control.map;
        if (map) {
            this.setMap(map); 
        }
		
		this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
    },
 	
	/**
	 * Method: setMap
	 * 将监听器关联到三维地图对象。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维地图对象。
	 */	    
    setMap: function (map) {
        if(map){
            this.map = map;
            this.map.handlers.push(this);
        }
    },
 	
   /**
    * Method: callback
    * 触发控件指定的回调方法。
    *
    * Parameters:
    * name - {String}
    * args - {Array(*)}
    */
    callback: function (name, args) {
        if (name && this.callbacks[name]) {
            this.callbacks[name].apply(this.control, args);
        }
    },

	/**
	 * Method: listener
	 * 监听鼠标事件。
	 *
	 * Parameters:
	 * e - {Object} 三维对象鼠标事件对象。
	 */	     
    listener:function(e){
        
    },

	/**
	 * APIMethod: activate
	 * 激活事件监听器，如果当前监听器已处于激活状态，则返回false。
	 *
	 * Return:
	 * {Boolean} 监听器是否被激活。
	 */	    
    activate: function() {
        if(this.active) {
            return false;
        }
        this.active = true;
        return true;
    },

	/**
	 * APIMethod: deactivate
	 * 关闭事件监听器，如果当前监听器已处于关闭状态，则返回false。
	 *
	 * Return:
	 * {Boolean} 监听器是否被关闭。
	 */    
    deactivate: function() {
        if(!this.active) {
            return false;
        }
        this.active = false;
        return true;
    },

    /**
     * APIMethod: destroy
     * 监听器销毁。
     */
    destroy: function () {
        this.deactivate();
		if(this.map){
			OpenLayers.Util.removeItem(this.map.handlers,this);
		}
        this.control = this.map = null;        
    },
	
    CLASS_NAME: "Geo.View3D.Handler"
});/**
 * Class: Geo.View3D.Handler.Box
 * 三维拉框动作监听类。
 * 
 * Inherits from:
 *  - <Geo.View3D.Handler>
 */
Geo.View3D.Handler.Box = Geo.Class(Geo.View3D.Handler,{
	
	/**
     * Property: bbox
     * {String} 表示用户拉框的范围。例如： "5,42,10,45"。
     */
	bbox: null,
	
	/**
	 * Constructor: Geo.View3D.Handler.Box
	 * Geo.View3D.Handler.Box构造函数。
	 * 
	 * Parameters:
	 * control - {Geo.View3D.Control}关联的控件。
	 * callbacks - {Object} 回调方法。
	 * options - {Object} 参数选项。
	 */  
    initialize: function(control, callbacks, options) {
        Geo.View3D.Handler.prototype.initialize.apply(this, arguments);
		
    },
	
	/**
     * APIMethod: listener
     * 监听鼠标拉框动作。
     *
     * Parameters:
     * mouseEvent - {Object} 三维地图的鼠标事件对象。
     */
    listener: function(mouseEvent) {
		//鼠标按下时执行
		if(mouseEvent.MouseState == 0 || Geo.View3D.Event.MouseEvent.isRightClick(mouseEvent)){
			this.bbox = mouseEvent.Longitude + "," + mouseEvent.Latitude;
			return;
		}
		//鼠标弹起时执行
		if (mouseEvent.MouseState == 2){
			this.bbox = this.bbox + "," + mouseEvent.Longitude + "," + mouseEvent.Latitude;
		}
		var arr = this.bbox.split(",");
		//排序为左下右上
		var bbox = arr[0] + "," + arr[3] + "," + arr[2] + "," + arr[1];
		this.callback("emitMouseHandler", [bbox]);
		
    },
	
	 /**
     * APIMethod: activate
     * 打开绘制点监听器。
     */
    activate: function() {
        if(!Geo.View3D.Handler.prototype.activate.apply(this, arguments)) {
            return false;
        }
		//CurrentOpState的值为2时表示拉框
		this.map.activexObj.CurrentOpState = 2;
        return true;
    },
	
	/**
     * APIMethod: deactivate
     * 关闭监听。
     */
    deactivate: function() {
        if(!Geo.View3D.Handler.prototype.deactivate.apply(this, arguments)) {
            return false;
        }
		//恢复CurrentOpState的默认值
		this.map.activexObj.CurrentOpState = 0;
        return true;
    },
	
    CLASS_NAME: "Geo.View3D.Handler.Box"
});/**
 * Class: Geo.View3D.Handler.KeybordDefaults
 * 三维视图的键盘事件监听器。本类负责监听键盘的空格键，上下左右键以及加号减号键。
 *
 * Inherits from:
 *  - <Geo.View3D.Handler>
 */
Geo.View3D.Handler.KeybordDefaults = Geo.Class(Geo.View3D.Handler, {

    /**
     * APIMethod: listener
     * 键盘事件监听器。
     *
     * Parameters:
     * e - {Object} 三维地图的键盘事件对象。
     */
    listener: function(e){
			if (e.keyCode == Geo.View3D.Event.KeyEvent.KEY_SPACE) {
				this.onKeySpace(e);
			} 
			if (e.keyCode == Geo.View3D.Event.KeyEvent.KEY_LEFT) {
				this.onKeyLeft(e);
			}
			if (e.keyCode == Geo.View3D.Event.KeyEvent.KEY_UP) {
				this.onKeyUp(e);
			}
			if (e.keyCode == Geo.View3D.Event.KeyEvent.KEY_RIGHT) {
				this.onKeyRight(e);
			}
			if (e.keyCode == Geo.View3D.Event.KeyEvent.KEY_DOWN) {
				this.onKeyDown(e);
			}
			if (e.keyCode == Geo.View3D.Event.KeyEvent.KEY_PLUS) {
				this.onKeyPlus(e);
			}
			if (e.keyCode == Geo.View3D.Event.KeyEvent.KEY_MINUS) {
				this.onKeyMinus(e);
			}
			if (e.keyCode == Geo.View3D.Event.KeyEvent.KEY_NUM_PLUS) {
				this.onKeyPlus(e);
			}
			if (e.keyCode == Geo.View3D.Event.KeyEvent.KEY_NUM_MINUS) {
				this.onKeyMinus(e);
			}
    },
    
    /**
     * APIMethod: onKeySpace
     * 空格键被按下时的事件响应方法。
     *
     * Parameters:
     * e - {Object} 三维地图的键盘事件对象。
     */
    onKeySpace: function(e){
    },
    
    /**
     * APIMethod: onKeyLeft
     * 向左方向键被按下时的事件响应方法。
     *
     * Parameters:
     * e - {Object} 三维地图的键盘事件对象。
     */
    onKeyLeft: function(e){
    },
    
    /**
     * APIMethod: onKeyUp
     * 向上方向键被按下时的事件响应方法。
     *
     * Parameters:
     * e - {Object} 三维地图的键盘事件对象。
     */
    onKeyUp: function(e){
    },
    
    /**
     * APIMethod: onKeyRight
     * 向右方向键被按下时的事件响应方法。
     *
     * Parameters:
     * e - {Object} 三维地图的键盘事件对象。
     */
    onKeyRight: function(e){
    },
    
    /**
     * APIMethod: onKeyDown
     * 向下方向键被按下时的事件响应方法。
     *
     * Parameters:
     * e - {Object} 三维地图的键盘事件对象。
     */
    onKeyDown: function(e){
    },
    
    /**
     * APIMethod: onKeyPlus
     * 加号键被按下时的事件响应方法。
     *
     * Parameters:
     * e - {Object} 三维地图的键盘事件对象。
     */
    onKeyPlus: function(e){
    },
    
    /**
     * APIMethod: onKeyMinus
     * 减号键被按下时的事件响应方法。
     *
     * Parameters:
     * e - {Object} 三维地图的键盘事件对象。
     */
    onKeyMinus: function(e){
    },
    
    CLASS_NAME: "Geo.View3D.Handler.KeybordDefaults"
});
/**
 * Class: Geo.View3D.Handler.Mouse
 * 三维视图的鼠标事件监听器。本类负责监听鼠标的左键右键和鼠标经过动作。
 *
 * Inherits from:
 *  - <Geo.View3D.Handler>
 */
Geo.View3D.Handler.Mouse = Geo.Class(Geo.View3D.Handler, {

	/**
	 * Constructor: Geo.View3D.Handler.Mouse
	 * Geo.View3D.Handler.Mouse构造函数。
	 * 
	 * Parameters:
	 * control - {Geo.View3D.Control}关联的控件。
	 * callbacks - {Object} 回调方法。
	 * options - {Object} 参数选项。
	 */  
    initialize: function(control, callbacks, options) {
        Geo.View3D.Handler.prototype.initialize.apply(this, arguments);
    },
	
    /**
     * APIMethod: listener
     * 鼠标事件监听器。
     *
     * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
     */
    listener: function(e){
		if (Geo.View3D.Event.MouseEvent.isLeftClick(e)) {
            this.callback("click", [e]);
        }
		
        if (Geo.View3D.Event.MouseEvent.isMousemove(e)) {
            this.callback("mouseMove", [e]);
        }
        if (Geo.View3D.Event.MouseEvent.isMouseOut(e)) {
            this.callback("mouseOut", [e]);
        }
        if (Geo.View3D.Event.MouseEvent.isMouseOver(e)) {
            this.callback("mouseOver", [e]);
        }
        
        if (Geo.View3D.Event.MouseEvent.isRightClick(e)) {
            this.callback("rightClick", [e]);
        }
        if (Geo.View3D.Event.MouseEvent.isMouseLeftDoubleClick(e)) {
            this.callback("dblclick", [e]);
        }
        if(Geo.View3D.Event.MouseEvent.isMouseUp(e)) {
        	this.callback("mouseUp", [e]);
        }
        if(Geo.View3D.Event.MouseEvent.isMouseDown(e)) {
        	this.callback("mouseDown", [e]);
        }
        if(Geo.View3D.Event.MouseEvent.isMouseWheel(e)) {
        	this.callback("mouseWheel", [e]);
        }
        if(Geo.View3D.Event.MouseEvent.isMouseRightUp(e)) {
        	this.callback("mouseRightUp", [e]);
        }
        
    },
    
    CLASS_NAME: "Geo.View3D.Handler.Mouse"
});
/**
 * Class: Geo.View3D.Handler.ModelChoose
 * 三维视图的模型选择事件监听器。
 *
 * Inherits from:
 *  - <Geo.View3D.Handler>
 */
Geo.View3D.Handler.ModelChoose = Geo.Class(Geo.View3D.Handler, {

    /**
     * Constructor: Geo.View3D.Control.ModelChoose
     * Geo.View3D.Control.ModelChoose构造函数。
     */
    initialize: function(control, callbacks, options){
        Geo.View3D.Handler.prototype.initialize.apply(this, arguments);
    },
    
    /**
     * APIMethod: listener
     * 模型点击监听动作。
     *
     * Parameters:
     * mouseEvent - {Object} 三维地图的鼠标事件对象。
     */
    listener: function(mouseEvent){
        var isSelected = false;
        if (this.map && this.map.activexObj) {
            if (mouseEvent.MouseButton == 1 && mouseEvent.MouseState == 1) {
                var modelLayer = null;
                
                var layers = this.map.layers;
                for (var i = 0; i < layers.length; i++) {
                    if (layers[i] instanceof Geo.View3D.Layer.Model) {
                        modelLayer = layers[i];
                    }
                }
                
                var x = mouseEvent.ScreenX;
                var y = mouseEvent.ScreenY;
                var pBSTR;
                isSelected = this.map.activexObj.SceneGroup.PerformSelection(modelLayer._layerData, x, y, pBSTR);
                this.callback("chooseModel", [mouseEvent, isSelected]);
            }
        }
    },
    
    /**
     * APIMethod: activate
     * 打开模型点击监听器。
     */
    activate: function(){
        if (!Geo.View3D.Handler.prototype.activate.apply(this, arguments)) {
            return false;
        }
        return true;
    },
    
    /**
     * APIMethod: deactivate
     * 关闭监听动作。
     */
    deactivate: function(){
        if (!Geo.View3D.Handler.prototype.deactivate.apply(this, arguments)) {
            return false;
        }
        return true;
    },
    
    CLASS_NAME: "Geo.View3D.Handler.ModelChoose"
});
/**
 * Class: Geo.View3D.Handler.Point
 * 三维视图点几何对象绘制操作事件监听器。该对象激活后，将在三维视图上监听绘制点的操作，
 * 完成后返回用户绘制的几何对象。该对象关闭后，将移除绘制图层。
 * 
 * Inherits from:
 *  - <Geo.View3D.Handler>
 */
Geo.View3D.Handler.Point = Geo.Class(Geo.View3D.Handler,{
	
	    
    /**
     * APIProperty: point
     * {<Geo.Feature.Vector>} 当前绘制的点要素。
     */
    point: null,

    /**
     * APIProperty: layer
     * {<Geo.View3D.Layer.Vector>} 用于显示绘制要素的临时三维矢量图层。
     */
    layer: null,

    /**
     * APIProperty: persist
     * {Boolean} 是否立即销毁临时图层绘制的要素。
     */
    persist: false,


    /**
     * APIProperty: layerOptions
     * {Object} 临时绘制矢量要素图层对象构造选项。
     */
    layerOptions: null,

    /** 
     * Constructor: Geo.View3D.Handler.Point
     * Geo.View3D.Handler.Point构造函数。
     * 
     * Parameters:
     * control - {<Geo.View3D.Control>} 三维控件对象。
     * options - {Object} 参数对象。
     */
    initialize: function(control, options) {
        if(!(options && options.layerOptions && options.layerOptions.styleMap)) {
            this.style = OpenLayers.Util.extend(Geo.Feature.Vector.style['default'], {});
        }

        Geo.View3D.Handler.prototype.initialize.apply(this, arguments);
    },
    
	/**
	 * APIMethod: listener
	 * 鼠标事件监听器。
	 * 
     * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */	           
    listener:function(e){
		if (Geo.View3D.Event.KeyEvent.isKeyDown(e) || Geo.View3D.Event.KeyEvent.isKeyUp(e)) {
            return;
        }
        if (Geo.View3D.Event.MouseEvent.isMousemove(e)) {
            return;
        }
		
		var lon = e.X;//e.Longitude;
        var lat = e.Y;//e.Latitude;
				
        if (Geo.View3D.Event.MouseEvent.isMouseDown(e)) {
	        this.createFeature(new Geo.LonLat(lon,lat));
		}
		if (Geo.View3D.Event.MouseEvent.isMouseUp(e)) {
			if(this.persist){
				this.layer.destroyFeatures();
			}

			this.callback("done", [this.point.geometry.clone()]);
		}
		
    },
	
    /**
     * APIMethod: activate
     * 打开绘制点监听器。
     */
    activate: function() {
        if(!Geo.View3D.Handler.prototype.activate.apply(this, arguments)) {
            return false;
        }
        var options = OpenLayers.Util.extend({
            displayInLayerSwitcher: false,
			isOnTop: true
        }, this.layerOptions);
        this.layer = new Geo.View3D.Layer.Vector(this.CLASS_NAME, options);
        this.map.addLayer(this.layer);
		
		//this._setGeoRaster();
		
        return true;
    },	
				
    /**
     * APIMethod: createFeature
     * 向临时矢量图层添加绘制要素。
     *
     * Parameters:
     * lonlat - {Object} 经纬度信息。
     */
    createFeature: function(lonlat) {
        this.point = new Geo.Feature.Vector(
            new Geo.Geometry.Point(lonlat.lon, lonlat.lat)
        );
        this.point.geometry.clearBounds();
        this.layer.addFeatures([this.point], {silent: true});
    },

    /**
     * APIMethod: deactivate
     * 关闭绘制点监听器。
     */
    deactivate: function() {
        if(!Geo.View3D.Handler.prototype.deactivate.apply(this, arguments)) {
            return false;
        }
        this.destroyFeature();
        if (this.layer.map != null) {
            this.layer.destroy(false);
        }
        this.layer = null;
		
		//this.map.activexObj.SetPickedState(false);
		
        return true;
    },
    
    /**
     * APIMethod: destroyFeature
     * 销毁临时绘制矢量要素。
     */
    destroyFeature: function() {
        if(this.layer) {
            this.layer.destroyFeatures();
        }
        this.point = null;
    },

	/**
     * 设置GeoRaster。
     */
    _setGeoRaster:function(){
        var GeoRaster = this.map._geoRaster;
        GeoRaster.GeoRasterType = 1;
        
        //设置精确拾取 开,漫游状态要还原为FALSE
    	this.map.activexObj.SetPickedState(true);  
    },
	
    CLASS_NAME: "Geo.View3D.Handler.Point"
});/**
 * Class: Geo.View3D.Handler.Path
 * 三维视图线几何对象绘制操作事件监听器。该对象激活后，将在三维视图上监听绘制线的操作，
 * 完成后返回用户绘制的几何对象。该对象关闭后，将移除绘制图层。
 * 
 * Inherits from:
 *  - <Geo.View3D.Handler>
 */
Geo.View3D.Handler.Path = Geo.Class(Geo.View3D.Handler,{

    /**
     * APIProperty: point
     * {<Geo.Feature.Vector>}当前绘制的点要素。
     */
    point: null,	
	
    /**
     * APIProperty: line
     * {<Geo.Feature.Vector>}当前绘制的线要素。
     */
    line: null,	    

    /**
     * APIProperty: layer
     * {<Geo.View3D.Layer.Vector>} 用于显示绘制要素的临时三维矢量图层。
     */
    layer: null,

    /**
     * APIProperty: persist
     * {Boolean} 是否立即销毁临时图层绘制的要素。
     */
    persist: false,


    /**
     * APIProperty: layerOptions
     * {Object} 临时绘制矢量要素图层对象构造选项。
     */
    layerOptions: null,
	
	//标记线是否点击右键绘制完成
	_isDone: false,

    /** 
     * Constructor: Geo.View3D.Handler.Path
     * Geo.View3D.Handler.Path构造函数。
     * 
     * Parameters:
     * control - {<Geo.View3D.Control>} 三维控件对象。
     * options - {Object} 参数对象。
     */
    initialize: function(control, options) {
        if(!(options && options.layerOptions && options.layerOptions.styleMap)) {
            this.style = OpenLayers.Util.extend(Geo.Feature.Vector.style['default'], {});
        }

        Geo.View3D.Handler.prototype.initialize.apply(this, arguments);
    },
    
	/**
	 * APIMethod: listener
	 * 鼠标事件监听器。
	 * 
     * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */	           
    listener:function(e){
		if (Geo.View3D.Event.KeyEvent.isKeyDown(e) || Geo.View3D.Event.KeyEvent.isKeyUp(e)) {
            return;
        }
        if (Geo.View3D.Event.MouseEvent.isMousemove(e)) {
            return;
        }
        if (Geo.View3D.Event.MouseEvent.isLeftClick(e)) {
			//alert(e.MouseButton +"   "+ e.MouseState);
			//结束当前线绘制后，再次点击清除前次绘制
			if(this._isDone){
				//this.layer.removeFeatures(this.line);
				this.line = null;
				this._isDone = false;
			}
			var GeoRaster = this.map._geoRaster;
	        var lon = e.X;//e.Longitude;
	        var lat = e.Y;//e.Latitude;
			this.addPoint(new Geo.LonLat(lon,lat));
			this.callback("point", [this.point.geometry, this.line.geometry]);
		}
		if(Geo.View3D.Event.MouseEvent.isRightClick(e)){
			//alert(e.MouseButton +"   "+ e.MouseState);
			this._isDone = true;
            if(this.persist){
				this.layer.destroyFeatures();
			}
            if (this.line) {
                this.callback("done", [this.line.geometry.clone()]);
                //var GeoRaster = this.map._geoRaster;
                //this.map.activexObj.SetPickedState(false);
            }
		}
    },
	
    /**
     * APIMethod: activate
     * 打开绘制线监听器。
     */
    activate: function() {
        if(!Geo.View3D.Handler.prototype.activate.apply(this, arguments)) {
            return false;
        }
        var options = OpenLayers.Util.extend({
            displayInLayerSwitcher: false,
			isOnTop: true
        }, this.layerOptions);
        this.layer = new Geo.View3D.Layer.Vector(this.CLASS_NAME, options);
        this.map.addLayer(this.layer);
		
		//this._setGeoRaster();
		
        return true;
    },	
	
	/**
	 * APIMethod: addPoint
	 * 添加点的方法。
	 * 
     * Parameters:
     * lonlat - {Object} 经纬度信息。
	 */	 
	addPoint:function(lonlat){
		this.point = new Geo.Feature.Vector(
            new Geo.Geometry.Point(lonlat.lon, lonlat.lat)
        );
        this.point.geometry.clearBounds();
		
		var lineGeometry;
		if(!this.line){
			lineGeometry = new Geo.Geometry.LineString([this.point.geometry]);
		} else {
			var points = this.line.geometry.components;
			points.push(this.point.geometry);
			lineGeometry = new Geo.Geometry.LineString(points);
		}
		this.layer.removeFeatures(this.line);
		this.line = new Geo.Feature.Vector(lineGeometry);
		this.layer.addFeatures([this.line], {silent: true});
	},
				
    /**
     * APIMethod: createFeature
     * 向临时矢量图层添加绘制要素。
     *
     * Parameters:
     * lonlat - {Object} 经纬度信息。
     */
    createFeature: function(lonlat) {
        this.point = new Geo.Feature.Vector(
            new Geo.Geometry.Point(lonlat.lon, lonlat.lat)
        );
        //this.callback("create", [this.point.geometry, this.point]);
        this.point.geometry.clearBounds();
        this.layer.addFeatures([this.point], {silent: true});
    },

    /**
     * APIMethod: deactivate
     * 关闭绘制线监听器。
     */
    deactivate: function() {
        if(!Geo.View3D.Handler.prototype.deactivate.apply(this, arguments)) {
            return false;
        }
        this.destroyFeature();
        if (this.layer.map != null) {
            this.layer.destroy(false);
        }
        this.layer = null;
		
		//this.map.activexObj.SetPickedState(false);
		
        return true;
    },
    
    /**
     * APIMethod: destroyFeature
     * 销毁临时绘制矢量要素。
     */
    destroyFeature: function() {
        if(this.layer) {
            this.layer.destroyFeatures();
        }
        this.point = null;
		this.line = null;
    },
	
    /**
     * 设置GeoRaster。
     */
    _setGeoRaster:function(){
        var GeoRaster = this.map._geoRaster;
        GeoRaster.GeoRasterType = 1;
        
        //设置精确拾取 开,漫游状态要还原为FALSE
    	this.map.activexObj.SetPickedState(true);  
    },
	
    CLASS_NAME: "Geo.View3D.Handler.Path"
});/**
 * Class: Geo.View3D.Handler.Polygon
 * 三维视图面几何对象绘制操作事件监听器。该对象激活后，将在三维视图上监听绘制面的操作，
 * 完成后返回用户绘制的几何对象。该对象关闭后，将移除绘制图层。
 * 
 * Inherits from:
 *  - <Geo.View3D.Handler>
 */
Geo.View3D.Handler.Polygon = Geo.Class(Geo.View3D.Handler,{

	_points: [],

    /**
     * APIProperty: point
     * {<Geo.Feature.Vector>}当前绘制的点要素。
     */
    point: null,	
	
    /**
     * APIProperty: polygon
     * {<Geo.Feature.Vector>}当前绘制的线要素。
     */
    polygon: null,	    

    /**
     * APIProperty: layer
     * {<Geo.View3D.Layer.Vector>} 用于显示绘制要素的临时三维矢量图层。
     */
    layer: null,

    /**
     * APIProperty: persist
     * {Boolean} 是否立即销毁临时图层绘制的要素。
     */
    persist: false,
	
    /**
     * APIProperty: checkSelfCross
     * {Boolean} 是否允许多边形自相交。
     */
	checkSelfCross: true,

	//标记线是否点击右键绘制完成
	_isDone: false,

    /**
     * APIProperty: layerOptions
     * {Object} 临时绘制矢量要素图层对象构造选项。
     */
    layerOptions: null,
    
    /** 
     * Constructor: Geo.View3D.Handler.Polygon
     * Geo.View3D.Handler.Polygon构造函数。
     * 
     * Parameters:
     * control - {<Geo.View3D.Control>} 三维控件对象。
     * options - {Object} 参数对象。
     */
    initialize: function(control, options) {
        if(!(options && options.layerOptions && options.layerOptions.styleMap)) {
            this.style = OpenLayers.Util.extend(Geo.Feature.Vector.style['default'], {});
        }

        Geo.View3D.Handler.prototype.initialize.apply(this, arguments);
    },
    
	/**
	 * APIMethod: listener
	 * 鼠标事件监听器。
	 * 
     * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */	           
    listener:function(e){
		if (Geo.View3D.Event.KeyEvent.isKeyDown(e) || Geo.View3D.Event.KeyEvent.isKeyUp(e)) {
            return;
        }
        if (Geo.View3D.Event.MouseEvent.isMousemove(e)) {
            return;
        }
        if (Geo.View3D.Event.MouseEvent.isLeftClick(e)) {
			//alert(e.MouseButton +" L  "+ e.MouseState);
			//结束当前线绘制后，再次点击清除前次绘制
			if(this._isDone){
//				this.layer.removeFeatures(this.polygon);
				this.polygon = null;
				this._isDone = false;
			}
			
	        var lon = e.X;//e.Longitude;
	        var lat = e.Y;//e.Latitude;
			
			//临时保存点击的点供自相交检查
			this._points.push(new Geo.Geometry.Point(lon, lat));
			var linearRingGeometry = new Geo.Geometry.LinearRing(this._points);
			var polygonGeometry = new Geo.Geometry.Polygon([linearRingGeometry]);
		
            //做自相交检查，如果要求做相交检查而且自相交则不添加点
//            if(this.checkSelfCross && this._checkSelfCross(polygonGeometry)){
//                return;
//            }

			this.addPoint(new Geo.LonLat(lon,lat));
			this.callback("point", [this.point.geometry, this.polygon.geometry]);
		}
		if(Geo.View3D.Event.MouseEvent.isRightClick(e)){
			//alert(e.MouseButton +" R  "+ e.MouseState);
			this._isDone = true;
			this._points = [];
            if(this.persist){
				this.layer.destroyFeatures();
			}
            if (this.polygon) {
                this.callback("done", [this.polygon.geometry.clone()]);
                //this.map.activexObj.SetPickedState(false);
            }
		}
    },
	
    /**
     * APIMethod: activate
     * 打开绘制面监听器。
     */
    activate: function() {
        if(!Geo.View3D.Handler.prototype.activate.apply(this, arguments)) {
            return false;
        }
        var options = OpenLayers.Util.extend({
            displayInLayerSwitcher: false,
			isOnTop: true
        }, this.layerOptions);
        this.layer = new Geo.View3D.Layer.Vector(this.CLASS_NAME, options);
        this.map.addLayer(this.layer);
		
		//this._setGeoRaster();
		
        return true;
    },	
	
	/**
	 * APIMethod: addPoint
	 * 添加点的方法。
	 * 
     * Parameters:
     * lonlat - {Object} 经纬度信息。
	 */	   
	addPoint:function(lonlat){
		this.point = new Geo.Feature.Vector(
            new Geo.Geometry.Point(lonlat.lon, lonlat.lat)
        );
        this.point.geometry.clearBounds();
		
		var polygonGeometry;
		var linearRingGeometry;
		if(!this.polygon){
			linearRingGeometry = new Geo.Geometry.LinearRing([this.point.geometry]);
		} else {
			var points = this.polygon.geometry.components[0].components;
			points.push(this.point.geometry);
			linearRingGeometry = new Geo.Geometry.LinearRing(points);
		}
		polygonGeometry = new Geo.Geometry.Polygon([linearRingGeometry]);
		this.layer.removeFeatures(this.polygon);
		this.polygon = new Geo.Feature.Vector(polygonGeometry);
		this.layer.addFeatures([this.polygon], {silent: true});
	},
				
    /**
     * APIMethod: createFeature
     * 向临时矢量图层添加绘制要素。
     *
     * Parameters:
     * lonlat - {Object} 经纬度信息。
     */
    createFeature: function(lonlat) {
        this.point = new Geo.Feature.Vector(
            new Geo.Geometry.Point(lonlat.lon, lonlat.lat)
        );
        //this.callback("create", [this.point.geometry, this.point]);
        this.point.geometry.clearBounds();
        this.layer.addFeatures([this.point], {silent: true});
    },

    /**
     * APIMethod: deactivate
     * 关闭绘制面监听器。
     */
    deactivate: function() {
        if(!Geo.View3D.Handler.prototype.deactivate.apply(this, arguments)) {
            return false;
        }
        this.destroyFeature();
        if (this.layer.map != null) {
            this.layer.destroy(false);
        }
        this.layer = null;
		
		//this.map.activexObj.SetPickedState(false);
		
        return true;
    },
    
    /**
     * APIMethod: destroyFeature
     * 销毁临时绘制矢量要素。
     */
    destroyFeature: function() {
        if(this.layer) {
            this.layer.destroyFeatures();
        }
        this.point = null;
        this.polygon = null;
    },
    
	//设置GeoRaster
    _setGeoRaster:function(){
        var GeoRaster = this.map._geoRaster;
        GeoRaster.GeoRasterType = 1;
        
        //设置精确拾取 开,漫游状态要还原为FALSE
    	this.map.activexObj.SetPickedState(true);  
    },
    
    //检查传入的点串有没有自交叉
    _checkSelfCross:function(allPoints){
        var checkPoints = this._getPointsSpaceSplitStr(allPoints);
        var Globe = this.map.activexObj;
        return Globe.SetTerrainAnalysisParam(checkPoints, 0, -1);
    },
	
    //将点数组转换成空格分隔的字符串
    _getPointsSpaceSplitStr:function(polygonGeometry){
		var linearRing = polygonGeometry.components[0];
		var allPoints = linearRing.components;
		
        var points = [];
        for(var i=0; i<allPoints.length; i++){
            points.push(allPoints[i].x);
            points.push(allPoints[i].y);
        }
        return points.join(" ");
    },	
	
    CLASS_NAME: "Geo.View3D.Handler.Polygon"
});/**
 * Class: Geo.View3D.Handler.Feature
 * 三维视图要素选择对象操作事件监听器。该对象激活后，将在三维视图上监听要素选择的操作。
 * 
 * Inherits from:
 *  - <Geo.View3D.Handler>
 */
Geo.View3D.Handler.Feature = Geo.Class(Geo.View3D.Handler,{

    //保存鼠标最后移入的要素id
    _feature: null,
	
    //是否启用图层选择功能
    _isEnableLayerSelect: false,

    /** 
     * Constructor: Geo.View3D.Handler.Feature
     * Geo.View3D.Handler.Feature构造函数。
     * 
     * Parameters:
     * control - {<Geo.View3D.Control>} 三维控件对象。
     * options - {Object} 参数对象。
     */
    initialize: function(control, options) {
        Geo.View3D.Handler.prototype.initialize.apply(this, arguments);
        this.control = control;
    },
    
	/**
	 * APIMethod: listener
	 * 鼠标事件监听器。
	 * 
     * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */	
    listener:function(e){
        var control = this.control;
        var globe = control.map.activexObj;
        var vectorLayer = control.layer;
        this._enableLayerSelect();
        var featureId = this._getFeatureIdFromScreen(e.ScreenX, e.ScreenY);
        if (control.hover && Geo.View3D.Event.MouseEvent.isMousemove(e)) {
            if(featureId && this._feature !== featureId){
                control.select(featureId);
                this._feature = featureId;
            }
            if(!featureId && this._feature){
                control.unselect(this._feature);
                this._feature = null;
            }
        }
        //监听鼠标点击下
        if (Geo.View3D.Event.MouseEvent.isLeftClick(e)) {
        	 if(featureId){
                control.select(featureId);
                this._feature = featureId;
            }
        }
        //监听鼠标左击下，取消选择要素
        if(Geo.View3D.Event.MouseEvent.isMouseDown(e)){
        	if(!featureId && this._feature){
                control.unselect(this._feature);
                this._feature = null;
            }
        }
        //监听鼠标右击下，取消选择要素
        if(Geo.View3D.Event.MouseEvent.isMouseRightDown(e)){
        	if(!featureId && this._feature){
                control.unselect(this._feature);
                this._feature = null;
            }
        }
    },

    //打开底层矢量图层选择功能
    _enableLayerSelect: function(){
        if(this._isEnableLayerSelect){
            return;
        }
        var control = this.control;
        var globe = control.map.activexObj;
        var vectorLayer = control.layer;
        //打开SelectionBox的选择功能，打开图层的选择功能
        globe.SelectionBox.EnableSelection = true;
        //针对标注
        var layerOp = globe.LayerBox.CreateLayerOperate(vectorLayer._dynamicLayer);
        layerOp.ChangeLayerProperty(6, true);
        //针对线面
        var layerOp2 = globe.LayerBox.CreateLayerOperate(vectorLayer._layerData);
        layerOp2.ChangeLayerProperty(6, true);
        this._isEnableLayerSelect = true;
    },

    //根据屏幕坐标查询对应要素id
    _getFeatureIdFromScreen: function(screenX,screenY){
        var control = this.control;
        var featureId = false;
        var globe = control.map.activexObj;
        globe.SelectionBox.SelectByScreenPoint(screenX, screenY);

        if(globe.SelectionBox.Count == 0){
            return featureId;
        }
        var box = globe.SelectionBox.QuerySelectedObject(0);
        if( null == box.POIID || undefined == box.POIID){
            featureId = box.Key;
        } else {
            featureId = box.POIGUID;
        }
        return featureId;
    },

    CLASS_NAME: "Geo.View3D.Handler.Feature"
});/**
 * Class: Geo.View3D.Handler.Keyboard
 * 三维视图的键盘事件监听器。本类负责监听键盘的按下和抬起事件。
 *
 * Inherits from:
 *  - <Geo.View3D.Handler>
 */
Geo.View3D.Handler.Keyboard = Geo.Class(Geo.View3D.Handler, {

	/**
	 * Constructor: Geo.View3D.Handler.Keyboard
	 * Geo.View3D.Handler.Keyboard构造函数。
	 * 
	 * Parameters:
	 * control - {Geo.View3D.Control}关联的控件。
	 * callbacks - {Object} 回调方法。
	 * options - {Object} 参数选项。
	 */  
    initialize: function(control, callbacks, options) {
        Geo.View3D.Handler.prototype.initialize.apply(this, arguments);
    },
	
    /**
     * APIMethod: listener
     * 鼠标事件监听器。
     *
     * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
     */
    listener: function(e){
		if (Geo.View3D.Event.KeyEvent.isKeyboardDown(e)) {
            this.callback("keyboardDown", [e]);
        }
        if (Geo.View3D.Event.KeyEvent.isKeyboardUp(e)) {
            this.callback("keyboardUp", [e]);
        }
    },
    
    CLASS_NAME: "Geo.View3D.Handler.Keyboard"
});
/**
 * Class: Geo.View3D.Control
 * 三维视图控件基类。本类不直接使用,需要由子类继承。
 */
Geo.View3D.Control = Geo.Class({
	
    /**
     * APIProperty: id
     * {String} 唯一标识符。
     */      
    id: null,

    /**
     * APIProperty: autoActivate
     * {Boolean} 控件加入地图后是否自动激活。
     */      
    autoActivate: false,

    /**
     * APIProperty: active
     * {Boolean} 控件当前激活状态。
     */    
    active: false,

    /**
     * APIProperty: handler
     * {Object} 三维视图事件监听对象。
     */      
    handler: null,
	
    /**
     * APIProperty: eventListeners
     * {Object} 三维视图事件监听器。
     */      
    eventListeners: null,
	
    /**
     * APIProperty: events
     * {Object} 三维视图事件。
     */      
    events: null,
	
    /**
     * APIProperty: EVENT_TYPES
     * {Array} 控件基类所支持的事件类型。
     */     
    EVENT_TYPES: ["activate", "deactivate"],

    /**
     * APIProperty: map
     * {<Geo.View3D.Map>} 控件所属地图对象。
     */
    map: null,

	/**
	 * Constructor: Geo.View3D.Control
	 * Geo.View3D.Control构造函数。
	 *
	 * Parameters:
	 * options - {Object} 相关参数选项。
	 */    
    initialize: function(options){
        OpenLayers.Util.extend(this, options);
        
        this.events = new OpenLayers.Events(this, null, this.EVENT_TYPES);
        if(this.eventListeners instanceof Object) {
            this.events.on(this.eventListeners);
        }
        if (this.id == null) {
            this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
        }
    },

	/**
	 * APIMethod: setMap
	 * 将控件关联到地图对象。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维地图对象。
	 */	    
    setMap: function(map) {
        this.map = map;
        if (this.handler) {
            this.handler.setMap(map);
        }
    },
    
    //控件绘制，由子类实现
    draw: function(px){
        
    },

	/**
	 * APIMethod: listener
	 * 鼠标事件监听器。
	 *
	 * Parameters:
	 * e - {Object} 三维地图鼠标事件对象。
	 */	     
    listener:function(e){
        
    },

	/**
	 * APIMethod: activate
	 * 激活控件。如果当前控件已经处于激活状态则返回false，否则激活该控件的事件监听器handler，并且触发该控件的"activate"事件，返回true。
	 */	     
    activate: function () {
        if (this.active) {
            return false;
        }
        if (this.handler) {
            this.handler.activate();
        }
        this.active = true;
        this.events.triggerEvent("activate");
        return true;
    },

	/**
	 * APIMethod: deactivate
	 * 关闭控件。如果当前控件已经处于关闭状态则返回false，否则关闭该控件的事件监听器handler，并且触发该控件的"deactivate"事件，返回true。
	 */	    
    deactivate: function () {
        if (this.active) {
            if (this.handler) {
                this.handler.deactivate();
            }
            this.active = false;
            this.events.triggerEvent("deactivate");
            return true;
        }
        return false;
    },
    
	/**
	 * APIMethod: destroy
	 * 销毁控件。
	 */	  
    destroy: function () {
        if(this.events) {
            if(this.eventListeners) {
                this.events.un(this.eventListeners);
            }
            this.events.destroy();
            this.events = null;
        }
        this.eventListeners = null;

        // eliminate circular references
        if (this.handler) {
            this.handler.destroy();
            this.handler = null;
        }
        if(this.handlers) {
            for(var key in this.handlers) {
                if(this.handlers.hasOwnProperty(key) &&
                   typeof this.handlers[key].destroy == "function") {
                    this.handlers[key].destroy();
                }
            }
            this.handlers = null;
        }
        if (this.map) {
            this.map.removeControl(this);
            this.map = null;
        }
    },
	  
    CLASS_NAME: "Geo.View3D.Control"
});/**
 * Class: Geo.View3D.Control.KeyboardDefaults
 * 三维视图键盘控制控件类。使用本控件可以实现用键盘进行三维视图的平移以及缩小放大功能。
 * 
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.KeyboardDefaults = Geo.Class(Geo.View3D.Control, {

    /**
     * APIProperty: autoActivate
     * 设置控件为加入地图中自动激活。
     */
    autoActivate: true,
    
    /**
     * APIProperty: delta
     * 按下方向键时平移增量。
     */
    delta: 0,
    
    /**
     * Constructor: Geo.View3D.Control.KeyboardDefaults
     * Geo.View3D.Control.KeyboardDefaults构造函数。
     */
    initialize: function(options){
        Geo.View3D.Control.prototype.initialize.apply(this, arguments);
        this.handler = new Geo.View3D.Handler.KeybordDefaults(this, null, {
            onKeySpace: OpenLayers.Function.bind(this.resetNorth, this),
            onKeyLeft: OpenLayers.Function.bind(this.panLeft, this),
            onKeyUp: OpenLayers.Function.bind(this.panUp, this),
            onKeyRight: OpenLayers.Function.bind(this.panRight, this),
            onKeyDown: OpenLayers.Function.bind(this.panDown, this),
            onKeyPlus: OpenLayers.Function.bind(this.zoomIn, this),
            onKeyMinus: OpenLayers.Function.bind(this.zoomOut, this)
        });
    },
    
    /**
     * APIMethod: resetNorth
     * 重新设置指北方向。
     */
    resetNorth: function(){
        if (this.map) {
            this.map.resetNorth();
        }
    },
    
    /**
     * APIMethod: panLeft
     * 三维视图向左平移。
     */
    panLeft: function(){
        this.pan("left");
    },
    
    /**
     * APIMethod: panUp
     * 三维视图向上平移。
     */
    panUp: function(){
        this.pan("up");
    },
    
    /**
     * APIMethod: panRight
     * 三维视图向右平移。
     */
    panRight: function(){
        this.pan("right");
    },
    
    /**
     * APIMethod: panDown
     * 三维视图向下平移。
     */
    panDown: function(){
        this.pan("down");
    },
    
    /**
     * APIMethod: pan
     * 三维视图平移。
     *
     * Paramters:
     * type - {String} 方向类型，其值可为："left"、"up"、"right"、"down"。
     */
    pan: function(type){
        var globe = this.map.activexObj;
        var delta = this.delta;//15;//globe.GetCamera().ViewRange;
        var camera = globe.Camera;
        switch (type) {
            case "left":
                camera.Pan(-delta, 0);
                break;
            case "up":
                camera.Pan(0, delta);
                break;
            case "right":
                camera.Pan(delta, 0);
                break;
            case "down":
                camera.Pan(0, -delta);
                break;
        }
    },
    
    /**
     * APIMethod: zoomIn
     * 地图放大。
     */
    zoomIn: function(){
        var map = this.map;
        if (map) {
            map.zoomIn();
        }
    },
    
    /**
     * APIMethod: zoomOut
     * 地图缩小。
     */
    zoomOut: function(){
        var map = this.map;
        if (map) {
            map.zoomOut();
        }
    },
	
    CLASS_NAME: "Geo.View3D.Control.KeyboardDefaults"
});
/**
 * Class: Geo.View3D.Control.Measure
 * 量算类。
 * (code)
 * 使用方法：
 * 1.构造一个实例与地图关联，将自己的事件分派器与地图量算响应方法相关联。
 * 2.添加针对不同的量算类型添加绘制不同类型几何体的HANDLER。
 * 3.捕获到绘点线面的动作后调用响应方法。
 * (end)
 * Inherits from:
 *  - <Geo.View3D.Control>
 *
 */
Geo.View3D.Control.Measure = Geo.Class(Geo.View3D.Control, {

    /**
     * 量算服务地址。
     */
    serviceUrl: null,
    
    /**
     * 图层等级
     */
    layerLevel: null,
    
    /**
     * 图层名称
     */
    layerName: null,
    
    /**
     * 失败回调函数
     */
    failFn: null,
    
    /**
     * 地形分析服务对象。
     */
    _terrainAnalysisService: null,
    
    /**
     * 监听器类型由量算子类设置。
     */
    handlerType: null,
    
    /**
     * 监听器构造参数。
     */
    handlerOptions: null,
    
    /**
     * 点。
     */
    _points: null,
    
    /**
     * 临时保存量算结果。
     */
    _result: null,
    
    /**
     * {Object} The functions that are sent to the handler for callback
     */
    callbacks: null,
    
    /**
     * 构造函数。生成一个Geo.View3D.Control.Measure的实例。
     */
    initialize: function(serviceUrl, options){
        Geo.View3D.Control.prototype.initialize.apply(this, [options]);
        this.serviceUrl = serviceUrl;
        this._terrainAnalysisService = new Geo.Service.TAS(this.id + "_service", serviceUrl);
        this.callbacks = OpenLayers.Util.extend({
            done: this._onComplete,
            point: this._onAddPoint
        }, this.callbacks);
        this.handlerOptions = this.handlerOptions || {};
        if (this.handlerType) {
            this.handler = new this.handlerType(this, this.callbacks, this.handlerOptions);
        }
        
    },
    
    /**
     * 量算完成。
     */
    _isComplete: false,
    
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     *
     */
    onAddPoint: function(){
    },
    
    /**
     * 在三维视图上结束绘制图形时，调用此方法
     */
    onComplete: function(result){
    },
    
    /**
     * 在三维视图上结束绘制图形时，调用此方法
     */
    _onComplete: function(geometry){
    },
    
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     */
    _onAddPoint: function(){
    },
    
    /**
     * 量算监听器
     */
    _measureHandler: function(mouseEvent){
    },
    
    /**
     * 设置量算服务地址
     */
    setMeasureService: function(url){
        if (url && this._terrainAnalysisService) {
            this._terrainAnalysisService.url = url;
        }
    },
    
    /**
     * 获取量算结果
     */
    _getMeasureResult: function(type, options, successFn){
        var defaultOptions = {
            pointCount: this._terrainAnalysisService._countCoord(options.coordinates),
            layerLevel: this.layerLevel,
            layerName: this.layerName,
            subjoin: 0
        };
        options = OpenLayers.Util.applyDefaults(options, defaultOptions);
        
        var serivce = this._terrainAnalysisService;
        if (serivce) {
            serivce[type](options, successFn, this.failFn);
        }
    },
    
    /**
     * 激活量算控件
     */
    activate: function(){
        if (Geo.View3D.Control.prototype.activate.apply(this, arguments)) {
            this.map._measureHandler = OpenLayers.Function.bind(this._measureHandler, this);
            this.setMeasureService(this.serviceUrl);
        }
        return true;
    },
    
    /**
     * 将二维点数组，加上指高度形成三维点数组转换成空格分隔的字符串
     */
    _getPointsThreeDegreeSpaceSplitStr: function(polygonGeometry, height){
        var linearRing = polygonGeometry.components[0];
        var allPoints = linearRing.components;
        
        var points = [];
        for (var i = 0; i < allPoints.length; i++) {
            points.push(allPoints[i].x);
            points.push(allPoints[i].y);
            points.push(height);
        }
        return points.join(" ");
    },
    
    /**
     * 将点数组转换成空格分隔的字符串
     */
    _getPointsSpaceSplitStr: function(polygonGeometry){
        var linearRing = polygonGeometry.components[0];
        var allPoints = linearRing.components;
        
        var points = [];
        for (var i = 0; i < allPoints.length; i++) {
            points.push(allPoints[i].x);
            points.push(allPoints[i].y);
        }
        return points.join(" ");
    },
    
    /**
     * 设置量算分析服务参数
     */
    _setMeasureParams: function(type, pointsString, boxHeight){
        var Globe = this.map.activexObj;
        if (type !== undefined) {
            Globe.SetTerrainAnalysisParam(pointsString, boxHeight, type);
        }
    },
    
    /**
     * 删除盒子图层
     */
    _clearBoxLayer: function(){
        var Globe = this.map.activexObj;
        var layer = Globe.GetSceneGroup().GetLayerByName(this.id + "_boxLayer");
        if (layer != null) {
            Globe.GetSceneGroup().RemoveLayer(layer);
        }
    },
    
    /**
     * 画盒子图层
     */
    _createBoxLayer: function(mousePoints){
    
        var Globe = this.map.activexObj;
        
        // 画盒子用接口
        var LocalDataBox = Globe.CreateAddLocalDataObj();
        
        var pointstr = this._getPointsThreeDegreeSpaceSplitStr(mousePoints, 0);
        
        
        var boxLayerId = this.id + "_boxLayer";
        var layerdata = LocalDataBox.AddPolyGon(boxLayerId, pointstr);
        
        layerdata.name = boxLayerId;
        LocalDataBox.setPolyGonHeight(boxLayerId, this.height);
        LocalDataBox.SetBoxFaceColor(boxLayerId, 0x7fffffff, 0x7fffffff, 0x7fffffff)
        
    },
    
    CLASS_NAME: "Geo.View3D.Control.Measure"
});
/**
 * Class: Geo.View3D.Control.DrawPath
 * 几何线绘制控件类。使用本控件可以在三维地图上画线。
 * 
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.DrawPath = Geo.Class(Geo.View3D.Control, {

    /**
     * APIProperty: type
     * 控件类型。 
     */  
    type: Geo.View2D.Control.TYPE_TOOL,
    
    /**
     * APIProperty: handlerOptions
     * {Object} 监听器的构造参数。
     */
    handlerOptions: null,

    /**
     * APIProperty: callbacks
     * {Object} 回调函数定义。
     */    
    callbacks: null,
    
	/**
	 * Constructor: Geo.View3D.Control.DrawPath
	 * Geo.View3D.Control.DrawPath构造函数。
	 */    
    initialize: function(options){
        Geo.View3D.Control.prototype.initialize.apply(this, [options]);
        this.callbacks = OpenLayers.Util.extend(
            {
                "done": this.done
            },
            this.callbacks
        );
        this.handlerOptions = this.handlerOptions || {};        
        this.handler = new Geo.View3D.Handler.Path(this, this.callbacks, this.handlerOptions);
    },

    /**
     * APIMethod: done
     * 几何对象绘制完成回调函数，用户可以使用自己的方法来覆盖它。
     * 
     * Paramters:
     * geometry - 绘制的几何对象。
     */   	
    done: function(geometry){
        
    }
    
});
/**
 * Class: Geo.View3D.Control.DrawPoint
 * 几何点绘制控件类。使用本控件可以在三维地图上画点。
 * 
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.DrawPoint = Geo.Class(Geo.View3D.Control, {

    /**
     * APIProperty: type
     * 控件类型。
     */
    type: Geo.View2D.Control.TYPE_TOOL,
    
    /**
     * APIProperty: handlerOptions
     * {Object} 监听器的构造参数。
     */
    handlerOptions: null,

    /**
     * APIProperty: callbacks
     * {Object} 回调函数定义。
     */    
    callbacks: null,
       
 	/**
	 * Constructor: Geo.View3D.Control.DrawPoint
	 * Geo.View3D.Control.DrawPoint构造函数。
	 */     
    initialize: function(options){
        Geo.View3D.Control.prototype.initialize.apply(this, [options]);
        this.callbacks = OpenLayers.Util.extend(
            {
                "done": this.done
            },
            this.callbacks
        );
        this.handlerOptions = this.handlerOptions || {};
        this.handler = new Geo.View3D.Handler.Point(this, this.callbacks, this.handlerOptions);
    },
	
    /**
     * APIMethod: done
     * 几何对象绘制完成回调函数，用户可以使用自己的方法来覆盖它。
     * 
     * Paramters:
     * geometry - 绘制的几何对象。
     */   	
    done: function(geometry){
        
    }
    
});
/**
 * Class: Geo.View3D.Control.DrawPolygon
 * 几何多边形绘制控件类。使用本控件可以在三维地图上画面。
 * 
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.DrawPolygon = Geo.Class(Geo.View3D.Control, {

    /**
     * APIProperty: type
     * 控件类型。 
     */
    type: Geo.View2D.Control.TYPE_TOOL,
    
    /**
     * APIProperty: handlerOptions
     * {Object} 监听器的构造参数。
     */
    handlerOptions: null,

    /**
     * APIProperty: callbacks
     * {Object} 回调函数定义。
     */    
    callbacks: null,
     
 	/**
	 * Constructor: Geo.View3D.Control.DrawPolygon
	 * Geo.View3D.Control.DrawPolygon构造函数。
	 */   
    initialize: function(options){
        Geo.View3D.Control.prototype.initialize.apply(this, [options]);
        this.callbacks = OpenLayers.Util.extend(
            {
                "done": this.done
            },
            this.callbacks
        );
        this.handlerOptions = this.handlerOptions || {};
        this.handler = new Geo.View3D.Handler.Polygon(this, this.callbacks, this.handlerOptions);
    },
	
    /**
     * APIMethod: done
     * 几何对象绘制完成回调函数，用户可以使用自己的方法来覆盖它。
     * Paramters:
     * geometry - 绘制的几何对象。
     */       
    done: function(geometry){
        
    }
    
});
/**
 * Class: Geo.View3D.Control.DrawFeature
 * 要素绘制控件可以在三维矢量图层上通过鼠标绘制点、线、面要素。
 *
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.DrawFeature = Geo.Class(Geo.View3D.Control, {
    
    /**
     * APIProperty: layer
     * {<Geo.View3D.Layer.Vector>} 矢量图层对象。
     */
    layer: null,

    /**
     * APIProperty: callbacks
     * {Object} 回调函数定义。
     */
    callbacks: null,
    
    /**
     * APIProperty: EVENT_TYPES
     * 触发的事件类型。
     */
    EVENT_TYPES: ["featureadded"],

	/**
     * APIMethod: featureAdded
     * 当在地图上绘画一个要素的时候会触发本方法。
     */
    featureAdded: function() {},

    /**
     * APIProperty: handlerOptions
     * {Object} 监听器的构造参数。
     */
    handlerOptions: null,
    
    /**
     * Constructor: Geo.View3D.Control.DrawFeature
     * Geo.View3D.Control.DrawFeature构造函数。
     * 
     * Parameters:
     * layer - {<Geo.View3D.Layer.Vector>} 
     * handler - {<Geo.View3D.Handler>} 
     * options - {Object} 
     */
    initialize: function(layer, handler, options) {
        
        // concatenate events specific to vector with those from the base
        this.EVENT_TYPES =
            Geo.View3D.Control.DrawFeature.prototype.EVENT_TYPES.concat(
            Geo.View3D.Control.prototype.EVENT_TYPES
        );
        
        Geo.View3D.Control.prototype.initialize.apply(this, [options]);
        this.callbacks = OpenLayers.Util.extend(
            {
                done: this.drawFeature
            },
            this.callbacks
        );
        this.layer = layer;
        this.handlerOptions = this.handlerOptions || {};

        var sketchStyle = this.layer.styleMap && this.layer.styleMap.styles.temporary;
        if(sketchStyle) {
            this.handlerOptions.layerOptions = OpenLayers.Util.applyDefaults(
                this.handlerOptions.layerOptions,
                {styleMap: new Geo.StyleMap({"default": sketchStyle})}
            );
        }
        this.handler = new handler(this, this.callbacks, this.handlerOptions);
    },

	/**
     * APIMethod: drawFeature
     * 在三维视图上绘制要素图层。
	 * 
	 * Paramters:
	 * geometry - {Object} 绘制的几何对象。
     */
    drawFeature: function(geometry) {
        var feature = new Geo.Feature.Vector(geometry);
        this.layer.addFeatures([feature]);
        this.featureAdded(feature);
        this.events.triggerEvent("featureadded",{feature : feature});
    },
	
    CLASS_NAME: "Geo.View3D.Control.DrawFeature"
});/**
 * Class: Geo.View3D.Control.SelectFeature
 * 三维视图下要素选择控件，该控件实现在指定的的图层上通过鼠标单击和悬浮选择矢量要素。
 *
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.SelectFeature = Geo.Class(Geo.View3D.Control, {

    clickout: true,

    multiple: false,

    EVENT_TYPES: ["beforefeaturehighlighted", "featurehighlighted", "featureunhighlighted"],
	
   /**
    * APIProperty: hover
    * {boolean} 在鼠标悬浮在要素上时，选中要素；移出要素时，取消选中。若设置为true，鼠标点击将不起作用。默认为false。
    */
    hover: false,	

    /**
     * APIProperty: layer
     * {<Geo.View3D.Layer.Vector>} 要素选择控件所对应的矢量图层
     */
    layer: null,
	
    /**
     * APIProperty: scope
     * {Object} onBeforeSelect, onSelect, onUnselect等回调方法的上下文，即this的指向。如果为null值，则指向要素选择控件本身。
     * 
     */
    scope: null,

    /**
     * APIProperty: onBeforeSelect
     * {Function} 要素被选中之前可以调用该方法，完成用户指定的任务。要求用户定义具体方法，该方法接收当前选中要素作为参数。
     */
    onBeforeSelect: function() {},

    /**
     * APIProperty: onSelect
     * {Function} 要素被选中后可以调用该方法，完成用户指定的任务。要求用户定义具体方法，该方法接收当前选中要素作为参数。
     */
    onSelect: function() {},

    /**
     * APIProperty: onUnselect
     * {Function} 要素取消选择后可以调用该方法，完成用户指定的任务。要求用户定义具体方法，该方法接收当前选中要素作为参数。
     */
    onUnselect: function() {},	

    /**
     * Constructor: Geo.View3D.Control.SelectFeature
     * Geo.View3D.Control.SelectFeature构造函数
     *
     * Parameters:
     * layer - {<Geo.View3D.Layer.Vector>} 要素选择控件所对应的矢量图层
     * options - {Object} 构造参数
     */
    initialize: function(layer, options) {
        this.EVENT_TYPES =
            Geo.View3D.Control.SelectFeature.prototype.EVENT_TYPES.concat(
            Geo.View3D.Control.prototype.EVENT_TYPES
        );
        Geo.View3D.Control.prototype.initialize.apply(this, [options]);
        this.handler = new Geo.View3D.Handler.Feature(this);
        this.layer = layer;
    },

    highlight: function(feature) {
        var layer = feature.layer;
    },


    unhighlight: function(feature) {
        var layer = feature.layer;
    },

    onSelect: function(feature){

    },
	
    /**
     * APIMethod: destroy
     * 销毁方法
     */
    destroy: function() {
    },	
	
    /**
     * APIMethod: setMap
     * 将控件关联到地图
     *
     * Parameters:
     * map - {<OpenLayers.Map>}
     */
    setMap: function(map) {
        Geo.View3D.Control.prototype.setMap.apply(this, arguments);
    },	

    /**
     * APIMethod: select
     * 选择要素，将指定要素添加到矢量图层的selectedFeatures数组中，重新以被选中样式绘制要素，
     * 并且调用onSelect方法。
     *
     * Parameters:
     * feature - {<Geo.Feature.Vector>}
     */
    select: function(featureId) {
        var feature = this._getFeatureFromId(featureId);
		if(null == feature || undefined == feature) return;
		var cont = this.onBeforeSelect.call(this.scope, feature);
        var layer = feature.layer;
        if(cont !== false) {
            cont = layer.events.triggerEvent("beforefeatureselected", {
                feature: feature
            });
            if(cont !== false) {
                if(this.multiple){
                    layer.selectedFeatures.push(feature);
                } else {
                    layer.selectedFeatures = [feature];
                }
                this.highlight(feature);
                layer.events.triggerEvent("featureselected", {feature: feature});
                this.onSelect.call(this.scope, feature);
            }
        }
    },

    _getFeatureFromId: function(featureId){
        var features = this.layer.features;
        for(var i=0; i<features.length; i++){
            var f = features[i];
            if(f.id === featureId){
                return f;
            };
        }
    },

    /**
     * APIMethod: unselect
     * 取消选择要素
     *
     * Parameters:
     * feature - {<Geo.Feature.Vector>}
     */
    unselect: function(featureId) {
        var feature = this._getFeatureFromId(featureId);
        if(null == feature || undefined == feature) return;
        var layer = feature.layer;
        this.unhighlight(feature);
        OpenLayers.Util.removeItem(layer.selectedFeatures, feature);
        this.onUnselect.call(this.scope, feature);
    },
	
    /**
     * APIMethod: unselectAll
     * 取消所有被选择要素
     *
     */
    unselectAll: function() {
        var layer = this.layer, feature;
        for(var i=layer.selectedFeatures.length-1; i>=0; --i) {
            feature = layer.selectedFeatures[i];
        }
    },	

    /**
     * APIProperty: CLASS_NAME
     * {String} 类名标识 - "Geo.View3D.Control.SelectFeature"
     * 
     */
    CLASS_NAME: "Geo.View3D.Control.SelectFeature"
});/**
 * Class: Geo.View3D.Control.Attribution
 * 图层属性信息控件。
 *
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.Attribution = 
  Geo.Class(Geo.View3D.Control, {
    
    /**
     * APIProperty: seperator
     * {String} 分隔符，用于分隔单个图层信息。不可以为HTML，可以加入转义符，例如："layer1\nlayer2"。
     */
    separator: ",",
	
	/**
	 * APIProperty: style
	 * {Object} 控件信息显示的样式。
	 * Symbolizer properties:
	 * startX - {Number} 以视图左上角为原点（0,0），文字框的左上点距离三维视图左边框的像素点。
	 * startY - {Number} 文字框的左上点距离三维视图上边框的像素点。
	 * endX - {Number} 文字框的右下点距离三维视图左边框的像素点。
	 * endY - {Number} 文字框的右下点距离三维视图上边框的像素点。
	 * fontSize - {Number} 字体大小。
	 * fontFamily - {String} 字体系列。
	 * opacity - {Number} 透明度。
	 * colorR - {Number} 颜色：红色的值。
	 * colorG - {Number} 颜色：绿色的值。
	 * colorB - {Number} 颜色：蓝色的值。
	 */
	style: {
		startX: 10,
		startY: 10,
		endX: 300,
		endY: 300,
		fontSize: 20,
		fontFamily: "雅黑",
		opacity: 255,
		colorR: 255,
		colorG: 255,
		colorB: 0
	},
    
    /**
     * Constructor: Geo.View3D.Control.Attribution 
     * 构造函数。
     * 
     * Parameters:
     * options - {Object} 选项参数。
     */
    initialize: function(options) {
        Geo.View3D.Control.prototype.initialize.apply(this, arguments);
    },

	/**
     * Method: updateAttribution
     * 控件销毁，私有。
     */
    destroy: function() {
		this.deactivate();
		this.removeTextElement();
        Geo.View3D.Control.prototype.destroy.apply(this, arguments);
    },    
     
	/**
     * Method: updateAttribution
     * 关联地图，私有。
     */
    setMap: function(map) {
        Geo.View3D.Control.prototype.setMap.apply(this, arguments);
    },

	/**
     * Method: updateAttribution
     * 控件绘制，私有。
     */
    draw: function(px){
        Geo.View3D.Control.prototype.draw.apply(this, arguments);
        this.map.events.on({
            'loadlayergroup': this.updateAttribution,
            scope: this
        });
        this.updateAttribution();
    },
	
    /**
     * Method: removeTextElement
     * 删除图层信息。
     */
    removeTextElement: function(){
        var globe = null;
        if (this.map) {
            globe = this.map.activexObj
            if (globe) {
                //globe.ScreenBox.ClearTextElement();
                globe.ScreenBox.RemoveTextElement(this.id);
            }
        }
    },
	
    /**
     * Method: updateAttribution
     * 更新图层信息。
     */
    updateAttribution: function() {
        if(this.map && this.map.activexObj){
            var globe = this.map.activexObj;
            var attributions = [];
            if (this.map.layers) {
                for(var i=0, len=this.map.layers.length; i<len; i++) {
                    var layer = this.map.layers[i];
                    if (layer.attribution && layer.getVisibility()) {
                        // add attribution only if attribution text is unique
                        if (OpenLayers.Util.indexOf(
                                        attributions, layer.attribution) === -1) {
                            attributions.push( layer.attribution );
                        }
                    }
                } 
				
                var outstr = attributions.join(this.separator);
                //globe.AddText(1, outstr, this.style.startX, this.style.startY, this.style.endX, this.style.endY, this.style.fontSize, this.style.fontFamily, this.style.opacity, this.style.colorR, this.style.colorG, this.style.colorB);
				globe.ScreenBox.AppendTextElement(this.id, 
				outstr, 
				this.style.fontFamily, 
				this.style.fontSize, 
				this.style.colorR+","+this.style.colorG+","+this.style.colorB, 
				this.style.startX, 
				this.style.startY, 
				this.style.endX, //width
				this.style.endY);//height
			}
        }
    },
	
    CLASS_NAME: "Geo.View3D.Control.Attribution"
});
/**
 * Class: Geo.View3D.Control.Box
 * 三维视图鼠标拉框类。本控件能够实现在三维视图下，用户使用鼠标进行拉框，来获得所拉框的bbox范围。
 * 
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.Box = Geo.Class(Geo.View3D.Control,{
	
	 /**
     * APIProperty: handlerOptions
     * {Object} 监听器的构造参数。
     */
    handlerOptions: null,

    /**
     * APIProperty: callbacks
     * {Object} 回调函数定义。
     */    
    callbacks: null,
	
    /**
     * Constructor: Geo.View3D.Control.PullBoxControl
     * Geo.View3D.Control.PullBoxControl构造函数。
     */
    initialize: function(options){
		Geo.View3D.Control.prototype.initialize.apply(this, [options]);
		this.callbacks = OpenLayers.Util.extend(
            {
                "emitMouseHandler": this.emitMouseHandler
            },
            this.callbacks
        );
		this.handlerOptions = this.handlerOptions || {};
    	this.handler = new Geo.View3D.Handler.Box( this,
                            this.callbacks, this.handlerOptions);
    },	
	
	/**
	 * APIMethod: emitMouseHandler
	 * 拉框后的回调方法，由用户覆盖。
	 * 
	 * Parameters:
     * bbox - {String} bounds的字符串表示方式,值的顺序为左下右上。
	 */
	emitMouseHandler: function(bbox) {

	},
	
	CLASS_NAME: "Geo.View3D.Control.Box"
});/**
 * Class: Geo.View3D.Control.ModelChoose
 * 三维视图模型选择控件类。
 * 
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.ModelChoose = Geo.Class(Geo.View3D.Control, {
	
	 /**
     * APIProperty: handlerOptions
     * {Object} 监听器的构造参数。
     */
    handlerOptions: null,

    /**
     * APIProperty: callbacks
     * {Object} 回调函数定义。
     */    
    callbacks: {},
	
    /**
     * Constructor: Geo.View3D.Control.ModelChoose
     * Geo.View3D.Control.ModelChoose构造函数。
     */
    initialize: function(options) {
		Geo.View3D.Control.prototype.initialize.apply(this, [options]);
		this.callbacks = OpenLayers.Util.extend(
            {
                "chooseModel": this.chooseModel
            },
            this.callbacks
        );
		this.handlerOptions = this.handlerOptions || {};
    	this.handler = new Geo.View3D.Handler.ModelChoose(this,
                            this.callbacks, this.handlerOptions);
    },	
	
	chooseModel: function(mouseEvent, isSelected) {
		
	},
	
	CLASS_NAME: "Geo.View3D.Control.ModelChoose"
});/**
 * Class: Geo.View3D.Control.Mouse
 * 三维视图鼠标动作类。使用本控件可以实现通过鼠标左键，右键以及鼠标移动动作来捕捉到三维地图的鼠标事件对象。
 * 说明：本类与鼠标拉框动作功能是分开的。
 * 
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.Mouse = Geo.Class(Geo.View3D.Control,{
	
	 /**
     * APIProperty: handlerOptions
     * {Object} 监听器的构造参数。
     */
    handlerOptions: null,

    /**
     * APIProperty: callbacks
     * {Object} 回调函数定义。
     */    
    callbacks: null,
	
    /**
     * Constructor: Geo.View3D.Control.Mouse
     * Geo.View3D.Control.Mouse构造函数。
     */
    initialize: function(options){
		Geo.View3D.Control.prototype.initialize.apply(this, [options]);
		this.callbacks = OpenLayers.Util.extend(
            {
                "click": this.onClick,
				"rightClick": this.onRightClick,
				"mouseMove": this.onMouseMove,
				"dblclick": this.onDblclick,
				"mouseUp": this.onMouseUp,
				"mouseRightUp":this.onMouseRightUp,
				"mouseDown": this.onMouseDown,
				"mouseWheel": this.onMouseWheel,
				"mouseOut": this.onMouseOut,
				"mouseOver": this.onMouseOver
            },
            this.callbacks
        );
		this.handlerOptions = this.handlerOptions || {};
    	this.handler = new Geo.View3D.Handler.Mouse( this,
                            this.callbacks, this.handlerOptions);
    },
	
   	/**
	 * APIMethod: onDblclick
	 * 鼠标左键双击动作，由用户覆盖
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象
	 */
	onDblclick: function(e) {

	},
	
	/**
	 * APIMethod: onClick
	 * 鼠标左键点击动作，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onClick: function(e) {

	},
	
	/**
	 * APIMethod: onRightClick
	 * 鼠标右键点击动作，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onRightClick: function(e) {
	
	},
	
	/**
	 * APIMethod: onMouseMove
	 * 鼠标移动动作，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onMouseMove: function(e) {

	},
	
	/**
	 * APIMethod: onMouseUp
	 * 鼠标左键抬起动作，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onMouseUp: function(e) {
		
	},
	
	/**
	 * APIMethod: onMouseDown
	 * 鼠标按下动作，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onMouseDown: function(e) {
	
	},
	/**
	 * APIMethod: onMouseWheel
	 * 鼠标滚轮动作，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onMouseWheel: function(e) {
		
	},
	
	/**
	 * APIMethod: onMouseOut
	 * 当鼠标移出元素时，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onMouseOut: function(e) {
		
	},
	
	/**
	 * APIMethod: onMouseOver
	 * 当鼠标移动到元素上时，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onMouseOver: function(e) {
		
	},
	
	/**
	 * APIMethod: onMouseRightUp
	 * 鼠标右键抬起动作，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onMouseRightUp: function() {
	
	},
	
	CLASS_NAME: "Geo.View3D.Control.Mouse"
});/**
 * Class: Geo.View3D.Control.Analysis
 * 测量与分析。
 *
 * Inherits from:
 *  - <Geo.View3D.Control.Analysis>
 */
Geo.View3D.Control.Analysis = Geo.Class(Geo.View3D.Control, {
	//定义数组对象
  	keyEventHandlers:[],
	trackerIds:[],
 	elementsKeys:[],
	//分析结果对象
	m_measureLength_result:null,//距离 result
	m_surfaceArea_result:null,//面积 result
	m_aspectAnalysis_Result:null,//坡向分析 result
	m_slopeAnalysis_Result:null,//坡度分析 result
	m_cutFillAnalysis_result:null,//填挖方分析 result
	m_nosSourceFlood_Result:null,//洪水淹没 result
	m_sectionPlane_Result:null,//剖面分析 result
	m_oObserverPoints_Result:null,//单点可视 result
	m_lineOfSight_Result:null,//两点通视 result
	//三维Tracker操作类型枚举
	enumTrackerType:
	{
		eTrackerEmpty : 0,
		eTrackerPolyline : 1,
		eTrackerPolygon : 2,
		eTrackerCircleSurface : 3,
		eTrackerCircleLine : 4,
		eTrackerVerticalLine : 5,
		eTrackerPolyline3D : 6,
		eScreenEnvelopeTracker : 7,
		eScreenPolylineTracker : 8
	},
	/**
     * APIProperty: 填挖方目标高度
     * {Number} 
     */
	cutFillAnalysisHeight:100,
	/**
     * APIProperty: 淹没高度
     * {Number} 
     */
	floodAnalysisHeight:100,
	/**
     * APIProperty: autoActivate
     * {Boolean} 控件加入地图后是否自动激活。
     */ 
	autoActivate: true,
    /**
     * Constructor: Geo.View3D.Control.Analysis
     * 构造函数。生成一个Geo.View3D.Control.Analysis的实例。
     */
    initialize: function(options){
        Geo.View3D.Control.prototype.initialize.apply(this, arguments);
    },
    
    /**
     * 量算距离
     */
    measureLengthAnalysis:function()
	{
		var id = OpenLayers.Util.createUniqueID();
		var globe = this.map.activexObj;
		if(globe){
			globe.DrawBox.StartTracker(id,this.enumTrackerType.eTrackerPolyline);
			this.trackerIds.push(id);
		}
	},

    /**
     * 量算面积
     */
    surfaceAreaAnalysis:function()
	{
		var id = OpenLayers.Util.createUniqueID();
		var globe = this.map.activexObj;
		if(globe){
			globe.DrawBox.StartTracker(id,this.enumTrackerType.eTrackerPolygon);
			this.surfaceAreaHandler = OpenLayers.Function.bind(function(eventObj){
	            this._surfaceAreaHandler(eventObj);
	        }, this);
			globe.attachEvent("OnTrackerFinished", this.surfaceAreaHandler);
			this.trackerIds.push(id);
			this.keyEventHandlers.push(this.surfaceAreaHandler);
		}
	},		
    _surfaceAreaHandler:function(vObjGeo,type)
	{
		var globe = this.map.activexObj;
		globe.detachEvent("OnTrackerFinished", this.surfaceAreaHandler);
		var globe = this.map.activexObj;
		this.m_surfaceArea_result = globe.AnalysisBox.AreaAsynchronous(vObjGeo.Result,10);
		globe.ScreenBox.AppendElement(this.m_surfaceArea_result.ProgressElement);
		this.m_surfaceArea_result.DoAnalysis();
		this.elementsKeys.push(this.m_surfaceArea_result.ProgressElement.Key);
	},		
    /**
     * 高度量算
     */
	measureHeightAnalysis:function(){
		var id = OpenLayers.Util.createUniqueID();
		var globe = this.map.activexObj;
		if(globe){
			globe.DrawBox.StartTracker(id,this.enumTrackerType.eTrackerVerticalLine);
			this.trackerIds.push(id);
		}
	},		
	/**
	 * 完成量算和分析的回调
	 * @param {} type 操作类型
	 * @param {} result 返回结果
	 */
	onComplete: function(type,result){
    },
    
	/**
	 * 高程信息查询
	 */
    queryElevationAnalysis:function(){
    	var globe = this.map.activexObj;
		if(globe){
			var queryElevationHandler = OpenLayers.Function.bind(function(eventObj){
            	this._queryElevationHandler(eventObj);
	        },this);
			globe.attachEvent("OnMouseEvent", queryElevationHandler);
			this.keyEventHandlers.push(queryElevationHandler);
		}
	},
	_queryElevationHandler:function(e){
		//监听鼠标单击事件
		if(e.MouseButton === 1 && e.MouseState === 0){
			var finalResult = {
	            longitude: null,
	            latitude: null,
	            altitude: null,
	            slope: null,
	            aspect: null
	        };
	        finalResult.longitude=e.X.toFixed(2);
	        finalResult.latitude=e.Y.toFixed(2);
	        finalResult.altitude=e.Altitude.toFixed(2);
	        //调用回调函数
			this.onComplete("elevationAnalysis",finalResult);
		}
	},
	/**
	 * 坡向分析
	 */
	aspectAnalysis:function(){
		var globe = this.map.activexObj;
		if(globe){
			var id = OpenLayers.Util.createUniqueID();
			globe.DrawBox.StartTracker(id,this.enumTrackerType.eTrackerPolygon);
			this.aspectTrackedHandler = OpenLayers.Function.bind(function(eventObj){
	            this._aspectTrackedHandler(eventObj);
	        }, this);
	        this.aspectFinishedHandler = OpenLayers.Function.bind(function(eventObj){
	            this._aspectFinishedHandler(eventObj);
	        }, this);
			globe.attachEvent("OnGeometryTracked", this.aspectTrackedHandler);
			globe.attachEvent("OnAnalysisFinished", this.aspectFinishedHandler);
			this.trackerIds.push(id);
			this.keyEventHandlers.push(this.aspectTrackedHandler);
			this.keyEventHandlers.push(this.aspectFinishedHandler);
		}
	},		
	_aspectTrackedHandler:function(vObjGeo)
	{
		var globe = this.map.activexObj;
		globe.detachEvent("OnGeometryTracked", this.aspectTrackedHandler);
		this.m_aspectAnalysis_Result = globe.AnalysisBox.RangeAspect(vObjGeo, 10);
		globe.ScreenBox.AppendElement(this.m_aspectAnalysis_Result.ProgressDisplayElement);
		this.elementsKeys.push(this.m_aspectAnalysis_Result.ProgressDisplayElement.Key);
		//开始分析
		this.m_aspectAnalysis_Result.DoAnalysis(null);
	},
	_aspectFinishedHandler:function(varResultObject,resultType)
	{
		var globe = this.map.activexObj;
		globe.detachEvent("OnAnalysisFinished", this.aspectFinishedHandler);
		globe.ScreenBox.RemoveElement(this.m_aspectAnalysis_Result.ProgressDisplayElement);
		globe.ScreenBox.AppendElement(this.m_aspectAnalysis_Result.ResultDisplayElement);
		this.elementsKeys.push(this.m_aspectAnalysis_Result.ResultDisplayElement.Key);
	},
	
	/**
	 * 坡度分析
	 */
	slopeAnalysis:function(){
		var globe = this.map.activexObj;
		if(globe){
			var id = OpenLayers.Util.createUniqueID();
			globe.DrawBox.StartTracker(id,this.enumTrackerType.eTrackerPolygon);
			this.slopeTrackedHandler = OpenLayers.Function.bind(function(eventObj){
	            this._slopeTrackedHandler(eventObj);
	        }, this);
	        this.slopeFinishedHandler = OpenLayers.Function.bind(function(eventObj){
	            this._slopeFinishedHandler(eventObj);
	        }, this);
			globe.attachEvent("OnGeometryTracked", this.slopeTrackedHandler); 
			globe.attachEvent("OnAnalysisFinished", this.slopeFinishedHandler); 
			this.trackerIds.push(id);
			this.keyEventHandlers.push(this.slopeTrackedHandler);
			this.keyEventHandlers.push(this.slopeFinishedHandler);
		}
	},
	_slopeTrackedHandler:function(vObjGeo)
	{
		var globe = this.map.activexObj;
		globe.detachEvent("OnGeometryTracked", this.slopeTrackedHandler); 
		this.m_slopeAnalysis_Result = globe.AnalysisBox.RangeSlope(vObjGeo, 10);
		globe.ScreenBox.AppendElement(this.m_slopeAnalysis_Result.ProgressDisplayElement);
		this.elementsKeys.push(this.m_slopeAnalysis_Result.ProgressDisplayElement.Key);
		//开始分析
		this.m_slopeAnalysis_Result.DoAnalysis(null);
	},
	_slopeFinishedHandler:function(varResultObject,resultType)
	{
		var globe = this.map.activexObj;
		globe.detachEvent("OnAnalysisFinished", this.slopeFinishedHandler); 
		globe.ScreenBox.RemoveElement(this.m_slopeAnalysis_Result.ProgressDisplayElement);
		globe.ScreenBox.AppendElement(this.m_slopeAnalysis_Result.ResultDisplayElement);
		this.elementsKeys.push(this.m_slopeAnalysis_Result.ResultDisplayElement.Key);
	},
	
	/**
	 * 填挖方分析
	 */
	cutFillAnalysis:function(){
		var globe = this.map.activexObj;
		if(globe){
			var id = OpenLayers.Util.createUniqueID();
			globe.DrawBox.StartTracker(id,this.enumTrackerType.eTrackerPolygon);
			this.cutFillTrackedHandler = OpenLayers.Function.bind(function(eventObj){
	            this._cutFillTrackedHandler(eventObj);
	        }, this);
			globe.attachEvent("OnGeometryTracked", this.cutFillTrackedHandler);  
			this.trackerIds.push(id);
			this.keyEventHandlers.push(this.cutFillTrackedHandler);
		}
	},			
	_cutFillTrackedHandler:function(vObjGeo)
	{
		var globe = this.map.activexObj;
		globe.detachEvent("OnGeometryTracked", this.cutFillTrackedHandler); 
		this.m_cutFillAnalysis_result = globe.AnalysisBox.CutFill(vObjGeo);
		globe.ScreenBox.AppendElement(this.m_cutFillAnalysis_result.ResultDisplayElement);						
		this.elementsKeys.push(this.m_cutFillAnalysis_result.ResultDisplayElement.Key);
		//分析
		this.m_cutFillAnalysis_result.CutFillTo(this.cutFillAnalysisHeight);
	},

	/**
	 * 洪水淹没
	 */
	nosSourceFloodAnalysis:function(){
		var globe = this.map.activexObj;
		if(globe){
			var id = OpenLayers.Util.createUniqueID();
			globe.DrawBox.StartTracker(id,this.enumTrackerType.eTrackerPolygon);
			this.nosSourceFloodTrackedHandler = OpenLayers.Function.bind(function(eventObj){
	            this._nosSourceFloodTrackedHandler(eventObj);
	        }, this);
			globe.attachEvent("OnGeometryTracked", this.nosSourceFloodTrackedHandler); 
			this.trackerIds.push(id);
			this.keyEventHandlers.push(this.nosSourceFloodTrackedHandler);
		}
	},
	_nosSourceFloodTrackedHandler:function(vObjGeo)
	{
		var globe = this.map.activexObj;
		globe.detachEvent("OnGeometryTracked", this.nosSourceFloodTrackedHandler); 
		this.m_nosSourceFlood_Result = globe.AnalysisBox.NoSourceFlood(vObjGeo);
		globe.ScreenBox.AppendElement(this.m_nosSourceFlood_Result.ResultDisplayElement);
		this.elementsKeys.push(this.m_nosSourceFlood_Result.ResultDisplayElement.Key);
		this.m_nosSourceFlood_Result.FloodTo(this.floodAnalysisHeight);
	},
	
	/**
	 * 剖面分析
	 */
	sectionPlaneAnalysis:function(){
		var globe = this.map.activexObj;
		if(globe){
			var id = OpenLayers.Util.createUniqueID();
			globe.DrawBox.StartTracker(id,this.enumTrackerType.eTrackerPolyline);
			this.sectionPlaneTrackedHandler = OpenLayers.Function.bind(function(eventObj){
	            this._sectionPlaneTrackedHandler(eventObj);
	        }, this);
			globe.attachEvent("OnGeometryTracked", this.sectionPlaneTrackedHandler);   
			this.trackerIds.push(id);
			this.keyEventHandlers.push(this.sectionPlaneTrackedHandler);
		}
	},			
	_sectionPlaneTrackedHandler:function(vObjGeo)
	{
		globe.detachEvent("OnGeometryTracked", this.sectionPlaneTrackedHandler); 
		var globe = this.map.activexObj;
		this.m_sectionPlane_Result = globe.AnalysisBox.SectionPlane(vObjGeo,50);
		var line = this.m_sectionPlane_Result.InterpolationGeometry;
		var drawBox = globe.DrawBox;
		var str="";
		var wkt = line.ExportToData(1,str);
		//定义数组对象
		var resultData=[];
		/**
		for (var i = 0; i < line.PointCount; i++)
		{
			//var x, y, z;
			//line.GetPoint(i, x, y, z);
			var x, y, z;
			line.ExportToData(i, 'out'+ 'x', out y, out z);
            //resultData.Add(z);
			resultData.push(z);
		}*/
//				 m_ResultView.Result = resultData;
		alert(resultData);
	},
	
	/**
	 * 单点可视
	 */
	observerPointsRangeAnalysis:function()
	{
		var globe = this.map.activexObj;
		if(globe){
			var id = OpenLayers.Util.createUniqueID();
			globe.DrawBox.StartTracker(id,this.enumTrackerType.eTrackerPolygon);
			this.trackerIds.push(id);
			this.observerPointsTrackedHandler = OpenLayers.Function.bind(function(eventObj){
	            this._observerPointsTrackedHandler(eventObj);
	        }, this);
	        this.observerPointsFinishedHandler = OpenLayers.Function.bind(function(eventObj){
	            this._observerPointsFinishedHandler(eventObj);
	        }, this);
			globe.attachEvent("OnGeometryTracked",this.observerPointsTrackedHandler); 
			globe.attachEvent("OnTrackerFinished", this.observerPointsFinishedHandler); 
		}
	},
	_observerPointsTrackedHandler:function(vObjGeo){
		//设置观察范围
		this.m_Range = vObjGeo;
	},
	_observerPointsFinishedHandler:function(varTrackerObject,enumTrackerType)
	{
		//设置观察点
		var tracker = varTrackerObject;
		if (tracker == null) return;
		var globe = this.map.activexObj;
		globe.detachEvent("OnGeometryTracked",this.observerPointsTrackedHandler); 
		globe.detachEvent("OnTrackerFinished", this.observerPointsFinishedHandler); 
		var id = OpenLayers.Util.createUniqueID();
		globe.DrawBox.StartTracker(id,this.enumTrackerType.eTrackerVerticalLine);
		this.trackerIds.push(id);
		this.observerPointsFinishedHandler2 = OpenLayers.Function.bind(function(eventObj){
	            this._observerPointsFinishedHandler2(eventObj);
	        }, this);		
		globe.attachEvent("OnTrackerFinished", this.observerPointsFinishedHandler2); 
		this.keyEventHandlers.push(this.observerPointsFinishedHandler2);
	},
	_observerPointsFinishedHandler2:function(varTrackerObject,enumTrackerType){
		var globe = this.map.activexObj;
		globe.detachEvent("OnTrackerFinished", this.observerPointsFinishedHandler2); 
		var pt3D =varTrackerObject.Location;
		this.m_oObserverPoints_Result=globe.AnalysisBox.ObserverPointsInRange(this.m_Range, pt3D);	
		globe.ScreenBox.AppendElement(this.m_oObserverPoints_Result.ShowProcessElement);
		this.elementsKeys.push(this.m_oObserverPoints_Result.ShowProcessElement.Key);
    	this.m_oObserverPoints_Result.StartAnalysisProcess();
	},
	
	/**
	 * 两点通视
	 */
	lineOfSightAnalysis:function(){
		var globe = this.map.activexObj;
		if(globe){
			var id = OpenLayers.Util.createUniqueID();
			globe.DrawBox.StartTracker(id,this.enumTrackerType.eTrackerVerticalLine);
//			this.lineOfSightTrackedHandler = OpenLayers.Function.bind(function(eventObj){
//	            this._lineOfSightTrackedHandler(eventObj);
//	        }, this);
	        this.lineOfSightFinishedHandler = OpenLayers.Function.bind(function(eventObj){
	            this._lineOfSightFinishedHandler(eventObj);
	        }, this);
//			globe.attachEvent("OnGeometryTracked", this.lineOfSightTrackedHandler);
			globe.attachEvent("OnTrackerFinished", this.lineOfSightFinishedHandler); 
			this.trackerIds.push(id);
		}
	},
//	_lineOfSightTrackedHandler:function(varGeo){					
//		this.startPt = varGeo.Location;
//	},
	_lineOfSightFinishedHandler:function(varGeo){					
		var tracker = varGeo;
		if (tracker == null) return;
		this.startPt = varGeo.Location;
		var globe = this.map.activexObj;
//		globe.detachEvent("OnGeometryTracked",this.lineOfSightTrackedHandler); 
		globe.detachEvent("OnTrackerFinished",this.lineOfSightFinishedHandler); 
		var id = OpenLayers.Util.createUniqueID();
		globe.DrawBox.StartTracker(id,this.enumTrackerType.eTrackerVerticalLine);
		this.trackerIds.push(id);
		this.lineOfSightFinishedHandler2 = OpenLayers.Function.bind(function(eventObj){
            this._lineOfSightFinishedHandler2(eventObj);
        }, this);		
		globe.attachEvent("OnTrackerFinished", this.lineOfSightFinishedHandler2); 
		this.keyEventHandlers.push(this.lineOfSightFinishedHandler2);
	},
	_lineOfSightFinishedHandler2:function(varTrackerObject,enumTrackerType){
		var globe = this.map.activexObj;
		globe.detachEvent("OnTrackerFinished", this.lineOfSightFinishedHandler2); 
		var endPt = varTrackerObject.Location;
		//两点通视
		this.m_lineOfSight_Result = globe.AnalysisBox.StartLineOfSight();
		this.m_lineOfSight_Result.EnableTracker = false;
		globe.ScreenBox.AppendElement(this.m_lineOfSight_Result);
		this.elementsKeys.push(this.m_lineOfSight_Result);
		//设置起点、终点的位置
		this.m_lineOfSight_Result.StartPoint = this.startPt;
		this.m_lineOfSight_Result.StartPointHeight = this.startPt.Z;
		this.m_lineOfSight_Result.EndPoint = endPt;  
		this.m_lineOfSight_Result.EndPointHeight=endPt.Z;
	},
	
	/**
	 * 清除分析结果
	 */
	clearAnalysisResult: function(){
		var globe = this.map.activexObj;
		if(globe){
			for(var i=0,len=this.trackerIds.length;i<len;i++){
				globe.DrawBox.RemoveTracker(this.trackerIds[i]);
			}
			for(var i=0,len=this.elementsKeys.length;i<len;i++){
				globe.ScreenBox.RemoveElement(this.elementsKeys[i]);
			}
	//		map.activexObj.DrawBox.RemoveAllTracker();
			for(var i=0,len=this.keyEventHandlers.length;i<len;i++){
				globe.detachEvent("OnGeometryTracked", this.keyEventHandlers[i]);	
				globe.detachEvent("OnAnalysisFinished", this.keyEventHandlers[i]);
				globe.detachEvent("OnTrackerFinished", this.keyEventHandlers[i]);
				globe.detachEvent("OnMouseEvent", this.keyEventHandlers[i]);
			}
		}
	},
	
 	/**
     * 激活控件
     */
    activate: function(){
        if (Geo.View3D.Control.prototype.activate.apply(this, arguments)) {
        	return true;
        }
        return false;
    },
    /**
     * 禁用控件
     */
    deactivate: function(){
    	//清除结果
    	this.clearAnalysisResult();
    	//清除全局变量
		this.keyEventHandlers = [];
		this.trackerIds = [];
	 	this.elementsKeys = [];
		this.m_measureLength_result = null;
		this.m_surfaceArea_result = null;
		this.m_aspectAnalysis_Result = null;
		this.m_slopeAnalysis_Result = null;
		this.m_cutFillAnalysis_result = null;
		this.m_nosSourceFlood_Result = null;
		this.m_sectionPlane_Result = null;
		this.m_oObserverPoints_Result = null;
		this.m_lineOfSight_Result = null;
        if (Geo.View3D.Control.prototype.deactivate.apply(this, arguments)) {
        	return true;
        }
        return false;
    },
    
    /**
     * Method: destroy
     */
    destroy: function() {
         this.deactivate();
         Geo.View3D.Control.prototype.destroy.apply(this, arguments);
    },
	/**
     * Method: updateAttribution
     * 关联地图，私有。
     */
    setMap: function(map) {
        Geo.View3D.Control.prototype.setMap.apply(this, arguments);
    },
   
    CLASS_NAME: "Geo.View3D.Control.Analysis"
});

/**
 * Class: Geo.View3D.Control.Keyboard
 * 三维视图键盘动作类。使用本控件可以实现通过键盘上下左右键动作来捕捉到三维地图的键盘事件对象。
 * 
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.Keyboard = Geo.Class(Geo.View3D.Control,{
	
	 /**
     * APIProperty: handlerOptions
     * {Object} 监听器的构造参数。
     */
    handlerOptions: null,

    /**
     * APIProperty: callbacks
     * {Object} 回调函数定义。
     */    
    callbacks: null,
	
    /**
     * Constructor: Geo.View3D.Control.Keyboard
     * Geo.View3D.Control.Keyboard构造函数。
     */
    initialize: function(options){
       Geo.View3D.Control.prototype.initialize.apply(this, [options]);
		this.callbacks = OpenLayers.Util.extend(
            {
                "keyboardDown": this.onKeyboardDown,
				"keyboardUp": this.onKeyboardUp
            },
            this.callbacks
        );
		this.handlerOptions = this.handlerOptions || {};
    	this.handler = new Geo.View3D.Handler.Keyboard(this,this.callbacks, this.handlerOptions);
    },
    
    /**
     * APIMethod: onKeyboardDown
     * 键盘按下。
     */
    onKeyboardDown: function(e){
    },
    
    /**
     * APIMethod: onKeyboardUp
     * 键盘抬起。
     */
    onKeyboardUp: function(e){
    },
	
	CLASS_NAME: "Geo.View3D.Control.Keyboard"
});/**
 * Class: Geo.View3D.Fly
 * 三维视图飞行控制对象。
 */
Geo.View3D.Fly = Geo.Class({
    
    /**
     * APIProperty: layer
     * {<Geo.View3D.Layer.Vector>} 供飞行路径及路径节点显示的矢量图层。
     */
    layer: null,
	
    /**
     * APIProperty: layerOptions
	 * {Object} 路径绘制矢量图层构造参数。
     */
	layerOptions: null,
	
    /**
     * APIProperty: map
	 * {Geo.View3D.Map} 三维视图对象。
     */
	map: null,
	
    /**
     * APIProperty: drawPathControl
     * {<Geo.View3D.Control.DrawFeature>} 用于飞行路径及路径节点的矢量绘制控件。
     */	
	drawPathControl:null,
	
	
	drawPointControl:null,
    /**
     * APIProperty: defaultFlyParams
     * {Object} 默认飞行路径节点相关设置参数。一条飞行路径是由一系列路径节点组成的，如果没有特别指定，
     * 添加路径节点时会应用默认设置参数。
     * 
     */	
	defaultFlyParams:{
		//默认飞行高度（米）
		height: 0,
		//默认飞行速度(千米/秒)，一般情况下为了取得比较好的视觉效果，飞行速度宜设置为：高度/10000
		speed: 0,
		//俯仰角
		tilt: 0,
		//侧倾角
		heading: 0
	},

    /**
     * APIProperty: model
     * {Object} 飞行当前中心点模型相关设置选项，有如下选项：
     * path - {String} 模型路径，默认值为空字符串。
     * visible - {Boolean} 该模型是否可见，默认值为false。
     */		
	model: null,
	
    /**
     * APIProperty: points
     * {Array(<Geo.Geometry.Point>)} 所有飞行途经点，包含点坐标、高度、俯仰角、侧倾角参数设置。
     */	
	points:null,

    /**
     * APIProperty: pathVisible
     * {Boolean} 飞行路径是否可见。
     */	
	pathVisible: true,
	
	/**
	 * APIProperty: pathVisible
	 * {Number} 飞行路径模式。0、贴地。1、恒高。
	 */
	pathFlyMode: 0,
	
	/**
     * APIProperty: eventListeners
     * {Object} 三维视图事件监听器。
     */      
    eventListeners: null, 
    
 	/**
 	 * APIProperty: EVENT_TYPES
 	 * {Array} 支持的事件类型。
 	 */
    EVENT_TYPES: ["OnFlyFinished"],
    
    /**
     * APIProperty: events
     * {Object} 三维飞行事件对象。
     */      
    events: null,
	/**
     * APIProperty: modelPath  
     * {String} 飞机模型地址（绝对路径）。
     */
    modelPath:"C:\\airplane\\airplane.x",
    /**
     * APIProperty: modelScale  
     * {String} 飞机模型缩小到原来的0.3倍，不能为负数。
     */
	modelScale:0.3,
	/**
     * APIProperty: modelDisToScreen  
     * {String} 飞机模型距相机的距离,不能为负数。
     */
	modelDisToScreen:5.0,
    /** 
     * Constructor: Geo.View3D.Fly
     * Geo.View3D.Fly 构造函数。
     *
     * Parameters:
     * options - {Object} 选项。
     *
     */	
	initialize: function(options){
		
        Geo.View3D.Control.prototype.initialize.apply(this, arguments);
		
        var options = OpenLayers.Util.extend({
            displayInLayerSwitcher: false,
			isOnTop: true
        }, this.layerOptions);
        
        this.events = new OpenLayers.Events(this, null, this.EVENT_TYPES);
        if(this.eventListeners instanceof Object) {
            this.events.on(this.eventListeners);
        }
        
		this.layer = new Geo.View3D.Layer.Vector(this.CLASS_NAME + "_layer", options);
		
        this.drawPathControl = new Geo.View3D.Control.DrawFeature(this.layer, Geo.View3D.Handler.Path, {
            featureAdded: OpenLayers.Function.bind(function(feature){
            	//停止飞行（避免多次绘制飞行路径的时候无法飞行）
            	this.controlFly(Geo.View3D.FLY_STOP);
				//设置飞行路径模式。0、贴地。1、恒高。
				this.setPathFlyMode(this.pathFlyMode);
				//绘制飞行线路完成后，设置飞行高度，速度，俯仰角，航仰角
//				this.setFlyCameraHeight(this.defaultFlyParams.height);
//                this.setFlySpeed(this.defaultFlyParams.speed);
//                this.setTilt(this.defaultFlyParams.tilt);
//                this.setHeading(this.defaultFlyParams.heading);
                //添加绘制要素到飞行点数组后进行飞行
                this.addFeatureToPoints(feature);
                this.drawPathControl.deactivate();
            }, this),
            //定义样式 
            handlerOptions: {   
                layerOptions: {   
	                style : {   
	                    fillOpacity : 0.8,   
	                    strokeWidth : 5,   
	                    pointRadius:20   
	                }   
	            }  
            }
        });
        this.drawPointControl = new Geo.View3D.Control.DrawFeature(this.layer, Geo.View3D.Handler.Point, {
            featureAdded: OpenLayers.Function.bind(function(feature){
				if(!feature)
					return;
        		//先停止飞行
	        	this.controlFly(Geo.View3D.FLY_STOP);
	        	//飞行的起点
	            var starPoint = new Geo.LonLat(feature.geometry.x, feature.geometry.y);
				//设置飞行参数
				this.setFlyFreePath(starPoint);
				//设置飞行高度
//				this.setFlyCameraHeight(2000);
				//设置飞行速度
//	            this.setFlySpeed(2000);
				//开始飞行,参数:Geo.View3D.FLY_START = 1;Geo.View3D.FLY_PASUE = 2;Geo.View3D.FLY_CONTINUE = 3;Geo.View3D.FLY_STOP = 4;
				this.controlFly(Geo.View3D.FLY_START);
				//设置飞行俯仰角
				this.setTilt(80);
                this.drawPointControl.deactivate();
            }, this)
        });
		this.points = [];
		this.model = {
			path: "",
			visible: false
		};
    },
     /**
     * APIMethod: showFlyModel
     * 显示隐藏飞机模型。
     * 
     */
    showFlyModel: function(){
    	var cross = this.map.activexObj.ScreenBox.QueryScreenElement(5);
        //如果已经显示，则隐藏
        if (cross.ModelVisible) {
            cross.ModelVisible = false;
        }
        else {
            //如果没有显示，则显示飞机模型；由于飞模型在建模时
            cross.ModelPath = this.modelPath;
            cross.ModelVisible = true;
            cross.ModelScale = this.modelScale; //模型的缩小到原来的0.3倍，不能为负数
            cross.ModelYaw = 0.0;   //绕Y轴旋转
            cross.ModelPitch = 90.0;//绕X轴旋转90度
            cross.ModelRoll = 180.0;//绕Z轴旋转180度
            cross.ModelDisToScreen = this.modelDisToScreen;//距相机的距离,不能为负数
        }
    },
    /**
     * APIMethod: initFlySet
     * 飞行参数初始化设置。
     * 
     * Parameters:
     * height - {Number} 飞行高度。
     * speed - {Number} 飞行速度。
     * tilt - {Number} 飞行俯仰角。
     * heading - {Number} 飞行侧倾角。
     */	
    initFlySet: function(height,speed,tilt,heading){
    	this.defaultFlyParams.height = height;
    	this.defaultFlyParams.speed = speed;
    	this.defaultFlyParams.tilt = tilt;
    	this.defaultFlyParams.heading = heading;
    },
    /**
     * Method: setMap
     * 将飞行控件对象关联到指定三维视图对象。
     * 
     * Parameters:
     * map - {<Geo.View3D.Map>} 三维视图对象。
     */		
	setMap: function(map){
		if(this.map){
			return;
		}
		this.map = map;
        //绑定飞行完成事件
        this.onFlyFinished = OpenLayers.Function.bind(function(eventObj){
            this._OnFlyFinished(eventObj);
        }, this);
        this.map.activexObj.attachEvent("OnFlyFinished", this.onFlyFinished);
        
		this._initFlyOption();
		map.addLayers([this.layer]);
		map.addControls([this.drawPathControl,this.drawPointControl]);
	},

	/**
	 * 飞行完成时进触发该事件
	 * @param {} event
	 */
	_OnFlyFinished:function(){
		this.events.triggerEvent("OnFlyFinished");
	},
	
	/**
	 * 解除地图关联
	 */
	removeMap: function(){
		if(this.map){
			this.map.activexObj.detachEvent("OnFlyFinished", this.onFlyFinished);
			this.layer && this.map.removeLayer(this.layer);
			this.drawPathControl && this.map.removeControl(this.drawPathControl);
			this.drawPointControl && this.map.removeControl(this.drawPointControl);
		};
		this.map = null;
	},

	/**
	 * APIMethod: destroy
	 * 销毁。
	 */	  
    destroy: function () {
    	this.removeMap();
        if (this.events) {
            if(this.eventListeners) {
                this.events.un(this.eventListeners);
            }
            this.events.destroy();
        }
        this.eventListeners = null;
        this.events = null;
    },
    
    /**
     * APIMethod: setPathVisible
     * 设置当前飞行路径是否可见。
     * 
     * Parameters:
     * isVisible - {Boolean} 路径是否可见的标识。
     */			
	setPathVisible: function(isVisible){
		this.drawPathControl.deactivate();
		this.layer.setVisibility(isVisible);
		this.pathVisible = isVisible;
	},
	
    /**
     * APIMethod: clearFlyPath
     * 清除本次设置的飞行路径。调用本方法后会停止当前飞行，移除飞行路径绘制图层上所有要素，并且清空所有飞行路径点。
     * 
     */		
	clearFlyPath: function(){
		this.controlFly(Geo.View3D.FLY_STOP);
		this.layer.removeFeatures(this.layer.features);
		this.points = [];
		this._clearAllFlyPoint();
		this.drawPathControl.deactivate();
	},
	
    /**
     * APIMethod: activate
     * 激活飞行控件。
     */	
	activate: function(){
		Geo.View3D.Control.prototype.activate.apply(this, arguments);
		this._initFlyOption();
	},
	
	onComplete: function(geometry){},
	
	onAddPoint: function(point,time,allPoints){},
	
	addPoints: function(){
		
	},
	
	/**
	 * APIMethod: addFeatureToPoints
	 * 添加绘制要素到飞行点数组。
	 *
	 * Parameters:
	 * feature - {<Geo.Feature.Vector>} 要素。
	 */	
	addFeatureToPoints:function(feature){
		this.points = [];
		var _points = feature.geometry.components;
		for(var i=0; i<_points.length; i++){
			this.points.push({
				longitude: _points[i].x,
				latitude: _points[i].y 
			});
		}
		this.setFlyPath();
		this.controlFly(Geo.View3D.FLY_START);		
	},
	
    /**
     * APIMethod: setTilt
     * 在飞行过程中实时调整俯仰角，有效值在0～90之间。
     * 
     * Parameters:
     * tilt - {Float} 俯仰角角度。
     */	
    setTilt: function(tilt){
		tilt = (tilt < 0) ? 0 : tilt;
		tilt = (tilt > 90) ? 90 : tilt;
//		this.defaultFlyParams.tilt = tilt;
//		this._flyMotion.FlyTilt = tilt;
//		this._flyMotion.IsRealtimeAdjust = true;
		this._camera.Tilt = tilt;
	},

    /**
     * APIMethod: setHeading
     * 在飞行过程中实时调整航向角，有效值在180～-180之间。
     * 
     * Parameters:
     * heading - {Float} 航向角角度。
     */		
	setHeading: function(heading){
//		this._flyMotion.FlyHeading = heading;
//		this._flyMotion.IsRealtimeAdjust = true;
		//自动恢复航向角 
		this._flyBox.ChangeAutoAdjustAttitude(0, false);
		this._camera.Heading = heading;
//		this.defaultFlyParams.heading = heading;
	},

    /**
     * APIMethod: setFlyPath
     * 设置描述飞行路径的几何对象。
     */		
    setFlyPath: function(){
		this._clearAllFlyPoint();
		
        for (var i = 0; i < this.points.length - 1; i++) {
            var pointStart = OpenLayers.Util.extend({}, this.points[i]);
            var pointEnd = OpenLayers.Util.extend({}, this.points[i + 1]);
            //创建一个飞行片段
            var flySegment = this._flyBox.CreateFlySegment(0);
            // 设置起点，相机所处高度默认为2000，暂时设置无效果，会被飞机高度取代
            flySegment.SetStartCoord(pointStart.longitude, pointStart.latitude, 2000);
            // 设置终点，相机所处高度默认为2000，暂时设置无效果，会被飞机高度取代
            flySegment.SetEndCoord(pointEnd.longitude, pointEnd.latitude, 2000);
            this._flyBox.AddFlySegment(flySegment);
        }
    },

    /**
     * APIMethod: getFlyPath
     * 获取飞行路径。
     */
	getFlyPath: function(){
		return this.points;
	},
	
    /**
     * APIMethod: setFlyCirclePath
     * 创建绕点飞行的路径。
     * 
     * Parameters:
     * starPoint - {<Geo.LonLat>} 起点坐标。
     * centerPoint - {<Geo.LonLat>} 绕点的中心坐标。
     * flyAngle - {Number} 设置飞行路径围绕中心点的角度。
     */
    setFlyCirclePath: function(starPoint, centerPoint, flyAngle){
        // 清除飞行片段
		this._clearAllFlyPoint();
        
        // 创建绕点飞行片段，设置起点，绕点中心和角度
		var flySegmentCircle = 1;
        var circleFlySegment = this._flyBox.CreateFlySegment(flySegmentCircle);
		
		var starPoint = starPoint ? starPoint : new Geo.LonLat(116.374153890879, 41.1);
		var centerPoint = centerPoint ? centerPoint : new Geo.LonLat(116.374153890879, 39.9056146840283);
		// 设置起点，相机所处高度默认为2000，暂时设置无效果，会被飞机的飞行高度取代
		circleFlySegment.SetStartCoord(starPoint.lon, starPoint.lat, 2000);
		// 设置绕点中心，相机所处高度默认为0，可以使相机俯视大地
        circleFlySegment.SetCentre(centerPoint.lon, centerPoint.lat, 0);
        // 设置飞行路径围绕中心点的角度
        circleFlySegment.FlyAngle = flyAngle ? flyAngle : 360;
        this._flyBox.AddFlySegment(circleFlySegment);
    },
	
	/**
     * APIMethod: setFlyFreePath
     * 设置自由飞行。
     * 
     * Parameters:
     * starPoint - {<Geo.LonLat>} 起点坐标。
     */
    setFlyFreePath: function(starPoint){
        // 清除飞行片段
		this._clearAllFlyPoint();
        // 创建绕点飞行片段，设置起点，绕点中心和角度
    	var circleFlySegment = this._flyBox.CreateFlySegment(2);
    	// 定义起点
		var starPoint = starPoint ? starPoint : new Geo.LonLat(116.374153890879, 41.001);
		// 设置起点
		circleFlySegment.SetStartCoord(starPoint.lon, starPoint.lat, 1000);
        // 设置飞行路径围绕中心点的角度
        this._flyBox.AddFlySegment(circleFlySegment);
    },			
				
    /**
     * APIMethod: controlFly
     * 控制飞行状态，可以设置开始飞行、暂停飞行、继续飞行和停止飞等状态。控制状态代码被定义为一系列常量，如下：
     * Geo.View3D.FLY_START: 1
     * Geo.View3D.FLY_PASUE: 2
     * Geo.View3D.FLY_CONTINUE: 3
     * Geo.View3D.FLY_STOP: 4
     * 
     * Parameters:
     * mode - {Integer} 控制状态代码。
     */			
	controlFly: function(mode){
		
		switch(mode) {
			case Geo.View3D.FLY_START:
				this._startFly();
				break;
			case Geo.View3D.FLY_PASUE:
				this._flyPause();
				break;
			case Geo.View3D.FLY_CONTINUE:
				this._flyContinue();
				break;
			case Geo.View3D.FLY_STOP:
				this._flyStop();
				break;
		}
	},

    /**
     * APIMethod: setFlyCameraHeight
     * 在飞行过程中实时调整飞行高度，有效值在5～63781370之间。在调整飞行高度后，为了保证正常的显示效果会自动根据高度调整飞行速度。
     * 
     * Parameters:
     * height - {Float} 飞行高度（单位：米）。
     */	    
    setFlyCameraHeight: function(height){
//    	this.defaultFlyParams.height = height;
    	this._flyBox.RelativeHeight = height;
//		this._flyMotion.FlyHeight = height;
//		this._flyMotion.IsRealtimeAdjust = true;
	},

    /**
     * APIMethod: setFlySpeed
     * 在飞行过程中实时调整飞行速度。
     * 
     * Parameters:
     * speed - {Float} 飞行速度（单位：公里/小时）。
     */	  	
    setFlySpeed: function(speed){
//    	this.defaultFlyParams.speed = speed;
		this._flyBox.FlySpeed = speed;
//		this._flyMotion.FlySpeed = speed;
//		this._flyMotion.IsRealtimeAdjust = true;
	},
	
    /**
     * Method: setFlyMode
     * 设置飞行模式。在geospace3D中，没有提供飞行模式的设置。之前activeX有提供飞行模式的设置。
     * 暂时保留这个接口。
     * 
     * Parameters:
     * mode - {Number} 0 正常飞行，1绕点。
     */	
	setFlyMode: function(mode){
	},
	
	/**
     * APIMethod: setPathFlyMode
     * 设置飞行路径模式。
     * 
     * Parameters:
     * pathFlyMode - {Number} 0：贴地。1：恒高。
     */	
	setPathFlyMode: function(pathFlyMode){
		//贴地
		if(pathFlyMode == 0){
			this.pathFlyMode = 0;
			this._flyBox.FlyHeightStyle = 2;
		}
		//恒高
		if (pathFlyMode == 1) {
			this.pathFlyMode = 1;
			this._flyBox.FlyHeightStyle = 3;
		}
	},
    
    /**
     * Method: saveFlyPathToFile
     * 保存飞行路径至文件。
     * 
     * Parameters:
     * path - {String} 路径。
     */	
    saveFlyPathToFile:function(path){
      //this._flyRoute.SaveFlyPathToFile(path);  
    },
	
    /**
     * Method: loadFlyPathFromFile
     * 从文件里面加载飞行路径
     * 
     * Parameters:
     * path - {String} 路径
     */
    loadFlyPathFromFile:function(path){
      //this._flyRoute.LoadFlyPathFromFile(path);  
    },
	
	/**
     * APIMethod: getGeometryFromFlyPoints
     * 从三维控件里面获取飞行路径点信息，并生成Geometry。
	 */
	getGeometryFromFlyPoints: function(){
		if(this._flyRoute){
			var pointsVar= [];
			for (var i=0; i< this._flyRoute.GetCount(); i++) {
				var pointInfo = this._flyMotionWrapper.GetPoint(this._flyRoute , i);
				var lon = pointInfo.XVal; //longitude
				var lat = pointInfo.YVal; //latitude
				var point = new Geo.Geometry.Point(lon, lat);
				pointsVar.push(point);
			}
			var pathGeometry = new Geo.Geometry.LineString(pointsVar);
			return pathGeometry;
		}
		return null;
	},

    /**
     * Method: setModelPath
     * 设置飞行模型文件路径。只接受绝对路径，可以传入url或本地文件路径。例如：
     * "http://localhost:8080/demo/images/airplane/airplane.x"或"c:\\airplane\\airplane.x"。
     * 设置新的模型文件路径后，模型的可见状态将被设置为false，调用setModelVisible(true)方法可将模型显示打开。
     * 
     * Parameters:
     * filePath - {String} 模型文件路径。
     */		
	setModelPath: function(filePath){
//		var globe = this.map.activexObj;
//		if (globe && (this.model.path !== filePath)) {
//			this.model.path = filePath;
//			this.model.visible = false;
//			globe.SetModelVisible(filePath,this.model.visible);
//		}
	},

    /**
     * APIMethod: setModelVisible
     * 设置当前飞行模型是否可见。
     * 
     * Parameters:
     * isVisible - {Boolean} 模型是否可见。
     */		
	setModelVisible: function(isVisible){
//		var globe = this.map.activexObj;
//		if (globe) {
//			this.model.visible = isVisible;
//			globe.SetModelVisible(this.model.path,isVisible);
//		}
	},

    /**
     * APIMethod: setCameraMode
     * 设置当前相机人称视角。
     * 
     * Parameters:
     * mode - {Number} mode值为0，代表第一人称视角表现飞行功能；mode值为1，代表第三人称视角。
     */		
	setCameraMode: function(mode){
		this._camera.CameraMode = mode;// mode为0，代表第一人称视角表现飞行功能
	},

    /**
     * APIMethod: getCameraMode
     * 获取当前相机人称视角
     * 
     * Returns:
     * {Number} 用于表示第一或第三人称视角表现飞行功能；值为0(1)，代表第一（三）人称视角。
     */		
	getCameraMode: function(){
		return this._camera.CameraMode;
	},
	
	//调整高度后，重新根据高度设置速度
	_getFlySpeed: function(height){
		return height * 14;
	},
	
	_flyRoute: null,
	
	_flyMotion: null,
	
	_camera: null,
	
	//初始化飞行所需对象
	_initFlyOption: function(){
		var globe = this.map.activexObj;
		if(globe){
			this._flyBox = globe.FlyBox;
			this._camera = globe.Camera;
			//geoSpace3D.FlyBox.FlyControl.Camera.CameraMode = 0;
			
//			this._flyRoute = globe.CreateFlyRoute();
//			this._flyMotion = globe.CreateFlyMotion();
//			this._flyMotionWrapper  = globe.GetFlyMotionWrapper();
//			this._camera = globe.GetCamera();

		}
		
	},
	
	//绘制飞行路径后，开始飞行之前，做相应参数设置
	_startFly: function(options){
		if(this._flyBox){
			this._flyBox.StartFly(0);
			//this._camera.CameraMode = 0;
			//this._flyMotion.SetFlyRoute(this._flyRoute);
	        //this._flyMotion.SetCamera(this._camera);
			//this._flyContinue();
		}
	},
	
	_flyPause: function(){
		if(this._flyBox){
			this._flyBox.PauseFly();
			//this._camera.CameraMode = 1;// 不是飞行状态时，恢复第三人称视角。
			//this._flyMotion.Pause();
		}
	},
	
	_flyContinue: function(){
		if(this._flyBox){
			this._flyBox.ResumeFly();
			//this._camera.CameraMode = 0;// 第一人称视角表现飞行功能
			//this._flyMotion.Fly();
		}
	},
	
	_flyStop: function(){
		if(this._flyBox){
			this._flyBox.StopFly();
			this._flyBox.ClearFlySegment();
			//this._camera.CameraMode = 1;// 不是飞行状态时，恢复第三人称视角。
			//this._flyMotion.Stop();
		}
		
	},	
	
	// 清除所有添加的飞行片段
	_clearAllFlyPoint: function(){
//		if(this._flyRoute){
//			this._flyRoute.removeAll();
//		}
		if (this._flyBox) {
			this._flyBox.ClearFlySegment();
		}
	},	
	
    CLASS_NAME: "Geo.View3D.Fly"

});

/**
 * Constant: Geo.View3D.FLY_START
 * 开始飞行的常量。
 */
Geo.View3D.FLY_START = 1;

/**
 * Constant: Geo.View3D.FLY_PASUE
 * 暂停飞行的常量。
 */
Geo.View3D.FLY_PASUE = 2;

/**
 * Constant: Geo.View3D.FLY_CONTINUE
 * 继续飞行的常量。
 */
Geo.View3D.FLY_CONTINUE = 3;

/**
 * Constant: Geo.View3D.FLY_STOP
 * 停止飞行的常量。
 */
Geo.View3D.FLY_STOP = 4;

Geo.View3D.Fly_MODE_ROUND = 1;
Geo.View3D.Fly_MODE_PATH = 0;
/**
 * Class: Geo.View3D.Popup
 * popup是可以在三维地图上打开和关闭的小型弹出窗口，通常是用于在选中一个矢量要素时，显示该要素的详细信息。popup通过
 * <Geo.View3D.Map.addPopup>方法添加到三维地图中。
 *
 * 代码示例:
 * (code)
 * popup = new Geo.View3D.Popup("3dPoup", 
 *                    new Geo.LonLat(5,40),
 *                    new Geo.Size(200,200),
 *                    "这是一个弹出框示例",
 *                    true);
 *       
 * map.addPopup(popup);
 * (end)
 */
Geo.View3D.Popup = Geo.Class({

    
    /** APIProperty: id
     * {String} 唯一标识。
     */
    id: "",

    /** 
     * APIProperty: lonlat 
     * {<Geo.LonLat>} 弹出框在地图中的坐标。
     */
    lonlat: null,


    /** 
     * APIProperty: size 
     * {<Geo.Size>} 弹出框的尺寸。
     */
    size: null,    

    /** 
     * APIProperty: contentHTML 
     * {String} 弹出框内显示的内容，如果contentHTML内容用到了CSS样式文件，注意使用CSS文件的绝对地址，否则无效果。
     */
    contentHTML: null,
    
    
    /** 
     * APIProperty: map 
     * {<Geo.View3D.Map>} 三维地图对象的引用。
     */
    map: null,
	
    /** 
     * APIProperty: contentType 
     * {int} 弹出框的内容类型，0.text 1.html 2.url，默认为html。
     */
    contentType: 1,

    //关闭时的回调函数
    _closeBoxCallback: null,
    
    /**
     * Constructor: Geo.View3D.Popup
     * Geo.View3D.Popup构造函数。
     *
     * Parameters:
     * id - {Object} 编号。
     * lonlat - {Object} 经纬度信息。
     * contentSize - {Object} 尺寸大小。
     * contentHTML - {Object} HTML代码。
     * closeBox - {Boolean} 是否显示关闭按钮。
     * closeBoxCallback - {Object} 点击关闭按钮的回调函数。
     */
    initialize:function(id, lonlat, contentSize, contentHTML, closeBox, closeBoxCallback) {
        if (id == null) {
            id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
        }

        this.id = id;
        this.lonlat = lonlat;

        this.contentSize = (contentSize != null) ? contentSize 
                                  : new Geo.Size(
                                                   Geo.View3D.Popup.WIDTH,
                                                   Geo.View3D.Popup.HEIGHT);
        if (contentHTML != null) { 
             this.contentHTML = contentHTML;
        }
		
		this._closeBox = new Boolean(closeBox);
		this._closeBoxCallback = closeBoxCallback;
    },
	
    //三维浮云框关闭按钮事件响应
    _closeBoxHandler: function(eType, bubbleWindwo, param) {
        var closeBoxCallback = this._closeBoxCallback;
        if (!closeBoxCallback) {
            return;
        }

        if (eType == 0) {
            closeBoxCallback();
        }
        this._removeCloseBoxHandler();
    },

    //附加关闭按钮事件响应
    _addCloseBoxHandler: function() {
        var globe = this.map.activexObj;
        this._closeBoxHandler = OpenLayers.Function.bind(this._closeBoxHandler, this);
        globe.attachEvent("OnBubbleWindowEvent", this._closeBoxHandler);
    },

    //移除关闭按钮事件响应
    _removeCloseBoxHandler: function(callbackFn) {
        var globe = this.map.activexObj;
        globe.detachEvent("OnBubbleWindowEvent", this._closeBoxHandler);
    },
    
    /**
     * APIMethod: draw
     * 绘制弹出框。
     *
     * Parameters:
     * px - {Object} 
     */
    draw: function(px) {
		var lonlat = px;
		var contentSize = this.contentSize;
		var contentHTML = this.contentHTML; 
        this._draw();//lonlat.lon,lonlat.lat,contentSize.w

    },
	
     //设置浮云框内容类型，可以为纯文本、HTML、URL
    _setContentType: function(){
        var globe = this.map.activexObj;
        globe.SceneGraph.SetBubbleContentType(this.contentType);
    },
    
	// 绘制
	_draw: function(){
		var map = this.map;
		if(map && map.activexObj){
		   var globe = map.activexObj;
		   this._setContentType();
		   var lonlat = this.lonlat;
		   var size = this.contentSize;
		   var sg = globe.SceneGraph;
		   sg.DeleteBubbleWindow();
		   sg.CreateBubbleWindow();
		   sg.SetBubblePoint(lonlat.lon,lonlat.lat);
		   sg.SetBubbleLocation(300,100,size.w,size.h);
		   sg.SetBubbleContent(this.contentHTML);
		   //sg.SetBubbleWindowRoundSize(15);
		   sg.SetBubbleWindowVisible(true);
		   //sg.SetBubbleCloseButtonVisible(this._closeBox);
		   this._addCloseBoxHandler();
		}
		
	},
	
	// 清除弹出框
	_clear: function(){
		var map = this.map;
		if(map && map.activexObj){
			var globe = map.activexObj;
		   	var sg = globe.SceneGraph;
		   	sg.DeleteBubbleWindow();
		   	this._removeCloseBoxHandler();
		}
	},
	
    CLASS_NAME: "Geo.View3D.Popup"
});

Geo.View3D.Popup.WIDTH = 270;
Geo.View3D.Popup.HEIGHT = 152;
Geo.View3D.Popup.COLOR = "white";
Geo.View3D.Popup.OPACITY = 1;
Geo.View3D.Popup.BORDER = "0px";
Geo.View3D.Popup.CONTENT_TYPE_TEXT = 0;
Geo.View3D.Popup.CONTENT_TYPE_HTML = 1;
Geo.View3D.Popup.CONTENT_TYPE_URL = 2;
/**
 * Class: Geo.View3D.Popup.FramedCloud
 * 三维视图浮云框。
 *
 * Inherits from:
 *  - <Geo.View3D.Popup>
 */
Geo.View3D.Popup.FramedCloud = Geo.Class(Geo.View3D.Popup,{
	
	/** 
     * Constructor: Geo.View3D.Popup.FramedCloud
     * Geo.View3D.Popup.FramedCloud构造函数。
     * 
     * Parameters:
     * id - {String}  浮云框的唯一标识，如果没有设置将会自动生成一个。
     * lonlat - {<Geo.LonLat>} 地图上浮云显示的位置。
     * contentSize - {<Geo.Size>} 浮云的尺寸。
     * contentHTML - {String} 浮云内容，浮云内容为HTML要素的字符串。如果HTML内容引用了CSS样式文件，注意引用CSS文件的绝对地址，否则无效果。
     * anchor - {Object} 锚点。包含一个大小信息{<Geo.Size>}和偏移信息{<Geo.Pixel>}的对象。
     * closeBox - {Boolean} 是否显示关闭浮云窗口的按钮。
     * closeBoxCallback - {Function} 关闭浮云触发该回调函数。
     */
    initialize:function(id, lonlat, contentSize, contentHTML, anchor, closeBox, 
                        closeBoxCallback) {
		var newArguments = [
            id, lonlat, contentSize, contentHTML, closeBox, closeBoxCallback
        ];
        Geo.View3D.Popup.prototype.initialize.apply(this, newArguments);
    },

    CLASS_NAME: "Geo.View3D.Popup.FramedCloud"
});/**
 * Class: Geo.View3D.FeatureManager
 * 要素结果管理器。提供了与矢量要素相关的一系列功能。支持对同一矢量图层上的要素进行分类管理，包含矢量图层样式设置、
 * 要素选择功能、要素浮云显示、要素集客户端分页等功能。
 */
Geo.View3D.FeatureManager = Geo.Class({
	
    /**
     * APIProperty: id
     * {String} 唯一标识。
     */
    id: null,	
    
    /**
     * APIProperty: map
     * {<Geo.View3D.Map>} 所属的地图对象。
     */
    map: null,
	
	//结果类型映射
	_typeMapping: null,
	
	/**
     * APIProperty: featureSortField
     * {String} 标识要素分类的属性名。
     */
	featureSortField: "featureSort",

	/**
     * APIProperty: orderNumberField
     * {String} 标识要素序号的属性名。
     */	
	orderNumberField: "orderNumber",

	/**
     * APIProperty: vectorLayer
     * {<Geo.View3D.Layer.Vector>} 矢量图层。
     */		
	vectorLayer: null,

	/**
     * APIProperty: selectControl
     * {<Geo.View3D.Control.SelectFeature>} 矢量要素选择控件。
     */	
	selectControl: null,

	/**
     * APIProperty: selectControl
     * {Integer} 默认的要素分页数量。
     */	
	maxFeaturesPerPage: 15,

    /**
     * Constructor: Geo.View3D.FeatureManager
     * Geo.View3D.FeatureManager对象构造函数
     * 
     * Parameters:
     * options - {Object} 相关选项设置
     */
	initialize: function(options){
		this._typeMapping = {};
		this.registerResultType("default");
		OpenLayers.Util.extend(this, options);
	},
	
	/**
     * APIMethod: setMap
     * 将要素管理对象关联到相应的地图对象。在关联到地图对象时,会在地图对象中加入一个矢量图层和相关控件。
     *
     * Parameters:
     * map - {<Geo.View3D.Map>} 地图对象
     */
	setMap: function(map){
		if(map && !this.map){
			this.map = map;
			
			//添加结果图层
			this.vectorLayer = new Geo.View3D.Layer.Vector("GeoGlobeFeatureManagerVector", {
				isOnTop: true,
				displayInLayerSwitcher: false
			});
			this.map.addLayer(this.vectorLayer);
			this._initSelectControl();
		}
	},

	/**
     * APIMethod: registerFeatureSort
     * 注册要素类别。如果希望对多个分类的要素进行管理，则需要先注册要素类别加以区分，
     * 然后再调用addFeatures方法向分类中添加要素集。
     *
     * Parameters:
     * sort - {String} 要素分类
     * options - {Object} 参数设置
     */	
	registerFeatureSort: function(sort,options){
		var DEFAULT_PARAMS = {
			features:[],
			currentPage:0,
			maxFeaturesPerPage: this.maxFeaturesPerPage,
			onTurnToPage: this.onTurnToPage,
			onFeatureSelect: Geo.View3D.FeatureManager.showFramedCloud,
			onFeatureUnselect: Geo.View3D.FeatureManager.closeFramedCloud,
			onFeatureOver: Geo.View3D.FeatureManager.showTopic,
			onFeatureOut: Geo.View3D.FeatureManager.closeTopic
		};
		this._typeMapping[sort] = OpenLayers.Util.extend(DEFAULT_PARAMS,options);
	},

     
    //此方法已被废弃，推荐使用registerResultSort
	registerResultType: function(sort,options){
        this.registerFeatureSort(sort,options);
	},
	
	/**
     * APIMethod: addFeatures
     * 向类别中添加要素，要素添加到类别后将为要素的外部属性中加上类型标识。
     *
     * Parameters:
     * features - {Array(<Geo.Feature.Vector>)} 添加的要素数组
     * sort - {String} 要素类别
     * isAppend - {Boolean} 是否追加要素
     */		
	addFeatures: function(features,sort,isAppend){
		sort = sort || "default";
        if(!(features instanceof Array)) {
			features = [features];
		}
		
		if(this._typeMapping[sort]){
			var features =  this._addTypeMarker(features,sort);
			
			//为要素添加自定义样式
			var style = this._typeMapping[sort].style;
			if(style){
				this._addStyleForFeatures(features,style);
			}
			
			if(!isAppend){
				this.clearResultFromMap(sort);
				this._typeMapping[sort].features = features;
			} else {
				this._typeMapping[sort].features.concat(features);
			}
			this._typeMapping[sort].currentPage = 0;
		}
	},
	
	/*
	 * APIMethod: onTurnToPage
	 * 获取当前页的要素，本方法需要用户自己去覆盖
	 * 
	 */
	onTurnToPage: function(feature){
		
	},
	
	/**
     * APIMethod: turnToPageN
     * 翻到指定页数。
     *
     * Parameters:
     * page - {Integer} 当前第几页
     * sort - {String} 要素类别
     * isDrawToMap - {Boolean} 是否绘制到地图上
     * 
     * Returns:
     * features - {Array(<Geo.Feature.Vector>)} 要素数组。
     */	
	turnToPageN: function(page, sort, isDrawToMap){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];

		var pageNum = this.getTotalPageNumber(sort);
		page = (page <= 0) ? 1 : page;
		page = (page > pageNum) ? pageNum : page; 
				
		var features = this._pagingFeatures({
			maxPerPage: mapping.maxFeaturesPerPage,
			pageNum:page,
			resultArr:mapping.features
		});
        
        this.addOrderForFeatures(features);
				
		if(page !== mapping.currentPage){
			this.clearResultFromMap(sort);
			this.drawFeaturesToMap(features);
			mapping.currentPage = page;
		}
		mapping.onTurnToPage(features);
		
		return features;
	},
	
	/**
     * APIMethod: turnToFirst
     * 翻到首页。
     *
     * Parameters:
     * sort - {String} 要素类别
     * isDrawToMap - {Boolean} 是否绘制到地图上
     * 
     * Returns:
     * features - {Array(<Geo.Feature.Vector>)} 要素数组。 
     */		
	turnToFirst:function(sort, isDrawToMap){
		sort = sort || "default";
		return this.turnToPageN(1,sort, isDrawToMap);
	},
	
	/**
     * APIMethod: turnToNext
     * 翻到下页。
     *
     * Parameters:
     * sort - {String} 要素类别
     * isDrawToMap - {Boolean} 是否绘制到地图上
     * 
     * Returns:
     * features - {Array(<Geo.Feature.Vector>)} 要素数组。
     */		
	turnToNext:function(sort, isDrawToMap){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		return this.turnToPageN(mapping.currentPage + 1, sort, isDrawToMap);
	},
	
	/**
     * APIMethod: turnToPre
     * 翻到前页。
     *
     * Parameters:
     * sort - {String} 要素类别
     * isDrawToMap - {Boolean} 是否绘制到地图上
     * 
     * Returns:
     * features - {Array(<Geo.Feature.Vector>)} 要素数组。 
     */		
	turnToPre:function(sort, isDrawToMap){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		return this.turnToPageN(mapping.currentPage - 1, sort, isDrawToMap);
	},
	
	/**
     * APIMethod: turnToLast
     * 翻到尾页。
     *
     * Parameters:
     * sort - {String} 要素类别
     * isDrawToMap - {Boolean} 是否绘制到地图上
     */		
	turnToLast:function(sort, isDrawToMap){
		sort = sort || "default";
		var last = this.getTotalPageNumber(sort);
		this.turnToPageN(last, sort, isDrawToMap);
	},
	
	/**
     * APIMethod: getPageInfo
     * 获取分页相关情况。
     *
     * Parameters:
     * sort - {String} 要素类别
     * 
     * Returns:
     * pageInfo - {Integer} 分页相关情况。
     */		
	getPageInfo: function(sort){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		var features = mapping.features;
		return Math.ceil(features.length / mapping.maxFeaturesPerPage);
	},
	
	/**
     * APIMethod: getTotalPageNumber
     * 获取指定类别的要素分页页数。
     *
     * Parameters:
     * sort - {String} 要素类别
     * 
     * Returns:
     * pageInfo - {Integer} 分页相关情况。
     */			
	getTotalPageNumber: function(sort){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		var features = mapping.features;
		return Math.ceil(features.length / mapping.maxFeaturesPerPage);
	},
	
	/**
     * APIMethod: getFeatures
     * 获取指定结果类型的要素。
     *
     * Parameters:
     * sort - {String} 要素类别
     * 
     * Returns:
     * features - {Array(<Geo.Feature.Vector>)} 要素数组。  
     */		
	getFeatures:function(sort){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		return mapping.features;
	},
	
	/**
     * APIMethod: drawFeaturesToMap
     * 将要素绘制到地图上，可以是指定类别名或指定要素数组。
     *
     * Parameters:
     * content - {String|<Array(Geo.Feature.Vector)>} 
     */		
	drawFeaturesToMap: function(content){
		var map, layer, features;
		map = this.map;
		layer = this.vectorLayer;
		
		if( typeof(content) == "string"){
			var sort = content || "default";
			if(this._typeMapping[sort] && map){
				features = this.getFeatures(sort);
			}

		};
		
		if( content instanceof  Array){
			features = content;
		};
		layer.addFeatures(features);
		layer.map.zoomToExtent(layer.getDataExtent());
	},
	
	/**
     * APIMethod: selectFeatureById
     * 通过ID来指定要素,通过选择控件来选择。
     *
     * Parameters:
     * featureid - {String|<Array(Geo.Feature.Vector)>} 要素编号
     */	
	selectFeatureById:function(featureid){
		this.selectControl.unselectAll();
//		var feature = this.vectorLayer.getFeatureById(featureid);
//		this.selectControl.select(feature);
		this.selectControl.select(featureid);
	},

	/**
     * APIMethod: clearFeatureFromMap
     * 清除指定类别要素,如无指定类别则默认清除"default"类别，如果指定值为"allType"则清除所有分类要素。
     *
     * Parameters:
     * sort - {String|<Array(Geo.Feature.Vector)>} 要素类别
     */		
	clearFeatureFromMap: function(sort){		
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		var features;
		var layer = this.vectorLayer;
		if(sort == "allType"){
			features = this.vectorLayer.features;
		} else {
			features = mapping ? mapping.features : [];
		}
		
		if(layer){
			this.selectControl.unselectAll();
			layer.removeFeatures(features);
		}
		
		
	},

    //此方法被废弃，推荐使用clearFeatureFromMap
	clearResultFromMap: function(sort){		
		this.clearFeatureFromMap(sort);
	},
	
	/**
     * APIMethod: addOrderForFeatures
     * 为要素数组中每个要素按顺序添加编号，编号是记录在“orderNumberField”属性指定的要素
     * 外部属性中。
     *
     * Parameters:
     * features - {Array<Geo.Feature.Vector>} 要素数组
     * 
     * Returns:
     * {Array<Geo.Feature.Vector>}
     */	
	addOrderForFeatures: function(features){
		//添加带序号的结果图标
	    for (var i = 0; i < features.length; i++) {
	        features[i].attributes[this.orderNumberField] = i;
	    }
		return features;
	},
    	
	//为要素加上样式
	_addStyleForFeatures: function(features, style){
		for(var i=0; i<features.length; i++){
			var f = features[i];
			if(!f.style){
				f.style = style;
			}
		}
	},
	
	//为每个要素添加类型标识属性
	_addTypeMarker: function(features,type){
		for(var i=0; i<features.length; i++){
			var feature = features[i];
			feature.attributes[this.featureSortField] = type;
		}
		return features;
	},
	
	/**
	 * 对指定结果要素数组进行分页处理
	 * options示例:
	 * {
	 * 		maxPerPage:15,
	 * 		pageNum:1,
	 * 		resultArr:[]
	 * }
	 */
	_pagingFeatures: function(options){
	    var start, end, 
			maxPerPage = options.maxPerPage, 
			pageNum = options.pageNum, 
			resultArr = options.resultArr;
	    start = (pageNum - 1) * maxPerPage;
	    end = pageNum * maxPerPage - 1;
	    
		var features = resultArr.slice(start, end + 1);
	    
	    //添加带序号的结果图标
	    var prefix = "images/resultIcons/";
	    for (var i = 0; i < features.length; i++) {
	        features[i].attributes[this.orderNumberField] = i;
	    }
	    
	    return features;
	},
	
	//根据事件类型分派事件
	_dispatchEvent: function(scope,feature,eventType){
		var resultType = feature.attributes[scope.featureSortField];
		var mapping = scope._typeMapping[resultType];
		mapping[eventType](feature);
	},
	
	//激活选择控件,自动检查是否控件初始化
	_initSelectControl: function(){
		if(!this.map){
			return;
		}
		if(!this.selectControl){
			
			//添加选择控件
			this.selectControl = new Geo.View3D.Control.SelectFeature(this.vectorLayer,{
				onSelect: OpenLayers.Function.bind(function(feature){
					this._dispatchEvent(this,feature,"onFeatureSelect");
				},this),
				onUnselect: OpenLayers.Function.bind(function(feature){
					this._dispatchEvent(this,feature,"onFeatureUnselect");
				},this),
				callbacks:{
					over: OpenLayers.Function.bind(function(feature){
						this._dispatchEvent(this,feature,"onFeatureOver");
					},this),
					out: OpenLayers.Function.bind(function(feature){
						this._dispatchEvent(this,feature,"onFeatureOut");
					},this)
				}
			})
			this.map.addControl(this.selectControl);
		}
	}
});

/**
 * APIProperty: Geo.View3D.FeatureManager.defaultStyleMap
 * {<Geo.StyleMap>} FeatureManager中vectorLayer图层的默认要素样式。
 */
Geo.View3D.FeatureManager.defaultStyleMap = new Geo.StyleMap({
    "default": new Geo.Style({
    	externalGraphic: OpenLayers.Util.getImagesLocation() + "marker.png",
    	graphicWidth:21,
		graphicHeight:25,
		graphicXOffset:-10,
		graphicYOffset:-12
    }) ,
    "select": new Geo.Style({
        externalGraphic: OpenLayers.Util.getImagesLocation() + "marker-blue.png",
    	graphicWidth:21,
		graphicHeight:25,
		graphicXOffset:-10,
		graphicYOffset:-12
    })
});

/**
 * APIMethod: Geo.View3D.FeatureManager.showFramedCloud
 * 为要素添加浮云，如果指定指定内容模板则浮云内空按模板规则生成。
 * 
 * Parameters:
 * feature - 浮云所属的矢量要素
 * templateString - 字符串内容模板
 * 
 */
Geo.View3D.FeatureManager.showFramedCloud = function(feature, templateString){
	var layer = feature.layer, map = layer ? layer.map : null;
	if(!layer || !map){
		return;
	}
	var str;
	if(templateString){
		var obj = {}
		for(var item in feature.attributes){
			obj[item] = feature.attributes[item];
		}
		str = OpenLayers.String.format(templateString,obj);
	} else {
		str = (function(){
	        var str = "";
	        for (var myitem in feature.attributes) {
	            str += myitem + ":" + feature.attributes[myitem] + "<br>";
	        }
	        return str;
	    })();
	}
    

	var lonlat = feature.geometry.getBounds().getCenterLonLat();
	
    if (map) {
        //map.panTo(lonlat);
		// 4000为设置的三维俯视高度
		map.flyTo(lonlat, 4000);
    }
    
    var popup = new Geo.View3D.Popup.FramedCloud(
		"featureInfo", 
		lonlat, 
		null, 
		str, 
		null, 
		true, 
		Geo.View3D.FeatureManager.onPopupClose
	);
    feature.popup = popup;
    map.addPopup(popup);
};

/**
 * APIMethod: Geo.View3D.FeatureManager.closeFramedCloud
 * 关闭并消毁指定要素上添加的浮云。
 * 
 * Parameters:
 * feature - 浮云所属的矢量要素
 * 
 */
Geo.View3D.FeatureManager.closeFramedCloud = function(feature){
    
};

/**
 * APIMethod: Geo.View3D.FeatureManager.onPopupClose
 * 浮云关闭时触发的方法。
 */
Geo.View3D.FeatureManager.onPopupClose = function(){
   
}
	
Geo.View3D.FeatureManager.showTopic = function(feature){
	
};
	
Geo.View3D.FeatureManager.closeTopic = function(feature){
	
};
/**
 * Class: Geo.View3D.Control.Measure.PointInfo
 * 量算出一个点的信息结果
 *
 * Inherits from:
 *  - <Geo.View3D.Control.Measure>
 */
Geo.View3D.Control.Measure.PointInfo = Geo.Class(Geo.View3D.Control.Measure, {
    /**
     * APIProperty: handlerType
     * 三维视图事件监听类型
     */
    handlerType: Geo.View3D.Handler.Point,
    
    //MEASURE_PARAM: 6,
    /**
     * Constructor: Geo.View3D.Control.Measure.PointInfo
     * 构造函数。生成一个Geo.View3D.Control.Measure.PointInfo的实例。
     */
    initialize: function(serviceUrl, options){
        Geo.View3D.Control.Measure.prototype.initialize.apply(this, arguments);
    },
	
    /**
     * APIMethod: onAddPoint
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onAddPoint: function(result){
    },
	
    /**
     * APIMethod: onComplete
     * 在三维视图上结束绘制图形时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onComplete: function(result){
    },
	
    /**
     * 在三维视图上结束绘制图形时，调用此方法
     * geometry {Object}
     */
    _onComplete: function(geometry){
        var pointsString = geometry.x + "," + geometry.y;
        var options = {};
        options.coordinates = pointsString;
        
		var longitude = parseFloat(geometry.x);
		var latitude = parseFloat(geometry.y);
		var altitude = this.map.activexObj.AnalysisBox.QueryAltitude(longitude, latitude);
        //最终结果定义
        var finalResult = {
            longitude: longitude,
            latitude: latitude,
            altitude: altitude,
            slope: null,
            aspect: null
        };
        
		
		this.onComplete(finalResult);
//        //分三次异步请求查询高程、坡度、坡向
//        this._getMeasureResult("pointAltitude", options, OpenLayers.Function.bind(function(result){
//            if (this._terrainAnalysisService._isException(result)) {
//                this.onComplete(result);
//                return result;
//            }
//            finalResult.altitude = result.Result.Value;
//            this._getMeasureResult("pointSlope", options, OpenLayers.Function.bind(function(result){
//                if (this._terrainAnalysisService._isException(result)) {
//                    this.onComplete(result);
//                    return result;
//                }
//                finalResult.slope = result.Result.Value;
//                this._getMeasureResult("pointAspect", options, OpenLayers.Function.bind(function(result){
//                    if (this._terrainAnalysisService._isException(result)) {
//                        this.onComplete(result);
//                        return result;
//                    }
//                    finalResult.aspect = result.Result.Value;
//                    this.onComplete(finalResult);
//                }, this));
//            }, this));
//        }, this));
        
        
    },
	
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     * result - {Object}
     */
    _onAddPoint: function(){
    },
	
    /**
     * APIProperty: CLASS_NAME
     * 类名标识 - "Geo.View3D.Control.Measure.PointInfo"
     */
    CLASS_NAME: "Geo.View3D.Control.Measure.PointInfo"

});

/**
 * Class: Geo.View3D.Control.Measure.Distance
 * 量算出距离结果
 *
 * Inherits from:
 *  - <Geo.View3D.Control.Measure>
 */
Geo.View3D.Control.Measure.Distance = Geo.Class(Geo.View3D.Control.Measure, {
    /**
     * APIProperty: handlerType
     * 三维视图事件监听类型
     */
    handlerType: Geo.View3D.Handler.Path,
    
    /**
     * APIProperty: isRealTime
     * {Boolean} 是否实时获取结果。 默认值为false。
     */
    isRealTime: false,
    //MEASURE_PARAM: 7,
    /**
     * Constructor: Geo.View3D.Control.Measure.Distance
     * 构造函数。生成一个Geo.View3D.Control.Measure.Distance的实例。
     */
    initialize: function(serviceUrl, options){
        Geo.View3D.Control.Measure.prototype.initialize.apply(this, arguments);
    },
    
    /*
     _measureHandler: function(mouseEvent){
     var result = {
     distance: mouseEvent.Distance,
     surfDistance: mouseEvent.SurfDistance
     };
     this._result = result;
     this.onAddPoint(result);
     },
     */
    /**
     * APIMethod: onAddPoint
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onAddPoint: function(result){
    },
    /**
     * APIMethod: onComplete
     * 在三维视图上结束绘制图形时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onComplete: function(result){
    },
    
    /**
     * 在三维视图上结束绘制图形时，调用此方法
     * geometry {Object}
     */
    _onComplete: function(geometry){
    
        var pointsString = this._points.join(",");
        var options = {};
        options.coordinates = pointsString;
        
        var finalResult = {
            distance: null,
            surfDistance: null
        };
        finalResult.distance = geometry.getGeodesicLength();
		
		this.onComplete(finalResult);
//        this._getMeasureResult("surfaceDistance", options, OpenLayers.Function.bind(function(result){
//            if (this._terrainAnalysisService._isException(result)) {
//                this.onComplete(result);
//                return result;
//            }
//            finalResult.surfDistance = result.Result.Value;
//            this.onComplete(finalResult);
//        }, this));
    },
    
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     * result - {Object}
     */
    _onAddPoint: function(pointGeometry, lineGeometry){
        var allPoints = lineGeometry.components;
        this._points = [];
        for (var i = 0; i < allPoints.length; i++) {
            this._points.push(allPoints[i].x);
            this._points.push(allPoints[i].y);
        }
        
        if (allPoints.length <= 1) {
            return;
        }
        
        if (this.isRealTime) {
        
            var pointsString = this._points.join(",");
            
            var options = {};
            options.coordinates = pointsString;
            var finalResult = {
                surfDistance: null
            };
            
            this._getMeasureResult("surfaceDistance", options, OpenLayers.Function.bind(function(result){
            
                finalResult.surfDistance = result.Result.Value;
                this.onAddPoint(finalResult);
            }, this));
        }
        
        
        //this._setMeasureParams(this.MEASURE_PARAM, points.join(" "), 0);     
    },
    
    /**
     * APIProperty: CLASS_NAME
     * 类名标识 - "Geo.View3D.Control.Measure.PointInfo"
     */
    CLASS_NAME: "Geo.View3D.Control.Measure.PointInfo"

});

/**
 * Class: Geo.View3D.Control.Measure.Area
 * 量算出一个面结果。
 *
 * Inherits from:
 *  - <Geo.View3D.Control.Measure>
 */
Geo.View3D.Control.Measure.Area = Geo.Class(Geo.View3D.Control.Measure, {

    /**
     * APIProperty: handlerType
     * 三维视图事件监听类型。
     */
    handlerType: Geo.View3D.Handler.Polygon,
    
    //MEASURE_PARAM: 2,
    
    /**
     * APIProperty: isRealTime
     * {Boolean} 是否实时获取结果。 默认值为false。
     */
    isRealTime: false,
    
    /**
     * Constructor: Geo.View3D.Control.Measure.Area
     * 构造函数。生成一个Geo.View3D.Control.Measure.Area的实例。
     * 
     */
    initialize: function(serviceUrl, options){
        Geo.View3D.Control.Measure.prototype.initialize.apply(this, arguments);
    },
    
    /*
     _measureHandler: function(mouseEvent){
     var result = {
     area: mouseEvent.Area,
     surfArea: mouseEvent.SurfArea
     };
     this._result = result;
     this.onAddPoint(result);
     },
     */
    /**
     * APIMethod: onAddPoint
     * 在三维视图上鼠标点击添加一个点时，调用此方法。
     *
     * Paramters:
     * result - {Object}
     */
    onAddPoint: function(result){
    },
    
    /**
     * APIMethod: onComplete
     * 在三维视图上结束绘制图形时，调用此方法。
     *
     * Paramters:
     * result - {Object}
     */
    onComplete: function(result){
    },
    
    /**
     * 在三维视图上结束绘制图形时，调用此方法。
     * geometry - {Object} 要素。
     */
    _onComplete: function(geometry){
    
        var pointsString = this._points.join(",");
        var options = {};
        options.coordinates = pointsString;
        
        var finalResult = {
            area: null,
            surfaceArea: null
        };
        finalResult.area = geometry.getGeodesicArea();
		
		this.onComplete(finalResult);
//        this._getMeasureResult("surfaceArea", options, OpenLayers.Function.bind(function(result){
//            if (this._terrainAnalysisService._isException(result)) {
//                this.onComplete(result);
//                return result;
//            }
//            finalResult.surfaceArea = result.Result.Value;
//            this.onComplete(finalResult);
//        }, this));
    },
    
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法。
     * pointGeometry - {Object}
     * lineGeometry - {Object}
     */
    _onAddPoint: function(pointGeometry, lineGeometry){
        var allPoints = lineGeometry.components[0].components;
        this._points = [];
        for (var i = 0; i < allPoints.length; i++) {
            this._points.push(allPoints[i].x);
            this._points.push(allPoints[i].y);
        }
        
        if (allPoints.length <= 2) {
            return;
        }
        
        if (this.isRealTime) {
        
            var pointsString = this._points.join(",");
            
            var options = {};
            options.coordinates = pointsString;
            var finalResult = {
                surfaceArea: null
            };
            
            this._getMeasureResult("surfaceArea", options, OpenLayers.Function.bind(function(result){
            
                finalResult.surfaceArea = result.Result.Value;
                this.onAddPoint(finalResult);
            }, this));
        }
        
        
        //this._setMeasureParams(this.MEASURE_PARAM, points.join(" "), 0);     
    },
    
    /*
     _onComplete:function(geometry){
     this.onComplete(this._result);
     },
     
     _onAddPoint: function(pointGeometry,polygonGeometry){
     
     //检查多于两个点才计算
     var linearRing = polygonGeometry.components[0];
     var allPoints = linearRing.components;
     if(allPoints.length <= 2){
     return;
     }
     //正式量算
     var pointsStr = this._getPointsSpaceSplitStr(polygonGeometry,0);
     this._setMeasureParams(this.MEASURE_PARAM, pointsStr, 0);
     },
     */
    CLASS_NAME: "Geo.View3D.Control.Measure.Area"
});

/**
 * Class: Geo.View3D.Control.Measure.Volume
 * 量算体积的分析结果
 *
 * Inherits from:
 *  - <Geo.View3D.Control.Measure>
 */
Geo.View3D.Control.Measure.Volume = Geo.Class(Geo.View3D.Control.Measure, {
    /**
     * APIProperty: handlerType
     * 三维视图事件监听类型
     */
    handlerType: Geo.View3D.Handler.Polygon,
    
    //MEASURE_PARAM: 2,
    /**
     * APIProperty: height
     * {Integer} 海拔高度。 默认值为200。
     */
    height: 200,
	
    /**
     * Constructor: Geo.View3D.Control.Measure.Volume
     * 构造函数。生成一个Geo.View3D.Control.Measure.Volume的实例。
     */
    initialize: function(serviceUrl, options){
        Geo.View3D.Control.Measure.prototype.initialize.apply(this, arguments);
    },
    
    /*
     _measureHandler: function(mouseEvent){
     var result = {
     height: this.height,
     volume: mouseEvent.Volume
     };
     this._result = result;
     this.onAddPoint(result);
     },
     */
    /**
     * APIMethod: onAddPoint
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onAddPoint: function(result){
    },
	
    /**
     * APIMethod: onComplete
     * 在三维视图上结束绘制图形时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onComplete: function(result){
    },
    
    /*
     _onComplete:function(geometry){
     this.onComplete(this._result);
     },
     
     _onAddPoint: function(pointGeometry,polygonGeometry){
     var linearRing = polygonGeometry.components[0];
     var allPoints = linearRing.components;
     if(allPoints.length <= 2){
     return;
     }
     var pointsStr = this._getPointsSpaceSplitStr(polygonGeometry);
     this._setMeasureParams(this.MEASURE_PARAM, pointsStr, this.height);
     },
     */
    /**
     * 在三维视图上结束绘制图形时，调用此方法
     * geometry {Object}
     */
    _onComplete: function(geometry){
    
        var pointsString = this._points.join(",");
        var options = {};
        options.coordinates = pointsString;
        options.subjoin = this.height;
        var finalResult = {
            height: this.height,
            geometry: geometry,
            //excavate:null,
            //file:null,
            volume: null
        };
		
		
		this.onComplete(finalResult);
//        this._getMeasureResult("volume", options, OpenLayers.Function.bind(function(result){
//            if (this._terrainAnalysisService._isException(result)) {
//                this.onComplete(result);
//                return result;
//            }
//            var arr = result.Result.Value.split(" ");
//            finalResult.volume = arr[0];
//            //finalResult.excavate = arr[1];
//            //finalResult.fill = arr[2];
//            this.onComplete(finalResult);
//        }, this));
    },
	
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     * result - {Object}
     */
    _onAddPoint: function(pointGeometry, lineGeometry){
        var allPoints = lineGeometry.components[0].components;
        this._points = [];
        for (var i = 0; i < allPoints.length; i++) {
            this._points.push(allPoints[i].x);
            this._points.push(allPoints[i].y);
        }
        
        if (allPoints.length <= 2) {
            return;
        }
        
        if (this.isRealTime) {
        
            var pointsString = this._points.join(",");
            
            var options = {};
            options.coordinates = pointsString;
            options.subjoin = this.height;
            var finalResult = {
                height: this.height,
                geometry: lineGeometry,
                //excavate: null,
                //fill: null,
                volume: null
            };
            
            this._getMeasureResult("volume", options, OpenLayers.Function.bind(function(result){
            
                //finalResult.volume = result.Result.Value;
                var arr = result.Result.Value.split(" ");
                finalResult.volume = arr[0];
                finalResult.excavate = arr[1];
                finalResult.fill = arr[2];
                this.onAddPoint(finalResult);
            }, this));
        }

        //this._setMeasureParams(this.MEASURE_PARAM, points.join(" "), 0);     
    },
	
    /**
     * APIProperty: CLASS_NAME
     * 类名标识 - "Geo.View3D.Control.Measure.Volume"
     */
    CLASS_NAME: "Geo.View3D.Control.Measure.Volume"

});

/**
 * Class: Geo.View3D.Control.Measure.Excavate
 * 量算填挖方的分析结果
 *
 * Inherits from:
 *  - <Geo.View3D.Control.Measure>
 */
Geo.View3D.Control.Measure.Excavate = Geo.Class(Geo.View3D.Control.Measure, {
    /**
     * APIProperty: handlerType
     * 三维视图事件监听类型
     */
    handlerType: Geo.View3D.Handler.Polygon,
    
    //MEASURE_PARAM: 0,
    /**
     * APIProperty: height
     * {Integer} 海拔高度。 默认值为200。
     */
    height: 200,
	
    /**
     * APIProperty: lowHeight
     * {Integer} 挖填方高度(低)。 默认值为0。
     */
	lowHeight: 0,
	
    /**
     * APIProperty: highHeight
     * {Integer} 挖填方高度(高)。 默认值为200。
     */
	highHeight: 200,
    /**
     * Constructor: Geo.View3D.Control.Measure.Excavate
     * 构造函数。生成一个Geo.View3D.Control.Measure.Excavate的实例。
     */
    initialize: function(serviceUrl, options){
        Geo.View3D.Control.Measure.prototype.initialize.apply(this, arguments);
    },
	
    /**
     * APIMethod: onAddPoint
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onAddPoint: function(result){
    },
	
    /**
     * APIMethod: onComplete
     * 在三维视图上结束绘制图形时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onComplete: function(result){
    },
	
    /**
     * 在三维视图上结束绘制图形时，调用此方法
     * geometry {Object}
     */
    _onComplete: function(geometry){
    
        var pointsString = this._points.join(",");
        var options = {};
        options.coordinates = pointsString;
        options.subjoin = this.height;
        var finalResult = {
            height: this.height,
            geometry: geometry,
            excavate: null,
            fill: null,
            volume: null
        };
		
		var ringStr = geometry.toString().replace("POLYGON","Ring");
		var ringStr = ringStr.replace("((","(");
		var ringStr = ringStr.replace("))",")");
        var polygon3D = this.map.activexObj.DrawBox.CreateGeometryObject(ringStr, "", 3, 1);
        //var polygon = this.map.activexObj.DrawBox.CreateGeometryObject("Ring(114 30,115 30,115 31,114 31,114 30)", "", 3, 1);
		var result3D = this.map.activexObj.AnalysisBox.CutFill(polygon3D, this.lowHeight, this.height);
        //var result = this.map.activexObj.AnalysisBox.CutFill(polygon, 0, 1);
		finalResult.excavate = result3D.CutVolume;
		finalResult.fill = result3D.FillVolume;
		finalResult.volume = 0;
		this.onComplete(finalResult);
		
       // alert("填：" + result.FillVolume + "挖：" + result.CutVolume);
//        this._getMeasureResult("volume", options, OpenLayers.Function.bind(function(result){
//            if (this._terrainAnalysisService._isException(result)) {
//                this.onComplete(result);
//                return result;
//            }
//            var arr = result.Result.Value.split(" ");
//            finalResult.volume = arr[0];
//            finalResult.excavate = arr[1];
//            finalResult.fill = arr[2];
//            this.onComplete(finalResult);
//        }, this));
    },
	
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     * result - {Object}
     */
    _onAddPoint: function(pointGeometry, lineGeometry){
        var allPoints = lineGeometry.components[0].components;
        this._points = [];
        for (var i = 0; i < allPoints.length; i++) {
            this._points.push(allPoints[i].x);
            this._points.push(allPoints[i].y);
        }
        
        if (allPoints.length <= 2) {
            return;
        }
        
        if (this.isRealTime) {
        
            var pointsString = this._points.join(",");
            
            var options = {};
            options.coordinates = pointsString;
            options.subjoin = this.height;
            var finalResult = {
                height: this.height,
                geometry: lineGeometry,
                excavate: null,
                fill: null,
                volume: null
            };
            
            this._getMeasureResult("volume", options, OpenLayers.Function.bind(function(result){
            
                //finalResult.volume = result.Result.Value;
                var arr = result.Result.Value.split(" ");
                finalResult.volume = arr[0];
                finalResult.excavate = arr[1];
                finalResult.fill = arr[2];
                this.onAddPoint(finalResult);
            }, this));
        }
    },
    
    /**
     * APIMethod: deactivate
     * 取消激活控件并清除盒子图层
     * Returns:
     * {Boolean} true
     */
    deactivate: function(){
        if (Geo.View3D.Control.prototype.deactivate.apply(this, arguments)) {
            //this._clearBoxLayer();
        }
        return true;
    },
	
    /**
     * APIProperty: CLASS_NAME
     * 类名标识 - "Geo.View3D.Control.Measure.Excavate"
     */
    CLASS_NAME: "Geo.View3D.Control.Measure.Excavate"

});

/**
 * Class: Geo.View3D.Control.Measure.Flood
 * 量算淹没分析的结果
 *
 * Inherits from:
 *  - <Geo.View3D.Control.Measure>
 */
Geo.View3D.Control.Measure.Flood = Geo.Class(Geo.View3D.Control.Measure, {
    /**
     * APIProperty: handlerType
     * 三维视图事件监听类型
     */
    handlerType: Geo.View3D.Handler.Polygon,
    
    //MEASURE_PARAM: 1,
    /**
     * APIProperty: height
     * {Integer} 海拔高度。 默认值为2000。
     */
    height: 2000,
    
    solidOptions: null,
    
    solid: null,
    /**
     * Constructor: Geo.View3D.Control.Measure.Flood
     * 构造函数。生成一个Geo.View3D.Control.Measure.Flood的实例。
     */
    initialize: function(serviceUrl, options){
        Geo.View3D.Control.Measure.prototype.initialize.apply(this, arguments);
    },
    
    _measureHandler: function(mouseEvent){
        var result = {
            height: this.height,
            volume: mouseEvent.Volume,
            inundatedArea: mouseEvent.InundatedArea,
            floodArea: mouseEvent.FloodArea,
            floodVolume: mouseEvent.FloodVolume
        };
        this._result = result;
        this.onAddPoint(result);
    },
	
    /**
     * APIMethod: onAddPoint
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onAddPoint: function(result){
    },
	
    /**
     * APIMethod: onComplete
     * 在三维视图上结束绘制图形时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onComplete: function(result){
    },
    
    /*
     _onComplete:function(geometry){
     this._createBoxLayer(geometry);
     this.onComplete(this._result);
     },
     
     _onAddPoint: function(pointGeometry,polygonGeometry){
     var linearRing = polygonGeometry.components[0];
     var allPoints = linearRing.components;
     if(allPoints.length <= 2){
     return;
     }
     var pointsStr = this._getPointsSpaceSplitStr(polygonGeometry);
     this._setMeasureParams(this.MEASURE_PARAM, pointsStr, this.height);
     },
     */
    /**
     * 在三维视图上结束绘制图形时，调用此方法
     * geometry {Object}
     */
    _onComplete: function(geometry){
    
        var pointsString = this._points.join(",");
        var options = {};
        options.coordinates = pointsString;
        options.subjoin = this.height;
        var finalResult = {
            height: this.height,
            inundatedArea: null,
            floodArea: null,
            floodVolume: null
        };
		
		this.onComplete(finalResult);
//        this._getMeasureResult("floodAnalysis", options, OpenLayers.Function.bind(function(result){
//            if (this._terrainAnalysisService._isException(result)) {
//                this.onComplete(result);
//                return result;
//            }
//            var arr = result.Result.Value.split(" ");
//            finalResult.inundatedArea = arr[0];
//            finalResult.floodArea = arr[1];
//            finalResult.floodVolume = arr[2];
//            this._drawSolid(geometry);
//            this.onComplete(finalResult);
//        }, this));
    },
	
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     * result - {Object}
     */
    _onAddPoint: function(pointGeometry, lineGeometry){
        var allPoints = lineGeometry.components[0].components;
        this._points = [];
        for (var i = 0; i < allPoints.length; i++) {
            this._points.push(allPoints[i].x);
            this._points.push(allPoints[i].y);
        }
        
        if (allPoints.length <= 2) {
            return;
        }
        
        if (this.isRealTime) {
            var options = {};
            options.coordinates = pointsString;
            options.subjoin = this.height;
            var finalResult = {
                height: this.height,
                inundatedArea: null,
                floodArea: null,
                floodVolume: null
            };
            this._getMeasureResult("floodAnalysis", options, OpenLayers.Function.bind(function(result){
                var arr = result.Result.Value.split(" ");
                finalResult.inundatedArea = arr[0];
                finalResult.floodArea = arr[1];
                finalResult.floodVolume = arr[2];
                this.onComplete(finalResult);
            }, this));
        }
        
        
        //this._setMeasureParams(this.MEASURE_PARAM, points.join(" "), 0);     
    },
    /**
     * 在三维视图上画一个盒子图层
     * geometry - {Object}
     */
    _drawSolid: function(geometry){
        if (this.solid) {
            this._clearSolid();
        }
        this.solid = new Geo.View3D.Layer.Solid(this.id + "_solid", geometry, this.height, this.solidOptions);
        this.map.addLayer(this.solid);
    },
    
    /**
     * 清除盒子图层
     */
    _clearSolid: function(){
        if (this.solid && this.map) {
            this.map.removeLayer(this.solid);
        }
    },
    
    /**
     * APIMethod: deactivate
     * 取消激活控件并清除盒子图层
     * 
     * Returns:
     * {Boolean} true
     */
    deactivate: function(){
        if (Geo.View3D.Control.prototype.deactivate.apply(this, arguments)) {
            this._clearSolid();
        }
        return true;
    },
    /**
     * APIProperty: CLASS_NAME
     * 类名标识 - "Geo.View3D.Control.Measure.Flood"
     */
    CLASS_NAME: "Geo.View3D.Control.Measure.Flood"

});

/**
 * Class: Geo.View3D.Control.Measure.Profile
 * 量算出两个点的剖面地形分析结果
 *
 * Inherits from:
 *  - <Geo.View3D.Control.Measure>
 */
Geo.View3D.Control.Measure.Profile = Geo.Class(Geo.View3D.Control.Measure, {
    /**
     * APIProperty: handlerType
     * 三维视图事件监听类型
     */
    handlerType: Geo.View3D.Handler.Path,
	
    /**
     * Constructor: Geo.View3D.Control.Measure.Profile
     * 构造函数。生成一个Geo.View3D.Control.Measure.Profile的实例。
     */
    initialize: function(serviceUrl, options){
        Geo.View3D.Control.prototype.initialize.apply(this, [options]);
        this.serviceUrl = serviceUrl;
        this._terrainAnalysisService = new Geo.Service.TAS(this.id + "_service", serviceUrl);
        this.callbacks = OpenLayers.Util.extend({
            point: this._onAddPoint
        }, this.callbacks);
        this.handlerOptions = this.handlerOptions || {};
        if (this.handlerType) {
            this.handler = new this.handlerType(this, this.callbacks, this.handlerOptions);
        }
        
    },
	
    /**
     * APIMethod: onAddPoint
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onAddPoint: function(result){
    },
	
    /**
     * APIMethod: onComplete
     * 在三维视图上结束绘制图形时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onComplete: function(result){
    },
	
    /**
     * 在三维视图上结束绘制图形时，调用此方法
     * geometry {Object}
     */
    _onComplete: function(geometry){
        var pointsString = this._points.join(",");
        
        var options = {};
        options.coordinates = pointsString;
        var finalResult = {
            heightArray: null
        };
        
		
		this.onComplete(finalResult);
//        this._getMeasureResult("profileAnalysis", options, OpenLayers.Function.bind(function(result){
//            if (this._terrainAnalysisService._isException(result)) {
//                this.onComplete(result);
//                return result;
//            }
//            finalResult.heightArray = result.Result.Value;
//            this.onComplete(finalResult);
//        }, this));
        
    },
	
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     * result - {Object}
     */
    _onAddPoint: function(pointGeometry, lineGeometry){
        var allPoints = lineGeometry.components;
        this._points = [];
        for (var i = 0; i < allPoints.length; i++) {
            this._points.push(allPoints[i].x);
            this._points.push(allPoints[i].y);
        }
        
        if (allPoints.length == 2) {
            this._onComplete();
            this.handler.deactivate();
            this.handler.activate();
            return;
        }
        
    },
    
    /**
     * APIProperty: CLASS_NAME
     * 类名标识 - "Geo.View3D.Control.Measure.Profile"
     */
    CLASS_NAME: "Geo.View3D.Control.Measure.Profile"

});
/**
 * Class: Geo.View3D.Control.Measure.TwoPointThrough
 * 量算出两个点是否可见以及分析的结果
 *
 * Inherits from:
 *  - <Geo.View3D.Control.Measure>
 */
Geo.View3D.Control.Measure.TwoPointThrough = Geo.Class(Geo.View3D.Control.Measure, {
    /**
     * APIProperty: handlerType
     * 三维视图事件监听类型
     */
    handlerType: Geo.View3D.Handler.Path,
	
    /**
     * Constructor: Geo.View3D.Control.Measure.TwoPointThrough
     * 构造函数。生成一个Geo.View3D.Control.Measure.TwoPointThrough的实例。
     */
    initialize: function(serviceUrl, options){
        Geo.View3D.Control.Measure.prototype.initialize.apply(this, arguments);
    },
    
    /**
     * APIMethod: onAddPoint
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onAddPoint: function(result){
    },
	
    /**
     * APIMethod: onComplete
     * 在三维视图上结束绘制图形时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onComplete: function(result){
    },
	
    /**
     * 在三维视图上结束绘制图形时，调用此方法
     * geometry {Object}
     */
    _onComplete: function(geometry){
        var pointsString = this._points.join(",");
        
        var options = {};
        options.coordinates = pointsString;
        var finalResult = {
            from: null,
            to: null,
            isVisible: null,
            firstUnseenHeight: null,
            heightArray: null
        };
        
		
		this.onComplete(finalResult);
//        this._getMeasureResult("profileAnalysis", options, OpenLayers.Function.bind(function(result){
//            if (this._terrainAnalysisService._isException(result)) {
//                this.onComplete(result);
//                return result;
//            }
//            finalResult.heightArray = result.Result.Value;
//            finalResult.isVisible = this.getVisible(finalResult.heightArray).isVisible;
//            finalResult.firstUnseenHeight = this.getVisible(finalResult.heightArray).firstUnseenHeight;
//            this.onComplete(finalResult);
//        }, this));
        
    },
	
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     * result - {Object}
     */
    _onAddPoint: function(pointGeometry, lineGeometry){
        var allPoints = lineGeometry.components;
        this._points = [];
        for (var i = 0; i < allPoints.length; i++) {
            this._points.push(allPoints[i].x);
            this._points.push(allPoints[i].y);
        }
        
        if (allPoints.length == 2) {
            this._onComplete();
            this.handler.deactivate();
            this.handler.activate();
            return;
        }
        
    },
	
    /**
     * APIMethod: getVisible
     * 得到是否可见的结果
     *
     * Paramters:
     * arrayString - {String} 一些高度的字符串
     */
    getVisible: function(arrayString){
        var array = arrayString.split(" ");
        var length = array.length;
        var isVisible = true;
        // 第一个障碍点高程值
        var firstUnseenHeight = null;
        for (var i = 0; i < length; i++) {
        
            //起点和终点之间的高度差
            var num1 = array[length - 1] - array[0];
            //高度差分成点总数的段数
            var num2 = num1 / (length - 1);
            //每段乘以第i个点，得到第i个点的高度
            var num3 = num2 * i;
            //第i个点的高度加上第一个点的高度
            var lineY = Number(array[0]) + num3;
            
            //判断第二个点至倒数第二个点是否有障碍点
            if (i > 0 && i < (length - 1) && isVisible && array[i] >= lineY) {
                isVisible = false;
                // 第一个障碍点高程值
                firstUnseenHeight = lineY;
            }
        }
        //     alert("firstUnseenPoint:" + firstUnseenPoint);
        var result = {
            firstUnseenHeight: firstUnseenHeight,
            isVisible: isVisible
        };
        return result;
    },
	
    /**
     * APIProperty: CLASS_NAME
     * 类名标识 - "Geo.View3D.Control.Measure.TwoPointThrough"
     */
    CLASS_NAME: "Geo.View3D.Control.Measure.TwoPointThrough"

});

/**
 * Class: Geo.View3D.Control.ModelChoose
 * 三维视图模型选择控件类。
 * 
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.ModelChoose = Geo.Class(Geo.View3D.Control, {
	
	 /**
     * APIProperty: handlerOptions
     * {Object} 监听器的构造参数。
     */
    handlerOptions: null,

    /**
     * APIProperty: callbacks
     * {Object} 回调函数定义。
     */    
    callbacks: {},
	
    /**
     * Constructor: Geo.View3D.Control.ModelChoose
     * Geo.View3D.Control.ModelChoose构造函数。
     */
    initialize: function(options) {
		Geo.View3D.Control.prototype.initialize.apply(this, [options]);
		this.callbacks = OpenLayers.Util.extend(
            {
                "chooseModel": this.chooseModel
            },
            this.callbacks
        );
		this.handlerOptions = this.handlerOptions || {};
    	this.handler = new Geo.View3D.Handler.ModelChoose(this,
                            this.callbacks, this.handlerOptions);
    },	
	
	chooseModel: function(mouseEvent, isSelected) {
		
	},
	
	CLASS_NAME: "Geo.View3D.Control.ModelChoose"
});/**
 * Class: Geo.CombineView
 * 地图视图类(复合视图),封装了二三维视图。
 * 
 * 复合视图是将二维地图和三维地图整合到一起，为用户提供不同的地理信息数据视图方式，
 * 并且可以方便的在两种视图方式之间切换、同步。具体实现过程是分别构造二维和三维两个
 * 地图对象，将两者同时放置在一个 div元素中，同一时间只显示一个地图对象，在切换到另
 * 一个地图对象时隐藏前一个，并将中心点位置和当前级别进行同步。用户可以分别对二、三
 * 维地图对象独立控制，比如进行相关控件、图层对象添加，属性的更改等操作。
 */
Geo.CombineView = Geo.Class({
	
	/**
     * APIProperty: id
     * {String} id号，视图中地图的唯一标识。
     */
    id: null,
    
 	/**
     * APIProperty: div
     * {DOMElement|String} 视图所在容器。
     */
    div: null,
    
  	/**
     * APIProperty: map2D
     * {<Geo.View2D.Map>} 二维地图对象,为与三维保持一致,二维视图对象只能为360金字塔。
     */
    map2D: null,
    
  	/**
     * APIProperty: map2DOptions
     * {Object} 可选二维地图初始化参数。
     */
    map2DOptions: null,
    
  	/**
     * APIProperty: map3D
     * {<Geo.View3D.Map>} 三维地图对象。
     */
    map3D: null,
    
   	/**
     * APIProperty: map3DOptions
     * {Object} 可选三维地图初始化参数。
     */
    map3DOptions: null,
	
	/**
     * Property: mapFlash
     * {<Geo.ViewFl.Map>} flash地图对象。
     */
	mapFlash: null,
	
	/**
     * Property: mapFlashOptions
     * {Object} flash地图构造参数。
     */
	mapFlashOptions: null,
    
   	/**
     * APIProperty: currentView
     * {Object} 当前视图。
     */
    currentView: null,
    
   	/**
     * APIProperty: viewList
     * {Object} 支持的视图列表及相关映射。
     */
    viewList: null,
    
   	/**
     * APIProperty: defaultView
     * {String} 缺省视图。可选：“2D”、“3D”，默认值为“2D”（即默认为二维视图）。
     */
    defaultView: "2D",
	
   	/**
     * APIProperty: defaultLayout
     * {String | <Geo.CombineView.layoutList>} 缺省布局。默认值为“single”。
     */
	defaultLayout: "single",
	
   	/**
     * APIProperty: currentLayout
     * {String} 当前布局。
     */
	currentLayout: null,
	
   	/**
     * APIProperty: center
     * {<Geo.LonLat>} 当前中心点。
     */
	center: null,
	
   	/**
     * APIProperty: zoom
     * {Integer} 当前级别。
     */
	zoom: null,
	
   	/**
     * APIProperty: ayncType
     * {Boolean} 视图同步方式"all","center","layers"。
     */
	ayncType: "all",
	
   	/**
     * APIProperty: layoutList
     * {Array} 支持的布局。
     */
	layoutList: ["single","vertical","horizontal"],
    
   	/**
     * APIProperty: EVENT_TYPES
     * {Array} 事件类型。
     */
    EVENT_TYPES: ["viewswitch", "addlayer", "loadlayergroup"],
    
   	/**
     * APIProperty: events
     * 复合视图对象的事件。
     */
    events: null,
    
   	/**
     * APIProperty: eventListeners
     * 复合视图对象的事件监听器。
     */
    eventListeners: null,
    
    /**
     * Constructor: Geo.CombineView
     * 构造函数。生成一个二三维复合视图对象实例。
     * 
     * Parameters:
     * div - {String} 指定地图对象将被渲染到哪个div 元素中。
     * options - {Object} 地图对象相关选项设置。
     */
	initialize: function(div, options){
        this.id = OpenLayers.Util.createUniqueID("Geo.CombineView_");
        this.div = OpenLayers.Util.getElement(div);
        
        this.viewList = {
            "2D": {
                title: "二维视图",
                getMapObj: OpenLayers.Function.bind(function(){
                    return this.map2D;
                }, this),
                initFn: OpenLayers.Function.bind(this.initMap2D, this),
                getInitOptions: OpenLayers.Function.bind(function(){
                    return this.map2DOptions;
                }, this)
            },
            "3D": {
                title: "三维视图",
                getMapObj: OpenLayers.Function.bind(function(){
                    return this.map3D;
                }, this),
                initFn: OpenLayers.Function.bind(this.initMap3D, this),
                getInitOptions: OpenLayers.Function.bind(function(){
                    return this.map3DOptions;
                }, this)
            },
			"flash": {
				title: "flash视图",
				getMapObj: OpenLayers.Function.bind(function(){
                    return this.mapFlash;
                }, this),
				initFn: OpenLayers.Function.bind(this.initMapFlash, this),
				getInitOptions: OpenLayers.Function.bind(function(){
                    return this.mapFlashOptions;
                }, this)
			}
        };
        OpenLayers.Util.extend(this, options);
		this.initLayout();
		
        //初始化缺省视图
        this.currentView = this.defaultView;
        var initFn = this.viewList[this.currentView].initFn;
        var initOptions = this.viewList[this.currentView].getInitOptions();
        initFn(initOptions);
        
        this.events = new OpenLayers.Events(this, this.div, this.EVENT_TYPES, this.fallThrough, {
            includeXY: true
        });
        if (this.eventListeners instanceof Object) {
            this.events.on(this.eventListeners);
        }
        

    },
    
    /**
     * APIMethod: initMap2D
     * 初始化二维地图对象。
     * 
     * Parameters:
     * options - {Object} 地图对象相关选项设置。
     * 
     * Returns
     * {Boolean} true为初始化成功。
     */
	initMap2D: function(options){
        if (!this.map2D) {
            var map2DDiv = document.createElement("div");
            map2DDiv.style.height = "100%";
            map2DDiv.style.width = "100%";
            map2DDiv.id = this.id + "_map2D";
            this.div.appendChild(map2DDiv);
            this.map2D = new Geo.View2D.Map(map2DDiv, options);
			
			this.map2D.events.on({
	            "move": function(){
					this.center = this.map2D.getCenter();
					this.zoom = this.map2D.getZoom();
				},
	            scope: this
	        });

            //this.map2D.setCenter(0,0);
        }
        return true;
    },
    
    /**
     * APIMethod: initMap3D
     * 初始化三维地图对象。
     * 
     * Parameters:
     * options - {Object} 地图对象相关选项设置。
     * 
     * Returns
     * {Boolean} true为初始化成功。
     */
    initMap3D: function(options){
        if (!this.map3D) {
            var map3DDiv = document.createElement("div");
            map3DDiv.style.height = "100%";
            map3DDiv.style.width = "100%";
            map3DDiv.id = this.id + "_map3D";
            this.div.appendChild(map3DDiv);
            this.map3D = new Geo.View3D.Map(map3DDiv, options);
        }
        return true;
    },
	
	/**
     * APIMethod: initMapFlash
     * 初始化三维地图对象。
     * 
     * Parameters:
     * options - {Object} 地图对象相关选项设置。
     * 
     * Returns
     * {Boolean} true为初始化成功。
     */
    initMapFlash: function(options){
        if (!this.mapFlash) {
            var mapFlashDiv = document.createElement("div");
            mapFlashDiv.style.height = "100%";
            mapFlashDiv.style.width = "100%";
            mapFlashDiv.id = this.id + "_mapFlash";
            this.div.appendChild(mapFlashDiv);
            this.mapFlash = new Geo.ViewFl.Map(mapFlashDiv, options);
        }
        return true;
    },
	
	//初始化布局
	initLayout:function(){
		
	},
	
    /**
     * APIMethod: switchView
     * 切换视图。
     * 
     * Parameters:
     * view - 要切换到的视图。
     */
	switchView: function(view){
		
        if (view == this.currentView) {
            return;
        }
        
        //未指视图或视图名字未找到，则切换到下一视图
        if (!view || !this.viewList[view]) {
            view = this.getNextView(this.currentView);
        };
		
		//如果将切换的视图未初始化，则初始化
        if (!this.viewList[view].mapObj) {
            this.viewList[view].initFn();
        };
        var currMapObj = this.viewList[this.currentView].getMapObj();
        currMapObj.div.style.display = "none";
        var mapObj = this.viewList[view].getMapObj();
        mapObj.div.style.display = "";
        this.syncView();
        this.currentView = view;
        this.events.triggerEvent("viewswitch", {
            view: view
        });
    },
	
     /**
     * APIMethod: zoomIn
     * 视图放大。
     */
	zoomIn: function(){
		var map = this.getCurrentMapObj();
		map.zoomIn();
	},
	
     /**
     * APIMethod: zoomOut
     * 视图缩小。
     */
	zoomOut: function(){
		var map = this.getCurrentMapObj();
		map.zoomOut();
	},
	
	/**
	 * APIMethod: setCenter
	 * 对视图进行中心定位，并放大到指定级别。
	 * 
	 * Parameters:
	 * center - {<Geo.LonLat>} 中心点的坐标。
	 * level - {Int}要放大的级别。
	 */
	setCenter: function(center, level){
		this.center = center;
		this.zoom = level;
		var map = this.getCurrentMapObj();
		map.setCenter(center, level);	
	},
	
   /**
    * APIMethod: addLayer
    * 添加图层。
    *
    * Parameters:
    * layer - {<OpenLayers.Layer>} 
    */	
	addLayer: function(layer){
		var map = this.getCurrentMapObj();
		map.addLayer(layer);
	},
	
	/**
	 * APIMethod: addLayers
	 * 添加多个图层。
	 * 
     * Parameters:
	 * layers - {Array(<OpenLayers.Layer>)} 
	 */
	addLayers: function(layers){
		if(!(layers instanceof Array)){
			layers = [layers];
		}
		for(var i=0; i<layers.length; i++){
			this.addLayer(layers[i]);
		}
	},

	/**
	 * APIMethod: loadLayerGroup
	 * 加载图层组。
	 * 
     * Parameters:
	 * layerGroup - {<Geo.View2D.LayerGroup>|Geo.View3D.LayerGroup} 
	 */
	loadLayerGroup:function(layerGroup){
		var map = this.getCurrentMapObj();
		map.loadLayerGroup(layerGroup);
	},

	/**
	 * APIMethod: unloadLayerGroup
	 * 卸载图层组。
	 */
	unloadLayerGroup: function(){
        var map = this.getCurrentMapObj();
		map.unloadLayerGroup();
    },
    	
	/**
	 * APIMethod: getCurrentMapObj
	 * 获取当前地图对象。
	 * 
	 * Return:
	 * {<Geo.View2D.Map>|<Geo.View3D.Map>} 当前地图对象的引用。
	 */
	getCurrentMapObj:function(){
		var view = this.currentView;
		var list = this.viewList;
		
		var map = list[view].getMapObj();
		if(!map){
			return null;
		}
		return map;
	},
	
	/**
	 * APIMethod: syncView
	 * 同步视图。
	 */
	syncView: function(){
		var list = this.viewList;
		var currentView = this.currentView;
		var currentMap = list[currentView].getMapObj();
		
		
		for(var item in list){
			if(currentView == item){
				continue;
			}
			var targetMap = list[item].getMapObj();
			if(!targetMap){
				return;
			}
			var currentRes = currentMap.getResolution();
            var targetZoom = targetMap.getZoomForResolution(currentRes);
            var targetCenter = currentMap.getCenter();
            targetMap.setCenter(targetCenter, targetZoom);
		}
	},

    	
	/**
	 * APIMethod: getNextView
	 * 获取下一个视图名称,用于循环切换视图。
	 * 
	 * Parameters:
	 * view - 指定的视图。
	 * 
	 * Returns:
	 * {Object} 当前视图。
	 */	
	getNextView:function(view){

		var firstView = null;
		var nextView = null;
		var isFisrt = true;
		var isNext = false;
		for(var item in this.viewList){
			if(isFisrt){
				firstView = item;
				isFisrt = false;
			}

			if (isNext){
				nextView = item;
				break;
			}
			
			if(item === view){
				isNext = true;
				continue;
			}
		}
		//如果下一视图为空,说明两种情况一是没有指定视图,
		//二是指定视图为最后一个视图,均返回第一个视图.
		if(!nextView){
			return firstView;
		}
		return nextView;
	},
	
    CLASS_NAME: "Geo.CombineView"
});

/**
 * Class: Geo.LayerManager
 * 图层管理器类，提供同时对二维、三维视图的图层操作相关功能,包括图层的添加，删除，图层的透明度设置，上移下移，定位等功能。
 */
Geo.LayerManager = Geo.Class({

    /**
     * APIProperty: map
     * {<Geo.View2D.Map>|<Geo.View3D.Map>|<Geo.CombineView>}关联的地图对象。 
     */
	map:null,
	
    /**
     * APIProperty: autoUpdateList
     * {Boolean} 是否自动触发更新图层列表方法updateLayerList，默认为"true"。 
     */
	autoUpdateList: true,
	
    /**
     * APIProperty: isAllLayers
     * {Boolean} 是否管理全部图层，默认为否，在使用getLayers方法获取地图对象所有图层时，
     * 图层属性displayInLayerSwitcher为false的图层对象将不在返回值的数组中。 
     */
	isAllLayers: false,
	
	 /**
     * APIProperty: template
     * {Object} 图层列表模板，json格式，是否自动触发更新图层列表方法updateLayerList，默认为"true"。 
     */
	template: {
		//外部容器
		wrapper: "<ul>${layerItemTemplate}</ul>",
		
		//图层列表表现模板
		item: "<li><input type='checkbox' ${visibility} " + 
			  "onchange='lm.toggleLayerVisibility(${layerid})' />${layerName}</li>" +
			  "",
	
		//无图层提示
		noLayer: "<li>当前没有图层</li>"
	},
	
	
    /**
     * APIProperty: ascending
     * 图层排列顺序。默认为“true”，表示按升序排序；当取值为“false”表示按降序排列。 
     */
	ascending: true,
	
	/**
	 * Constructor: Geo.LayerManager
	 * 构造方法。
	 * 
	 * Parameters:
	 * options - {Object} 可选的实例属性设置对象。
	 */
	initialize:function(options){
		OpenLayers.Util.extend(this,options);
	},
	
	/**
	 * Method: setMap
	 * 关联地图对象。
	 * 
	 * Parameters:
	 * map - {<Geo.View2D.Map>|<Geo.View3D.Map>|<Geo.CombineView>} 要关联的地图对象。
	 */
	setMap:function(map){
		this.map = map;
		this._updateLayerList();
	},

	/**
	 * APIMethod: getCurrentMapObj
	 * 获取当前地图对象。
	 * 
	 * Return:
	 * map - {<Geo.View2D.Map>|<Geo.View3D.Map>|<Geo.CombineView>} 要关联的地图对象。
	 */	
	getCurrentMapObj:function(){
		var map = this.map;
		if(map.CLASS_NAME == "Geo.CombineView"){
			map = map.getCurrentMapObj();
		}
		return map;
	},

	/**
	 * APIMethod: updateLayerList
	 * 更新图层列表回调函数，可以由用户自定义覆盖。
	 * 
	 * layers - {Array(<Openlayers.Layer>|<Geo.View3D.Layer>)} 当前地图中加载的图层对象。
	 */		
	updateLayerList:function(layers){
	},
	
	//获取当前地图中的图层对象，调用更新图层方法。
	_updateLayerList: function(){
		var layers = this.getLayers();
		if (this.map && this.autoUpdateList) {
			this.updateLayerList(layers);
		}
	},
	
	/**
	 * APIMethod: getLayers
	 * 获取当前地图对象中所有加载的图层。如果isAllLayers属性设置false，
	 * 则只获取那些图层属性displayInLayerSwitcher为false图层。
	 * 
	 * Return:
	 * {Array(<Openlayers.Layer>|<Geo.View3D.Layer>)} 图层数组。
	 */
	getLayers:function(){
		var layers = [];
		var map = this.getCurrentMapObj();
		
		//不存在地图,返回空图层数组
		if(!map){
			return layers;
		}
		
		//如果未设置全部图层,则只获在图层管理器里显示的图层
		var allLayers = map.layers;
		if(!this.isAllLayers){			
			for(var i = 0; i<allLayers.length; i++){
				var layer = allLayers[i];
				if(layer.displayInLayerSwitcher){
					layers.push(layer);
				}
			}			
		}
		if (!this.ascending) { layers.reverse(); }
		return layers;
	},
	
	/**
	 * APIMethod: setOpacity
	 * 设置图层透明度。
	 * 
	 * Parameters:
	 * layerid - 图层的标识。
	 * opacity - {Float} 透明度值。
	 */
	setOpacity: function(layerid, opacity){
		var map = this.getCurrentMapObj();
        var layer = map.getLayer(layerid);
        if (layer) {
            layer.setOpacity(opacity);
        }
		this._updateLayerList();
    },
	
	/**
	 * APIMethod: raisLayer
	 * 上移,下移图层。通过指定增量值更改指定图层的索引。当指定增量值为正时图层上移，当指定增量值为负时图层下移。
	 * 
	 * Parameters:
	 * layerid - 指定图层的标识。
	 * delta - 指定的增量值，决定图层的移动方式。
	 */
	raisLayer: function(layerid, delta){
		var map = this.getCurrentMapObj();
        var layer = map.getLayer(layerid);
        if (layer) {
            map.raiseLayer(layer, delta);
        }
		this._updateLayerList();
    },
	
	/**
	 * APIMethod: raisLayerToTop
	 * 将指定图层移动到顶层。
	 * 
	 * Parameters:
	 * layerid - 指定图层的标识。
	 */
	raisLayerToTop:function(layerid){
		var map = this.getCurrentMapObj();
		var layer = map.getLayer(layerid);
        if (layer) {
            var layers = map.layers;
			var index = OpenLayers.Util.indexOf(layers,layer);
			var delta = layers.length - index;
			this.raisLayer(layerid,delta);
        }
	},
	
	/**
	 * APIMethod: raisLayerToBottom
	 * 将指定图层移动到底层。
	 * 
	 * Parameters:
	 * layerid - 指定图层的标识。
	 */
	raisLayerToBottom: function(layerid){
		var map = this.getCurrentMapObj();
		var layer = map.getLayer(layerid);
        if (layer) {
			var layers = map.layers;
			var index = OpenLayers.Util.indexOf(layers,layer);
			var delta = 0 - index;
			this.raisLayer(layerid,delta)
        }
	},
	
	/**
	 * APIMethod: toggleLayerVisibility
	 * 切换图层可视性。
	 * 
	 * Parameters:
	 * layerid - 指定图层的标识。
	 * isUpdateLayerList - 是否自动更新图层列表。
	 */
	toggleLayerVisibility: function(layerid, isUpdateLayerList){
		var map = this.getCurrentMapObj();
        var layer = map.getLayer(layerid);
        layer.setVisibility(!layer.getVisibility());
//		this._updateLayerList();
    },
	
	/**
	 * APIMethod: gotoLayer
	 * 将地图视图定位到指定图层。
	 * 
	 * Parameters:
	 * layerid - 指定图层的标识。
	 */
	gotoLayer: function(layerid){
		var map = this.getCurrentMapObj();
        var layer = map.getLayer(layerid);
        if(layer.gotoCenter){
            layer.gotoCenter();
            return;
        }
        var extent, zoom;
		if(layer instanceof Geo.View2D.Layer.WMTS) {
			extent = layer.tileFullExtent;
		}else if(layer instanceof OpenLayers.Layer.Vector) {
			extent = layer.getDataExtent();
			extent = extent ? extent : (layer.maxExtent ? layer.maxExtent : map.maxExtent);
			map.zoomToExtent(extent);
			return;
		}else if(layer instanceof Geo.View2D.Layer.WMS) {
			extent = layer.maxExtent ? layer.maxExtent : map.maxExtent;
			map.zoomToExtent(extent);
			return;
		}else if(layer instanceof Geo.View2D.Layer.DynamicMapService) {
			extent = layer.maxExtent ? layer.maxExtent : map.maxExtent;
			map.zoomToExtent(extent);
			return;
		}else if(layer instanceof Geo.View2D.Layer.TileMapService) {
			extent = layer.maxExtent ? layer.maxExtent : map.maxExtent;
			map.zoomToExtent(extent);
			return;
		}else{
			extent = layer.maxExtent ? layer.maxExtent : map.maxExtent;
		}
        //判断当前地图是否是flex，如果是flex，从layer中获取extent和maxRes的值。
        var maxRes
        var currentView = this.getCurrentMapObj().CLASS_NAME;
		if(currentView == "Geo.ViewFl.Map"){
			extent = layer.maxExtent ? layer.maxExtent : layer.getExtent();
			maxRes = layer.getResolution();
		}else {
        	maxRes = layer.maxResolution ? layer.maxResolution : map.maxResolution;
		}
        zoom = map.getZoomForResolution(maxRes,true);
        map.setCenter(extent.getCenterLonLat(), zoom);
    },
	
	/**
	 * APIMethod: removeLayer
	 * 移除指定的图层。
	 * 
	 * Parameters:
	 * layerid - 指定图层的标识。
	 * isUpdateLayerList - 是否自动更新图层列表。
	 */
	removeLayer:function(layerid, isUpdateLayerList){
		var map = this.getCurrentMapObj();
        var layer = map.getLayer(layerid);
        if (layer) {
            map.removeLayer(layer);
        }
		this._updateLayerList();
	},
	
	/**
	 * APIMethod: addLayer
	 * 加载图层。
	 * 
	 * Parameters:
	 * type - {String} 图层类型。
	 * allOptions - 属性设置项对象。
	 * 
	 * Returns:
	 * {Boolean} 添加成功返回true，反之返回false。
	 */
	addLayer: function(type, allOptions){
		var map = this.getCurrentMapObj();
        var view = map.CLASS_NAME;
		type = type.toUpperCase();
		var layerObj = Geo.LayerManager.supportService[view][type];
		var layer = null;
		if(layerObj){
			layer = layerObj(allOptions);
			map.addOverLayer(layer);
			this._updateLayerList();
			return true;
		}
		return false;
	},
	
	CLASS_NAME: "Geo.LayerManager"
});

/**
 * APIProperty: Geo.LayerManager.supportService
 * {Object} Geo.LayerManager对图层类型的支持。
 */
Geo.LayerManager.supportService = {
    "Geo.View2D.Map": {
        "OGC_WMS": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var params = allOptions.params;
            var options = allOptions.options;
            var isSeparate = allOptions.isSeparate;
            var layersStr = allOptions.params.layers
            
            //分开加载各个图层
            if (isSeparate) {
                var arrLayersStr = layersStr.split(",");
                var arrLayer = [];
                for (var i = 0, l = arrLayers.length; i < l; i++) {
                    OpenLayers.Util.extend(params, {
                        layers: arrLayers[i]
                    });
                    arrLayer.push(new OpenLayers.Layer.WMS(name, url, params, options));
                }
                return arrLayer;
            }
            
            return new OpenLayers.Layer.WMS(name, url, params, options);
        },
        "GEO_TILE": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.View2D.Layer.GlobeTile(name, url, options);
        },
        "OGC_WMTS": function(allOptions){
            return new OpenLayers.Layer.WMTS(allOptions);
        },
		"GEO_CWMS": function(allOptions){
			var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.View2D.Layer.CWMS(name, url, options);
        },
		"ARCGIS_REST": function(allOptions){
			var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.View2D.Layer.ArcGIS93Rest(name, url, options);
        },
		"OGC_WFS": function(allOptions){
			var name = allOptions.name;
            var url = allOptions.url;
			var version = allOptions.version;
            var options = allOptions.options;
			
			
            var strategies = [];
            // 如果IsViewPort为true，则根据可视范围来查询
        //  if (options.isViewPort == "true") {
            	strategies.push(new OpenLayers.Strategy.BBOX());
       //   }
            
            // 如果有关键字，则在策略中加入一个过滤器。
            if (options.keyWord) {
                var filter = new Geo.Filter.Comparison({
                    type: Geo.Filter.Comparison.LIKE,//关系运算
                    property: options.featurePropertyName,//查询字段
                    value: "/*" + options.keyWord + "/*"// 值
                });
                var strategyFilter = new OpenLayers.Strategy.Filter({
                    filter: filter
                });
                strategies.push(strategyFilter);
            }
            var wfsLayer = new Geo.View2D.Layer.Vector(name, {
                //使用bbox查询策略
                strategies: strategies,
                //使用WFS协议方法
                protocol: new OpenLayers.Protocol.WFS({
                    maxFeatures: options.maxFeatures,//现在服务返回的结果数
                    geometryName: options.geometry,
                    url: url,
					version:version,
                    featureType: options.featureType//要素类型
                })
            });
            return wfsLayer;
        }
    },
    "Geo.View3D.Map": {
        "OGC_WMS": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var params = allOptions.params;
            var options = allOptions.options;
            var isSeparate = allOptions.isSeparate;
            var layersStr = allOptions.params.layers
            
            //分开加载各个图层
            if (isSeparate) {
                var arrLayersStr = layersStr.split(",");
                var arrLayer = [];
                for (var i = 0, l = arrLayers.length; i < l; i++) {
                    OpenLayers.Util.extend(params, {
                        layers: arrLayers[i]
                    });
                    arrLayer.push(new Geo.View3D.Layer.WMS(name, url, params, options));
                }
                return arrLayer;
            }
            
            return new Geo.View3D.Layer.WMS(name, url, params, options);
        },
        "GEO_TILE": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.View3D.Layer.GlobeTile(name, url, options);
        },
        "GEO_TERRAIN": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.View3D.Layer.Terrain(name, url, options);
        },
        "GEO_MODEL": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.View3D.Layer.Model(name, url, options);
        },
        "OGC_WMTS": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions;
            return new Geo.View3D.Layer.WMTS(name, url, options);
        },
		"GEO_WTFS": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.View3D.Layer.WTFS(name, url, options);
        },
		"ARCGIS_REST": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.View3D.Layer.ArcgisRest(name, url, options);
        },
		"OGC_WFS": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.View3D.Layer.WFS(name, url, options);
        }
    },
    "Geo.ViewFl.Map": {
        "OGC_WMS": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var params = allOptions.params;
            var options = allOptions.options;
            var isSeparate = allOptions.isSeparate;
            var layersStr = allOptions.params.layers
            
            //分开加载各个图层
            if (isSeparate) {
                var arrLayersStr = layersStr.split(",");
                var arrLayer = [];
                for (var i = 0, l = arrLayers.length; i < l; i++) {
                    OpenLayers.Util.extend(params, {
                        layers: arrLayers[i]
                    });
                    arrLayer.push(new Geo.ViewFl.Layer.WMS(name, url, params, options));
                }
                return arrLayer;
            }
            
            return new Geo.ViewFl.Layer.WMS(name, url, params, options);
        },
        "GEO_TILE": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.ViewFl.Layer.GlobeTile(name, url, options);
        },
        "OGC_WMTS": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions;
            return new Geo.ViewFl.Layer.WMTS(name, url, options);
        }
    }
};
/**
 * Class: Geo.Analysis.AreasAndLengthsParameters
 * GeometryService面积与周长操作参数类。GeometryService类的areasAndLengths方法调用时需要使用本类。
 */
Geo.Analysis.AreasAndLengthsParameters = Geo.Class({

	/**
     * APIProperty: areaUnit
     * {Int} 面积单位。可以使用
     */	
    areaUnit: null,

	/**
     * APIProperty: lengthUnit
     * {Int} 长度单位。
     */	
    lengthUnit: null,

	/**
     * APIProperty: polygons
     * {Array<Geo.Geometry.Polygon>} 多边形几何对象集。
     */		
    polygons: null,

	/**
     * APIProperty: inSr
     * {String} 输入几何对象的空间参考编号，例如：4326。
     */	
    inSr: 4326,

	/**
	 * Constructor: Geo.Analysis.AreasAndLengthsParameters
	 * Geo.Analysis.AreasAndLengthsParametersGeometryService面积与周长操作参数类构造函数。
	 *
	 * Parameters:
	 * params - 构造参数。
	 */	
    initialize: function (params) {
        Geo.Util.extend(this,params);
    },

    toJson: function () {
        var jsonObj = {
            sr:this.inSr
        };

        var polygons = this.polygons;
        var geometriesObj = [];
        for (var i = 0; i < polygons.length; i++) {
            var polygon = Geo.Analysis.Util.geoGeometryToEsriObjMapping['polygon'](polygons[i]);
            geometriesObj.push(polygon);
        }
        var geometriesStr = new Geo.Format.JSON().write(geometriesObj);
        jsonObj.polygons = geometriesStr;

        if (this.lengthUnit) {
            jsonObj.lengthUnit = this.lengthUnit;
        }

        if (this.areaUnit) {
            jsonObj.areaUnit = new Geo.Format.JSON().write({"areaUnit":this.areaUnit});
        }

        return jsonObj;
    }

});/**
 * Class: Geo.Analysis.BufferAnalysis
 * 缓冲区分析类。
 */
Geo.Analysis.BufferAnalysis = Geo.Class({

	/**
     * APIProperty: url
     * {String} 缓冲分析操作所需要的WPS服务地址。
     */	
	url: null,

	/**
     * APIProperty: type
     * {Integer} 缓冲区的端点类型，默认值为Geo.Analysis.BufferAnalysis.CAP_ROUND。
     * 可以为Geo.Analysis.BufferAnalysis.CAP_ROUND、Geo.Analysis.BufferAnalysis.CAP_BUTT、
     * Geo.Analysis.BufferAnalysis.CAP_SQUARE三者之一。
     */
	type: 1,
	
	/**
     * APIProperty: accuracy
     * {Integer} 缓冲的拟合精度。默认值为32。
     */
	accuracy: 32,

	/**
	 * Constructor: Geo.Analysis.BufferAnalysis
	 * Geo.Analysis.BufferAnalysis类构造函数。
	 *
	 * Parameters:
	 * url - {String} WPS服务地址。
	 * options - {Object} 相关属性的设置项，可选。
	 */	
	initialize: function(url,options){
		this.url = url;
		OpenLayers.Util.extend(this, options);
	},
	
    
    /**
     * 构造查询字串。将要缓冲的要素和缓冲半径来构造用于Post查询的字符串。
     * 参数:
     * features - 要执行缓冲分析的要素。
     * distance - 缓冲半径。
     */
	_buildPostXML: function(features,distance){
				
		var gmlParser = new OpenLayers.Format.GML();
        var geoStr = gmlParser.write(features);
		var xmlstr = 
            '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + 
			    '<wps:Execute service="WPS" version="1.0.0" xmlns:gml="http://www.opengis.net/gml" xmlns:wps="http://www.opengis.net/wps/1.0.0" xmlns:ows="http://www.opengis.net/ows/1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.opengis.net/wps/1.0.0 ../wpsExecute_request.xsd">' + 
			    '<ows:Identifier>Buffer</ows:Identifier>' +
			    '<wps:DataInputs><wps:Input><ows:Identifier>InputPolygon</ows:Identifier><wps:Data><wps:ComplexData schema="http://foo.bar/MyComplexValueSchema.xsd" mimeType="text/xml" encoding="UTF-8">' + 
			    geoStr + '</wps:ComplexData></wps:Data></wps:Input>' + 
			'<wps:Input><ows:Identifier>BufferDistance</ows:Identifier><wps:Data><wps:LiteralData>' + distance + '</wps:LiteralData></wps:Data>' + 
			'</wps:Input><wps:Input><ows:Identifier>BufferType</ows:Identifier><wps:Data><wps:LiteralData>' + this.type + '</wps:LiteralData></wps:Data></wps:Input><wps:Input><ows:Identifier>BufferAccuracy</ows:Identifier><wps:Data><wps:LiteralData>' + this.accuracy + '</wps:LiteralData></wps:Data></wps:Input></wps:DataInputs><wps:ResponseForm><wps:RawDataOutput><ows:Identifier>BufferedPolygon</ows:Identifier></wps:RawDataOutput></wps:ResponseForm></wps:Execute>';
        return xmlstr;
	},

    /**
     * 获取所有要素范围之合的中心点。
     * 
     * 参数:
     * features - 要执行缓冲分析的要素。
     * 
     * 返回值:
     * {<Geo.LonLat>} 中心点的坐标。
     */
	_getFeaturesCenter: function(features){		
		var bounds = this._getFeaturesExtent(features);
		return bounds.getCenterLonLat();
	},
	
	/**
	 * 获取要素数组范围之合。
	 *
	 * 参数:
	 * features - 要查看的要素数组。
	 * 
	 * 返回值:
	 * {<Geo.Bounds>} 要素数组的总的范围。
	 */
	_getFeaturesExtent: function (features) {
        if(!(features instanceof Array)){
			features = [features];
		}
        var maxExtent = null;
        if(features && (features.length > 0)) {
            maxExtent = new Geo.Bounds();
            var geometry = null;
            for(var i=0, len=features.length; i<len; i++) {
                geometry = features[i].geometry;
                if (geometry) {
                    maxExtent.extend(geometry.getBounds());
                }
            }
        }
        return maxExtent;
    },
	
	
	/**
	 * APIMethod: startAnalysis
	 * 开始执行分析，如果服务端正确返回结果会触发successFn回调函数。
	 *
	 * Parameters:
	 * feature - 要分析的要素。
	 * distance - 缓冲半径。
	 * unit - {String} 长度计量单位。取值"m","km","degree"，可选，默认值为"m"。
	 * 
	 * 代码示例:
	 * 
	 * (code)
	 * //绘制一个被缓冲的中心点
     * var geometry = new Geo.Geometry.Point(110, 35);
     * var feature = new Geo.Feature.Vector(geometry);
     * 
	 * //设置缓冲距离500米
     * var distance = 500;
     * 
     * //缓冲单位
     * var unit = "m";
     * 
     * //开始缓冲分析
     * ba.startAnalysis(feature, distance, unit);
     * (end)
	 */
	startAnalysis: function(feature,distance,unit){
		var unitList = ["m","km","degree"];
		
		var lonlat = this._getFeaturesCenter(feature);
		
		//距离单位默认为米
		if(!unit || (OpenLayers.Util.indexOf(unitList,unit) == -1)){
			unit = "m";
		}
		
		switch(unit){
			case "km":
				distance = 1000 * distance;
			case "m":
				distance = this._meterToDegree(distance,lonlat);				
		}
		var postStr = this._buildPostXML(feature,distance);
		var xhr = new OpenLayers.Request.POST({
			url: this.url,
			data: postStr,
			scope: this,
			success:function(result){
				if("" == result.responseText || null == result.responseText){
					this.failFn();
					return;
				}
                var feature = this._parserResult(result);
                this.successFn(feature);
            },
			failure:this.failFn
			
		});
	},
	
	/**
	 * 根据地理坐标位置，将米转换成经纬度。
	 *
	 * 参数:
	 * meter - 要转换的地理坐标。
	 * lonlat - 经纬度。
	 */
	_meterToDegree: function(meter,lonlat){
		var a = 0.00000899; //赤道上的距离1公里=0.000008993220293度
		var templat = lonlat.lat;
		return meter * ( a / Math.cos(OpenLayers.Util.rad(templat)) );
	},
	
	/**
	 * APIMethod: successFn
	 * 缓冲分析操作成功的回调函数，由用户使用自己定义的方法替代。
	 *
	 * Parameters:
	 * features - {Array(<Geo.Feature.Vector>)} 结果要素数组。
	 */	
	successFn:function(features){
	},

	/**
	 * APIMethod: failFn
	 * 缓冲分析操作失败回调函数，默认提示"缓冲分析操作失败，请检测服务是否正常运行。"，
	 * 用户可以使用自定义方法替代。
	 */		
	failFn:function(){
		alert("缓冲分析操作失败，请检测服务是否正常运行。");
	},
	
    /**
     * 解析缓冲分析操作返回结果
     */
	_parserResult: function(result){
		var feature = null;
		var xmlParser = new OpenLayers.Format.XML();
		if(!result.responseXML){
			result.responseXML = xmlParser.read(result.responseText);
		}
		var gmlParser = new OpenLayers.Format.GML();		
			feature = gmlParser.read(result.responseXML);
		return feature;
	},

	CLASS_NAME: "Geo.Analysis.BufferAnalysis"
});

/**
 * Constant: Geo.Analysis.BufferAnalysis.CAP_ROUND
 * {Integer} 圆形缓冲区端点。
 */
Geo.Analysis.BufferAnalysis.CAP_ROUND = 1;

/**
 * Constant: Geo.Analysis.BufferAnalysis.CAP_ROUND
 * {Integer} 平角缓冲区端点。
 */
Geo.Analysis.BufferAnalysis.CAP_BUTT = 2;


/**
 * Constant: Geo.Analysis.BufferAnalysis.CAP_ROUND
 * {Integer} 矩形缓冲区端点。
 */
Geo.Analysis.BufferAnalysis.CAP_SQUARE = 3;/**
 * Class: Geo.Analysis.BufferParameters
 * GeometryService缓冲查询参数类。GeometryService类的buffer方法调用时需要使用本类。
 */
Geo.Analysis.BufferParameters = Geo.Class({


	/**
     * APIProperty: bufferSpatialReference
     * {Int} 缓冲空间参考编号，例如：4326。
     */		
    bufferSpatialReference: null, //bufferProjection

	/**
     * APIProperty: distances
     * {Number} 缓冲距离。
     */		
    distances: null,

	/**
     * APIProperty: geodesic
     * {Boolean} 是否使用的是地理坐标系统。
     */		
    geodesic: false,

	/**
     * APIProperty: geometries
     * {Array<Geo.Geometry>} 缓冲几何对象集。
     */		
    geometries: null,

	/**
     * APIProperty: outSpatialReference
     * {Int} 输出空间参考编号，例如：4326。
     */		
    outSpatialReference: null,//outProjection

	/**
     * APIProperty: unionResults
     * {Boolean} 对分析结果进行合并。
     */		
    unionResults: false,

	/**
     * APIProperty: unit
     * 缓冲距离单位。
     */		
    unit: null,

	/**
	 * Constructor: Geo.Analysis.BufferParameters
	 * Geo.Analysis.BufferParameters类构造函数。
	 *
	 * Parameters:
	 * params 构造参数
	 */
    initialize: function (params) {
        Geo.Util.extend(this,params);
    },

    toJson: function () {
        var jsonObj = {
                unit:this.unit,
                unionResults:this.unionResults,
                geodesic:this.geodesic
            },
            distances = this.distances,
            outSpatialReference = this.outSpatialReference,
            bufferSpatialReference = this.bufferSpatialReference;

        var geometries = Geo.Analysis.Util.geoGeometryAndTypeToEsriObj(this.geometries);
        var geometriesStr = new Geo.Format.JSON().write(geometries);
        jsonObj.geometries = geometriesStr;
        jsonObj.inSR = 4326;

        if (distances) {
            jsonObj.distances = distances.join(",");
        }
        if (outSpatialReference) {
            jsonObj.outSR = outSpatialReference;
        }
        if (bufferSpatialReference) {
            jsonObj.bufferSR = bufferSpatialReference;
        }
        return jsonObj;
    }

});/**
 * Class: Geo.Analysis.DensifyParameters
 * GeometryService的densify(增加密度操作)参数类。
 */
Geo.Analysis.DensifyParameters = Geo.Class({


	/**
     * APIProperty: geometries
     * {Array<Geo.Geometry>} 输入的几何对象。
     */		
    geometries:null,

	/**
     * APIProperty: geodesic
     * {Boolean} 是否地理坐标系统。
     */		
    geodesic:null,

	/**
     * APIProperty: lengthUnit
     * {Int} 长度单位。
     */		
    lengthUnit:null,

	/**
     * APIProperty: maxSegmentLength
     * {Number} 最大线段长度。
     */		
    maxSegmentLength:null,

	/**
     * APIProperty: inSr
     * {Int} 输入几何对象的空间参考编号，例如：4326。
     */		
    inSr: 4326,

	/**
	 * Constructor: Geo.Analysis.DensifyParameters
	 * Geo.Analysis.DensifyParameters类构造函数。
	 *
	 * Parameters:
	 * params 构造参数。
	 */	
    initialize: function (params) {
        Geo.Util.extend(this,params);
    },

    toJson: function () {

        var jsonObj = {
            sr: this.inSr
        };

        if (this.geometries && this.geometries.length > 0) {
            var geometriesObj = Geo.Analysis.Util.geoGeometryAndTypeToEsriObj(this.geometries);
            var geometriesString = new Geo.Format.JSON().write(geometriesObj);
            jsonObj.geometries = geometriesString;
        }

        if (this.geodesic) {
            jsonObj.geodesic = this.geodesic;
        }

        if (this.lengthUnit) {
            jsonObj.lengthUnit = this.lengthUnit;
        }

        if (this.maxSegmentLength) {
            jsonObj.maxSegmentLength = this.maxSegmentLength;
        }
        
        return jsonObj;
    }

});/**
 * Class: Geo.Analysis.DistanceParameters
 * GeometryService距离查询参数类。GeometryService类的distance方法调用时需要使用本类。
 */
Geo.Analysis.DistanceParameters = Geo.Class({

	/**
     * APIProperty: distanceUnit
     * {Int} 距离的单位。
     */		
    distanceUnit: null,

	/**
     * APIProperty: geometry1
     * {Geo.Geometry} 被测量几何对象之一。
     */		
    geometry1: null,

	/**
     * APIProperty: geometry2
     * {Geo.Geometry} 被测量几何对象之一。
     */		
    geometry2: null,

	/**
     * APIProperty: inSr
     * 输入几何对象的空间参考编号，例如：4326。
     */		
    inSr: 4326,

	/**
	 * Constructor: Geo.Analysis.DistanceParameters
	 * Geo.Analysis.DistanceParameters类构造函数。
	 *
	 * Parameters:
	 * params 构造参数。
	 */
    initialize: function (params) {
        Geo.Util.extend(this,params);
    },

    toJson: function () {
        var jsonObj = {
            sr:this.inSr
        };

        if (this.geometry1) {
            var inGeometry = Geo.Analysis.Util.geoGeometryAndTypeToEsriObj(this.geometry1);
            var geometryStr = new Geo.Format.JSON().write(inGeometry);
            jsonObj.geometry1 = geometryStr;
        }

        if (this.geometry2) {
            var inGeometry = Geo.Analysis.Util.geoGeometryAndTypeToEsriObj(this.geometry2);
            var geometryStr = new Geo.Format.JSON().write(inGeometry);
            jsonObj.geometry2 = geometryStr;
        }

        if (this.distanceUnit) {
            jsonObj.distanceUnit = this.distanceUnit;
        }
        return jsonObj;
    }

});/**
 * Class: Geo.Analysis.GeneralizeParameters
 * GeometryService抽稀操作参数类。GeometryService类的generalize方法调用时需要使用本类。
 */
Geo.Analysis.GeneralizeParameters = Geo.Class({

	/**
     * APIProperty: deviationUnit
     * {Int} 偏离单位。
     */		
    deviationUnit: null,

	/**
     * APIProperty: geometries
     * {Array<Geo.Geometry>} 输入几何对象集。
     */		
    geometries: null,

	/**
     * APIProperty: maxDeviation
     * {Number} 最大偏离值。
     */		
    maxDeviation: null,

	/**
     * APIProperty: inSr
     * {Int} 输入几何对象的空间参考编号，例如：4326。
     */		
    inSr: 4326,


	/**
	 * Constructor: Geo.Analysis.GeneralizeParameters
	 * Geo.Analysis.GeneralizeParameters类构造函数。
	 *
	 * Parameters:
	 * params 构造参数。
	 */
    initialize: function (params) {
        Geo.Util.extend(this,params);
    },

    toJson: function () {
        var jsonObj = {
            sr:this.inSr || 4326
        };

        if(this.geometries){
            var geometriesObj = Geo.Analysis.Util.geoGeometryAndTypeToEsriObj(this.geometries,this.inSr);
            var geometriesString = new Geo.Format.JSON().write(geometriesObj);
            jsonObj.geometries = geometriesString;
        }

        if (this.deviationUnit) {
            jsonObj.deviationUnit = this.deviationUnit;
        }
        
        if (this.maxDeviation) {
            jsonObj.maxDeviation = this.maxDeviation;
        }

        return jsonObj;
    }

});/*

http://sampleserver6.arcgisonline.com/arcgis/sdk/rest/

 http://tasks.arcgisonline.com/ArcGIS/rest/services/Geometry/GeometryServer/buffer?f=json&unit=9093&unionResults=false&geodesic=false&geometries=%7B%22geometryType%22%3A%22esriGeometryPolyline%22%2C%22geometries%22%3A%5B%7B%22paths%22%3A%5B%5B%5B-12448201.500800378%2C5144959.494568795%5D%2C%5B-12479999.304567003%2C4924820.853107547%5D%5D%5D%2C%22spatialReference%22%3A%7B%22wkid%22%3A102100%7D%7D%5D%7D&inSR=102100&distances=25&outSR=102100&bufferSR=32612
 {"geometries":[{"rings":[[[-12501658.88973,5152667.96701734],[-12501302.646001,5154876.36219508],[-12500551.7942033,5158345.3997183],[-12499575.8687868,5161758.86094977],[-12498378.8266595,5165101.99726929],[-12496965.59067,5168360.33362632],[-12495342.0321103,5171519.73226211],[-12493514.9480215,5174566.45654885],[-12491492.0357635,5177487.23376193],[-12489281.86167,5180269.31540188],[-12486893.826704,5182900.53588044],[-12484338.1270485,5185369.36937112],[-12481625.7110631,5187664.98335099],[-12478768.2327329,5189777.28953903],[-12475778.0007977,5191696.99200073],[-12472667.9248973,5193415.63080657],[-12469451.4589211,5194925.62316849],[-12466142.5406195,5196220.29898869],[-12462755.528915,5197293.93382203],[-12459305.1400268,5198141.77658247],[-12455806.3795177,5198760.0718145],[-12452274.4749642,5199146.07898401],[-12448724.8060674,5199298.08525168],[-12445172.8340899,5199215.41424117],[-12441634.0312441,5198898.42901119],[-12438123.8100217,5198348.53071207],[-12434657.4524243,5197568.15144174],[-12431250.0397568,5196560.74307521],[-12427916.3848223,5195330.7595138],[-12424670.9634049,5193883.63594891],[-12421527.8496982,5192225.76259019],[-12418500.6527951,5190364.45309027],[-12415602.4554058,5188307.91031047],[-12412845.7561907,5186065.1863962],[-12410242.4148282,5183646.14024387],[-12407803.5999713,5181061.39043044],[-12405539.7414685,5178322.26519134],[-12403460.4860414,5175440.74969295],[-12401574.6565398,5172429.42989239],[-12399890.2162374,5169301.43443151],[-12398414.2361081,5166070.37480663],[-12397152.8679911,5162750.28294529],[-12396111.3204906,5159355.5476382],[-12395293.8401021,5155900.85096564],[-12394703.697601,5152401.10181295],[-12394343.1770737,5148871.37112292],[-12394213.5709776,5145326.82567098],[-12394315.1785869,5141782.66215304],[-12394647.3094747,5138254.04212966],[-12394828.1548198,5136956.50024476],[-12427796.6514075,4917157.51513507],[-12428161.3780682,4915004.62291364],[-12428920.156229,4911626.1164873],[-12429896.801091,4908305.69966143],[-12431086.9320995,4905057.46405296],[-12432485.2727623,4901895.16706509],[-12434085.6762219,4898832.17652923],[-12435881.1549284,4895881.41629901],[-12437863.9118813,4893055.31379944],[-12440025.3764164,4890365.75074634],[-12442356.2416166,4887824.01605948],[-12444846.5052864,4885440.76100325],[-12447485.5130481,4883225.95779429],[-12450262.0034219,4881188.86080486],[-12453164.1556811,4879337.97040253],[-12456179.6392082,4877681.00079758],[-12459295.6642326,4876224.84985484],[-12462499.0349286,4874975.57367004],[-12465776.2035849,4873938.36283976],[-12469113.3248823,4873117.52286517],[-12472496.3132141,4872516.45873371],[-12475910.8986533,4872137.66119142],[-12479342.6848092,4871982.6980403],[-12482777.2069262,4872052.20796149],[-12486199.9898034,4872345.89855544],[-12489596.6057288,4872862.54714868],[-12492952.7326598,4873600.00580756],[-12496254.212186,4874555.2088738],[-12499487.1056925,4875724.18555658],[-12502637.7518834,4877102.07416309],[-12505692.8213361,4878683.14055867],[-12508639.3710211,4880460.80073599],[-12511464.8977683,4882427.64507415],[-12514157.3894706,4884575.46738683],[-12516705.3749385,4886895.29593336],[-12519097.9723419,4889377.42843641],[-12521324.9349354,4892011.46976568],[-12523376.6948629,4894786.37222658],[-12525244.4049303,4897690.47932815],[-12526919.9768781,4900711.57182748],[-12528396.1180988,4903836.9159701],[-12529666.3639073,4907053.31497657],[-12530725.1083131,4910347.16248912],[-12531567.6307444,4913704.49704199],[-12532190.1185817,4917111.06051715],[-12532589.6878473,4920552.35613136],[-12532764.3986279,4924013.70922007],[-12532713.2676065,4927480.32910664],[-12532436.2759084,4930937.37159047],[-12532276.8510024,4932210.01084963],[-12501658.88973,5152667.96701734]]]}]}


 -- 线缓冲：
 请求：
 http://tasks.arcgisonline.com/ArcGIS/rest/services/Geometry/GeometryServer/buffer?f=json&unit=9093&unionResults=false&geodesic=false&geometries=%7B%22geometryType%22%3A%22esriGeometryPolyline%22%2C%22geometries%22%3A%5B%7B%22paths%22%3A%5B%5B%5B-12479999.30456701%2C5055681.045531732%5D%2C%5B-12479999.30456701%2C4769500.811632109%5D%5D%5D%2C%22spatialReference%22%3A%7B%22wkid%22%3A102100%7D%7D%5D%7D&inSR=102100&distances=25&outSR=102100&bufferSR=32612&callback=dojo.io.script.jsonp_dojoIoScript3._jsonpCallback
 响应：
 dojo.io.script.jsonp_dojoIoScript3._jsonpCallback({"geometries":[{"rings":[[[-12533482.3920909,5055518.97438717],[-12533423.8897517,5058359.28955154],[-12533144.5527118,5061862.66453099],[-12532637.2549517,5065341.43014181],[-12531903.9277441,5068780.62533233],[-12530947.4808156,5072165.42773726],[-12529771.7929123,5075481.21773848],[-12528381.6998284,5078713.64430603],[-12526782.9771993,5081848.68808045],[-12524982.31816,5084872.7245784],[-12522987.3083072,5087772.58634285],[-12520806.3948085,5090535.62267952],[-12518448.8525536,5093149.75777926],[-12515924.7452993,5095603.54703769],[-12513244.88322,5097886.23011012],[-12510420.7769939,5099987.78140261],[-12507464.5876157,5101898.95777581],[-12504389.073255,5103611.34186208],[-12501207.5333515,5105117.38290362],[-12497933.7490011,5106410.4320792],[-12494581.9210657,5107484.77528991],[-12491166.6071002,5108335.66075715],[-12487702.6542285,5108959.32126542],[-12484205.1326316,5109352.99346771],[-12480689.2664823,5109514.9307596],[-12477170.3641974,5109444.41220549],[-12473663.7486216,5109141.7457401],[-12470184.6871328,5108608.26711164],[-12466748.3216242,5107846.33309469],[-12463369.5990206,5106859.31072685],[-12460063.2041411,5105651.56003186],[-12456843.4918338,5104228.41379884],[-12453724.4229864,5102596.1518741],[-12450719.5015546,5100761.97020281],[-12447841.7137745,5098733.94723438],[-12445103.4709183,5096521.00468129],[-12442516.5547348,5094132.86568549],[-12440092.0657198,5091580.00847797],[-12437840.3755839,5088873.61709617],[-12435771.083121,5086025.52940329],[-12433892.9735939,5083048.18170636],[-12432213.9830943,5079954.55139985],[-12430741.1658379,5076758.09787923],[-12429480.6672741,5073472.70085274],[-12428437.6998939,5070112.59749523],[-12427616.5242083,5066692.31956384],[-12427020.4349272,5063226.6275961],[-12426651.7497599,5059730.44680377],[-12426511.804184,5056218.80146671],[-12426511.1457619,5055545.94611684],[-12428036.0336212,4769352.83498031],[-12428123.6500519,4766593.93515491],[-12428432.6757379,4763195.37024949],[-12428962.1179393,4759825.47491063],[-12429709.4958472,4756498.61163729],[-12430671.4059969,4753228.93119631],[-12431843.5411973,4750030.3146638],[-12433220.7113122,4746916.31496056],[-12434796.8683086,4743900.10221584],[-12436565.1353623,4740994.41005253],[-12438517.837528,4738211.48378392],[-12440646.5369048,4735563.03172162],[-12442942.0694246,4733060.17863564],[-12445394.5851717,4730713.42140331],[-12447993.590816,4728532.58807022],[-12450727.9940226,4726526.79946878],[-12453586.1506172,4724704.43343707],[-12456555.9132521,4723073.09299169],[-12459624.6814538,4721639.57644496],[-12462779.4540143,4720409.85222713],[-12466006.8824558,4719389.03539118],[-12469293.3246172,4718581.36820585],[-12472624.9012514,4717990.20488255],[-12475987.5512998,4717617.9979875],[-12479367.0890372,4717466.28982485],[-12482749.2614591,4717535.70633015],[-12486119.8054963,4717825.95514011],[-12489464.5052426,4718335.82641064],[-12492769.2494226,4719063.19780146],[-12496020.0886376,4720005.04196733],[-12499203.290831,4721157.43905068],[-12502305.3980817,4722515.59080904],[-12505313.2804572,4724073.83892665],[-12508214.1898182,4725825.68739008],[-12510995.8125654,4727763.8265434],[-12513646.3201368,4729880.16187195],[-12516154.4181563,4732165.84472933],[-12518509.3941653,4734611.30701734],[-12520701.1626562,4737206.29849525],[-12522720.3081889,4739939.92665564],[-12524558.1264819,4742800.70002447],[-12526206.6620325,4745776.57369743],[-12527658.7441803,4748854.99703078],[-12528908.0187702,4752022.96451689],[-12529948.9783182,4755267.06857639],[-12530776.9881715,4758573.55334082],[-12531388.3085246,4761928.37234023],[-12531780.1146053,4765317.24570801],[-12531950.5116619,4768725.72011593],[-12531957.787004,4769379.33634663],[-12533482.3920909,5055518.97438717]]]}]});

 -- 折线缓冲：
 请求：
 http://tasks.arcgisonline.com/ArcGIS/rest/services/Geometry/GeometryServer/buffer?f=json&unit=9093&unionResults=false&geodesic=false&geometries=%7B%22geometryType%22%3A%22esriGeometryPolyline%22%2C%22geometries%22%3A%5B%7B%22paths%22%3A%5B%5B%5B-12322233.278186447%2C5094816.804013731%5D%2C%5B-12488560.251734945%2C4878347.139910171%5D%2C%5B-12404173.772508135%2C4666769.44561686%5D%2C%5B-12265975.625368574%2C4871009.185194796%5D%2C%5B-12308780.36120826%2C5086255.856845794%5D%5D%5D%2C%22spatialReference%22%3A%7B%22wkid%22%3A102100%7D%7D%5D%7D&inSR=102100&distances=25&outSR=102100&bufferSR=32612&callback=dojo.io.script.jsonp_dojoIoScript4._jsonpCallback
 响应：
 dojo.io.script.jsonp_dojoIoScript4._jsonpCallback({"geometries":[{"rings":[[[-12541076.7438678,4877504.10216634],[-12541028.3364416,4880954.56887413],[-12540755.1287214,4884395.65280984],[-12540258.0582237,4887812.58900813],[-12539539.0264035,4891190.68568943],[-12538600.8950558,4894515.38842477],[-12537447.4768718,4897772.34296529],[-12536083.5235173,4900947.45979422],[-12534514.7085864,4904026.97594639],[-12532747.6055332,4906997.51692784],[-12530789.6628476,4909846.15758264],[-12530552.9294699,4910164.9703536],[-12364624.6158991,5128071.310346],[-12362636.6470152,5130487.86483991],[-12360226.176635,5133073.82538236],[-12357651.0682151,5135495.96072325],[-12354922.3641639,5137743.64299403],[-12352051.7984337,5139806.99580175],[-12349051.7451221,5141676.93996979],[-12345935.1641781,5143345.23748663],[-12342715.5443774,5144804.53087079],[-12339406.8426703,5146048.37771835],[-12336023.4212991,5147071.28249857],[-12332579.9838255,5147868.7230943],[-12329091.5071991,5148437.17187378],[-12325573.1745094,5148774.11380166],[-12322040.3053044,5148878.05803166],[-12318508.2853164,5148748.54550881],[-12314992.4962413,5148386.15081147],[-12311508.2455397,5147792.47970916],[-12308070.6962383,5146970.16096171],[-12304694.7973657,5145922.83413593],[-12301395.2168797,5144655.13092698],[-12298186.2739428,5143172.65352082],[-12295081.8752069,5141481.94752491],[-12292095.4522324,5139590.46966145],[-12289239.901167,5137506.55273517],[-12286926.1960408,5135572.68271533],[-12284687.7532269,5134534.58765761],[-12281588.5520646,5132841.04376347],[-12278607.4990242,5130947.08098661],[-12275757.4658733,5128861.04258667],[-12273050.731715,5126592.10635662],[-12270498.929233,5124150.24022962],[-12268112.9938447,5121546.15613554],[-12265903.1172762,5118791.25899764],[-12263878.7037897,5115897.59391503],[-12262048.3320085,5112877.78991366],[-12260419.7190833,5109745.00181229],[-12258999.6898334,5106512.85045552],[-12257794.1509495,5103195.3604628],[-12256808.0680406,5099806.89689256],[-12256124.1084931,5096773.12399089],[-12214426.7602713,4881089.8194563],[-12214351.3848035,4880687.41567675],[-12213840.2438594,4877274.71341227],[-12213552.7350734,4873836.92429415],[-12213489.8582471,4870388.80242969],[-12213651.6491718,4866945.11545961],[-12214037.1838335,4863520.58160403],[-12214644.5860712,4860129.80742991],[-12215471.0391251,4856787.22619928],[-12216512.8021552,4853507.03731049],[-12217765.2287614,4850303.14845148],[-12219222.7904722,4847189.11732111],[-12220879.1029909,4844178.09727692],[-12222726.9559627,4841282.78397875],[-12222892.6299641,4841042.3764045],[-12361543.6727746,4637982.11024385],[-12363338.1627012,4635479.18610495],[-12363338.1998903,4635479.13385301],[-12365465.1363773,4632872.61760233],[-12367756.2005034,4630411.47262989],[-12370201.5677619,4628106.02466627],[-12372790.7805724,4625965.93293172],[-12375512.7930918,4624000.15246547],[-12378356.0168414,4622216.8989166],[-12381308.3702273,4620623.61712306],[-12384357.3281623,4619226.95239045],[-12387489.9736049,4618032.72452939],[-12390693.0506843,4617045.90599554],[-12393953.0185676,4616270.6029287],[-12397256.1071457,4615710.0391668],[-12400588.3720601,4615366.54435243],[-12403935.7514256,4615241.54506905],[-12407284.1227934,4615335.55924317],[-12410619.3599242,4615648.19456662],[-12413927.3895657,4616178.14965519],[-12417194.248445,4616923.21922369],[-12420406.1400356,4617880.30252555],[-12423549.4896442,4619045.41483248],[-12426611.000181,4620413.70299349],[-12429577.7061279,4621979.46397716],[-12432437.0267805,4623736.16630983],[-12435176.8179336,4625676.47562],[-12437785.4216666,4627792.2829467],[-12440251.7160465,4630074.73573535],[-12442565.1609696,4632514.27264402],[-12444715.8432057,4635100.66080427],[-12446694.5187541,4637823.03639546],[-12448492.6532618,4640669.94668396],[-12450102.4591197,4643629.39668951],[-12451516.930207,4646688.89670686],[-12451923.5450506,4647677.62887734],[-12537138.5109865,4858429.85646112],[-12537981.1128644,4860624.95262823],[-12539037.252032,4863902.718215],[-12539878.2234675,4867243.81868591],[-12540500.224775,4870634.06418163],[-12540900.3777804,4874059.02701361],[-12541076.7438678,4877504.10216634]],[[-12428704.2698307,4870201.97521191],[-12392262.5603917,4777893.89309665],[-12321832.6324904,4882468.0228035],[-12342169.4509018,4982350.71375731],[-12428704.2698307,4870201.97521191]]]}]});

 -- 简化：
 http://tasks.arcgisonline.com/ArcGIS/rest/services/Geometry/GeometryServer/simplify?f=json&sr=102100&geometries=%7B%22geometryType%22%3A%22esriGeometryPolygon%22%2C%22geometries%22%3A%5B%7B%22rings%22%3A%5B%5B%5B-12462877.410231133%2C5187764.23040848%5D%2C%5B-12372375.96874151%2C5193879.192671293%5D%2C%5B-12333240.21025951%2C5014099.3021446075%5D%2C%5B-12296550.436682635%2C4776838.766347484%5D%2C%5B-12448201.500800384%2C4616626.755061798%5D%2C%5B-12579061.69322457%2C4888131.07953067%5D%2C%5B-12462877.410231133%2C5187764.23040848%5D%5D%5D%2C%22spatialReference%22%3A%7B%22wkid%22%3A102100%7D%7D%5D%7D&callback=dojo.io.script.jsonp_dojoIoScript5._jsonpCallback

 dojo.io.script.jsonp_dojoIoScript5._jsonpCallback({"geometryType":"esriGeometryPolygon","geometries":[{"rings":[[[-12296550.4367,4776838.7663],[-12448201.5008,4616626.7551],[-12579061.6932,4888131.0795],[-12462877.4102,5187764.2304],[-12372375.9687,5193879.1927],[-12333240.2103,5014099.3021],[-12296550.4367,4776838.7663]]]}]});

 -- 多边形缓冲：

 http://tasks.arcgisonline.com/ArcGIS/rest/services/Geometry/GeometryServer/buffer?f=json&unit=9093&unionResults=false&geodesic=false&geometries=%7B%22geometryType%22%3A%22esriGeometryPolygon%22%2C%22geometries%22%3A%5B%7B%22rings%22%3A%5B%5B%5B-12296550.4367%2C4776838.7663%5D%2C%5B-12448201.5008%2C4616626.7551%5D%2C%5B-12579061.6932%2C4888131.0795%5D%2C%5B-12462877.4102%2C5187764.2304%5D%2C%5B-12372375.9687%2C5193879.1927%5D%2C%5B-12333240.2103%2C5014099.3021%5D%2C%5B-12296550.4367%2C4776838.7663%5D%5D%5D%2C%22spatialReference%22%3A%7B%22wkid%22%3A102100%7D%7D%5D%7D&inSR=102100&distances=25&outSR=102100&bufferSR=32612&callback=dojo.io.script.jsonp_dojoIoScript6._jsonpCallback

 dojo.io.script.jsonp_dojoIoScript6._jsonpCallback({"geometries":[{"rings":[[[-12631604.7587989,4886803.30135151],[-12631587.9144612,4890256.24045779],[-12631346.076289,4893701.87143209],[-12630880.0456877,4897125.41702692],[-12630191.5890072,4900512.16407104],[-12629283.4331295,4903847.52764016],[-12628244.0617386,4906892.88849913],[-12513401.787154,5207683.33686586],[-12513311.7527692,5207913.67385863],[-12511897.605708,5211188.83316827],[-12510272.0237713,5214364.97911786],[-12508441.8093525,5217428.30111899],[-12506414.6700901,5220365.45270973],[-12504199.1882038,5223163.61222583],[-12501804.7847813,5225810.54187211],[-12499241.6816724,5228294.64492079],[-12496520.8576896,5230605.01949316],[-12493654.002097,5232731.51053761],[-12490653.4635815,5234664.75693511],[-12487532.1962517,5236396.236862],[-12484303.7027856,5237918.30858626],[-12480981.9738171,5239224.24647156],[-12477581.4249982,5240308.27424879],[-12474116.8328526,5241165.59300701],[-12470603.2665164,5241792.40372715],[-12467056.0200941,5242185.92681559],[-12466801.8105161,5242205.05282635],[-12375782.6582314,5248394.51301208],[-12372467.7879883,5248501.88382835],[-12368897.9454231,5248390.0025724],[-12365343.2515088,5248042.68856221],[-12361819.1898603,5247461.4803563],[-12358341.103799,5246648.9519998],[-12354924.1258416,5245608.70110674],[-12351583.1096717,5244345.33034471],[-12348332.5613019,5242864.42591217],[-12345186.5750776,5241172.53048601],[-12342158.7687721,5239277.1108494],[-12339262.2236717,5237186.52287362],[-12336509.42632,5234909.97081616],[-12333912.2138605,5232457.46403025],[-12331481.7221952,5229839.76914898],[-12329228.3384633,5227068.35935073],[-12327161.6570251,5224155.36094805],[-12325290.4390754,5221113.49659099],[-12323622.5773417,5217956.02668741],[-12322165.0637988,5214696.68831659],[-12320923.9633134,5211349.63363688],[-12319904.3900564,5207929.36446666],[-12319319.2758208,5205473.94353257],[-12281122.1324525,5025273.9855384],[-12280921.0711829,5024268.79413923],[-12280578.2241391,5022257.65778718],[-12245109.6760879,4784628.52192149],[-12244920.5006273,4783213.82261246],[-12244624.5048507,4779808.67657124],[-12244551.0261329,4776392.53055315],[-12244700.1535449,4772980.01758215],[-12245071.0240277,4769585.72563825],[-12245661.8308346,4766224.13593494],[-12246469.8345438,4762909.56173131],[-12247491.3784937,4759656.08819253],[-12248721.9073833,4756477.5148034],[-12250155.9901552,4753387.29796851],[-12251787.3459062,4750398.49632324],[-12253608.8726532,4747523.71765551],[-12253608.8726545,4747523.71752612],[-12255612.6800572,4744775.06828832],[-12257790.1246459,4742164.10522239],[-12259260.0266977,4740581.27179557],[-12410962.8857459,4581477.58426905],[-12411808.4200027,4580598.73922088],[-12414232.2897077,4578293.96349883],[-12416800.0174246,4576153.15663056],[-12419500.6450263,4574185.27971676],[-12422322.6717316,4572398.55984914],[-12425254.1021811,4570800.45872794],[-12428282.4958895,4569397.64320458],[-12431395.0190154,4568195.9604762],[-12434578.4972037,4567200.41495215],[-12437819.4685537,4566415.14916241],[-12441104.2395581,4565843.42876485],[-12444418.9397489,4565487.62922601],[-12447749.578182,4565349.22742592],[-12451082.1001648,4565428.79575786],[-12454402.4438059,4565726.00036503],[-12457696.5965767,4566239.60223496],[-12460950.6520895,4566967.46166103],[-12464150.8666688,4567906.5472307],[-12467283.7141164,4569052.94658065],[-12470335.9418028,4570401.88184122],[-12473294.6238268,4571947.72781693],[-12476147.2140936,4573684.03368301],[-12478881.5983463,4575603.54762345],[-12481486.1439325,4577698.24473861],[-12483949.74824,4579959.35891307],[-12486261.8856746,4582377.41604121],[-12488412.6518427,4584942.27175391],[-12490392.8065675,4587643.15090135],[-12492193.8129726,4590468.69055813],[-12493807.8756513,4593406.98518822],[-12494330.0588845,4594465.48335452],[-12626106.9096625,4864732.62193334],[-12627056.6106408,4866751.9164053],[-12628353.1272963,4869942.71492902],[-12629439.7822246,4873212.70663395],[-12630311.7421792,4876548.03669932],[-12630965.0756154,4879934.54661505],[-12631396.7719375,4883357.83169952],[-12631604.7587989,4886803.30135151]]]}]});

 */
/**
 * Class: Geo.Analysis.GeometryService
 * Geometry Service服务类。
 */
Geo.Analysis.GeometryService = Geo.Class({

	/**
     * APIProperty: url
     * {String} Geometry Service服务地址。
     */	
    url: null,

	/**
	 * Constructor: Geo.Analysis.GeometryService
	 * Geo.Analysis.GeometryService类构造函数。
	 *
	 * Parameters:
	 * url - {String} Geometry Service服务地址。
	 */
    initialize:function (url) {
        this.url = url;
    },

	/**
	 * APIMethod: areasAndLengths
	 * 面积与周长操作。
	 *
	 * Parameters:
	 * areasAndLengthsParameters - {Geo.Analysis.AreasAndLengthsParameters} 面积与周长操作相关参数。
	 * callback - {Function} 操作成功回调函数。
	 * errback - {Function} 操作失败回调函数。
	 */	
    areasAndLengths:function (areasAndLengthsParameters, callback, errback) {

        /*
            http://resources.arcgis.com/en/help/arcgis-rest-api/index.html#/Areas_and_Lengths/02r3000000t4000000/
            http://sampleserver6.arcgisonline.com/arcgis/rest/services/Utilities/Geometry/GeometryServer/areasAndLengths?sr=102009&polygons=%5B%7B%22rings%22%3A%5B%5B%5B-628833%2C206205%5D%2C%5B-630269%2C192298%5D%2C%5B-631848%2C173991%5D%2C%5B-616471%2C341822%5D%2C%5B-620213%2C301450%5D%2C%5B-625923%2C237538%5D%2C%5B-628833%2C206205%5D%5D%5D%7D%2C%7B%22rings%22%3A%5B%5B%5B0%2C0%5D%2C%5B0%2C100000%5D%2C%5B100000%2C100000%5D%2C%5B100000%2C0%5D%2C%5B0%2C0%5D%5D%5D%7D%5D&lengthUnit=9035&areaUnit=%7B%22areaUnit%22%3A%22esriAcres%22%7D&calculationType=preserveShape&f=html
            示例：http://atlas.resources.ca.gov/arcgis/sdk/rest/areasandlengths.html
         */
        var requestParams = areasAndLengthsParameters.toJson();

        this._request = Geo.Analysis.Util.sendRequest({
            url:this.url + "/areasAndLengths",
            params:requestParams,
            callback:callback, errback:errback
        });
    },


	/**
	 * APIMethod: autoComplete
	 * 自动完成操作。autoComplete操作可以简化与其它相邻多边形的多边形的构造过程。它构造的多边形将填充指定polygon和polyline之间的缝隙。
	 *
	 * Parameters:
	 * polygons - {Array<Geo.Geometry.Polygon>}参照的多边形数组。
	 * polylines - {Array<Geo.Geometry.LineString>}用于构造多边形的折线数组。
	 * inSr - {String}输入几何对象的空间参考。
	 * callback - {Function} 操作成功回调函数。
	 * errback - {Function} 操作失败回调函数。
	 */		
    autoComplete:function (polygons, polylines, inSr, callback, errback) {
        /*
        示例：http://sampleserver6.arcgisonline.com/arcgis/sdk/rest/autoComplete.html
         */

        var requestParams = {
            sr:inSr || 4326
        };

        if (polygons) {
            var geometriesObj = [];
            for (var i = 0; i < polygons.length; i++) {
                var polygon = Geo.Analysis.Util.geoGeometryToEsriObjMapping['polygon'](polygons[i]);
                geometriesObj.push(polygon);
            }
            var geometriesStr = new Geo.Format.JSON().write(geometriesObj);
            requestParams.polygons = geometriesStr;
        }

        if (polylines) {
            var geometriesObj = [];
            for (var i = 0; i < polylines.length; i++) {
                var polyline = Geo.Analysis.Util.geoGeometryToEsriObjMapping['polyline'](polylines[i]);
                geometriesObj.push(polyline);
            }
            var geometriesStr = new Geo.Format.JSON().write(geometriesObj);
            requestParams.polylines = geometriesStr;
        }

        this._request = Geo.Analysis.Util.sendRequest({
            url:this.url + "/autoComplete",
            params:requestParams,
            callback:_successHandler, errback:errback
        });

        function _successHandler(result){
            result.geometryType = "esriGeometryPolygon";
            var geometries = Geo.Analysis.Util.esriObjToGeoGeometry(result);
            callback({geometries: geometries});
        }

    },

	/**
	 * APIMethod: buffer
	 * 缓冲分析操作。对指定几何对象进行缓冲分析，生成缓冲区。
	 *
	 * Parameters:
	 * bufferParameters - {Geo.Analysis.BufferParameters}缓冲分析参数。
	 * callback - {Function} 操作成功回调函数。
	 * errback - {Function} 操作失败回调函数。
	 */		
    buffer:function (bufferParameters, callback, errback) {

        /*
        示例：http://sampleserver6.arcgisonline.com/arcgis/sdk/rest/buffer.html
         */
        var requestParams = bufferParameters.toJson();

        this._request = Geo.Analysis.Util.sendRequest({
            url:this.url + "/buffer",
            params:requestParams,
            callback:_successHandler, errback:errback
        });

        function _successHandler(result){
            result.geometryType = "esriGeometryPolygon";
            var geometries = Geo.Analysis.Util.esriObjToGeoGeometry(result);
            callback({geometries: geometries});
        }

    },

	/**
	 * APIMethod: convexHull
	 * 获取指定几何对象的凸包。输入对象可以是Geo.Geometry.Point, Geo.Geometry.LineString或Geo.Geometry.Polygon。
	 *
	 * Parameters:
	 * geometries - {Array<Geo.Geometry>}几何对象数组。
	 * inSr - {String}输入几何对象的空间参考。
	 * callback - {Function} 操作成功回调函数。
	 * errback - {Function} 操作失败回调函数。
	 */	
    convexHull:function (geometries, inSr, callback, errback) {
        /*
            示例：http://sampleserver6.arcgisonline.com/arcgis/sdk/rest/convexHull.html
         */

        var requestParams = {
            sr:inSr || 4326
        };

        if (geometries) {
            var inGeometries = Geo.Analysis.Util.geoGeometryAndTypeToEsriObj(geometries);
            var geometriesStr = new Geo.Format.JSON().write(inGeometries);
            requestParams.geometries = geometriesStr;
        }

        this._request = Geo.Analysis.Util.sendRequest({
            url:this.url + "/convexHull",
            params:requestParams,
            callback:_successHandler, errback:errback
        });

        function _successHandler(result){
            var geometryType = result.geometryType;
            var geometry = Geo.Analysis.Util.esriObjToGeoGeometryMapping[geometryType](result.geometry);
            callback(geometry);
        }

    },

	/**
	 * APIMethod: cut
	 * 几何对象分割。使用分割线去分割指定的几何对象。
	 *
	 * Parameters:
	 * geometries - {Array<Geo.Geometry>} 几何对象数组。
	 * cutterGeometry - {<Geo.Geometry>} 分割几何对象。
	 * inSr - {String} 输入几何对象的空间参考。
	 * callback - {Function} 操作成功回调函数。
	 * errback - {Function} 操作失败回调函数。
	 */		
    cut:function (geometries, cutterGeometry, inSr, callback, errback) {
        /*
            示例：http://sampleserver6.arcgisonline.com/arcgis/sdk/rest/cut.html
         */

        var requestParams = {
            sr:inSr || 4326
        };

        if (geometries) {
            var inGeometries = Geo.Analysis.Util.geoGeometryAndTypeToEsriObj(geometries);
            var geometriesStr = new Geo.Format.JSON().write(inGeometries);
            requestParams.target = geometriesStr;
        }

        if (cutterGeometry) {
            var inCutterGeometry = Geo.Analysis.Util.geoGeometryToEsriObjMapping['polyline'](cutterGeometry);
            var geometryStr = new Geo.Format.JSON().write(inCutterGeometry);
            requestParams.cutter = geometryStr;
        }

        this._request = Geo.Analysis.Util.sendRequest({
            url:this.url + "/cut",
            params:requestParams,
            callback:_successHandler, errback:errback
        });

        function _successHandler(result){
            var geometries = Geo.Analysis.Util.esriObjToGeoGeometry(result);
            callback({
                cutIndexes: result.cutIndexes,
                geometries: geometries
            });
        }

    },

	/**
	 * APIMethod: difference
	 * 获取两组几何对象的差集。求两组几何对象之间的差异。
	 *
	 * Parameters:
	 * geometries - {Array<Geo.Geometry>} 几何对象数组。
	 * geometry - {<Geo.Geometry>} 几何对象。
	 * inSr - {String} 输入几何对象的空间参考。
	 * callback - {Function} 操作成功回调函数。
	 * errback - {Function} 操作失败回调函数。
	 */	
    difference:function (geometries, geometry, inSr, callback, errback) {
        /*
            示例：http://atlas.resources.ca.gov/arcgis/sdk/rest/difference.html
         */
        var requestParams = {
            sr:inSr || 4326
        };

        if (geometries) {
            var inGeometries = Geo.Analysis.Util.geoGeometryAndTypeToEsriObj(geometries);
            var geometriesStr = new Geo.Format.JSON().write(inGeometries);
            requestParams.geometries = geometriesStr;
        }

        if (geometry) {
            var inGeometry = Geo.Analysis.Util.geoGeometryAndTypeToEsriObj(geometry);
            var geometryStr = new Geo.Format.JSON().write(inGeometry);
            requestParams.geometry = geometryStr;
        }

        this._request = Geo.Analysis.Util.sendRequest({
            url:this.url + "/difference",
            params:requestParams,
            callback:_successHandler, errback:errback
        });

        function _successHandler(result){
            var geometries = Geo.Analysis.Util.esriObjToGeoGeometry(result);
            callback({geometries: geometries});
        }

    },

	/**
	 * APIMethod: distance
	 * 测量两个几何对象之间的平面或球面距离。
	 *
	 * Parameters:
	 * distanceParameters - {Geo.Analysis.DistanceParameters} 测量距离操作参数。
	 * callback - {Function} 操作成功回调函数。
	 * errback - {Function} 操作失败回调函数。
	 */	
    distance:function (distanceParameters, callback, errback) {
        /*
            示例：http://atlas.resources.ca.gov/arcgis/sdk/rest/distance.html
         */

        var requestParams = distanceParameters.toJson();

        this._request = Geo.Analysis.Util.sendRequest({
           url:this.url + "/distance",
           params:requestParams,
           callback:callback, errback:errback
        });
    },

	/**
	 * APIMethod: generalize
	 * 抽稀处理几何对象。
	 *
	 * Parameters:
	 * generalizeParameters - {Geo.Analysis.GeneralizeParameters} 抽稀操作参数。
	 * callback - {Function} 操作成功回调函数。
	 * errback - {Function} 操作失败回调函数。
	 */		
    generalize:function (generalizeParameters, callback, errback) {
        /*
            示例：http://atlas.resources.ca.gov/arcgis/sdk/rest/generalize.html
         */

        var requestParams = generalizeParameters.toJson();

        this._request = Geo.Analysis.Util.sendRequest({
           url:this.url + "/generalize",
           params:requestParams,
           callback:_successHandler, errback:errback
        });

        function _successHandler(result){
            var geometries = Geo.Analysis.Util.esriObjToGeoGeometry(result);
            callback({geometries: geometries});
        }
    },

	/**
	 * APIMethod: intersect
	 * 获取两组几何对象的交集。
	 *
	 * Parameters:
	 * geoGeometries - {Array<Geo.Geometry>} 几何对象数组。
	 * geoGeometry - {<Geo.Geometry>} 几何对象。
	 * inSr - {String} 输入几何对象的空间参考。
	 * callback - {Function} 操作成功回调函数。
	 * errback - {Function} 操作失败回调函数。
	 */	
    intersect:function (geoGeometries, geoGeometry,inSr, callback, errback) {
        /*
        示例：http://atlas.resources.ca.gov/arcgis/sdk/rest/intersect.html
        http://sampleserver6.arcgisonline.com/arcgis/sdk/rest/intersect.html
        注意：几何对象的坐标串一定要顺时针方向
         */

        var geometriesObj = Geo.Analysis.Util.geoGeometryAndTypeToEsriObj(geoGeometries,4326);
        var geometriesStr = new Geo.Format.JSON().write(geometriesObj);

        var geometryObj = Geo.Analysis.Util.geoGeometryAndTypeToEsriObj(geoGeometry,4326);
        var geometryStr = new Geo.Format.JSON().write(geometryObj);

        var requestParams = {
            geometries: geometriesStr,
            geometry: geometryStr,
            sr:inSr || 4326
        };

        this._request = Geo.Analysis.Util.sendRequest({
            url:this.url + "/intersect",
            params:requestParams,
            callback:_successHandler, errback:errback
        });

        function _successHandler(result){
            var geometries = Geo.Analysis.Util.esriObjToGeoGeometry(result);
            callback({geometries: geometries});
        }
    },

	/**
	 * APIMethod: labelPoints
	 * 获取指定多边形的标注点。
	 *
	 * Parameters:
	 * polygons - {Array<Geo.Geometry.Polygon>} 多边形几何对象集。
	 * inSr - {String} 输入几何对象的空间参考。
	 * callback - {Function} 操作成功回调函数。
	 * errback - {Function} 操作失败回调函数。
	 */	
    labelPoints: function (polygons, inSr, callback, errback) {
        /*
            示例：http://atlas.resources.ca.gov/arcgis/sdk/rest/labelPoints.html
         */
        var geometriesObj = [];
        for (var i = 0; i < polygons.length; i++) {
            var polygon = Geo.Analysis.Util.geoGeometryToEsriObjMapping['polygon'](polygons[i]);
            geometriesObj.push(polygon);
        }

        var geometriesStr = new Geo.Format.JSON().write(geometriesObj);

        var requestParams = {
            polygons: geometriesStr,
            sr:inSr || 4326
        };

        this._request = Geo.Analysis.Util.sendRequest({
            url:this.url + "/labelPoints",
            params:requestParams,
            callback:_successHandler, errback:errback
        });

        function _successHandler(result){
            var labelPoints = [];
            for (var i = 0; i < result.labelPoints.length; i++) {
                var labelPoint = result.labelPoints[i];
                labelPoints.push(Geo.Analysis.Util.esriObjToGeoGeometryMapping["point"](labelPoint));
            }
            callback({labelPoints: labelPoints});
        }
    },

	/**
	 * APIMethod: lengths
	 * 获取折线的长度值。
	 *
	 * Parameters:
	 * lengthsParameter - {Geo.Analysis.LengthsParameter} 长度量算操作参数。
	 * callback - {Function} 操作成功回调函数。
	 * errback - {Function} 操作失败回调函数。
	 */	
    lengths:function (lengthsParameter, callback, errback) {
        /*
            示例：
            http://sampleserver6.arcgisonline.com/ArcGIS/rest/services/Utilities/Geometry/GeometryServer/lengths?sr=4269&polylines=[%0D%0A{%0D%0A%22paths%22%3A[%0D%0A[[-117%2C34]%2C[-116%2C34]%2C[-117%2C33]]%2C%0D%0A[[-115%2C44]%2C[-114%2C43]%2C[-115%2C43]]%0D%0A]%0D%0A}%2C%0D%0A{%0D%0A%22paths%22%3A[%0D%0A[[32.49%2C17.83]%2C[31.96%2C17.59]%2C[30.87%2C17.01]%2C[30.11%2C16.86]]%0D%0A]%0D%0A}%0D%0A]%0D%0A%0D%0A&lengthUnit=9036&calculationType=preserveShape&f=html
         */
        var requestParams = lengthsParameter.toJson();

        this._request = Geo.Analysis.Util.sendRequest({
            url:this.url + "/lengths",
            params:requestParams,
            callback:callback, errback:errback
        });
    },

	/**
	 * APIMethod: offset
	 * 获取几何对象的偏移复本。
	 *
	 * Parameters:
	 * offsetParameter - {Geo.Analysis.OffsetParameter} 偏移操作参数。
	 * callback - {Function} 操作成功回调函数。
	 * errback - {Function} 操作失败回调函数。
	 */	
    offset:function (offsetParameter, callback, errback) {
        /*
            示例：http://atlas.resources.ca.gov/arcgis/sdk/rest/offset.html
         */

        var requestParams = offsetParameter.toJson();

        this._request = Geo.Analysis.Util.sendRequest({
            url:this.url + "/offset",
            params:requestParams,
            callback:_successHandler, errback:errback
        });

        function _successHandler(result){
            var geometries = Geo.Analysis.Util.esriObjToGeoGeometry(result);
            callback({geometries: geometries});
        }
    },

	/**
	 * APIMethod: project
	 * 将一组几何对象转换到新的投影类型。
	 *
	 * Parameters:
	 * projectParameters - {Geo.Analysis.ProjectParameters} 投影转换参数。
	 * callback - {Function} 操作成功回调函数。
	 * errback - {Function} 操作失败回调函数。
	 */	
    project:function (projectParameters, callback, errback) {
        /*
        示例：
        http://developers.arcgis.com/en/javascript/samples/util_project/
        http://developers.arcgis.com/en/javascript/samples/util_coordinate_converter/
        服务测试：http://atlas.resources.ca.gov/arcgis/sdk/rest/project.html
         */

        var requestParams = projectParameters.toJson();
        
        this._request = Geo.Analysis.Util.sendRequest({
            url:this.url + "/project",
            params:requestParams,
            callback:_successHandler, errback:errback
        });

        function _successHandler(result){
            var geometries = Geo.Analysis.Util.esriObjToGeoGeometry(result);
            callback({geometries: geometries});
        }

    },

	/**
	 * APIMethod: relation
	 * 计算两个几何对象是否属于指定的空间关系。
	 *
	 * Parameters:
	 * relationParameters - {Geo.Analysis.RelationParameters} 参数。
	 * callback - {Function} 操作成功回调函数。
	 * errback - {Function} 操作失败回调函数。
	 */	
    relation:function (relationParameters, callback, errback) {
        /*
            示例：http://atlas.resources.ca.gov/arcgis/sdk/rest/relation.html
         */
        var requestParams = relationParameters.toJson();

        this._request = Geo.Analysis.Util.sendRequest({
            url:this.url + "/relation",
            params:requestParams,
            callback:callback, errback:errback
        });
    },

	/**
	 * APIMethod: densify
	 * 增加密度操作
	 *
	 * Parameters:
	 * densifyParameters - {Geo.Analysis.DensifyParameters} 增加密度操作参数。
	 * callback - {Function} 操作成功回调函数。
	 * errback - {Function} 操作失败回调函数。
	 */
    densify: function (densifyParameters, callback, errback) {
        /*
            示例：http://atlas.resources.ca.gov/arcgis/sdk/rest/densify.html
         */
        var requestParams = densifyParameters.toJson();

        this._request = Geo.Analysis.Util.sendRequest({
            url:this.url + "/densify",
            params:requestParams,
            callback:_successHandler, errback:errback
        });

        function _successHandler(result){
            var geometries = Geo.Analysis.Util.esriObjToGeoGeometry(result);
            callback({geometries: geometries});
        }
    },

	/**
	 * APIMethod: reshape
	 * 使用整形折线重构另一折线或多边形的一部分。
	 *
	 * Parameters:
	 * targetGeometry - {<Geo.Geometry.Polygon>} 几何对象。
	 * reshaperGeometry - {<Geo.Geometry.Polygon>} 几何对象。
	 * inSr - {String} 输入几何对象的空间参考。
	 * callback - {Function} 操作成功回调函数。
	 * errback - {Function} 操作失败回调函数。
	 */	
    reshape:function (targetGeometry, reshaperGeometry, inSr, callback, errback) {
        /*
            示例：http://atlas.resources.ca.gov/arcgis/sdk/rest/reshape.html
            https://developers.arcgis.com/en/javascript/jssamples/util_reshape.html
         */

        var requestParams = {
            sr:inSr || 4326
        };

        if (targetGeometry) {
            var inTargetGeometry = Geo.Analysis.Util.geoGeometryAndTypeToEsriObj(targetGeometry);
            var geometryStr = new Geo.Format.JSON().write(inTargetGeometry);
            requestParams.target = geometryStr;
        }

        if (reshaperGeometry) {
            var inReshaperGeometry = Geo.Analysis.Util.geoGeometryToEsriObjMapping['polyline'](reshaperGeometry);
            var geometryStr = new Geo.Format.JSON().write(inReshaperGeometry);
            requestParams.reshaper = geometryStr;
        }

        this._request = Geo.Analysis.Util.sendRequest({
            url:this.url + "/reshape",
            params:requestParams,
            callback:_successHandler, errback:errback
        });

        function _successHandler(result){
            var geometry = Geo.Analysis.Util.esriObjToGeoGeometry(result);
            callback({geometry: geometry});
        }

    },

	/**
	 * APIMethod: simplify
	 * 对指定几何对象进行拓扑校正。
	 *
	 * Parameters:
	 * geometries - {Array<Geo.Geometry>} 几何对象集。
	 * inSr - {String} 输入几何对象的空间参考。
	 * callback - {Function} 操作成功回调函数。
	 * errback - {Function} 操作失败回调函数。
	 */	
    simplify:function (geometries, inSr, callback, errback) {

        /*
            示例：http://atlas.resources.ca.gov/arcgis/sdk/rest/simplify.html
         */
        var geometriesObj = Geo.Analysis.Util.geoGeometryAndTypeToEsriObj(geometries);
        var geometriesStr = new Geo.Format.JSON().write(geometriesObj);
        var requestParams = {
            sr:inSr || 4326,
            geometries:geometriesStr
        };

        this._request = Geo.Analysis.Util.sendRequest({
            url:this.url + "/simplify",
            params:requestParams,
            callback:_successHandler, errback:errback
        });

        function _successHandler(result){
            var geometries = Geo.Analysis.Util.esriObjToGeoGeometry(result);
            callback({geometries: geometries});
        }
    },

	/**
	 * APIMethod: trimExtend
	 * 修剪或扩展指定几何对象。
	 *
	 * Parameters:
	 * trimExtendParameters - {Geo.Analysis.TrimExtendParameters} 修剪或扩展操作参数。
	 * callback - {Function} 操作成功回调函数。
	 * errback - {Function} 操作失败回调函数。
	 */	
    trimExtend:function (trimExtendParameters, callback, errback) {
        /*
            示例：http://atlas.resources.ca.gov/arcgis/sdk/rest/trimExtend.html
         */
        var requestParams = trimExtendParameters.toJson();

        this._request = Geo.Analysis.Util.sendRequest({
            url:this.url + "/trimExtend",
            params:requestParams,
            callback:_successHandler, errback:errback
        });

        function _successHandler(result){
            result.geometryType = "esriGeometryPolyline";
            var geometries = Geo.Analysis.Util.esriObjToGeoGeometry(result);
            callback({geometries: geometries});
        }
    },

	/**
	 * APIMethod: union
	 * 获取多个几何对象的并集。
	 *
	 * Parameters:
	 * geometries - {Array<Geo.Geometry>} 几何对象集。
	 * inSr - {String} 输入几何对象的空间参考。
	 * callback - {Function} 操作成功回调函数。
	 * errback - {Function} 操作失败回调函数。
	 */	
    union:function (geometries, inSr, callback, errback) {
        /*
            示例：http://atlas.resources.ca.gov/arcgis/sdk/rest/union.html
         */

        var geometriesObj = Geo.Analysis.Util.geoGeometryAndTypeToEsriObj(geometries);
        var geometriesStr = new Geo.Format.JSON().write(geometriesObj);
        var requestParams = {
            sr:inSr || 4326,
            geometries:geometriesStr
        };

        this._request = Geo.Analysis.Util.sendRequest({
            url:this.url + "/union",
            params:requestParams,
            callback:_successHandler, errback:errback
        });

        function _successHandler(result){
            var geometry = Geo.Analysis.Util.esriObjToGeoGeometry(result);
            callback({geometry: geometry});
        }
    },

    onAreasAndLengthsComplete:function (areasAndLengths) {
    },

    onAutoCompleteComplete:function (polygons) {
    },

    onBufferComplete:function (geometries) {
    },

    onConvexHullComplete:function (geometry) {
    },

    onCutComplete:function (results) {
    },

    onDifferenceComplete:function (geometries) {
    },

    onDistanceComplete:function (distance) {
    },

    onError:function (error) {
    },

    onGeneralizeComplete:function (geometries) {
    },

    onIntersectComplete:function (geometries) {
    },

    onLabelPointsComplete:function (labelPoints) {
    },

    onLengthsComplete:function (lengths) {
    },

    onOffsetComplete:function (geometries) {
    },

    onProjectComplete:function (geometries) {
    },

    onRelationComplete:function (relationships) {
    },

    onReshapeComplete:function (geometry) {
    },

    onSimplifyComplete:function (geometries) {
    },

    onTrimExtendComplete:function (geometries) {
    },

    onUnionComplete:function (geometry) {
    }
});

//定义一些常量
Geo.Util.extend(Geo.Analysis.GeometryService, {
    UNIT_METER:9001,
    UNIT_GERMAN_METER:9031,
    UNIT_FOOT:9002,
    UNIT_SURVEY_FOOT:9003,
    UNIT_CLARKE_FOOT:9005,
    UNIT_FATHOM:9014,
    UNIT_NAUTICAL_MILE:9030,
    UNIT_SURVEY_CHAIN:9033,
    UNIT_SURVEY_LINK:9034,
    UNIT_SURVEY_MILE:9035,
    UNIT_KILOMETER:9036,
    UNIT_CLARKE_YARD:9037,
    UNIT_CLARKE_CHAIN:9038,
    UNIT_CLARKE_LINK:9039,
    UNIT_SEARS_YARD:9040,
    UNIT_SEARS_FOOT:9041,
    UNIT_SEARS_CHAIN:9042,
    UNIT_SEARS_LINK:9043,
    UNIT_BENOIT_1895A_YARD:9050,
    UNIT_BENOIT_1895A_FOOT:9051,
    UNIT_BENOIT_1895A_CHAIN:9052,
    UNIT_BENOIT_1895A_LINK:9053,
    UNIT_BENOIT_1895B_YARD:9060,
    UNIT_BENOIT_1895B_FOOT:9061,
    UNIT_BENOIT_1895B_CHAIN:9062,
    UNIT_BENOIT_1895B_LINK:9063,
    UNIT_INDIAN_FOOT:9080,
    UNIT_INDIAN_1937_FOOT:9081,
    UNIT_INDIAN_1962_FOOT:9082,
    UNIT_INDIAN_1975_FOOT:9083,
    UNIT_INDIAN_YARD:9084,
    UNIT_INDIAN_1937_YARD:9085,
    UNIT_INDIAN_1962_YARD:9086,
    UNIT_INDIAN_1975_YARD:9087,
    UNIT_FOOT_1865:9070,
    UNIT_RADIAN:9101,
    UNIT_DEGREE:9102,
    UNIT_ARCMINUTE:9103,
    UNIT_ARCSECOND:9104,
    UNIT_GRAD:9105,
    UNIT_GON:9106,
    UNIT_MICRORADIAN:9109,
    UNIT_ARCMINUTE_CENTESIMAL:9112,
    UNIT_ARCSECOND_CENTESIMAL:9113,
    UNIT_MIL6400:9114,
    UNIT_BRITISH_1936_FOOT:9095,
    UNIT_GOLDCOAST_FOOT:9094,
    UNIT_INTERNATIONAL_CHAIN:109003,
    UNIT_INTERNATIONAL_LINK:109004,
    UNIT_INTERNATIONAL_YARD:109001,
    UNIT_STATUTE_MILE:9093,
    UNIT_SURVEY_YARD:109002,
    UNIT_50KILOMETER_LENGTH:109030,
    UNIT_150KILOMETER_LENGTH:109031,
    UNIT_DECIMETER:109005,
    UNIT_CENTIMETER:109006,
    UNIT_MILLIMETER:109007,
    UNIT_INTERNATIONAL_INCH:109008,
    UNIT_US_SURVEY_INCH:109009,
    UNIT_INTERNATIONAL_ROD:109010,
    UNIT_US_SURVEY_ROD:109011,
    UNIT_US_NAUTICAL_MILE:109012,
    UNIT_UK_NAUTICAL_MILE:109013,
    UNIT_SQUARE_INCHES:"esriSquareInches",
    UNIT_SQUARE_FEET:"esriSquareFeet",
    UNIT_SQUARE_YARDS:"esriSquareYards",
    UNIT_ACRES:"esriAcres",
    UNIT_SQUARE_MILES:"esriSquareMiles",
    UNIT_SQUARE_MILLIMETERS:"esriSquareMillimeters",
    UNIT_SQUARE_CENTIMETERS:"esriSquareCentimeters",
    UNIT_SQUARE_DECIMETERS:"esriSquareDecimeters",
    UNIT_SQUARE_METERS:"esriSquareMeters",
    UNIT_ARES:"esriAres",
    UNIT_HECTARES:"esriHectares",
    UNIT_SQUARE_KILOMETERS:"esriSquareKilometers"
});
/**
 * Class: Geo.Analysis.LengthsParameters
 * GeometryService长度计算参数类。GeometryService类的lengths方法调用时需要使用本类。
 */
Geo.Analysis.LengthsParameters = Geo.Class({

	/**
     * APIProperty: calculationType
     * {String} 计算方式。可以为以下值：
     * "planar"：计算平面长度，仅在指定空间参考时使用，否则使用preserveShape方式；
     * "geodesic": 计算球面长度；
     * "preserveShape": 计算球面长度，保留形状；
     */		
    calculationType: null,

	/**
     * APIProperty: geodesic
     * {Boolean} 是否使用的是地理坐标系统。此属性在10.1版本中被废弃，请使用calculationType属性代替。
     */		
    geodesic: null,

	/**
     * APIProperty: lengthUnit
     * {Int} 长度单位。
     */		
    lengthUnit: null,

	/**
     * APIProperty: polylines
     * {Array<Geo.Geometry>} 需要被计算长度的折线几何对象。
     */		
    polylines: null,

    /**
     * APIProperty: inSr
     * {Int} 输入几何对象的空间参考编号，例如：4326。
     */
    inSr: 4326,

	/**
	 * Constructor: Geo.Analysis.LengthsParameters
	 * Geo.Analysis.LengthsParameters类构造函数。
	 *
	 * Parameters:
	 * params - 构造参数。
	 */
    initialize: function (params) {
        Geo.Util.extend(this,params);
    },

    toJson: function () {
        var jsonObj = {
            sr:this.inSr
        };

        var polylines = this.polylines;
        var geometriesObj = [];
        for (var i = 0; i < polylines.length; i++) {
            var polyline = Geo.Analysis.Util.geoGeometryToEsriObjMapping['polyline'](polylines[i]);
            geometriesObj.push(polyline);
        }
        var geometriesStr = new Geo.Format.JSON().write(geometriesObj);
        jsonObj.polylines = geometriesStr;

        if (this.lengthUnit) {
            jsonObj.lengthUnit = this.lengthUnit;
        }
        if (this.geodesic) {
            jsonObj.geodesic = this.geodesic;
        }
        if (this.calculationType) {
            jsonObj.calculationType = this.calculationType;
        }
        return jsonObj;
    }

});/**
 * Class: Geo.Analysis.OffsetParameters
 * GeometryService偏移操作参数类。GeometryService类的offset方法调用时需要使用本类。
 */
Geo.Analysis.OffsetParameters = Geo.Class(/** @lends Geo.Analysis.OffsetParameters.prototype */{

	/**
     * APIProperty: bevelRatio
     * {Number} 斜率。
     */	
    bevelRatio: null,

	/**
     * APIProperty: geometries
     * {Array<Geo.Geometry>} 求偏移的几何对象集。
     */	
    geometries: null,

	/**
     * APIProperty: offsetDistance
     * {Number} 偏移距离。
     */	
    offsetDistance: null,

	/**
     * APIProperty: offsetHow
     * {String} 如何结束相交。
     */	
    offsetHow: null,

	/**
     * APIProperty: offsetUnit
     * {Int} 偏移单位。
     */	
    offsetUnit: null,

	/**
     * APIProperty: inSR
     * {Int} 输入几何对象的空间参考编号，例如：4326。
     */	
    inSR: 4326,

	/**
	 * Constructor: Geo.Analysis.OffsetParameters
	 * Geo.Analysis.OffsetParameters类构造函数。
	 *
	 * Parameters:
	 * params - 构造参数。
	 */
    initialize: function (params) {
        Geo.Util.extend(this,params);
    },

    toJson: function () {

            var jsonObj = {
                sr: this.inSR
            };

            if (this.geometries && this.geometries.length > 0) {
                var geometries = Geo.Analysis.Util.geoGeometryAndTypeToEsriObj(this.geometries,this.inSR);
                var geometriesStr = new Geo.Format.JSON().write(geometries);
                jsonObj.geometries = geometriesStr
            }

            if (this.bevelRatio) {
                jsonObj.bevelRatio = this.bevelRatio;
            }

            if (this.offsetDistance) {
                jsonObj.offsetDistance = this.offsetDistance;
            }

            if (this.offsetHow) {
                jsonObj.offsetHow = this.offsetHow;
            }

            if (this.offsetUnit) {
                jsonObj.offsetUnit = this.offsetUnit;
            }

            return jsonObj;
    }

});

Geo.Analysis.OffsetParameters.OFFSET_BEVELLED = "esriGeometryOffsetBevelled";
Geo.Analysis.OffsetParameters.OFFSET_MITERED = "esriGeometryOffsetMitered";
Geo.Analysis.OffsetParameters.OFFSET_ROUNDED = "esriGeometryOffsetRounded";/**
 * Class: Geo.Analysis.ProjectParameters
 * GeometryService投影类型转换操作参数类。GeometryService类的project方法调用时需要使用本类。
 */
Geo.Analysis.ProjectParameters = Geo.Class({

	/**
     * APIProperty: geometries
     * {Array<Geo.Geometry>}  输入几何对象。
     */	
    geometries: null,

	/**
     * APIProperty: inSR
     * {Int} 输入几何对象的空间参考。
     */	
    inSR: null,

	/**
     * APIProperty: outSR
     * {String} 输出几何对象的空间参考。
     */	
    outSR: null,

	/**
     * APIProperty: transformation
     * {String} 投影转换参数。
     */	
    transformation: null,

	/**
     * APIProperty: transformationForward
     * {Boolean} 向前转换。
     */	
    transformationForward: null,

	/**
	 * Constructor: Geo.Analysis.ProjectParameters
	 * Geo.Analysis.ProjectParameters类构造函数。
	 *
	 * Parameters:
	 * params - 构造参数。
	 */
    initialize: function (params) {
        Geo.Util.extend(this,params);
    },

    toJson: function () {
        var obj = {};
        obj.outSR = this.outSR;
        obj.inSR = this.inSR;

        var geometries = Geo.Analysis.Util.geoGeometryAndTypeToEsriObj(this.geometries);
        var geometriesStr = new Geo.Format.JSON().write(geometries);
        obj.geometries = geometriesStr;//'{"geometryType":"esriGeometryPoint","geometries":[{"x":115,"y":35}]}';
        if (this.transformation) {
            obj.transformation = this.transformation;
        }
        if (this.transformForward !== undefined) {
            obj.transformForward = this.transformForward;
        }
        return obj;
    }

});/**
 * Class: Geo.Analysis.RelationParameters
 * 空间关系参数类。
 */
Geo.Analysis.RelationParameters = Geo.Class({

	/**
     * APIProperty: geometries1
     * {Array<Geo.Geometry>}  第1组几何对象。
     */		
    geometries1: null,

	/**
     * APIProperty: geometries2
     * {Array<Geo.Geometry>} 第2组几何对象。
     */		
    geometries2: null,

	/**
     * APIProperty: relation
     * {String} 指定的空间关系操作。
     */		
    relation: null,

	/**
     * APIProperty: relationParam
     * {String} 空间关系运算所需要的'Shape Comparison Language'字符串。
     */		
    relationParam: null,

    /**
     * APIProperty: inSr
     * {String} 输入几何对象的空间参考编号，例如：4326。
     */
    inSr: 4326,

	/**
	 * Constructor: Geo.Analysis.RelationParameters
	 * Geo.Analysis.RelationParameters类构造函数。
	 *
	 * Parameters:
	 * params - 构造参数。
	 */
    initialize: function (params) {
        Geo.Util.extend(this,params);
    },

    toJson: function () {
        var jsonObj = {
            sr:this.inSr
        };

        if(this.geometries1){
            var geometriesObj = Geo.Analysis.Util.geoGeometryAndTypeToEsriObj(this.geometries1);
            var geometriesString = new Geo.Format.JSON().write(geometriesObj);
            jsonObj.geometries1 = geometriesString;
        }

        if(this.geometries2){
            var geometriesObj = Geo.Analysis.Util.geoGeometryAndTypeToEsriObj(this.geometries2);
            var geometriesString = new Geo.Format.JSON().write(geometriesObj);
            jsonObj.geometries2 = geometriesString;
        }

        if(this.relation){
            jsonObj.relation = this.relation;
        }

        if(this.relationParam){
            jsonObj.relationParam = this.relationParam;
        }

        return jsonObj;
    }

});

Geo.Util.extend(Geo.Analysis.RelationParameters,{
    SPATIAL_REL_CROSS:"esriGeometryRelationCross",
    SPATIAL_REL_DISJOINT:"esriGeometryRelationDisjoint",
    SPATIAL_REL_IN:"esriGeometryRelationIn",
    SPATIAL_REL_INTERIORINTERSECTION:"esriGeometryRelationInteriorIntersection",
    SPATIAL_REL_INTERSECTION:"esriGeometryRelationIntersection",
    SPATIAL_REL_COINCIDENCE:"esriGeometryRelationLineCoincidence",
    SPATIAL_REL_LINETOUCH:"esriGeometryRelationLineTouch",
    SPATIAL_REL_OVERLAP:"esriGeometryRelationOverlap",
    SPATIAL_REL_POINTTOUCH:"esriGeometryRelationPointTouch",
    SPATIAL_REL_TOUCH:"esriGeometryRelationTouch",
    SPATIAL_REL_WITHIN:"esriGeometryRelationWithin",
    SPATIAL_REL_RELATION:"esriGeometryRelationRelation"
});/**
 * Class: Geo.Analysis.SuperposeAnalysis
 * 叠置分析类。
 */
Geo.Analysis.SuperposeAnalysis = Geo.Class({
	
	/**
     * APIProperty: url
     * {String} 叠置分析操作所需要的WPS服务地址。
     */	
	url: null,
	
	/**
     * APIProperty: type
     * {String} 叠置分析操作类型。
     */	
	type:"Intersection",

    //请求串模板
	_requestStringTemplate:
		'<wps:Execute service="WPS" version="1.0.0" xmlns:gml="http://www.opengis.net/gml" xmlns:wps="http://www.opengis.net/wps/1.0.0" xmlns:ows="http://www.opengis.net/ows/1.1" xmlns:wfs="http://www.opengis.net/wfs" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.opengis.net/wps/1.0.0 ../wpsExecute_request.xsd">'+
			'<ows:Identifier>${type}</ows:Identifier>'+
			'<wps:DataInputs>'+
				'<wps:Input>'+
					'<ows:Identifier>InputPolygon</ows:Identifier>'+
					'<wps:Data>'+
						'<wps:ComplexData schema="http://foo.bar/MyComplexValueSchema.xsd" mimeType="text/xml" encoding="UTF-8">'+
							'${dataInputs}'+
						'</wps:ComplexData>'+
					'</wps:Data>'+
				'</wps:Input>'+
			'</wps:DataInputs>'+
			'<wps:ResponseForm>'+
				'<wps:RawDataOutput>'+
					'<ows:Identifier>BufferedPolygon</ows:Identifier>'+
				'</wps:RawDataOutput>'+
			'</wps:ResponseForm>'+
		'</wps:Execute>',

	/**
     * APIProperty: sourceFeatures
     * {Array(<Geo.Feature.Vector>)}  叠置分析操作指定的源要素。
     */	
	sourceFeatures: null,

	/**
     * APIProperty: targetFeatures
     * {Array(<Geo.Feature.Vector>)}  叠置分析操作指定的目标要素。
     */	
	targetFeatures: null,
	
    /**
     * Constructor: Geo.Analysis.SuperposeAnalysis
     * Geo.Analysis.SuperposeAnalysis类构造函数。
     *
     * Parameters:
     * url - {String} WPS服务地址
     * options - {Object} 相关属性的设置项，可选
     */
	initialize: function(url,options){
		this.url = url;
		this.sourceFeatures = [];
		this.targetFeatures = [];
		OpenLayers.Util.extend(this, options);
	},
	
	//构造查询字串
	_buildRequestString: function(){
		var gmlParser = new OpenLayers.Format.GML();
        var sourceStr = gmlParser.write(this.sourceFeatures);
		var targetStr = gmlParser.write(this.targetFeatures);
		
		var string = OpenLayers.String.format(this._requestStringTemplate,{
            type: this.type,
			dataInputs: sourceStr + targetStr
		});
        return string;
	},
	
	/**
	 * APIMethod: startAnalysis
	 * 开始执行分析，如果服务端正确返回结果会触发successFn回调函数。
	 *
	 */
	startAnalysis: function(){
		
		//查询前做设置方面检查
		if(this._checkSet()){
			return false;
		}
		
		//发送分析请求
		var postStr = this._buildRequestString();
		var xhr = new OpenLayers.Request.POST({
			url: this.url,
			data: postStr,
			scope: this,
			success:function(result){
				if("" == result.responseText || null == result.responseText){
					this.failFn();
					return;
				}
                var features = this._parserResult(result);
                this.successFn(features);
            },
			failure:this.failFn
			
		});
	},
	
	//检查相关参数设置
	_checkSet: function(){
		if(!this.url){
			return false;
		}
		if(!this.sourceFeatures || !this.sourceFeatures.length){
			return false;
		}
		if(!this.targetFeatures || !this.targetFeatures.length){
			return false;
		}
	},
	
	/**
	 * APIMethod: successFn
	 * 分析操作成功的回调函数
	 *
	 * Parameters:
	 * features - {Array(<Geo.Feature.Vector>)} 结果要素数组
	 */	
	successFn:function(features){
		
	},

	/**
	 * APIMethod: failFn
	 * 叠置分析操作失败回调函数，默认提示"叠置分析操作失败，请检测服务是否正常运行。"，
	 * 用户可以使用自定义方法替代。
	 */		
	failFn:function(){
		alert("叠置分析操作失败，请检测服务是否正常运行。");
	},
	
	//解析结果
	_parserResult: function(result){
		var feature = [];
		var xmlParser = new OpenLayers.Format.XML();
		if(!result.responseXML){
			result.responseXML = xmlParser.read(result.responseText);
		}
		var gmlPrefix = "gml";
		var gmlUri = xmlParser.lookupNamespaceURI(result.responseXML, gmlPrefix);
		var featureCollection = xmlParser.getElementsByTagNameNS(result.responseXML, gmlUri, "FeatureCollection");
		if(featureCollection.length > 0){
			var gmlstr = xmlParser.write(featureCollection[0]);
			var gmlParser = new OpenLayers.Format.GML();		
			feature = gmlParser.read(gmlstr);
		}
		return feature;
	},				

	CLASS_NAME:"Geo.Analysis.SuperposeAnalysis"
	
});/**
 * Class: Geo.Analysis.TrimExtendParameters
 * GeometryService修剪与扩展操作参数类。
 */
Geo.Analysis.TrimExtendParameters = Geo.Class({

	/**
     * APIProperty: extendHow
     * {Int} 扩展操作标志。
     */	
    extendHow: null,

	/**
     * APIProperty: polylines
     * {Array<Geo.Geometry>} 被修剪或扩展的折线。
     */	
    polylines: null,

	/**
     * APIProperty: trimExtendTo
     * {Geo.Geometry} 修剪或扩展的参考折线。
     */	
    trimExtendTo: null,

    /**
     * APIProperty: inSr
     * {String} 输入几何对象的空间参考编号，例如：4326。
     */
    inSr: 4326,

	/**
	 * Constructor: Geo.Analysis.TrimExtendParameters
	 * Geo.Analysis.TrimExtendParameters类构造函数。
	 *
	 * Parameters:
	 * params - 构造参数。
	 */
    initialize: function (params) {
        Geo.Util.extend(this,params);
    },

    toJson: function () {
        var jsonObj = {
            sr:this.inSr
        };

        if (this.extendHow) {
            jsonObj.extendHow = this.extendHow;
        }

        if (this.polylines) {
            var geometries = [];
            for (var i = 0; i < this.polylines.length; i++) {
                var geo = Geo.Analysis.Util.geoGeometryToEsriObjMapping['polyline'](this.polylines[i]);
                geometries.push(geo);
            }
            var geometryStr = new Geo.Format.JSON().write(geometries);
            jsonObj.polylines = geometryStr;
        }

        if (this.trimExtendTo) {
            var trimExtendToGeometry = Geo.Analysis.Util.geoGeometryToEsriObjMapping['polyline'](this.trimExtendTo);
            var geometryStr = new Geo.Format.JSON().write(trimExtendToGeometry);
            jsonObj.trimExtendTo = geometryStr;
        }
        
        return jsonObj;
    }

});/**
 * Class: Geo.Analysis.Util
 * Geo.Analysis.Util名字空间，本名字空间下存放常用方法。
 */
Geo.Analysis.Util = {

    createSRByWkid:function(wkid){
        return {"wkid":wkid};
    },

    isFeaturesArray: function(features){
        if(Geo.Util.isArray(features) && features[0].CLASS_NAME == "OpenLayers.Feature.Vector"){
            return true;
        } else {
            return false;
        }
    },

    geoFeaturesToEsriFeatures:function(geoFeatures,sr){
        var featuresObj = null;
        if(geoFeatures && geoFeatures.length >= 1){
            var geometryType = geoFeatures[0].geometry.CLASS_NAME;
            featuresObj = {
                "geometryType": Geo.Analysis.Util.esriFullGeometryTypeMapping[geometryType],
                "features":[],
                "sr": Geo.Analysis.Util.createSRByWkid(sr)
            };
            
            for (var i = 0; i < geoFeatures.length; i++) {
                var geometry = geoFeatures[i].geometry;
                var featureObj = {
                    "geometry": Geo.Analysis.Util.geoGeometryToEsriObjMapping[
                                            Geo.Analysis.Util.geoGeometryToEsriMapping[geometryType]](geometry),
                    "spatialReference": Geo.Analysis.Util.createSRByWkid(sr)
                };
                featuresObj.features.push(featureObj);
            }
        }
        return featuresObj;

    },

    esriFeaturesToGeoFeatures: function(esriFeatures,geometryType){
        var fs = null;
        if(esriFeatures && Geo.Util.isArray(esriFeatures)){
            fs = [];
            for (var i = 0; i < esriFeatures.length; i++) {
                var f = esriFeatures[i],geometry,attributes;

                if(f.geometry){
                    geometry = Geo.Analysis.Util.esriObjToGeoGeometryMapping[geometryType](f.geometry);
                }
                if(f.attributes){
                    attributes = Geo.Util.extend({}, f.attributes);
                }
                var geoFeature = new Geo.Feature.Vector(geometry,attributes);
                fs.push(geoFeature);
            }
        }
        return fs;
    },

    geoFeaturesToEsriObj: function(features){
        var fs = null;
        if(features && Geo.Util.isArray(features)){
            fs = [];
            for (var i = 0; i < features.length; i++) {
                var f = features[i];
                var obj = {};
                if(f.geometry){
                    obj["geometry"] = Geo.Analysis.Util.geoGeometryToEsriObj(f.geometry);
                }
                if(f.attributes){
                    obj["attributes"] = Geo.Util.extend({}, f.attributes);
                }
                fs.push(obj);
            }
        }
        return fs;
    },

    esriObjToGeoGeometry: function(esriObj){

        if(esriObj && esriObj.geometries){
            var geoGeometries = [];
            for (var i = 0; i < esriObj.geometries.length; i++) {
                geoGeometries.push(Geo.Analysis.Util.esriObjToGeoGeometryMapping[esriObj.geometryType](esriObj.geometries[i]));
            }
            return geoGeometries;
        }

        if(esriObj && esriObj.geometry){
            return Geo.Analysis.Util.esriObjToGeoGeometryMapping[esriObj.geometryType](esriObj.geometry);
        }



    },

    geoGeometryToEsriObj: function(geoGeometry){
        var esriObj = null;
        if(geoGeometry && geoGeometry.CLASS_NAME){
            var classname = Geo.Analysis.Util.geoGeometryToEsriMapping[geoGeometry.CLASS_NAME];
            esriObj = Geo.Analysis.Util.geoGeometryToEsriObjMapping[classname](geoGeometry);
        }

        return esriObj;
    },

    esriFullGeometryTypeToGeoMapping: {
        "esriGeometryPoint": OpenLayers.Geometry.Point,
        "esriGeometryPolygon": OpenLayers.Geometry.Polygon
    },

    geoGeometryToEsriMapping: {
        "OpenLayers.Geometry.Point": "point",
        "OpenLayers.Geometry.LineString": "polyline",
        "OpenLayers.Geometry.MultiLineString": "polyline",
        "OpenLayers.Geometry.Polygon": "polygon"
    },

    esriFullGeometryTypeMapping: {
        "OpenLayers.Geometry.Point": "esriGeometryPoint",
        "OpenLayers.Geometry.Polygon": "esriGeometryPolygon",
        "OpenLayers.Geometry.LineString": "esriGeometryPolyline"
    },

    //todo:geoGeometriesToEsriObj未完成
    //创建几何对象或几何对象集的JS对象
    geoGeometryAndTypeToEsriObj: function(geometry,wkid){
        var geometryObj = {};
        //geometryObj["geometryType"] = "esriGeometryPolygon";
        //geometryObj["spatialReference"] = projection;//Geo.Analysis.Util.projection2ErsiObj(projection);

        if(wkid){
            geometryObj["spatialReference"] = {"wkid" : wkid};
        }
        if(Geo.Util.isArray(geometry)){
            var geoArr = [];
            for (var i = 0; i < geometry.length; i++) {
                geoArr.push(Geo.Analysis.Util.geoGeometryToEsriObj(geometry[i]));
            }
            geometryObj["geometryType"] = Geo.Analysis.Util.esriFullGeometryTypeMapping[geometry[0].CLASS_NAME];
            geometryObj["geometries"] = geoArr;


        }else{
            geometryObj["geometryType"] = Geo.Analysis.Util.esriFullGeometryTypeMapping[geometry.CLASS_NAME];
            geometryObj["geometry"] = Geo.Analysis.Util.geoGeometryToEsriObj(geometry);
        }

        return geometryObj;
    },
    
    //todo:esriObjToGeoGeometry参数检查完善
    esriObjToGeoGeometryMapping: {

        "point": function(agsPoint) {
            return new Geo.Geometry.Point(agsPoint.x, agsPoint.y);
        },

        "esriGeometryPoint": function(agsPoint) {
            return new Geo.Geometry.Point(agsPoint.x, agsPoint.y);
        },

        "coordinate": function(agsCoordinate) {
            return new Geo.Geometry.Point(agsCoordinate[0], agsCoordinate[1]);
        },

        "path": function(agsPointArray) {
            var olPoints = [];
            for(var i=0; i<agsPointArray.length; i++) {
                var olPoint = null;
                try {
                    olPoint = Geo.Analysis.Util.esriObjToGeoGeometryMapping['coordinate'](agsPointArray[i]);
                    olPoints.push(olPoint);
                } catch(e) {

                }
            }
            olLineString = new Geo.Geometry.LineString(olPoints);
            return olLineString;
        },

        "ring": function(agsPointArray) {
            // check if it is a closed ring, otherwise throws exception
            var beginPoint = agsPointArray[0];
            var endPoint = agsPointArray[agsPointArray.length-1];
            if(beginPoint[0] != endPoint[0] || beginPoint[1] != endPoint[1]) {
                //todo:几何对象非封闭环检查报错
            }

            var olLinearRing = null;
            var olLineString = null;
            try {
                olLineString = Geo.Analysis.Util.esriObjToGeoGeometryMapping['path'](agsPointArray);
            } catch(e) {
                OpenLayers.Console.error(e.toString());
                throw e;
            }
            olLinearRing = new Geo.Geometry.LinearRing(olLineString.components);
            return olLinearRing;
        },

        "polyline": function(agsPolyline) {
            var olMultiLineString = null;
            var paths = agsPolyline.paths;
            var lineStrings = [];
            for(var i=0; i<paths.length; i++) {
                try {
                    var lineString = Geo.Analysis.Util.esriObjToGeoGeometryMapping['path'](paths[i]);
                    lineStrings.push(lineString);
                } catch(e) {
                    OpenLayers.Console.error(e.toString());
                    throw e;
                }
            }
            olMultiLineString = new Geo.Geometry.MultiLineString(lineStrings);
            return olMultiLineString;
        },

        "esriGeometryPolyline": function(agsPolyline) {
            var olMultiLineString = null;
            var paths = agsPolyline.paths;
            var lineStrings = [];
            for(var i=0; i<paths.length; i++) {
                try {
                    var lineString = Geo.Analysis.Util.esriObjToGeoGeometryMapping['path'](paths[i]);
                    lineStrings.push(lineString);
                } catch(e) {
                    OpenLayers.Console.error(e.toString());
                    throw e;
                }
            }
            olMultiLineString = new Geo.Geometry.MultiLineString(lineStrings);
            return olMultiLineString;
        },

        "polygon": function(agsPolygon) {
            var olPolygon = null;
            var rings = agsPolygon.rings;
            var linearRings = [];
            for(var i=0; i<rings.length; i++) {
                try {
                    var linearRing = Geo.Analysis.Util.esriObjToGeoGeometryMapping['ring'](rings[i]);
                    linearRings.push(linearRing);
                } catch(e) {
                    OpenLayers.Console.error(e.toString());
                    throw e;
                }
            }
            olPolygon = new Geo.Geometry.Polygon(linearRings);
            return olPolygon;
        },

        "esriGeometryPolygon": function(agsPolygon) {
            var olPolygon = null;
            var rings = agsPolygon.rings;
            var linearRings = [];
            for(var i=0; i<rings.length; i++) {
                try {
                    var linearRing = Geo.Analysis.Util.esriObjToGeoGeometryMapping['ring'](rings[i]);
                    linearRings.push(linearRing);
                } catch(e) {
                    OpenLayers.Console.error(e.toString());
                    throw e;
                }
            }
            olPolygon = new Geo.Geometry.Polygon(linearRings);
            return olPolygon;
        },

        "multipoint": function(agsMultipoint) {
            var olPoints = [];
            var agsPoints = agsMultipoint.points;
            for(var i=0; i<agsPoints.length; i++) {
                try {
                    var olPoint = Geo.Analysis.Util.esriObjToGeoGeometryMapping['coordinate'](agsPoints[i]);
                    olPoints.push(olPoint);
                } catch(e) {
                    OpenLayers.Console.error(e.toString());
                    throw e;
                }
            }
            return olPoints;
        },

        "extent": function(agsExtent) {
            return new Geo.Bounds(agsExtent.xmin, agsExtent.ymin, agsExtent.xmax, agsExtent.ymax);
        }
    },

    geoGeometryToEsriObjMapping: {
        'point': function(point) {
            return {
                x: point.x,
                y: point.y
            };
        },

        'coordinate': function(point) {
            return [point.x,point.y];
        },

        'path': function(olLineString) {
            var agsPath = [];
            for(var i=0; i<olLineString.components.length; i++) {
                var olPoint = olLineString.components[i];
                var agsCoordinate = Geo.Analysis.Util.geoGeometryToEsriObjMapping['coordinate'](olPoint);
                agsPath.push(agsCoordinate);
            }
            return agsPath;
        },

        'linearring': function(olLinearRing) {
            var agsRing = [];
            for(var i=0; i<olLinearRing.components.length; i++) {
                var olPoint = olLinearRing.components[i];
                var agsCoordinate = Geo.Analysis.Util.geoGeometryToEsriObjMapping['coordinate'](olPoint);
                agsRing.push(agsCoordinate);
            }
            return agsRing;
        },

            //todo:Geo.Analysis.Util.geoGeometryToEsriObj['polyline']方法待整理
        'polyline': function(olLineString) {

            var agsPolyline = {paths:[]};

            if(olLineString instanceof Geo.Geometry.LineString){
                var path = Geo.Analysis.Util.geoGeometryToEsriObjMapping['path'](olLineString);
                agsPolyline.paths.push(path);
            }

            if(olLineString instanceof Geo.Geometry.MultiLineString){
                for(var i=0; i<olLineString.components.length; i++) {
                    var olLineString2 = olLineString.components[i];
                    var path = Geo.Analysis.Util.geoGeometryToEsriObjMapping['path'](olLineString2);
                    agsPolyline.paths.push(path);
                }
            }
            return agsPolyline;
        },

        'polygon': function(olPolygon) {

            var agsPolygon = {
                rings:[]
            };

            for(var i=0; i<olPolygon.components.length; i++) {
                var olLinearRing = olPolygon.components[i];
                var agsRing = Geo.Analysis.Util.geoGeometryToEsriObjMapping['linearring'](olLinearRing);
                agsPolygon.rings.push(agsRing);
            }
            return agsPolygon;
        },

        'extent': function(olBounds) {
            return {
                xmin: olBounds.left,
                ymin: olBounds.bottom,
                xmax: olBounds.right,
                ymax: olBounds.top
            };
        }
    },



    //根据Geo.Projection对象或编号生成ErsiSpatialReference格式的对象
    projection2ErsiObj: function(projection){
        var projCode;
        //if(typeof projection !== "string"){
        //    projCode = projection.projCode;
        //} else {
            projCode = projection
        //}
        return {
            "wkid": projCode
        };
    },

    //附加Esri空间参考到Esri几何对象上
    appendProjectionToEsriGeometry: function(geometry,projection){
        var projectionObj = Geo.Analysis.Util.projection2ErsiObj(projection);
        return Geo.Util.extend(geometry,projectionObj);
    },

    //附加类型到Esri几何对象上
    appendTypeToEsriGeometrys: function(geometrys,projection){
        var projectionObj = Geo.Analysis.Util.projection2ErsiObj(projection);
        if(Geo.Util.isArray(geometrys)){
            return Geo.Util.extend(geometry,projectionObj);
        }

    },

    /*//根据Geo.Geometry对象Ersi格式的几何对象
    geoGeometryToEsriObj:{

        "Point": function(point){
            return {
                x: point.x,
                y: point.y
            };
        },

        //todo:Geo.Geometry.Multipoint转成EsriObj
        "Multipoint": function(multipoint){
            var points = [];
            return {
                points: points
            };
        },

        //todo:Geo.Geometry.LineString转成EsriObj
        "LineString": function(lineString){
        },

        //todo:Geo.Geometry.Polygon转成EsriObj
        "Polygon": function(polygon){
            var rings = [];
            var geoLinearRings = polygon.components;
            for (var i = 0; i < geoLinearRings.length; i++) {
                var geoPoints = geoLinearRings[i].components;
                var points = [];
                for (var j = 0; j < geoPoints.length; j++) {
                    var geoPoint = geoPoints[j];
                    points.push([geoPoint.x, geoPoint.y]);
                }
                rings.push(points);
            }
            return {
                rings:rings
            };
        }
    },*/

    sendRequest: function(options){

        var url = options.url,
            params = options.params,
            callback = options.callback,
            errback = options.errback;
        
        var defaultParams = {
            f:"json"
        };

        function _successHandler(result){
            var parser = new Geo.Format.JSON();
            var resultJson = parser.read(result.responseText);//
            if(callback){
                callback(resultJson);
            }
        }

        /*var request = Geo.Request.GET({
            url:url,
            params:Geo.Util.applyDefaults(params,defaultParams),
            success:_successHandler, failure:errback
        });*/

        params = Geo.Util.applyDefaults(params,defaultParams);
        var postContent = Geo.Util.getParameterString(params);

        var request = new Geo.Request.POST({
            url: url,
            success: _successHandler,
            failure: errback,
            data:postContent,
            headers: {
                "Content-Type": "application/x-www-form-urlencoded"
            }
        });

        return request;
    }


};/**
 * Class: Geo.Query.WFSQuery
 * WFS地图要素服务查询类。本类也适用于聚合网络要素服务（Aggregation Web Feature Service简称AWFS）和地名地址要素服务（Web Feature Service Gazetteer简称WFS-G）的查询。
 */
Geo.Query.WFSQuery = Geo.Class({
	
    /**
     * APIProperty: url
     * {String} WFS服务地址。
     */
	url: null,
	
    /**
     * APIProperty: featureType
     * {String} 要素类型。
     */	
	featureType: "",
	
    /**
     * APIProperty: maxFeatures
     * {Number} 最大结果数。
     */	
	maxFeatures: 10,
	
    /**
     * APIProperty: filter
     * {<Geo.Filter>} 查询条件。
     */
	filter: null,
    
    /**
     * APIProperty: geometryName
     * {String} 要素中geometry属性的名称，默认为"the_geom"。
     */
    geometryName: "the_geom",	


    /**
     * APIProperty: protocol
     * {<Geo.Protocol>} WFS查询协议对象。
     */	
	protocol: null,

    /**
     * APIProperty: format
     * {<Geo.Format>} 用于对查询操作返回结果进行解析的格式解析器，默认为GML解析器。
     */
	format: null,
    
    /**
     * APIProperty: format
     * {<Geo.Format>} 格式解析器构造参数。
     */    
    formatOptions: null,
    
    /**
     * APIProperty: isSeparate
     * {Boolean} 设置是否将查询结果按图层名分类。
     */  
    isSeparate: false,
	
	/**
	 * APIProperty: sortBy
	 * {Array} 设置WFS查询结果的排序参数，该参数为一个数组对象。
	 * 
	 * 说明：
	 * 1.wfsg和wfs服务都支持排序；如果wfsg服务中的Post请求串中没有sort节点，那么该服务就不进行排序了（此时用其他字段排序也不起作用了）。当服务在查询中
	 * 有sort节点的时候， 建议用户选择STANDARDNAME和sort字段之一进行排序。如果使用DoMainName作为查询关键字，也可以使用DoMainName进行作为排序字段。
	 * 
	 * 2.wfsg服务和wfs服务默认是以sort字段进行排序，sort字段的值是数字，如果用户以sort字段进行排序，那么sort字段的值（数字）越大，
	 * 在结果列表中越排在后面，相反，sort字段的值越小，则在结果列表中排在越前面，如果sort字段的值相同，则按照其在数据库中读出来的先后顺序排列，
	 * 如果sort字段没值，则排在结果的最后面
	 * 
	 * 3.若是以STANDARDNAME作为排序字段，如果STANDARDNAME的值是中文，那么排序就是第一个汉字的拼音的首字母的先后顺序作为排序字段（如北京和安徽，
	 * 北京是b为拼音首字母，安徽是a为拼音首字母，那么就是安徽排在北京的前面），若值的第一个汉字拼音首字母相同，则是以第一个汉字拼音的第二个字
	 * 母的先后顺序排列；如果STANDARDNAME的值是英文，也一样，依次类推。
	 * 
	 * 例如:
	 * (code)
	 *		 wfsQueryObj.sortBy = [{
     *              property: "STANDARDNAME",
     *              order: "DESC"
     *          }]
	 * (end)
	 * 
     * sortBy数组内对象所包含的属性:
     * property - {String} 查询出的要素的某一属性的名称，根据该属性进行排序。
     * order - {String} 设置正序("ASC")或倒序("DESC")。
	 */
	sortBy: null,


	/**
	 * Constructor: Geo.Query.WFSQuery
	 * Geo.Query.WFSQuery类构造函数。
	 * 
	 * Parameters:
	 * url - {String} WFS服务地址。
	 * featureType - {String} 要素类型。
	 * options - {Object} 相关属性的设置项，可选。
	 */	
	initialize: function(url,featureType,options){
		this.url = url;
		this.featureType = featureType;
		this.format = new OpenLayers.Format.GML();
		OpenLayers.Util.extend(this, options);
	},

	/**
	 * APIMethod: query
	 * 开始查询。
	 * 
	 * Parameters:
	 * filter - {Geo.Filter} 过滤器。
	 * successFn - {Function} 请求成功的回调函数。
	 * 		该回调函数会提供一个形参，该形参是一个数组，名为features,在地名查询2.0及其以上的版本中，features有一个属性叫trueNames，
	 * 该属性用于存放纠错词信息。在地名查询2.0以下的版本中不提供trueNames属性。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
	 * 例如:
	 * (code)
	 *  	//查询范围
	 *		var queryBBOX = new Geo.Bounds(-180,-90,180,90);
	 *		 //范围过滤
	 *		 var filter = new Geo.Filter.Spatial({
	 *           type: Geo.Filter.Spatial.BBOX,
	 *           property: this.geometryName,            
	 *		    value: queryBBOX
	 *       });
	 *	
	 *		 wfsQueryObj.query(filter,successFn,failFn);
	 * (end)
	 */
	query: function(filter,successFn,failFn){
		
		this.protocol = new OpenLayers.Protocol.WFS({
			readFormat: this.format,
            formatOptions: this.formatOptions,
			propertyNames: this.propertyNames,
			maxFeatures: this.maxFeatures,
            url: this.url,
			geometryName : this.geometryName,
            featureType: this.featureType
        });
		
        //兼容老接口，如果未指定成功或失败回调函数，则使用successFn或failFn属性
        var queryFilter = filter || this.filter;
        var querySuccessFn = successFn || this.successFn;
        var queryFailFn = failFn || this.failFn;
        
		var callback = OpenLayers.Function.bind(function(result){
				
			//显示查询失败信息
			if(!result.success()){
				queryFailFn();
				return;
			}

			var features = result.features
            
            //根据要求进行按图层名分捡要素
            if(this.isSeparate){
                features = this._separateFeatures(features);
            }
            //对于容错给予提示的节点
            var trueNames = this._read_trueName(result);
			trueNames ? (features.trueNames = trueNames) : features;
			querySuccessFn(features);
			
		},this);

		this.response = this.protocol.read({
			sortBy: this.sortBy,
			filter: queryFilter,
			callback: callback
		});
	},
    
	//读取容错提示节点
	_read_trueName: function(result) {
		var trueNames = [];
		if(result.priv && result.priv.responseText) {
			var trueNameDocs = this.format.getXMLDoc().getElementsByTagName("trueName");
			if (trueNameDocs == null || trueNameDocs.length == 0) {
                return null;
            }
			for(var i = 0; i < trueNameDocs.length; i++) {
				trueNames.push(trueNameDocs[i].text);
			}
			return trueNames;
		}
		return trueNames;
	},
	
	/**
	 * APIMethod: getBufferRegion
	 * 得到缓冲区域。
	 * 
	 * Parameters:
     * point - {<Geo.Feature.Vector>} 点要素。
     * distance - {Integer} 半径。
     * unit - {String} 缓冲单位。
     * 
	 * Returns:
     * {<Geo.Geometry.Polygon>} 几何多边形。
	 */
	getBufferRegion: function(point,distance,unit) {
		var lonlat = this._getFeaturesCenter(point);
		switch(unit){
			case "km":
				distance = 1000 * distance;
			case "m":
				distance = this._meterToDegree(distance,lonlat);				
		}
		return Geo.Geometry.Polygon.createRegularPolygon(point,distance,40,360); 
	},
	
    /**
     * Method: _getFeaturesCenter
     * 获取所有要素范围之合的中心点。
     * 
     * Parameters:
     * features - 要执行缓冲分析的要素。
     * 
     * Returns:
     * {<Geo.LonLat>} 中心点的坐标。
     */
	_getFeaturesCenter: function(features){		
		var bounds = this._getFeaturesExtent(features);
		return bounds.getCenterLonLat();
	},
	
	/**
	 * Method: _getFeaturesExtent
	 * 获取要素数组范围之合。
	 *
	 * Parameters:
	 * features - 要查看的要素数组
	 * 
	 * Returns:
	 * {<Geo.Bounds>} 要素数组的总的范围。
	 */
	_getFeaturesExtent: function (features) {
        if(!(features instanceof Array)){
			features = [features];
		}
        var maxExtent = null;
        if(features && (features.length > 0)) {
            maxExtent = new Geo.Bounds();
            var geometry = null;
            for(var i=0, len=features.length; i<len; i++) {
                geometry = features[i].geometry;
                if (geometry) {
                    maxExtent.extend(geometry.getBounds());
                }
            }
        }
        return maxExtent;
    },
	
	/**
	 * Method: _meterToDegree
	 * 根据地理坐标位置，将米转换成经纬度。
	 *
	 * Parameters:
	 * meter - 要转换的地理坐标。
	 * lonlat - 经纬度。
	 */
	_meterToDegree: function(meter,lonlat){
		var a = 0.00000899; //赤道上的距离1公里=0.000008993220293度
		var templat = lonlat.lat;
		return meter * ( a / Math.cos(OpenLayers.Util.rad(templat)) );
	},
	
	/**
	 * APIMethod: pointQuery
	 * 点查询。
	 * 
	 * Parameters:
	 * point - {<Geo.Geometry.Point>} 点要素。
	 * distance - {Number} 缓冲半径。它是指指定线的距离范围。服务利用这个属性可以对线进行缓冲区分析得到一个面，再用面去进行查询。
 	 *		distance的取值范围：大于等于零。
	 * 		例如：如果距离是5，单位是米，那么服务内部会将这个线以5米为半径对其进行缓冲区分析得到成一个面，再使用面做查询。
	 * unit - {String} 单位  值为"m"或degree。
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
	 * 例如:
	 * (code)
	 *   //距离
	 *	 var distance = 50000000;
	 *	 //单位
     *	 var unit = "m";
	 *   //点要素
	 *	 var queryPoint = new Geo.Geometry.Point(110.40056,39.93202);
	 *   wfsQueryObj.pointQuery(queryPoint,distance,unit,successFn,failFn);
	 * (end)
	 */
    pointQuery: function(point,distance,unit,successFn,failFn){
        distance = distance || 0;
        unit = unit || "degree";
        var filter = new OpenLayers.Filter.Spatial({
            type:OpenLayers.Filter.Spatial.DWITHIN,
            property: this.geometryName, 
            distance: distance,
            distanceUnits: unit,
            value: point
        });
        this.query(filter,successFn,failFn);
    },
    
    /**
	 * APIMethod: pathQuery
	 * 线查询。
	 * 
	 * Parameters:
	 * path - {<Geo.Geometry.LineString>} 线要素。
	 * distance - {Number}缓冲半径。它是指指定线的距离范围。服务利用这个属性可以对线进行缓冲区分析得到一个面，再用面去进行查询。
 	 *		distance的取值范围：大于等于零。
	 * 		例如：如果距离是5，单位是米，那么服务内部会将这个线以5米为半径对其进行缓冲区分析得到成一个面，再使用面做查询。
	 * unit - {String} 单位  值为"m"或degree。
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 例如:
     * (code)
     *   //距离
	 *	 var distance = 50000000;
	 *	 //单位
     *	 var unit = "m";
     *   //线要素
	 *	 var queryPath = new Geo.Geometry.LineString([
     *         new Geo.Geometry.Point(110,35),
     *         new Geo.Geometry.Point(110,36)
     *    ]);
     * 	 wfsQueryObj.pathQuery(queryPath, distance, unit, successFn,failFn);
     * (end)
	 * 
	 */
    pathQuery: function(path,distance,unit,successFn,failFn){
        distance = distance || 0;
        unit = unit || "degree";
        var filter = new OpenLayers.Filter.Spatial({
            type:OpenLayers.Filter.Spatial.DWITHIN,
            property: this.geometryName, 
            distance: distance,
            distanceUnits: unit,
            value: path
        });
        this.query(filter,successFn,failFn);
    },
    
    /**
	 * APIMethod: polygonQuery
	 * 面查询。
	 * 
	 * Parameters:
	 * polygon - {<Geo.Geometry.Polygon>} 面要素。
	 * isContain - {Boolean} 是包含还是相交。
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 例如:
     * (code)
     * 	 var isContain = false;
	 *	 var queryPolygon = new Geo.Geometry.Polygon([
     *   	 new Geo.Geometry.LinearRing([
     *       new Geo.Geometry.Point(77.76672363281,37.655639648436),
     *       new Geo.Geometry.Point(77.8884299300619,38.21858951787163),
     *       new Geo.Geometry.Point(77.8884299300619,38.21858951787163),
     *       new Geo.Geometry.Point(77.8884299300619,38.21858951787163)
     *       ])                
     *   ]);
     * 	 wfsQueryObj.polygonQuery(queryPolygon, isContain, successFn,failFn);
     * (end)
	 */
    polygonQuery: function(polygon,isContain,successFn,failFn){
        var filterType = isContain ? OpenLayers.Filter.Spatial.CONTAINS : 
                                     OpenLayers.Filter.Spatial.INTERSECTS;
        var filter = new OpenLayers.Filter.Spatial({
            type: filterType,
            property: this.geometryName, 
            value: polygon
        });
        this.query(filter,successFn,failFn);
    },
    
    /**
	 * APIMethod: bboxQuery
	 * 范围查询。
	 * 
	 * Parameters:
	 * bbox - {<Geo.Bounds>} 范围。
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
	 * 例如:
	 * (code)
	 *   //查询范围
		 var queryBBOX = new Geo.Bounds(-180,-90,180,90);
	 * 	 wfsQueryObj.bboxQuery(queryBBOX, successFn,failFn);
	 * (end)
	 */
    bboxQuery: function(bbox,successFn,failFn){
        var filter = new Geo.Filter.Spatial({
            type: OpenLayers.Filter.Spatial.BBOX,
            property: this.geometryName,            
		    value: bbox
        });
        this.query(filter,successFn,failFn);
    },
    
	/**
	 * APIMethod: attributeQuery
	 * 属性查询。
	 * 
	 * Parameters:
	 * type - {String} 比较类型。
	 * property - {String} 属性名。
	 * value - {Number} or {String} 属性值。
	 * options - {Object} 可选参数。
	 *    lowerBoundary - {Number} or {String} 值小的边界。
	 *    upperBoundary - {Number} or {String} 值大的边界。
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 例如:
     * (code)
     *   var type = Geo.Filter.Comparison.LIKE;
	 *		var property = "label";
	 *		var value = "*";
	 *		wfsQueryObj.attributeQuery(type,property,value,{
	 *			matchCase : true
	 *	 },successFn,failFn);
     * (end)
	 * 
	 */
    attributeQuery: function(type, property, value, options, successFn,failFn){
        
        var matchCase = options && options.matchCase;
        var lowerBoundary = options ? options.lowerBoundary : null;
        var upperBoundary = options ? options.upperBoundary : null;
        
        var filter = new OpenLayers.Filter.Comparison({
            type: type,
            property: property,            
		    value: value,
            matchCase: matchCase,
            lowerBoundary: lowerBoundary,
            upperBoundary: upperBoundary
        });
        this.query(filter,successFn,failFn);
    },

    /**
     * APIProperty: successFn
     * 查询成功后的回调函数，用户可以自定义此方法。
	 *
	 * Parameters:
	 * features - {Array(<Geo.Feature.Vector>)} 结果要素数组。
     */
	successFn: function(features){
        
    },

    /**
     * APIMethod: failFn
     * WFS查询失败响应方法，默认提示"对不起,查询失败,请查询服务是否正常"，用户可以根据需要覆盖此方法。
     */    
    failFn: function(){
    	alert("对不起,查询失败,请查询服务是否正常。");
    },
    
    //私有,按图层类型分离要素
    _separateFeatures: function(features){
        var result = {};
        for(var i=0; i<features.length; i++){
            var f = features[i];
            var featureType;
            
            //如果是经GML2解析器则判断gml属性中的featureType，如果是GML3则判断type
            if (f.gml) {
                featureType = f.gml.featureType;
            }
            else {
                featureType = f.type;
            }
            
            if(!result[featureType]){
                result[featureType] = [];
            }
            result[featureType].push(f);
        }
        return result;
    },
    	
	CLASS_NAME: "Geo.Query.WFSQuery"
});
/*
 * ===================================================
 * WFS查询服务端分页所需类定义
 * ===================================================
 */
OpenLayers.Format.Filter.v1.prototype.writers["ogc"]["SortBy"] = function(sortProperties) {
	var node = this.createElementNSPlus("ogc:SortBy");
	for (var i=0,l=sortProperties.length;i<l;i++) {
	    this.writeNode(
	        "ogc:SortProperty",
	        sortProperties[i],
	        node
	    );
	}
	return node;
},
/*
 * ===================================================
 * 注意，以下是对Format/WFST/v1.js文件的修改
 * 增加：
 * resultType: options && options.resultType,
 * startPosition: options && options.startPosition,
 * ===================================================
 */

OpenLayers.Format.WFST.v1.prototype.writers.wfs.GetFeature = function(options) {
    var node = this.createElementNSPlus("wfs:GetFeature", {
        attributes: {
            service: "WFS",
            version: this.version,
            outputFormat: options && options.outputFormat,
            resultType: options && options.resultType,
            startPosition: options && options.startPosition,
            maxFeatures: options && options.maxFeatures,
            "xsi:schemaLocation": this.schemaLocationAttr(options)
        }
    });
    if (typeof this.featureType == "string") {
        this.writeNode("Query", options, node);
    } else {
        for (var i=0,len = this.featureType.length; i<len; i++) { 
            options.featureType = this.featureType[i]; 
            this.writeNode("Query", options, node); 
        } 
    }
    return node;
}
OpenLayers.Format.Filter.v1.prototype.writers["ogc"]["SortProperty"] = function(sortProperty) {
	var node = this.createElementNSPlus("ogc:SortProperty");
	this.writeNode(
	    "ogc:PropertyName",
	    sortProperty,
	    node
	);
	this.writeNode(
	    "ogc:SortOrder",
	    (sortProperty.order == 'DESC') ? 'DESC' : 'ASC',
	    node
	);
	return node;
},

OpenLayers.Format.Filter.v1.prototype.writers["ogc"]["SortOrder"] = function(value) {
    var node = this.createElementNSPlus("ogc:SortOrder", {
        value: value
    });
    return node;
},

//查询服务出错时给出错误提示
OpenLayers.Protocol.WFS.v1.prototype.parseResponse  = function(request, options) {
    var doc = request.responseXML;
        if(!doc || !doc.documentElement) {
            doc = request.responseText;
        }
        if(!doc || doc.length <= 0) {
            return null;
        }
        var result=null;
        try{
        	result = (this.readFormat !== null) ? this.readFormat.read(doc) : 
            this.format.read(doc, options);
        }catch(e){
        	var error = "程序运行异常："+e.name + "，"+e.message;
        	alert(error);
//        	throw e;
        }
        if (!this.featureNS) {
            var format = this.readFormat || this.format;
            this.featureNS = format.featureNS;
            // no need to auto-configure again on subsequent reads
            format.autoConfig = false;
            if (!this.geometryName) {
                this.setGeometryName(format.geometryName);
            }
        }
        return result;
},

OpenLayers.Format.WFST.v1_0_0.prototype.writers = {
    "wfs": OpenLayers.Util.applyDefaults({
        "Query": function(options) {
            options = OpenLayers.Util.extend({
                featureNS: this.featureNS,
                featurePrefix: this.featurePrefix,
                featureType: this.featureType,
                srsName: this.srsName,
                srsNameInQuery: this.srsNameInQuery
            }, options);
            var node = this.createElementNSPlus("wfs:Query", {
                attributes: {
                    typeName: (options.featureNS ? options.featurePrefix + ":" : "") +
                        options.featureType
                }
            });
            if(options.srsNameInQuery && options.srsName) {
                node.setAttribute("srsName", options.srsName);
            }
            if(options.featureNS) {
                node.setAttribute("xmlns:" + options.featurePrefix, options.featureNS);
            }
            if(options.propertyNames) {
                for(var i=0,len = options.propertyNames.length; i<len; i++) {
                    this.writeNode(
                        "ogc:PropertyName", 
                        {property: options.propertyNames[i]},
                        node
                    );
                }
            }
            if(options.filter) {
                this.setFilterProperty(options.filter);
                this.writeNode("ogc:Filter", options.filter, node);
            }
            if (options.sortBy) {
                this.writeNode("ogc:SortBy", options.sortBy, node);
            }
            return node;
        }
    }, OpenLayers.Format.WFST.v1.prototype.writers["wfs"]),
    "gml": OpenLayers.Format.GML.v2.prototype.writers["gml"],
    "feature": OpenLayers.Format.GML.v2.prototype.writers["feature"],
    "ogc": OpenLayers.Format.Filter.v1_0_0.prototype.writers["ogc"]
},

Geo.Query.WFSQuery.prototype.sortBy =  null,

//wfs查询
Geo.Query.WFSQuery.prototype.query = function(filter,successFn,failFn){
	
	this.protocol = new OpenLayers.Protocol.WFS({
		readFormat: this.format,
        formatOptions: this.formatOptions,
		propertyNames: this.propertyNames,
		maxFeatures: this.maxFeatures,
        url: this.url,
		geometryName : this.geometryName,
        featureType: this.featureType
    });
	
    //兼容老接口，如果未指定成功或失败回调函数，则使用successFn或failFn属性
    var queryFilter = filter || this.filter;
    var querySuccessFn = successFn || this.successFn;
    var queryFailFn = failFn || this.failFn;
    
	var callback = OpenLayers.Function.bind(function(result){
			
		//显示查询失败信息
		if(!result.success()){
			queryFailFn();
			return;
		}

		var features = result.features
        
        //根据要求进行按图层名分捡要素
        if(this.isSeparate){
            features = this._separateFeatures(features);
        }
        //对于容错给予提示的节点
        var trueNames = this._read_trueName(result);
		features.trueNames = trueNames;
		querySuccessFn(features);
		
	},this);

	this.response = this.protocol.read({
		sortBy: this.sortBy,
		filter: queryFilter,
		callback: callback
	});
},


OpenLayers.Format.WFSHits = OpenLayers.Class(OpenLayers.Format.XML,{

  wfsns: "http://www.opengis.net/wfs",

  featureCollection: "FeatureCollection",

  read:function(data){
    if(typeof data == "string") { 
        data = OpenLayers.Format.XML.prototype.read.apply(this, [data]);
    }
    var featureCollectionNodes = data.documentElement;
    var numberOfFeatures = parseInt(featureCollectionNodes.getAttribute("numberOfFeatures"));
    return {numberOfFeatures:numberOfFeatures}
  }
});


Geo.Query.WFSQuery.prototype.resultType = "Results";

Geo.Query.WFSQuery.prototype.startPosition = null;

//查询总数据的总条数
Geo.Query.WFSQuery.prototype.queryTotalNumber = function(filter,successFn,failFn){

        var hitsParser = new OpenLayers.Format.WFSHits();

		this.protocol = new OpenLayers.Protocol.WFS({
			readFormat: hitsParser,
			propertyNames: this.propertyNames,
            resultType: "hits",
			maxFeatures: this.maxFeatures,
            url: this.url,
			geometryName : this.geometryName,
            featureType: this.featureType
        });
		
        //兼容老接口，如果未指定成功或失败回调函数，则使用successFn或failFn属性
        var queryFilter = filter || this.filter;
        var querySuccessFn = successFn || this.successFn;
        var queryFailFn = failFn || this.failFn;
        
		var callback = OpenLayers.Function.bind(function(result){
				
			//显示查询失败信息
			if(!result.success()){
				queryFailFn();
				return;
			}

			var hitsResult = result.features
            
			querySuccessFn(hitsResult);
			
		},this);

		this.response = this.protocol.read({
			filter: queryFilter,
			callback: callback
		});

};

/*
 * 查询当前页的内容
 */
Geo.Query.WFSQuery.prototype.queryPage = function(filter, successFn, failFn, options){
    var perPageNumber = (options && options.perPageNumber) || 15,
        pageNumber = (options && options.pageNumber) || 1;
    
    var startPosition = (pageNumber - 1) * perPageNumber + 1;

	this.protocol = new OpenLayers.Protocol.WFS({
		readFormat: this.format,
        formatOptions: this.formatOptions,
		propertyNames: this.propertyNames,
        maxFeatures: perPageNumber,
        startPosition: startPosition,
        url: this.url,
		geometryName : this.geometryName,
        featureType: this.featureType
    });
	
    //兼容老接口，如果未指定成功或失败回调函数，则使用successFn或failFn属性
    var queryFilter = filter || this.filter;
    var querySuccessFn = successFn || this.successFn;
    var queryFailFn = failFn || this.failFn;
    
	var callback = OpenLayers.Function.bind(function(result){
			
		//显示查询失败信息
		if(!result.success()){
			queryFailFn();
			return;
		}

		var features = result.features
        
        //根据要求进行按图层名分捡要素
        if(this.isSeparate){
            features = this._separateFeatures(features);
        }
        //对于容错给予提示的节点
        var trueNames = this._read_trueName(result);
		features.trueNames = trueNames;
		querySuccessFn(features);
		
	},this);

	this.response = this.protocol.read({
		sortBy:this.sortBy,
//		maxFeatures: this.maxFeatures,
		filter: queryFilter,
		callback: callback
	});
}

/**
 * Class: Geo.Query.CatalogQuery
 * CSW资源目录服务查询类。
 * 
 */
Geo.Query.CatalogQuery = Geo.Class({
	
	/**
     * APIProperty: url
     * {String} CSW服务地址。
     */
	url: null,
	
	/**
     * APIProperty: failFn
     * {Function} 请求失败的回调函数，可以用自定义函数覆盖。
     */
	failFn: function(){
		alert("对不起，查询请求失败！请检查资源目录服务是否正常运行。\n" + 
				"当前服务地址为：" + this.url);
	},
	
	/**
     * Constructor: Geo.Query.CatalogQuery
     * Geo.Query.CatalogQuery类的构造函数。
     *
     * Parameters:
     * url - {String} CSW服务地址。
     * options - {Object} 相关属性的设置项，可选。
     *
     */
	initialize: function(url, options){
		this.url = url;
		OpenLayers.Util.extend(this,options);
	},
	
	//soap格式请求串模板
	_soapTemplate: 
		'<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xsi:schemaLocation="http://www.opengis.net/ows" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">' +
		   '<soapenv:Body>' +
		      '${soapBody}' +
		   '</soapenv:Body>' +
		'</soapenv:Envelope>',
	
	//查询请求串模板
	_getRecordsTemplate: 
	     '<csw:GetRecords service="CSW" version="2.0.2" outputFormat="text/xml" ' + 
		 		'resultType="results" ${outputSchema} ' + 
				'xmlns:csw="http://www.opengis.net/cat/csw" xmlns:ogc="http://www.opengis.net/ogc" ' + 
				'${customNamespaces}> ' +
	         '<csw:Query typeNames="${typeNames}">' +
	            '<csw:ElementSetName>full</csw:ElementSetName>' +
	            '${constraint}' +
	         '</csw:Query>' +
	      '</csw:GetRecords>',
	
	//查询条件模板
	_constraintTemplate:
		'<csw:Constraint version="2.0.0">' +
		   '${filter}' +
		'</csw:Constraint>',
	
    /**
     * APIMethod: getResTreeNode
     * 读取资源目录树节点。
     * 
     * Parameters:
     * parentId - {String} 要读取的资源目录树节点父类ID号，默认值为0。
     * caller - {Object} 回调函数的作用域。。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     */
	getResTreeNode: function(parentId,caller,successFn,failFn){
		if(parentId){
			parentId = 0;
		}
		
		//请求相关设置
		var customNamespaces = 'xmlns:geoglobe="http://www.geostar.com.cn/geoglobe"';
		var outputSchema = 'outputSchema="geoglobe:ResourceType"';
		var typeNames = "geoglobe:ResourceType";
		
		//生成查询条件过滤器
		var kindFilter = new Geo.Filter.Comparison({
	        type: Geo.Filter.Comparison.EQUAL_TO,
	        property: "/geoglobe:ResourceType/geoglobe:kind",
	        value: "CATALOG"
	    });		
		var parentIdFilter = new Geo.Filter.Comparison({
	        type: Geo.Filter.Comparison.EQUAL_TO,
	        property: "/geoglobe:ResourceType/geoglobe:parentId",
	        value: parentId
	    });
		var constraintFilter = new Geo.Filter.Logical({
		    type: Geo.Filter.Logical.AND,
		    filters: [kindFilter,parentIdFilter]
		});
		var constraintString = this._makerFilterString(constraintFilter);
		
		//生成查询请求串
		var requestString = OpenLayers.String.format(this._getRecordsTemplate,{
			customNamespaces: customNamespaces,
			constraint: constraintString,
			outputSchema: outputSchema,
			typeNames: typeNames
		});
		
		requestString = this._wrapToSoapRequest(requestString);
		
		//发送查询请求
		if(!(failFn instanceof Function)){
			failFn = this.failFn;
		}
		
		var successHandler = OpenLayers.Function.bind(function(result){
			var result = this._getBodyFromSoapResponse(result.responseText);
			var successHandler = OpenLayers.Function.bind(successFn,this);
			successHandler(result);
		},this);
		
		var xhr = new OpenLayers.Ajax.Request(
			this.url, 
			{
				contentType:"application/xml", method:"post",
				postBody: requestString,
				onSuccess: successHandler,
				onFailure: failFn
			}
		);
	},
	
	//输入关键字等条件查询所需服务元数据，对queryMetaData方法的封装，方便使用
	searchServices: function(options,caller,successFn,failFn){
		
		
	},

    /**
     * APIMethod: queryMetaData
     * 查询服务元数据。
     * 
     * Parameters:
     * filter - {<Geo.Filter>} 查询条件，如果不指定（值为null）则返回所有服务元数据记录。
     * caller - {Object} 指定回调函数的作用域。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     */
	queryMetaData: function(filter,caller,successFn,failFn){
		
		//查询资源目录用到的XML名字空间
		var customNamespaces = ' xmlns:smmd="http://data.sbsm.gov.cn/smmd/2007"';
		var outputSchema= ' outputSchema="smmd:Metadata"';
		var typeNames = "smmd:Metadata";
		
		var constraintString = this._makerFilterString(filter);
		
		//生成查询请求串
		var requestString = OpenLayers.String.format(this._getRecordsTemplate,{
			customNamespaces: customNamespaces,
			constraint: constraintString,
			outputSchema: outputSchema,
			typeNames: typeNames
		});
		
		requestString = this._wrapToSoapRequest(requestString);
		
		//发送查询请求
		if(!(failFn instanceof Function)){
			failFn = this.failFn;
		}
		
		var successHandler = OpenLayers.Function.bind(function(result){
			var result = this._getBodyFromSoapResponse(result.responseText);
			var successHandler = OpenLayers.Function.bind(successFn,this);
			successHandler(result);
		},this);
		var xhr = new OpenLayers.Ajax.Request(
			this.url, 
			{
				contentType:"application/xml", method:"post",
				postBody: requestString,
				onSuccess: successHandler,
				onFailure: failFn
			}
		);
	},
	
	//加上SOAP请求包
	_wrapToSoapRequest:function(string){
		var requestString = OpenLayers.String.format(this._soapTemplate,{
			soapBody: string
		});
		return requestString;
	},
	
	//从SOAP响应结果中获取实际内容
	_getBodyFromSoapResponse:function(data){
		if(typeof data == "string") { 
            data = Geo.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
		
		//如果是SOAP响应，从中取出内容，如果不是直接返回内容。
		if(data.nodeName == "SOAP-ENV:Envelope"){
			return data.childNodes[0].childNodes[0];
		}
		return data;
	},
	
	//生成过滤器字符串
	_makerFilterString: function(filter){
		if(!filter){
			filter = new Geo.Filter.Comparison({
                type: Geo.Filter.Comparison.LIKE,
                property: "/smmd:Metadata/smmd:mdFileID",
                value: "*"
            });
		}
		var parser = new Geo.Format.Filter();
		var filterString = parser.write(filter).xml;
		constraintString = OpenLayers.String.format(this._constraintTemplate, {
			filter: filterString
		});
		return constraintString;
	},
	
	CLASS_NAME: "Geo.Query.CatalogQuery"
});

/**
 * 继承并修改自Geo.Format.CSWGetRecords.v2_0_2类，
 * 增加对CSW2.0.0以及国家资源目录标准的支持。
 */
Geo.Format.CSWGetRecords.v2_0_0 = Geo.Class(Geo.Format.CSWGetRecords.v2_0_2, {

    namespaces: {
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance",
        csw: "http://www.opengis.net/cat/csw",
        dc: "http://purl.org/dc/elements/1.1/",
        dct: "http://purl.org/dc/terms/",
        ows: "http://www.opengis.net/ows",
		geoglobe: "http://www.geostar.com.cn/geoglobe",
		smmd: "http://data.sbsm.gov.cn/smmd/2007"
    },

    version: "2.0.0",
	
    schemaLocation: "http://www.opengis.net/cat/csw http://schemas.opengis.net/csw/CSW-discovery.xsd",

    readers: {
        "csw": {
            "GetRecordsResponse": function(node, obj) {
                obj.records = [];
                this.readChildNodes(node, obj);
                var version = this.getAttributeNS(node, "", 'version');
                if (version != "") {
                    obj.version = version;
                }
            },
            "RequestId": function(node, obj) {
                obj.RequestId = this.getChildValue(node);
            },
            "SearchStatus": function(node, obj) {
                obj.SearchStatus = {};
                var timestamp = this.getAttributeNS(node, "", 'timestamp');
                if (timestamp != "") {
                    obj.SearchStatus.timestamp = timestamp;
                }
            },
            "SearchResults": function(node, obj) {
                this.readChildNodes(node, obj);
                var attrs = node.attributes;
                var SearchResults = {};
                for(var i=0, len=attrs.length; i<len; ++i) {
                    if ((attrs[i].name == "numberOfRecordsMatched") ||
                        (attrs[i].name == "numberOfRecordsReturned") ||
                        (attrs[i].name == "nextRecord")) {
                        SearchResults[attrs[i].name] = parseInt(attrs[i].nodeValue);
                    } else {
                        SearchResults[attrs[i].name] = attrs[i].nodeValue;
                    }
                }
                obj.SearchResults = SearchResults;
            }
        },
        "dc": {
            "*": function(node, obj) {
                var name = node.localName || node.nodeName.split(":").pop();
                if (!(obj[name] instanceof Array)) {
                    obj[name] = new Array();
                }
                var dc_element = {};
                var attrs = node.attributes;
                for(var i=0, len=attrs.length; i<len; ++i) {
                    dc_element[attrs[i].name] = attrs[i].nodeValue;
                }
                dc_element.value = this.getChildValue(node);
                obj[name].push(dc_element);
            }
        },
        "dct": {
            "*": function(node, obj) {
                var name = node.localName || node.nodeName.split(":").pop();
                if (!(obj[name] instanceof Array)) {
                    obj[name] = new Array();
                }
                obj[name].push(this.getChildValue(node));
            }
        },
        "ows": {
            "WGS84BoundingBox": function(node, obj) {
                if (!(obj.BoundingBox instanceof Array)) {
                    obj.BoundingBox = new Array();
                }
                var lc = this.getChildValue(
                    this.getElementsByTagNameNS(
                        node,
                        this.namespaces["ows"],
                        "LowerCorner"
                    )[0]
                ).split(' ', 2);
                var uc = this.getChildValue(
                    this.getElementsByTagNameNS(
                        node,
                        this.namespaces["ows"],
                        "UpperCorner"
                    )[0]
                ).split(' ', 2);

                var boundingBox = {
                    value: [
                        parseFloat(lc[0]),
                        parseFloat(lc[1]),
                        parseFloat(uc[0]),
                        parseFloat(uc[1])
                    ]
                };
                var attrs = node.attributes;
                for(var i=0, len=attrs.length; i<len; ++i) {
                    boundingBox[attrs[i].name] = attrs[i].nodeValue;
                }
                obj.BoundingBox.push(boundingBox);
            },

            "BoundingBox": function(node, obj) {
                this.readers['ows']['WGS84BoundingBox'].apply(this, [node, obj]);
            }
        },
		
		//增加自定义记录类型
		"geoglobe": {
			"ResourceType": function(node, obj){
				var record = {type: "ResourceType"};
                this.readChildNodes(node, record);
                obj.records.push(record);
				
			},
			"*": function(node, obj){
				var name = node.localName || node.nodeName.split(":").pop();
                obj[name] = this.getChildValue(node);
			}
		},
		"smmd": {
			"Metadata": function(node, obj){
				var record = {type: "Metadata"};
                this.readChildNodes(node, record);
                obj.records.push(record);
			},
			"*": function(node, obj){
				var name = node.localName || node.nodeName.split(":").pop();
                obj[name] = this.getChildValue(node);
			}
		}
    },

	CLASS_NAME: "OpenLayers.Format.CSWGetRecords.v2_0_0" 
});/**
 * Class: Geo.Query.ModelQuery
 * 三维地图模型服务查询类。
 * 本类支持：1.鼠标点击模型查询模型信息;2.根据矩形范围查询模型信息。
 */
Geo.Query.ModelQuery = Geo.Class({
	
    /**
     * Property: url
     * {String} 服务地址。
     */
//	url: null,
	
    /**
     * APIProperty: maxFeatures
     * {Number} 最大结果数。
     */	
	maxFeatures: 10,

    /**
     * APIProperty: format
     * {<Geo.Format>} 用于对查询操作返回结果进行解析的格式解析器，默认为XML解析器。
     */
	format: null,
    
    /**
     * APIProperty: modelLayer
     * {<Geo.View3d.Layer.ModelLayer>} 查询的模型图层对象。
     */
    modelLayer : null,
    
    /**
     * APIProperty: map
     * {<Geo.View3D.Map>} 三维地图对象。 
     */
    map : null,
    
    /**
     * APIProperty: enumLayerPropertyName
     * <Object>} 图层属性对象。
     */
	enumLayerPropertyName :
	{
		layerName : 0,
		layerVisible : 1,
		layerTransparency : 2,
		layerFullEnvelope : 3,
		wmslayerInfo : 4,
		wmtslayerInfo : 5,
		EnableSelection : 6
	},
	/**
	 * Constructor: Geo.Query.ModelQuery
	 * Geo.Query.ModelQuery类构造函数。
	 * 
	 * Parameters:
	 * options - {Object} 相关属性的设置项，可选。
	 */	
	initialize: function(modelLayer,options){
		//this.url = url;
		this.modelLayer = modelLayer;
		this.format = new Geo.Util.Format.XML2JSON();
		OpenLayers.Util.extend(this, options);
	},

	/**
	 * APIMethod: query
	 * 开始查询。
	 * 
	 * Parameters:
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
	 * (end)
	 */
	query: function(successFn,failFn){
		if(this.modelLayer == null){
			return;
		}
		var map = this.modelLayer.map;
		var globe = map.activexObj; 
		//打开SelectionBox的选择功能，打开图层的选择功能
		globe.SelectionBox.EnableSelection = true;
		var layerOp = globe.LayerBox.CreateLayerOperate(this.modelLayer._layerData);
		layerOp.ChangeLayerProperty(this.enumLayerPropertyName.EnableSelection, true);
		//监听鼠标事件,在鼠标事件中执行选择命令
		var querySuccessFn = successFn || this.successFn;
		var queryFailFn = failFn || this.failFn;
		this.queryHandler = OpenLayers.Function.bind(function(eventObj,successFn,failFn){
	        this._queryHandler(eventObj,querySuccessFn,queryFailFn);
	    }, this);
		//调用SelectionBox的选择方法,输入参数是屏幕坐标
		globe.attachEvent("OnMouseEvent", this.queryHandler);
	},
	
	//点击查询
	 _queryHandler : function(e,successFn,failFn){
    	var map = this.modelLayer.map;
		var globe = map.activexObj; 
		//监听鼠标单击事件
		if(e.MouseButton === 1 && e.MouseState === 0){
			globe.SelectionBox.SelectByScreenPoint(e.ScreenX, e.ScreenY);
			if(!e){
				failFn();
				return;
			}
			//alert(""+e.ScreenX+","+ e.ScreenY);
			//获取选中的模型ID,根据选择集中的索引，获取模型ID
			var modelId = globe.SelectionBox.QuerySelectedID(0);
			if(globe.SelectionBox.Count == 0){
				return;
			}
			//创建一个请求属性数据的对象
			var AttributeOperater = globe.ObjectFactory.CreateObjectFromParameter("eGMDLAttributeOperater", "");
			var strAtt = AttributeOperater.QueryAttributeFromServerID(this.modelLayer.url, modelId);
			var attXml = this.format.read(strAtt);
			if(attXml){
				var feature = attXml.Feature;
				if(feature){
					var x = feature.X ? feature.X : "";
					var y = feature.Y ? feature.Y : "";
					var z = feature.Z ? feature.Z : "";
					var minX = feature.GEOSTAR_MIN_X ? feature.GEOSTAR_MIN_X : "";
					var minY = feature.GEOSTAR_MIN_Y ? feature.GEOSTAR_MIN_Y : "";
					var maxX = feature.GEOSTAR_MAX_X ? feature.GEOSTAR_MAX_X : "";
					var maxY = feature.GEOSTAR_MAX_X ? feature.GEOSTAR_MAX_X : "";
					var name = feature.NAME ? feature.NAME :"";
					var featureObject = {
						longitude: null,
			            latitude: null,
			            altitude: null,
			            name: null,
			            bounds: null
					}; 
					featureObject.longitude = x;
					featureObject.latitude = y;
					featureObject.altitude = z;
					featureObject.name = name;
					featureObject.bounds = new Geo.Bounds(minX, minY, maxX, maxY);
					//调用回调函数
					successFn(featureObject);
				}
			}
		}
    },
    /**
     * 删除查询模型监听 
     */
    removeQuery: function(){
    	var map = this.modelLayer.map;
    	var globe = map.activexObj; 
		globe.detachEvent("OnMouseEvent", this.queryHandler);
    },
    
	CLASS_NAME: "Geo.Query.ModelQuery"
});
/**
 * Class: Geo.Query.MapServiceQuery
 * MapService地图服务查询类，可以查询指定图层或表的要素结果，支持空间查询和属性查询两种方式.
 */
Geo.Query.MapServiceQuery = Geo.Class({
	
	/**
	 *  APIProperty: url
	 * {String} 服务地址。
	 */
	url: null,
	
	/**
	 * Constructor: Geo.Query.MapServiceQuery
	 * 构造函数。
	 * 
	 * Parameters:
	 * url - {String} 服务地址
	 * options - {Object} 可选项，目前没有可设置的参数
	 */	
	initialize: function(url,options){
		var location = url.indexOf("/",url.length - 1);
		if(location != -1) {
			this.url = url + "query";
		}else {
			this.url = url + "/" + "query";
		}
		var format = new Geo.Util.Format.MapServiceQuery();
		this.jsonp = new OpenLayers.Protocol.Script({
			format:format
		});
		OpenLayers.Util.extend(this, options);
	},
	
	/**
	 * APIMethod: query
	 * 查询
	 * 
	 * Parameters:
	 * queryParameter - {<Geo.Query.MapServiceQueryParameters>}查询参数
	 * successFn - {Function} 请求成功的回调函数。
	 * failFn - {Function} 请求失败的回调函数。
	 *      (code)
	 *      例如：
	 *      var url = "http://sampleserver1.arcgisonline.com/ArcGIS/rest/services/Specialty/ESRI_StateCityHighway_USA/MapServer/1";
 	 *     	var queryObj = new Geo.Query.MapServiceQuery(url);
	 *		var params = new Geo.Query.MapServiceQueryParameters();
	 *		params.where="STATE_NAME='Florida'",
	 *		params.geometry=new Geo.Bounds(-180,-90,180,90),
	 *		params.spatialRel="esriSpatialRelEnvelopeIntersects",
	 *		params.inSR="4326",
	 *		params.outSR="4326"
	 *		queryObj.query(params,function(result) {
	 *			vectorLayer.addFeatures(result.features);	
	 *		});
	 *      (end)
	 */
	query: function(queryParameter ,successFn, failFn) {
		var params = this._getParamsFromQueryParameter(queryParameter);	
		var DEFAULT_PARAMS = {
			f:"json",
			pretty:true
		}
		OpenLayers.Util.applyDefaults(
	        params, DEFAULT_PARAMS
	    );
		this.jsonp.createRequest(this.url,params, OpenLayers.Function.bind(function(result){
			var failFn = failFn || this.failFn;
			if(result.error) {
				failFn(result.error);
				return;
			}
			var features = this.jsonp.format.read(result);
			var queryResult =  new Geo.Query.MapServiceQueryResult();
			queryResult.features = features;
			queryResult.displayFieldName = result["displayFieldName"];
			queryResult.fieldAliases = result["fieldAliases"];
			queryResult.geometryType = result["geometryType"];
			queryResult.spatialReference = result["spatialReference"];
			successFn(queryResult);
		},this));

	},
	
	queryForIds: function(queryParameter ,successFn, failFn) {
		var params = this._getParamsFromQueryParameter(queryParameter);	
		var DEFAULT_PARAMS = {
			f:"json",
			returnIdsOnly:true,
			pretty:true
		}
		OpenLayers.Util.applyDefaults(
	        params, DEFAULT_PARAMS
	    );
		this.jsonp.createRequest(this.url,params, OpenLayers.Function.bind(function(result){
			var queryResult = {
				objectIdFieldName:result["objectIdFieldName"],
				objectIds:result["objectIds"]
			}
			successFn(queryResult);
		},this));
	},
	
	_getParamsFromQueryParameter: function(queryParameter) {
		var params = {};
		for(var param in queryParameter) {
			if(queryParameter[param] !== null) {
				params[param] = queryParameter[param];
			}
		}
		
		if(params.geometry instanceof Geo.Geometry || params.geometry instanceof Geo.Bounds) {
			if(params.serviceType == "ArcgisRest") {
				params.geometryType = "esri" + this._getGeometryType(params.geometry);
			}else {
				params.geometryType = this._getGeometryType(params.geometry);
			}
			params.geometry = this._getGeometryRepresentation(params.geometry);//this.jsonp.format._getGeometryRepresentation
		}
		
		if(params.timeExtent) {
			if(params.timeExtent.startTime instanceof Date && params.timeExtent.endTime instanceof Date) {
				var startTime = Date.parse(params.timeExtent.startTime);
				var endTime = Date.parse(params.timeExtent.endTime);
				params.time = startTime + "," + endTime;
				delete params.timeExtent;
			}
		}
		
		if(params.spatialRel && params.serviceType == "ArcgisRest") {
			params.spatialRel = "esri" + params.spatialRel;
		}
		delete params.serviceType;
		return params;
	},
	
	/**
	 * Method: 得到与该几何信息相对应的arcgis几何类型
	 * 
	 * Parameters:
	 * {Object} geometry
	 */	
	_getGeometryType: function(geometry) {
		var name = geometry.CLASS_NAME;
		var geometryType = "";
		switch(name) {
			case "OpenLayers.Bounds": 
				geometryType = "GeometryEnvelope";
				break;
			case "OpenLayers.Geometry.Point":
				geometryType = "GeometryPoint";
				break;
			case "OpenLayers.Geometry.MultiLineString":
				geometryType = "GeometryPolyline";
				break;	
			case "OpenLayers.Geometry.Polygon":
				geometryType = "GeometryPolygon";
				break;	
		}
		return geometryType;
	},
	
	/**
	 * Method: 得到arcgis可以理解的几何表示法
	 * 
	 * Parameters:
	 * {Object} geometry
	 */		
	_getGeometryRepresentation: function(geometry) {
		var name = geometry.CLASS_NAME;
		var geometryStr = "";
		switch(name) {
			case "OpenLayers.Bounds": 
				geometryStr = geometry.toBBOX();
				break;
			case "OpenLayers.Geometry.Point":
				geometryStr = geometry.x + "," + geometry.y;
				break;
			case "OpenLayers.Geometry.Polygon":
				var json = this.extract['geometry'].apply(this, [geometry]);
				var jsonObj = {rings:json.coordinates};
				geometryStr = OpenLayers.Format.JSON.prototype.write.apply(this.jsonp.format,
                                                              [jsonObj]);
				break;	
			case "OpenLayers.Geometry.MultiLineString":
				var json = this.extract['geometry'].apply(this, [geometry]);
				var jsonObj = {paths:json.coordinates};
				geometryStr = OpenLayers.Format.JSON.prototype.write.apply(this.jsonp.format,
                                                              [jsonObj]);
				break;		
		}
		return geometryStr;
	},
	
	/**
     * Property: extract
     * Object with properties corresponding to the GeoJSON types.
     *     Property values are functions that do the actual value extraction.
     */
    extract: { 
        'geometry': function(geometry) {
            if (geometry == null) {
                return null;
            }                     
            var geometryType = geometry.CLASS_NAME.split('.')[2];
            var data = this.extract[geometryType.toLowerCase()].apply(this, [geometry]);
            var json;
            json = {
                "type": geometryType,
                "coordinates": data
            };
            return json;
        },

        'point': function(point) {
            return [point.x, point.y];
        },

        'multipoint': function(multipoint) {
            var array = [];
            for(var i=0, len=multipoint.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [multipoint.components[i]]));
            }
            return array;
        },
        
        'linestring': function(linestring) {
            var array = [];
            for(var i=0, len=linestring.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [linestring.components[i]]));
            }
            return array;
        },

        'multilinestring': function(multilinestring) {
            var array = [];
            for(var i=0, len=multilinestring.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [multilinestring.components[i]]));
            }
            return array;
        },
        
        'polygon': function(polygon) {
            var array = [];
            for(var i=0, len=polygon.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [polygon.components[i]]));
            }
            return array;
        }
    },
	
	/**
	 * Method: 将几何信息的json表示转换成
	 * 
	 * Parameters:
	 * {Object} geometry
	 */		
	_geometryType: {
		"points": function(geometry) {
			var points = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var point = new OpenLayers.Geometry.Point(geometry[i][0], geometry[i][1]);
					points.push(point);
				}
			}
			return points;
		},
		"paths": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LineString(ps);
					lines.push(line);
				}
				var paths = new OpenLayers.Geometry.MultiLineString(lines);
			}
			return paths;
		},
		"rings": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LinearRing(ps);
					lines.push(line);
				}
				var Polygon = new OpenLayers.Geometry.Polygon(lines);
			}
			return Polygon;
		}
	},
	
	/**
	 * APIMethod: failFn
	 * 查询失败响应方法，默认提示"对不起,查询失败,请查询服务是否正常"，用户可以根据需要覆盖此方法。
	 */
	failFn: function(error){
		alert("对不起,查询失败,请查询服务是否正常。");
    },

	CLASS_NAME: "Geo.Query.MapServiceQuery"
});/**
 * Class: Geo.Query.MapServiceQueryParameters
 * 本对象支持服务类型：OGC_Geo_MapService_Rest、Arcgis_MapService_Rest
 */
Geo.Query.MapServiceQueryParameters = Geo.Class({
	
	/**
	 * APIProperty: serviceType
	 * 服务类型，默认值：MapserviceRest
	 * 可供选择的值：MapserviceRest，ArcgisRest
	 * 其中MapserviceRest表示OGC 地图服务查询接口，
	 * ArcgisRest表示Arcgis地图服务查询接口
	 * 
	 */
	serviceType:"MapserviceRest",

	/**
	 * APIProperty: geometry
	 * {<Geo.Bounds> || <Geo.Geometry>}geometry} 作为一个空间过滤条件。geometry的类型由geometryType指定。除点与包络矩形的JSON形式以外，用户可以用一个简单的逗号分隔的语法来指定几何对象。
	 * 如果要使用空间范围作为查询条件则使用本属性，如果不需要空间范围作为条件则本属性可忽略。
	 * 本属性支持的服务类型：OGC_Geo_MapService_Rest、Arcgis_MapService_Rest
	 * 本属性支持的Geo.Geometry类型包括：
	 * Geo.Geometry.Point,Geo.Geometry.MultiPoint,Geo.Geometry.MultiLineString,Geo.Geometry.Polygon
	 * 其他Geo.Geometry类型不支持。
	 */
	geometry:null,
	
	/**
	 * APIProperty: objectIds
	 * {String} 
	 * 查询的要素ID。默认可不填。取值举例：objectIds:"1,2",本属性就像一个过滤器，会过滤掉要素id不为1或2的要素。
	 * 
	 */
	objectIds:null,
	
	/**
	 * APIProperty: orderByFields
	 * {Array(String)} 查询排序字段。Arcgis 10.1 以后才支持。默认可不填。
	 */
	orderByFields:null,
	
	/**
	 * APIProperty: outFields
	 *  {Array(String)} 输出字段。如果不需要定制输出的字段，默认可不填。
	 */
	outFields:null,
	
	/**
	 * APIProperty: inSR
	 * {Integer} 输入几何对象的投影类型编号。不填则按服务默认的投影类型解析geometry参数
	 */
	inSR:null,
	
	/**
	 * APIProperty: outSR
	 * {Integer} 输出几何对象的投影类型编号。不填则按服务默认的投影类型输出结果
	 */
	outSR:null,
	
	/**
	 * APIProperty: maxAllowableOffset
	 *  定义Find操作返回的几何对象的最大允许偏移值。本属性主要用于对线和面进行抽稀
	 *  maxAllowableOffset的单位与空间参考单位一致。
	 *  如果sr值未定义，maxAllowableOffset的单位与地图的空间参考单位一致。
	 *  如：maxAllowableOffset=2
	 */
	maxAllowableOffset: null,
	
	/**
	 * APIProperty: returnGeometry
	 * 	{Boolean} 返回结果中是否包含几何信息。不填则服务默认其值为true
	 */
	returnGeometry:null,
	
	/**
	 * APIProperty: spatialRelationship
	 * {String} 空间查询条件。不填则默认值为"SpatialRelIntersects"。
	 */
	spatialRel:null,
	
	/**
	 * APIProperty: timeExtent
	 * {Object} 请求指定时间段内的瓦片。默认可不填
	 */
	timeExtent:null,
	
	/**
	 * APIProperty: where
	 * {String} 属性查询条件，sql语句格式
	 */
	where:null,
	
	/**
	 * APIProperty: text
	 * {String} 根据服务的displayField字段进行查询；
	 *  value参数是对where <displayField> like '%<text>%' 的where子句的速记。
	 *  文本是区分大小写的。如果指定了where参数，该参数会被忽略。
	 */
	text:null,
	
	/**
	 * Constructor: Geo.Query.MapServiceQueryParameters
	 * 构造函数。
	 * 
	 */	
	initialize: function(options){
		OpenLayers.Util.extend(this, options);
	}
});
/**
 * Class: Geo.Query.MapServiceQueryResult
 * Geo.Query.MapServiceQuery 地图服务查询类结果操作对象。本对象支持服务类型：OGC_Geo_MapService_Rest、Arcgis_MapService_Rest
 * 说明：地名服务查询对象调用query方法进入成功回调后，回调函数返回的就是本对象。
 */
Geo.Query.MapServiceQueryResult = Geo.Class({
	/**
     * APIProperty: displayFieldName
     * {String} 字段名称：
     */
	displayFieldName:null,
	
	/**
	 * APIProperty: features
	 * Array({<Geo.Feature.Vector>}) 要素对象集合
	 */
	features:null,
	
	/**
     * APIProperty: fieldAliases
     * {String} 字段别名
     */
	fieldAliases:null,
	
	/**
     * APIProperty: geometryType
     * {String} 几何对象类型 ("GeometryPoint" / "GeometryMultiPoint" / "GeometryPolyline" / "GeometryPolygon" / "GeometryEnvelope")，缺省"GeometryPoint"。如：geometryType=GeometryPolygon。
     */
	geometryType:null,
	
	/**
     * APIProperty: spatialReference
     * {String} 空间参考
     */
	spatialReference:null,
	
	/**
	 * Constructor: Geo.Query.MapServiceQueryResult
	 * 构造函数。
	 * 
	 */	
	initialize: function(options){
		OpenLayers.Util.extend(this, options);
	}
});
/**
 * Class: Geo.Query.MapServiceIdentify
 * MapService空间查询类,支持几何查询。
 */
Geo.Query.MapServiceIdentify = Geo.Class({
	
    /**
	 * APIProperty: url
	 * {String} 服务地址。
	 */
	url: null,
	
	/**
	 * Constructor: Geo.Query.MapServiceIdentify
	 * 构造函数。
	 * 
	 * Parameters:
	 * url - {String} 服务地址
	 * options - {Object} 可选项，目前没有可用参数
	 */	
	initialize: function(url,options){
		this.url = url + "/identify";
		this.format = new OpenLayers.Format.JSON();
		this.jsonp = new OpenLayers.Protocol.Script({
			format:this.format
		});
		OpenLayers.Util.extend(this, options);
	},
	
	/**
	 * APIMethod: query
	 * 查询
	 * 
	 * Parameters:
	 * queryParameter - {<Geo.Query.MapServiceIdentifyParameters>}查询参数
	 * successFn - {Function} 请求成功的回调函数。
	 * failFn - {Function} 请求失败的回调函数。 	
	 *      (code)
	 *      例如：
 	 *     	var queryObj = new Geo.Query.MapServiceIdentify("http://192.168.42.75:7777/wkDT/MapServer/identify");
	 *		var params = new Geo.Query.MapServiceIdentifyParameters();
	 *		params.geometryType = "GeometryEnvelope",
	 *		params.layers = "all:4",
	 *		params.geometry = "75,10,130,50",
	 *		params.imageDisplay = "600,550,96",
	 *		queryObj.query(params,function(result) {
	 *			for(var i = 0,len = result.length; i < len; i++){
	 *	    		vectorLayer.addFeatures(result[i].feature);
	 *	    	}	
	 *		});
	 *      (end)
	 */
	query: function(queryParameter ,successFn, failFn) {
		var params = this._getParamsFromQueryParameter(queryParameter);	
		var DEFAULT_PARAMS = {
			f:"json"
		}
		OpenLayers.Util.applyDefaults(
	        params, DEFAULT_PARAMS
	    )
	    this.jsonp.createRequest(this.url,params, OpenLayers.Function.bind(function(result){
	    	if(result.error) {
				if(failFn){
					failFn(result.error);
	    		}
				return;
			}
			var results = this._getResult(result);
			successFn(results);
		},this));
	},
	
	/**
	 * Method: 获取查询结果的json表示法
	 * 
	 * Parameters:
	 * {Object} result
	 */	
	_getResult : function(result){
		var results = [];
		if(result.results) {
			for(var i = 0,j = result.results.length; i < j; i++) {
				var olGeometry = this._getGeometry(result.results[i].geometry);
				var attributes = this._getAttribute(result.results[i].attributes);
				var feature = new OpenLayers.Feature.Vector(olGeometry,attributes);
				var identifyResult = new Geo.Query.MapServiceIdentifyResult();
				identifyResult.layerId = result.results[i].layerId;
				identifyResult.layerName = result.results[i].layerName;
				identifyResult.displayFieldName = result.results[i].displayFieldName;
				identifyResult.feature = feature;
				identifyResult.geometryType = result.results[i].geometryType;
				results.push(identifyResult);
			}
		}
		return results;
	},
	
	_getParamsFromQueryParameter: function(queryParameter) {
		var params = {};
		for(var param in queryParameter) {
			if(queryParameter[param] !== null) {
				params[param] = queryParameter[param];
			}
		}
		
		if(params.geometry instanceof Geo.Geometry || params.geometry instanceof Geo.Bounds) {
			params.geometry = this._getGeometryRepresentation(params.geometry);
		}
		
		if(params.spatialRel && params.serviceType == "ArcgisRest") {
			params.spatialRel = "esri" + params.spatialRel;
		}
		if(params.geometryType && params.serviceType == "ArcgisRest") {
			params.geometryType = "esri" + this._getGeometryType(params.geometry);
		}
		delete params.serviceType;
		return params;
	},
	
	/**
	 * Method: 得到与该几何信息相对应的arcgis几何类型
	 * 
	 * Parameters:
	 * {Object} geometry
	 */	
	_getGeometryType: function(geometry) {
		var name = geometry.CLASS_NAME;
		var geometryType = "";
		switch(name) {
			case "OpenLayers.Bounds": 
				geometryType = "GeometryEnvelope";
				break;
			case "OpenLayers.Geometry.Point":
				geometryType = "GeometryPoint";
				break;
			case "OpenLayers.Geometry.MultiLineString":
				geometryType = "GeometryPolyline";
				break;	
			case "OpenLayers.Geometry.Polygon":
				geometryType = "GeometryPolygon";
				break;	
		}
		return geometryType;
	},
	
	/**
	 * Method: 得到arcgis可以理解的几何表示法
	 * 
	 * Parameters:
	 * {Object} geometry
	 */	
	_getGeometryRepresentation: function(geometry) {
		var name = geometry.CLASS_NAME;
		var geometryStr = "";
		switch(name) {
			case "OpenLayers.Bounds": 
				geometryStr = geometry.toBBOX();
				break;
			case "OpenLayers.Geometry.Point":
				geometryStr = geometry.x + "," + geometry.y;
				break;
			case "OpenLayers.Geometry.Polygon":
				var json = this.extract['geometry'].apply(this, [geometry]);
				var jsonObj = {rings:json.coordinates};
				geometryStr = this.format.write(jsonObj);
				break;	
			case "OpenLayers.Geometry.MultiLineString":
				var json = this.extract['geometry'].apply(this, [geometry]);
				var jsonObj = {paths:json.coordinates};
				geometryStr = this.format.write(jsonObj);
				break;		
		}
		return geometryStr;
	},
	
	/**
     * Property: extract
     * Object with properties corresponding to the GeoJSON types.
     *     Property values are functions that do the actual value extraction.
     */
    extract: { 
        'geometry': function(geometry) {
            if (geometry == null) {
                return null;
            }                     
            var geometryType = geometry.CLASS_NAME.split('.')[2];
            var data = this.extract[geometryType.toLowerCase()].apply(this, [geometry]);
            var json;
            json = {
                "type": geometryType,
                "coordinates": data
            };
            return json;
        },

        'point': function(point) {
            return [point.x, point.y];
        },

        'multipoint': function(multipoint) {
            var array = [];
            for(var i=0, len=multipoint.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [multipoint.components[i]]));
            }
            return array;
        },
        
        'linestring': function(linestring) {
            var array = [];
            for(var i=0, len=linestring.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [linestring.components[i]]));
            }
            return array;
        },

        'multilinestring': function(multilinestring) {
            var array = [];
            for(var i=0, len=multilinestring.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [multilinestring.components[i]]));
            }
            return array;
        },
        
        'polygon': function(polygon) {
            var array = [];
            for(var i=0, len=polygon.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [polygon.components[i]]));
            }
            return array;
        }
    },
	
	/**
	 * Method: 获取查询结果的json表示法
	 * 
	 * Parameters:
	 * {Object} result
	 */	
	_getJson: function(result) {
		var resultObj = this.format.read(result.responseText);
		return resultObj;
	},
	
	/**
	 * Method: 得到openlayers几何对象
	 * 
	 * Parameters:
	 * {Object} geometry
	 */	
	_getGeometry: function(geometry) {
		for(var pro in geometry) {
			//TODO：服务组封装的地图服务返回的geometry节点中包含spatialReference,加了这个判断，初步估计服务组封装的查询服务的返回结果结构有问题
			if("spatialReference" == pro) {
				return;
			}
			if(geometry.hasOwnProperty("x") && geometry.hasOwnProperty("y")) {
				var geometry = new OpenLayers.Geometry.Point(geometry["x"],geometry["y"]);
			}else if(geometry.hasOwnProperty("xmin") && geometry.hasOwnProperty("ymin")&& geometry.hasOwnProperty("xmax")&& geometry.hasOwnProperty("ymax"))
			{
				 var geometry = new OpenLayers.Bounds(geometry.xmin,geometry.ymin,geometry.xmax,geometry.ymax).toGeometry();
			}else {
				var geometry = this._geometryType[pro](geometry[pro]);
			}
			return geometry;
		}
	},

	/**
	 * Method: 得到要素的属性信息
	 * 
	 * Parameters:
	 * {Object} geometry
	 */		
	_getAttribute: function(attrs) {
		var attributes = {};
		if(attrs && !(attrs instanceof Array)) {
			attrs = [attrs];
		}
		if(attrs instanceof Array) {
			for(var i = 0; i < attrs.length; i++) {
				 OpenLayers.Util.applyDefaults(attributes,attrs[i]);
			}
		}
		return attributes;
	},
	
	/**
	 * Method: 将几何信息的json表示转换成
	 * 
	 * Parameters:
	 * {Object} geometry
	 */		
	_geometryType: {
		"points": function(geometry) {
			var points = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var point = new OpenLayers.Geometry.Point(geometry[i][0], geometry[i][1]);
					points.push(point);
				}
			}
			return points;
		},
		"paths": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LineString(ps);
					lines.push(line);
				}
				var paths = new OpenLayers.Geometry.MultiLineString(lines);
			}
			return paths;
		},
		"rings": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LinearRing(ps);
					lines.push(line);
				}
				var Polygon = new OpenLayers.Geometry.Polygon(lines);
			}
			return Polygon;
		}
	},
	
	CLASS_NAME: "Geo.Query.MapServiceIdentify"
});
/**
 * Class: Geo.Query.MapServiceIdentifyParameters
 * Identify空间查询参数，rest服务的空间查询参数。本对象须结合Geo.Query.MapServiceIdentify对象使用，Geo.Query.MapServiceIdentify对象的query方法的第一个参数传入是本对象。支持服务：OGC_Geo_MapService_Rest。
 */
Geo.Query.MapServiceIdentifyParameters = Geo.Class({
	
    /**
     * APIProperty: geometry
     * {<Geo.Geometry>} Geo.Geometry对象。
     */
	geometry: null,
	
    /**
     * APIProperty: geometryType
     * {String} 几何对象类型 ("GeometryPoint" / "GeometryMultiPoint" / "GeometryPolyline" / "GeometryPolygon" / "GeometryEnvelope")，缺省"GeometryPoint"。如：geometryType=GeometryPolygon。
     */	
	geometryType: "",
	
    /**
     * APIProperty: layers
     * {String} 执行Identify操作的图层 有三种方式定义哪 些图层执行Identify操作：
	 * top:仅指定位置最上层的图层。
	 * visible:在指定位置的所有可见图层。
	 * all:在指定位置的所有图层。
	 * 缺省为"top"即最顶层图层。如：layers= visible:2,5。
     */	
	layers: "",
	
    /**
     * APIProperty: imageDisplay
     * {<Geo.Filter>} 地图的屏幕图像显示参数（width, height和 dpi）。mapExtent和imageDisplay参数由服务用于决定当前范围的图层可见性。它们也用于计算地图上的基于屏幕像素值的搜索距离容差。如：imageDisplay=600,550,96。
     */
	imageDisplay: "",
    
    /**
     * APIProperty: returnGeometry
     * {String} 如果为true，结果集中包含每个结果相关的几何对象，缺省为“true” 。如：returnGeometry=false。
     */
    returnGeometry: true,	
    /**
     * APIProperty: layerDefs
     * {String} 附加参数，允许在地图输出中分别对各个图层进行条件过滤，通过对这些图层指定表达方式的方式。每个图层的过滤器表达示应用于选择显示在地图中的图层的相关要素。如：0:POP2000 > 1000000;5:AREA > 100000 (文本形式){"0":"POP2000 > 1000000","5":"AREA > 100000"} (JSON形式)。
     */	
	layerDefs: "",
	
	/**
	 * Constructor: Geo.Query.MapServiceIdentifyParameters
	 * 构造函数。
	 */	
	initialize: function(){
	},
    	
	CLASS_NAME: "Geo.Query.MapServiceIdentifyParameters"
});
/**
 * Class: Geo.Query.MapServiceIdentifyResult
 * Identify空间查询结果操作对象。本对象须结合Geo.Query.MapServiceIdentify对象使用，Geo.Query.MapServiceIdentify对象的query方法的第二个参数返回的结果。支持服务：OGC_Geo_MapService_Rest。
 */
Geo.Query.MapServiceIdentifyResult = Geo.Class({
	
    /**
     * APIProperty: layerId
     * {Number} 图层ID。
     */
	layerId: null,
	
    /**
     * APIProperty: layerName
     * {String} 图层名称
     */	
	layerName: "",
	
    /**
     * APIProperty: displayFieldName
     * {String} 字段名称：
     */	
	displayFieldName: "",
	
    /**
     * APIProperty: feature
     * {<Geo.Feature.Vector>} 要素对象
     */
	feature: null,
	
	 /**
     * APIProperty: geometryType
     * {String} 几何对象类型 ("GeometryPoint" / "GeometryMultiPoint" / "GeometryPolyline" / "GeometryPolygon" / "GeometryEnvelope")，缺省"GeometryPoint"。如：geometryType=GeometryPolygon。
     */	
	geometryType: "",
	
	/**
	 * Constructor: Geo.Query.MapServiceIdentifyResult
	 * 构造函数。
	 */	
	initialize: function(){
	},
    
    	
	CLASS_NAME: "Geo.Query.MapServiceIdentifyResult"
});
/**
 * Class: Geo.Query.MapServiceDataFeatures
 * MapService要素查询，查询指定图层中的单个要素信息。
 */
Geo.Query.MapServiceDataFeatures = Geo.Class({
	
   /**
	 * APIProperty: url
	 * {String} 服务地址。
	 */
	url: null,
	
	/**
	 * Constructor: Geo.Query.MapServiceDataFeatures
	 * 构造函数。
	 * 
	 * Parameters:
	 * url - {String} 服务地址
	 * options - {Object} 可选项，目前没有可用参数
	 */	
	initialize: function(url,options){
		this.url = url;
		this.format = new OpenLayers.Format.JSON();
		this.jsonp = new OpenLayers.Protocol.Script({
			format:this.format
		});
		OpenLayers.Util.extend(this, options);
	},
	
	/**
	 * APIMethod: query
	 * 查询
	 * 
	 * Parameters:
	 * queryParameter - {<Geo.Query.MapServiceDataFeaturesParameters>}查询参数
	 * successFn - {Function} 请求成功的回调函数。
	 * failFn - {Function} 请求失败的回调函数。
	 *      (code)
	 *      例如：
 	 *     	var queryObj = new Geo.Query.MapServiceDataFeatures("http://192.168.42.75:7777/wkDT/MapServer");
	 *		var params = new Geo.Query.MapServiceDataFeaturesParameters();
	 *		params.layerOrTableId="4",
	 *		params.featureId="3",
	 *		queryObj.query(params,function(result) {
	 *			vectorLayer.addFeatures(result.feature);	
	 *		});
	 *      (end)
	 */
	query: function(queryParameter ,successFn, failFn) {
		if(!queryParameter.layerOrTableId){
			return;
		}
		if(!queryParameter.featureId){
			return;
		}
		this.accessUrl = this.url + "/" + queryParameter.layerOrTableId + "/" + queryParameter.featureId;
		var DEFAULT_PARAMS = {
			f:"json"
		}
		var params = queryParameter;
		OpenLayers.Util.applyDefaults(
	        params, DEFAULT_PARAMS
	    )
	    this.jsonp.createRequest(this.accessUrl,params, OpenLayers.Function.bind(function(result){
	    	if(result.error) {
				if(failFn){
					failFn(result.error);
	    		}
				return;
			}
			var feature = null;
			var featuresResult = new Geo.Query.MapServiceDataFeaturesResult();
			if(result.feature.geometry){
				feature = this._getFeatures(result);
			}
			featuresResult.feature = feature;
			successFn(featuresResult);
		},this));
	},
	
	_getParamsFromQueryParameter: function(queryParameter) {
		var params = {};
		for(var param in queryParameter) {
			if(queryParameter[param] !== null) {
				params[param] = queryParameter[param];
			}
		}
		if(params.geometry instanceof Geo.Geometry || params.geometry instanceof Geo.Bounds) {
			params.geometry = this._getGeometryRepresentation(params.geometry);
		}
		
		if(params.spatialRel && params.serviceType == "ArcgisRest") {
			params.spatialRel = "esri" + params.spatialRel;
		}
		if(params.geometryType && params.serviceType == "ArcgisRest") {
			params.geometryType = "esri" + this._getGeometryType(params.geometry);
		}
		delete params.serviceType;
		return params;
	},
	
	/**
	 * Method: 得到与该几何信息相对应的arcgis几何类型
	 * 
	 * Parameters:
	 * {Object} geometry
	 */
	_getGeometryType: function(geometry) {
		var name = geometry.CLASS_NAME;
		var geometryType = "";
		switch(name) {
			case "OpenLayers.Bounds": 
				geometryType = "GeometryEnvelope";
				break;
			case "OpenLayers.Geometry.Point":
				geometryType = "GeometryPoint";
				break;
			case "OpenLayers.Geometry.MultiLineString":
				geometryType = "GeometryPolyline";
				break;	
			case "OpenLayers.Geometry.Polygon":
				geometryType = "GeometryPolygon";
				break;	
		}
		return geometryType;
	},
	
	/**
	 * Method: 得到arcgis可以理解的几何表示法
	 * 
	 * Parameters:
	 * {Object} geometry
	 */
	_getGeometryRepresentation: function(geometry) {
		var name = geometry.CLASS_NAME;
		var geometryStr = "";
		switch(name) {
			case "OpenLayers.Bounds": 
				geometryStr = geometry.toBBOX();
				break;
			case "OpenLayers.Geometry.Point":
				geometryStr = geometry.x + "," + geometry.y;
				break;
			case "OpenLayers.Geometry.Polygon":
				var json = this.extract['geometry'].apply(this, [geometry]);
				var jsonObj = {rings:json.coordinates};
				geometryStr = this.format.write(jsonObj);
				break;	
			case "OpenLayers.Geometry.MultiLineString":
				var json = this.extract['geometry'].apply(this, [geometry]);
				var jsonObj = {paths:json.coordinates};
				geometryStr = this.format.write(jsonObj);
				break;		
		}
		return geometryStr;
	},
	
	/**
     * Property: extract
     * Object with properties corresponding to the GeoJSON types.
     *     Property values are functions that do the actual value extraction.
     */
    extract: { 
        'geometry': function(geometry) {
            if (geometry == null) {
                return null;
            }                     
            var geometryType = geometry.CLASS_NAME.split('.')[2];
            var data = this.extract[geometryType.toLowerCase()].apply(this, [geometry]);
            var json;
            json = {
                "type": geometryType,
                "coordinates": data
            };
            return json;
        },

        'point': function(point) {
            return [point.x, point.y];
        },

        'multipoint': function(multipoint) {
            var array = [];
            for(var i=0, len=multipoint.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [multipoint.components[i]]));
            }
            return array;
        },
        
        'linestring': function(linestring) {
            var array = [];
            for(var i=0, len=linestring.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [linestring.components[i]]));
            }
            return array;
        },

        'multilinestring': function(multilinestring) {
            var array = [];
            for(var i=0, len=multilinestring.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [multilinestring.components[i]]));
            }
            return array;
        },
        
        'polygon': function(polygon) {
            var array = [];
            for(var i=0, len=polygon.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [polygon.components[i]]));
            }
            return array;
        }
    },
	
	/**
	 * Method: 获取查询结果的json表示法
	 * 
	 * Parameters:
	 * {Object} result
	 */
	_getJson: function(result) {
		var resultObj = this.format.read(result.responseText);
		return resultObj;
	},
	
	/**
	 * Method: 获取查询结果的要素
	 * 
	 * Parameters:
	 * {Object} result
	 */
	_getFeatures:function(result) {
		var feature = null;
		if(result.feature) {
			var olGeometry = this._getGeometry(result.feature.geometry);
			var attributes = this._getAttribute(result.feature.attributes);
			var f = new OpenLayers.Feature.Vector(olGeometry,attributes);
			feature = f;
		}
		return feature;
	},
	
	/**
	 * Method: 得到openlayers几何对象
	 * 
	 * Parameters:
	 * {Object} geometry
	 */
	_getGeometry: function(geometry) {
		for(var pro in geometry) {
			//TODO：服务组封装的地图服务返回的geometry节点中包含spatialReference,加了这个判断，初步估计服务组封装的查询服务的返回结果结构有问题
			if("spatialReference" == pro) {
				return;
			}
			if(geometry.hasOwnProperty("x") && geometry.hasOwnProperty("y")) {
				var geometry = new OpenLayers.Geometry.Point(geometry["x"],geometry["y"]);
			}else if(geometry.hasOwnProperty("xmin") && geometry.hasOwnProperty("ymin")&& geometry.hasOwnProperty("xmax")&& geometry.hasOwnProperty("ymax"))
			{
				 var geometry = new OpenLayers.Bounds(geometry.xmin,geometry.ymin,geometry.xmax,geometry.ymax).toGeometry();
			}else {
				var geometry = this._geometryType[pro](geometry[pro]);
			}
			return geometry;
		}
	},
	
	/**
	 * Method: 得到要素的属性信息
	 * 
	 * Parameters:
	 * {Object} geometry
	 */
	_getAttribute: function(attrs) {
		var attributes = {};
		if(attrs && !(attrs instanceof Array)) {
			attrs = [attrs];
		}
		if(attrs instanceof Array) {
			for(var i = 0; i < attrs.length; i++) {
				 OpenLayers.Util.applyDefaults(attributes,attrs[i]);
			}
		}
		return attributes;
	},
	
	/**
	 * Method: 将几何信息的json表示转换成
	 * 
	 * Parameters:
	 * {Object} geometry
	 */
	_geometryType: {
		"points": function(geometry) {
			var points = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var point = new OpenLayers.Geometry.Point(geometry[i][0], geometry[i][1]);
					points.push(point);
				}
			}
			return points;
		},
		"paths": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LineString(ps);
					lines.push(line);
				}
				var paths = new OpenLayers.Geometry.MultiLineString(lines);
			}
			return paths;
		},
		"rings": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LinearRing(ps);
					lines.push(line);
				}
				var Polygon = new OpenLayers.Geometry.Polygon(lines);
			}
			return Polygon;
		}
	},
    	
	CLASS_NAME: "Geo.Query.MapServiceDataFeatures"
});
/**
 * Class: Geo.Query.MapServiceDataFeaturesParameters
 * DataFeatures要素查询参数，rest服务的地图服务要素查询参数。本对象须结合Geo.Query.MapServiceDataFeatures对象使用，Geo.Query.MapServiceDataFeatures对象的query方法的第一个参数传入是本对象。支持服务：OGC_Geo_MapService_Rest。
 */
Geo.Query.MapServiceDataFeaturesParameters = Geo.Class({
	
    /**
     * APIProperty: layerOrTableId
     * {Number} 图层或表 id。
     */
	layerOrTableId: 0,
	
    /**
     * APIProperty: featureId
     * {Number} 要素id
     */	
	featureId: 0,
	
	/**
	 * Constructor: Geo.Query.MapServiceDataFeaturesParameters
	 * 构造函数。
	 */	
	initialize: function(){
	},
    	
	CLASS_NAME: "Geo.Query.MapServiceDataFeaturesParameters"
});
/**
 * Class: Geo.Query.MapServiceDataFeaturesResult
 * DataFeatures要素查询结果操作对象。本对象须结合Geo.Query.MapServiceDataFeatures对象使用，Geo.Query.MapServiceDataFeatures对象的query方法的第二个参数返回的结果。支持服务：OGC_Geo_MapService_Rest。
 */
Geo.Query.MapServiceDataFeaturesResult = Geo.Class({
	
	 /**
     * APIProperty: feature
     * {<Geo.Vector.Feature>} 要素对象
     */
	feature: null,
	/**
	 * Constructor: Geo.Query.MapServiceDataFeaturesResult
	 * 构造函数。
	 */	
	initialize: function(){
	},
     	
	CLASS_NAME: "Geo.Query.MapServiceDataFeaturesResult"
});/**
 * Class: Geo.Query.MapServiceFind
 * MapService地图搜索，在一或多个图层中，查询搜索指定文本。
 */
Geo.Query.MapServiceFind = Geo.Class({
	
   /**
	 * APIProperty: url
	 * {String} 服务地址。
	 */
	url: null,
	
	/**
	 * Constructor: Geo.Query.MapServiceFind
	 * 构造函数。
	 * 
	 * Parameters:
	 * url - {String} 服务地址
	 * options - {Object} 可选项，目前没有可用参数
	 */	
	initialize: function(url,options){
		this.url = url + "/find";
		this.format = new OpenLayers.Format.JSON();
		this.jsonp = new OpenLayers.Protocol.Script({
			format:this.format
		});
		OpenLayers.Util.extend(this, options);
	},
	
	/**
	 * APIMethod: query
	 * 查询
	 * 
	 * Parameters:
	 * queryParameter - {<Geo.Query.MapServiceFindParameters>}查询参数
	 * successFn - {Function} 请求成功的回调函数。
	 * failFn - {Function} 请求失败的回调函数。
	 *      (code)
	 *      例如：
 	 *     	var queryObj = new Geo.Query.MapServiceFind("http://192.168.42.75:7777/wkDT/MapServer/find");
	 *		var params = new Geo.Query.MapServiceFindParameters();
	 *		params.searchText = "1";
	 *		params.searchFields = "NAME";
	 * 		params.layers = "0,1,2,4";
	 *		params.returnGeometry = "true";
	 *		queryObj.query(params,function(result) {
	 *		    for(var i = 0,len = result.length; i < len; i++){
	 *	    		vectorLayer.addFeatures(result[i].feature);
	 *	    	}	
	 *		});
	 *      (end)
	 */
	query: function(queryParameter ,successFn, failFn) {
		var params = this._getParamsFromQueryParameter(queryParameter);	
		var DEFAULT_PARAMS = {
			f:"json",
			pretty:true
		}
		OpenLayers.Util.applyDefaults(
	        params, DEFAULT_PARAMS
	    )
	    this.jsonp.createRequest(this.url,params, OpenLayers.Function.bind(function(result){
	    	if(result.error) {
				if(failFn){
					failFn(result.error);
	    		}
				return;
			}
			var results = this._getResult(result);
			successFn(results);
		},this));
	},
	
	/**
	 * Method: 获取查询结果的json表示法
	 * 
	 * Parameters:
	 * {Object} result
	 */
	_getResult : function(result){
		var results = [];
		if(result.results) {
			for(var i = 0,j = result.results.length; i < j; i++) {
				var olGeometry = this._getGeometry(result.results[i].geometry);
				var attributes = this._getAttribute(result.results[i].attributes);
				var feature = new OpenLayers.Feature.Vector(olGeometry,attributes);
				var identifyResult = new Geo.Query.MapServiceIdentifyResult();
				identifyResult.layerId = result.results[i].layerId;
				identifyResult.layerName = result.results[i].layerName;
				identifyResult.displayFieldName = result.results[i].displayFieldName;
				identifyResult.feature = feature;
				identifyResult.geometryType = result.results[i].geometryType;
				identifyResult.foundFieldName = result.results[i].foundFieldName;
				results.push(identifyResult);
			}
		}
		return results;
	},
	
	_getParamsFromQueryParameter: function(queryParameter) {
		var params = {};
		for(var param in queryParameter) {
			if(queryParameter[param] !== null) {
				params[param] = queryParameter[param];
			}
		}
		
		if(params.geometry instanceof Geo.Geometry || params.geometry instanceof Geo.Bounds) {
			params.geometry = this._getGeometryRepresentation(params.geometry);
		}
		
		if(params.spatialRel && params.serviceType == "ArcgisRest") {
			params.spatialRel = "esri" + params.spatialRel;
		}
		if(params.geometryType && params.serviceType == "ArcgisRest") {
			params.geometryType = "esri" + this._getGeometryType(params.geometry);
		}
		delete params.serviceType;
		return params;
	},
	
	/**
	 * Method: 得到与该几何信息相对应的arcgis几何类型
	 * 
	 * Parameters:
	 * {Object} geometry
	 */	
	_getGeometryType: function(geometry) {
		var name = geometry.CLASS_NAME;
		var geometryType = "";
		switch(name) {
			case "OpenLayers.Bounds": 
				geometryType = "GeometryEnvelope";
				break;
			case "OpenLayers.Geometry.Point":
				geometryType = "GeometryPoint";
				break;
			case "OpenLayers.Geometry.MultiLineString":
				geometryType = "GeometryPolyline";
				break;	
			case "OpenLayers.Geometry.Polygon":
				geometryType = "GeometryPolygon";
				break;	
		}
		return geometryType;
	},
	
	/**
	 * Method: 得到arcgis可以理解的几何表示法
	 * 
	 * Parameters:
	 * {Object} geometry
	 */		
	_getGeometryRepresentation: function(geometry) {
		var name = geometry.CLASS_NAME;
		var geometryStr = "";
		switch(name) {
			case "OpenLayers.Bounds": 
				geometryStr = geometry.toBBOX();
				break;
			case "OpenLayers.Geometry.Point":
				geometryStr = geometry.x + "," + geometry.y;
				break;
			case "OpenLayers.Geometry.Polygon":
				var json = this.extract['geometry'].apply(this, [geometry]);
				var jsonObj = {rings:json.coordinates};
				geometryStr = this.format.write(jsonObj);
				break;	
			case "OpenLayers.Geometry.MultiLineString":
				var json = this.extract['geometry'].apply(this, [geometry]);
				var jsonObj = {paths:json.coordinates};
				geometryStr = this.format.write(jsonObj);
				break;		
		}
		return geometryStr;
	},
	
	/**
     * Property: extract
     * Object with properties corresponding to the GeoJSON types.
     *     Property values are functions that do the actual value extraction.
     */
    extract: { 
        'geometry': function(geometry) {
            if (geometry == null) {
                return null;
            }                     
            var geometryType = geometry.CLASS_NAME.split('.')[2];
            var data = this.extract[geometryType.toLowerCase()].apply(this, [geometry]);
            var json;
            json = {
                "type": geometryType,
                "coordinates": data
            };
            return json;
        },

        'point': function(point) {
            return [point.x, point.y];
        },

        'multipoint': function(multipoint) {
            var array = [];
            for(var i=0, len=multipoint.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [multipoint.components[i]]));
            }
            return array;
        },
        
        'linestring': function(linestring) {
            var array = [];
            for(var i=0, len=linestring.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [linestring.components[i]]));
            }
            return array;
        },

        'multilinestring': function(multilinestring) {
            var array = [];
            for(var i=0, len=multilinestring.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [multilinestring.components[i]]));
            }
            return array;
        },
        
        'polygon': function(polygon) {
            var array = [];
            for(var i=0, len=polygon.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [polygon.components[i]]));
            }
            return array;
        }
    },
	
	/**
	 * Method: 得到openlayers几何对象
	 * 
	 * Parameters:
	 * {Object} geometry
	 */		
	_getGeometry: function(geometry) {
		for(var pro in geometry) {
			//TODO：服务组封装的地图服务返回的geometry节点中包含spatialReference,加了这个判断，初步估计服务组封装的查询服务的返回结果结构有问题
			if("spatialReference" == pro) {
				return;
			}
			if(geometry.hasOwnProperty("x") && geometry.hasOwnProperty("y")) {
				var geometry = new OpenLayers.Geometry.Point(geometry["x"],geometry["y"]);
			}else if(geometry.hasOwnProperty("xmin") && geometry.hasOwnProperty("ymin")&& geometry.hasOwnProperty("xmax")&& geometry.hasOwnProperty("ymax"))
			{
				 var geometry = new OpenLayers.Bounds(geometry.xmin,geometry.ymin,geometry.xmax,geometry.ymax).toGeometry();
			}else {
				var geometry = this._geometryType[pro](geometry[pro]);
			}
			return geometry;
		}
	},
	
	/**
	 * Method: 得到要素的属性信息
	 * 
	 * Parameters:
	 * {Object} geometry
	 */	
	_getAttribute: function(attrs) {
		var attributes = {};
		if(attrs && !(attrs instanceof Array)) {
			attrs = [attrs];
		}
		if(attrs instanceof Array) {
			for(var i = 0; i < attrs.length; i++) {
				 OpenLayers.Util.applyDefaults(attributes,attrs[i]);
			}
		}
		return attributes;
	},
	
	/**
	 * Method: 将几何信息的json表示转换成
	 * 
	 * Parameters:
	 * {Object} geometry
	 */		
	_geometryType: {
		"points": function(geometry) {
			var points = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var point = new OpenLayers.Geometry.Point(geometry[i][0], geometry[i][1]);
					points.push(point);
				}
			}
			return points;
		},
		"paths": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LineString(ps);
					lines.push(line);
				}
				var paths = new OpenLayers.Geometry.MultiLineString(lines);
			}
			return paths;
		},
		"rings": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LinearRing(ps);
					lines.push(line);
				}
				var Polygon = new OpenLayers.Geometry.Polygon(lines);
			}
			return Polygon;
		}
	},
	
	CLASS_NAME: "Geo.Query.MapServiceFind"
});
/**
 * Class: Geo.Query.MapServiceFindParameters
 * Find搜索参数，rest服务的搜索参数。本对象须结合Geo.Query.MapServiceFind对象使用，Geo.Query.MapServiceFind对象的query方法的第一个参数传入的是本对象。支持服务：OGC_Geo_MapService_Rest。
 */
Geo.Query.MapServiceFindParameters = Geo.Class({
	
    /**
     * APIProperty: searchText
     * {String} 搜索文本。本参数值是跨图层和用户指定字段的文本。如：searchText=Los.
     */
	searchText: "",
	
    /**
     * APIProperty: contains
     * {Boolean} 输出数据格式，缺省为“true” 。如：contains=false
     */	
	contains: true,
	
	/**
     * APIProperty: searchFields
     * {String} 要搜索的字段的名称。字段以一个逗号分隔的图层资源中返回的字段列表的形式定义，缺省搜索多个字段。如：searchFields=AREANAME,SUB_REGION
     */	
	searchFields: "",
	
	/**
     * APIProperty: layers
     * {String} 执行Find操作的多个图层。以逗号分隔的地图服务根资源中返回的图层ID列表指定。如：layers=2,4,7
     */	
	layers: "",
	
	/**
     * APIProperty: returnGeometry
     * {Boolean} 如果为true，结果集包含每个结果相关的几何对象，缺省为“true”。如：returnGeometry=false
     */	
	returnGeometry: true,
	
	/**
	 * Constructor: Geo.Query.MapServiceFindParameters
	 * 构造函数。
	 */	
	initialize: function(){
	},
    	
	CLASS_NAME: "Geo.Query.MapServiceFindParameters"
});
/**
 * Class: Geo.Query.MapServiceFindResult
 * Find文本搜索结果操作对象。本对象须结合Geo.Query.MapServiceFind对象使用，Geo.Query.MapServiceFind对象的query方法的第二个参数返回的结果。支持服务：OGC_Geo_MapService_Rest。
 */
Geo.Query.MapServiceFindResult = Geo.Class({
	
    /**
     * APIProperty: layerId
     * {Number} 图层ID。
     */
	layerId: null,
	
    /**
     * APIProperty: layerName
     * {String} 图层名称
     */	
	layerName: "",
	
    /**
     * APIProperty: displayFieldName
     * {String} 字段名称：
     */	
	displayFieldName: "",
	
    /**
     * APIProperty: feature
     * {Geo.Vector.Feature} 要素对象
     */
	feature: null,
	
	 /**
     * APIProperty: geometryType
     * {String} 几何对象类型 ("GeometryPoint" / "GeometryMultiPoint" / "GeometryPolyline" / "GeometryPolygon" / "GeometryEnvelope")，缺省"GeometryPoint"。如：geometryType=GeometryPolygon。
     */	
	geometryType: "",
	
	 /**
     * APIProperty: foundFieldName
     * {String} 查找的字段名称
     */
	foundFieldName: "",
	
	/**
	 * Constructor: Geo.Query.MapServiceFindResult
	 * 构造函数。
	 */	
	initialize: function(){
	},
    
    	
	CLASS_NAME: "Geo.Query.MapServiceFindResult"
});
/**
 * Class: Geo.Query.GeoCodingQuery
 * 地址匹配查询类。默认版本是1.0.0。
 *
 * 例子:
 * (code)
 *     	var coding = new Geo.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
 *			version:"1.1.0"
 *		});
 * (end)
 */
Geo.Query.GeoCodingQuery = function(url, options) {
    options = OpenLayers.Util.applyDefaults(
        options, Geo.Query.GeoCodingQuery.DEFAULTS
    );
    var cls = Geo.Query.GeoCodingQuery["v"+options.version.replace(/\./g, "_")];
    if(!cls) {
        throw "不支持的地址匹配服务版本: " + options.version;
    }
    return new cls(url, options);
};

Geo.Query.GeoCodingQuery.DEFAULTS = {
    "version": "1.0.0"
};/**
 * Class: Geo.Query.GeoCodingQuery.v1
 * 地址匹配服务查询接口的抽象类,抽象类不能实例化。
 */
Geo.Query.GeoCodingQuery.v1 = Geo.Class({
	
	/**
	 * APIProperty: version
	 * 服务版本，默认值是"1.0.0"。
	 */
	version:"1.0.0",
	
	/**
     * APIProperty: url
     * {String}服务地址。
     */
	url: null,
	
	/**
     * Constructor: Geo.Query.GeoCodingQuery.v1
     * Geo.Query.GeoCodingQuery.v1类的构造函数。
     *
     * Parameters:
     * url - {String} 
     * options - {Object} 相关属性的设置项，可选。
     *    version  {String} 服务版本。
     */
	initialize: function(url, options){
		this.url = url;
		OpenLayers.Util.extend(this,options);
		this.format = new Geo.Format.JSON();
	},
	
	/**
	 * Method: getCommonParams
	 * 获取公共的参数
	 * 
	 * Parameters:
	 * 	options
	 */
	getCommonParams: function(options) {
		var params = {
			request: "GetCategory",
			service:"GeoCoding",
			version:this.version,
			output:"json"
		};
		OpenLayers.Util.extend(params,options);
		return params;
	},
	
	/**
	 * APIMethod: getCategoryByName
	 * 根据类别名称查询类别及子类别。
	 * 
	 * Parameters:
	 * name - {String} 类别名称。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：GetCategory.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 */
	getCategoryByName:function(name,successFn,failFn) {
		var params = this.getCommonParams();
		if(typeof name === "string" && name.length !== 0) {
			params.categoryName = name;
		}
		var failFn = failFn || this.failFn;
		OpenLayers.Function.bind(this._requestCategory,this)(params,successFn,failFn);
	},

	/**
	 * APIMethod: getCategoryByCode
	 * 根据类别编码查询类别及子类别。
	 * 
	 * Parameters:
	 * code - {Number}类别编码。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：GetCategory.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * 示例：根据范围和地址进行查询：
	 * (code)
	 * 		var coding = new Geo.Query.GeoCodingQuery("http://192.168.42.76:7021/GeoCoding/geocoding");
	 * 		coding.getCategoryByCode(1012001008000000,
	 * 		function(GeoCoding){},function(){});
	 * (end)
	 */
	getCategoryByCode: function(code,successFn,failFn) {
		var params = this.getCommonParams();
		if(typeof code === "number") {
			params.categoryCode = code;
		}
		OpenLayers.Function.bind(this._requestCategory,this)(params,successFn,failFn);
	},
	
	/**
	 * APIMethod: getAllCategory
	 * 查询所有类别信息。
	 * 
	 * Parameters:
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：GetCategory.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 */
	getAllCategory: function(successFn,failFn) {
		var params = this.getCommonParams();
		OpenLayers.Function.bind(this._requestCategory,this)(params,successFn,failFn);
	},
	
	/**
	 * Method: _requestCategory
	 * 执行get请求操作
	 * 
	 * Parameters:
	 * 	params
	 *  successFn
	 *  failFn
	 */
	_requestCategory:function(params,successFn,failFn) {
		var failFn = failFn || this.failFn;
		OpenLayers.loadURL(this.url,params,this,function(result) {
			try{
				var category = this.format.read(result.responseText);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(category);
		},failFn);
	},
	
	/**
	 * Method: _analysis_GeoCodeResult
	 * 解析返回的结果，getCoder接口查询结果第一级结构
	 * 
	 * Parameters:
	 * 	json
	 */
	_analysis_GeoCodeResult: function(json) {
		var queryResult = {
			status:json.status
		};
		switch(json.status) {
			case "OK":
				var results = json.results;
				if(results) {
					queryResult.results = this._analysis_GeoCodeResult_results(results);
				}
			break;
			case "INVALID_REQUEST":
				
			
			case "NO_RESULTS":
				
			
			case "UNKNOWN_ERROR":
				
			break;
		}
		return queryResult;
	},
	
	/**
	 * Method: _analysis_GeoCodeResult_results
	 * getCoder接口查询结果第二级结构
	 * 
	 * Parameters:
	 * 	results
	 */
	_analysis_GeoCodeResult_results: function(results) {
		var aresults = [];
		//如果存在results节点，那么它就是一个数组
		if(results instanceof Array) {
			for(var i = 0,j = results.length; i < j;i++) {
				var result = {};
				result.requestKeyWord = results[i].requestKeyWord;
				if(results[i].errorCorrectionTips) {
					result.errorCorrectionTips = results[i].errorCorrectionTips;
				}
				//匹配结果总数
				result.count = results[i].count;
				if(results[i].result) {
					result.result = this._analysis_GeoCodeResult_results_result(results[i].result);
				}
				aresults.push(result);
			}
			return aresults;
		}
	},
	
	/**
	 * Method: _analysis_GeoCodeResult_results
	 * getCoder接口查询结果第三级结构
	 * 
	 * Parameters:
	 * 	result
	 */
	_analysis_GeoCodeResult_results_result: function(result) {
		var addresss = [];
		for(var i = 0,j = result.length; i < j;i++) {
			var address = {};
			//匹配结果的类型
			address.resultType = result[i].resultType;
			//匹配地址是否为精确地址
			address.precise = result[i].precise;
			//该条匹配结果是否为摘要信息
			address.isBrief = result[i].isBrief;
			//匹配结果与请求关键字的匹配度，值域为1到100，值越大匹配度就越高
			address.score = result[i].score;
			if(address.isBrief == false) {
				address.addressComponent = this._analysis_GeoCodeResult_results_result_address(result[i].addressComponent,address.resultType);
			}
			address.poiArray = this._analysispoiArray(result[i].poiArray);
			if(result[i].location) {
				address.location = result[i].location;
			}
			//TODO:referenceAddressArray
			if(address.precise == 0) {
				address.referenceAddressArray = result[i].referenceAddressArray;
			}
			addresss.push(address);
		}
		return addresss;
	},
	
	/**
	 * Method: _analysis_GeoCodeResult_results_result_address
	 * getCoder接口查询结果第四级结构，当前匹配结果的地址详细信息
	 * 
	 * Parameters:
	 * 	addressComponent
	 *	resultType
	 */
	_analysis_GeoCodeResult_results_result_address:function(addressComponent,resultType) {
		var addressC = {
			country: addressComponent.country
		};
		//行政区划的第二级-省、直辖市、自治区
		if(addressComponent.province) {
			addressC.province = addressComponent.province;
		}
		//行政区划第三级-市
		if(addressComponent.city) {
			addressC.city = addressComponent.city;
		}
		//行政区划第四级-区或县
		if(addressComponent.district) {
			addressC.district = addressComponent.district;
		}
		//行政区划第五级-乡镇
		if(addressComponent.town) {
			addressC.town = addressComponent.town;
		}
		if(addressComponent.street) {
			addressC.street = {
				name:addressComponent.street.name
			};
			var streetGeometry = null;
			if(resultType === "street") {
				//TODO:需要增加对线的json串的解析
				if(addressComponent.street.geometry) {
					var sgeometry = addressComponent.street.geometry;//this.format.read(addressComponent.street.geometry);
				}
				
				if(sgeometry["paths"]) {
					//TODO:这个需要做测试，这里的几何信息一般来说是线，不过也有可能不是线
					streetGeometry = this._getGeometry(sgeometry);
					addressC.street.geometry = streetGeometry;
				}else if(sgeometry["rings"]){
					streetGeometry = this._getGeometry(sgeometry);
					addressC.street.geometry = streetGeometry;
				}else if(sgeometry["x"] && sgeometry["y"]){
					streetGeometry = this._getGeometry(sgeometry);
					addressC.street.geometry = streetGeometry;
				}
			}
		}
		if(addressComponent.streetNumber) {
			addressC.streetNumber = addressComponent.streetNumber;
		}
		if(addressComponent.buildingNumber) {
			addressC.buildingNumber = addressComponent.buildingNumber;
		}
		if(resultType === "adminArea") {
			//当前匹配最小级行政区划的空间信息,本属性需要被转换成Geo.Geometry类型
			var areaGeometry = null;
			if(addressComponent.geometry) {
				var geometry = addressComponent.geometry;//this.format.read(addressComponent.geometry);
				//如果它是面，我们解析它
				if(geometry["rings"]) {
					areaGeometry = this._getGeometry(geometry);
					addressC.geometry = areaGeometry;
				}else if(geometry["paths"]) {
					areaGeometry = this._getGeometry(geometry);
					addressC.geometry = areaGeometry;
				}else if(typeof geometry["x"] === "number" && typeof geometry["y"] === "number") {
					addressC.geometry = this._getGeometry(geometry);
				}
			}
			//当前匹配最小级行政区划下属的其它行政区划名称，多个以逗号隔开
			if(addressComponent.subordinate) {
				addressC.subordinate = addressComponent.subordinate;
			}
			//行政区的邮政编码
			if(addressComponent.zipCode) {
				addressC.zipCode = addressComponent.zipCode;
			}
			//电话长途区划
			if(addressComponent.callingCode) {
				addressC.callingCode = addressComponent.callingCode;
			}
		}
		return addressC;
	},
	
	/**
	 * Method: _analysispoiArray
	 * result节点的儿子节点
	 * 
	 * Parameters:
	 * 	poiArray
	 */
	_analysispoiArray: function(poiArray) {
		var pointFeatures = [];
		for(var i = 0,j = poiArray.length; i < j;i++) {
			var point = {};
			for(var pro in poiArray[i]) {
				point[pro] = poiArray[i][pro];
			}
			pointFeatures.push(point);
		}
		return pointFeatures;
	},
	
	/**
	 * Method: _analysisLocation
	 * result节点的儿子节点
	 * 
	 * Parameters:
	 * 	location
	 */
	_analysisLocation:function(location) {
		
	},
	
	/**
	 * Method: _getGeometry
	 * 得到openlayers几何对象
	 * 
	 * Parameters:
	 * {Object} geometry
	 */
	_getGeometry: function(geometry) {
		for(var pro in geometry) {
			//TODO：服务组封装的地图服务返回的geometry节点中包含spatialReference,加了这个判断，初步估计服务组封装的查询服务的返回结果结构有问题
			if("spatialReference" == pro) {
				return;
			}
			if(geometry.hasOwnProperty("x") && geometry.hasOwnProperty("y")) {
				var geometry = new OpenLayers.Geometry.Point(geometry["x"],geometry["y"]);
			}else if(geometry.hasOwnProperty("xmin") && geometry.hasOwnProperty("ymin")&& geometry.hasOwnProperty("xmax")&& geometry.hasOwnProperty("ymax"))
			{
				var geometry = new OpenLayers.Bounds(geometry.xmin,geometry.ymin,geometry.xmax,geometry.ymax).toGeometry();
				//TODO:需要增加多点类型
			}else {
				var geometry = this._geometryType[pro](geometry[pro]);
			}
			return geometry;
		}
	},
	
	/**
	 * Method: _geometryType
	 * 将几何信息的json表示转换成
	 * 
	 * Parameters:
	 * {Object} geometry
	 */	
	_geometryType: {
		"points": function(geometry) {
			var points = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var point = new OpenLayers.Geometry.Point(geometry[i][0], geometry[i][1]);
					points.push(point);
				}
			}
			return points;
		},
		"paths": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LineString(ps);
					lines.push(line);
				}
				var paths = new OpenLayers.Geometry.MultiLineString(lines);
			}
			return paths;
		},
		"rings": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LinearRing(ps);
					lines.push(line);
				}
				var Polygon = new OpenLayers.Geometry.Polygon(lines);
			}
			return Polygon;
		}
	},
	
	/**
     * APIProperty: failFn
     * {Function} 请求失败的回调函数，可以用自定义函数覆盖。
     */
	failFn: function(error) {
		if(typeof error == "string") {
			alert(error);
		}
		alert("对不起，查询请求失败！请检查地址匹配服务是否正常运行。\n" + 
				"当前服务地址为：" + this.url);
	},

	CLASS_NAME: "Geo.Query.GeoCodingQuery.v1" 
});/**
 * Class: Geo.Query.GeoCodingQuery.v1_0_0 
 * 地址匹配服务查询接口1.0.0版本，本类可以实现如下功能：
 *   1.根据地址(例如：湖北省武汉市江夏区武大园一路9号)获取地理坐标(例如纬度29.58123 和经度113.41321)或者执行反向转换。
 *   2.根据地理坐标获取地址信息。
 *   3.可以根据地名地址分类名称或者地名地址分类编码获取地名地址分类信息。
 *   说明：本类提供的五个接口的成功回调的返回内容存在两种情况：第一：是返回json对象，第二：是返回xml串。如果返回xml串，表示服务器内部发生错误或者客户端解析服务返回的结果时，发生了错误。
 *
 *	Inherits from:
 *  	- <Geo.Query.GeoCodingQuery.v1>
 */
Geo.Query.GeoCodingQuery.v1_0_0 = Geo.Class(Geo.Query.GeoCodingQuery.v1, {
	
	/**
     * Constructor: Geo.Query.GeoCodingQuery.v1_0_0
     * Geo.Query.GeoCodingQuery.v1_0_0类的构造函数。
     *
     * Parameters:
     * url - {String} 
     * options - {Object} 相关属性的设置项，可选。
     *    version  {String} 服务版本。
     */
	
	/**
	 * APIMethod: addressesToLocations
	 * 根据地址匹配查询参数查询匹配的地址信息。
	 * 
	 * Parameters:
	 * options: - {Object}请求参数。
	 *   address  {String || Array(String)} (必选) 查询的地址名称集合。
	 *   categoryCode  {Integer} (可选) 类别编码，该编码值可以通过获取分类的接口获取。
	 *   extent  {<Geo.Bounds>} (可选) 查询的空间范围。缺省情况无查询范围限制。
	 *   fuzzyMatch   {Boolean} (可选) 是否模糊匹配，true表示精确匹配，false表示模糊匹配。默认值为false。
	 *   resultType  {String} (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 *   maxCount  {Integer} (可选) ：查询多少条数据。缺省情况是查询满足条件的所有结果。
	 *   startPosition  {Integer} (可选) ： 从第几条开始查询，缺省值是1。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * 	示例：根据范围和地址进行查询：
	 * (code)
	 * 		var coding = new Geo.Query.GeoCodingQuery("http://192.168.42.76:7021/GeoCoding/geocoding");
	 * 		coding.addressesToLocations({
	 *			extent:Geo.Bounds.fromString("-180,-90,180,90"),
	 *			address:"法库县"
	 *		},function(GeoCoding) {},function() {});
	 * (end)
	 */
	addressesToLocations: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GeoCoder"
		});
		if(typeof options.address === "string") {
			params.address = options.address;
		}else if(options.address instanceof Array) {
			var address = "";
			for(var i = 0; i < options.address.length;i++) {
				address += (options.address[i] + ",");
			}
			address = address.substr(0, address.length - 1);
			params.address = address;
		}else if(options.address == undefined || options.address == null) {
			throw "address是必选参数！";
		}
		if(typeof options.categoryCode === "number") {
			params.categoryCode  = categoryCode;
		}
		if(typeof options.categoryCode === "number") {
			params.categoryCode  = categoryCode;
		}
		if(options.extent instanceof Geo.Bounds) {
			params.bbox = options.extent.toBBOX(null,true);
		}
		if(typeof options.fuzzyMatch === "boolean") {
			params.fuzzyMatch = options.fuzzyMatch;
		}
		if(typeof options.resultType  === "string") {
			params.resultType = options.resultType;
		}
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		if(typeof options.startPosition  === "number") {
			params.startPosition = options.startPosition;
		}
		OpenLayers.loadURL(this.url,params,this,function(result) {
			try{
				var json = this.format.read(result.responseText);
				var GeoCodingResult = this._analysis_GeoCodeResult(json);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(GeoCodingResult);
		},this.failFn);
		
	},
	
	/**
	 * APIMethod: locationToAddresses
	 * 根据位置查找匹配的地址信息。
	 * 
	 * Parameters:
	 * options: - {Object}请求参数。
	 * 	 lonlat  {Geo.LonLat} (必选) 位置。
	 *   tolerance  {Number} (可选) 容差范围,默认单位为度。默认值为0.000899。
	 *   unit  {Number} (可选)容差的单位,默认值为度。
	 *   resultType  {String} (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 *   maxCount  {Integer} (可选) ：查询多少条数据。缺省情况是查询满足条件的所有结果。
	 *   startPosition  {Integer} (可选) ： 从第几条开始查询，缺省值是1。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * 示例：根据坐标位置和容差进行查询
	 * (code)
	 * 		var coding = new Geo.Query.GeoCodingQuery("http://192.168.42.76:7021/GeoCoding/geocoding");
	 * 		coding.locationToAddresses({
	 *			lonlat:new Geo.LonLat(41.79427361488343,123.3541488647461),
	 *			tolerance:0.000899
	 *		},function(GeoCoding) {
	 *			
	 *		},function() {});
	 * (end)
	 */
	locationToAddresses: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GeoCoder"
		});
		if(options.lonlat instanceof Geo.LonLat) {
			params.latlng = options.lonlat.lat+","+options.lonlat.lon;
		}else  {
			throw "address是必选参数！请填写正确的数据类型！";
		}
		if(typeof options.tolerance === "number") {
			params.tolerance  = options.tolerance;
		}
		if(typeof options.unit === "number") {
			params.unit  = options.unit;
		}
		if(typeof options.resultType  === "string") {
			params.resultType = options.resultType;
		}
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		if(typeof options.startPosition  === "number") {
			params.startPosition = options.startPosition;
		}
		OpenLayers.loadURL(this.url,params,this,function(result) {
			try{
				var json = this.format.read(result.responseText);
				var GeoCodingResult = this._analysis_GeoCodeResult(json);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(GeoCodingResult);
		},this.failFn);
	},
	
	CLASS_NAME: "Geo.Query.GeoCodingQuery.v1_0_0" 
});/**
 * Class: Geo.Query.GeoCodingQuery.v1_1_0
 * 地址匹配服务查询接口1.1.0版本，本类可以实现如下功能：
 *   1.根据地址(例如：湖北省武汉市江夏区武大园一路9号)获取地理坐标(例如纬度29.58123 和经度113.41321)或者执行反向转换。
 *   2.根据地理坐标获取地址信息。
 *   3.可以根据地名地址分类名称或者地名地址分类编码获取地名地址分类信息。
 *   说明：本类提供的五个接口的成功回调的返回内容存在两种情况：第一：是返回json对象，第二：是返回xml串。如果返回xml串，表示服务器内部发生错误或者客户端解析服务返回的结果时，发生了错误。
 *	 4.可以根据多个地址信息查询到地理坐标信息。
 *	 5.可以根据多个地理坐标值获取地址信息。
 *
 *	Inherits from:
 *  	- <Geo.Query.GeoCodingQuery.v1>
 */
Geo.Query.GeoCodingQuery.v1_1_0 = Geo.Class(Geo.Query.GeoCodingQuery.v1, {
	
	/**
	 * APIProperty: method
	 * 数据请求方式，默认值是"get"。
	 */
	method: "get",
	
	/**
	 * Property: _filter
	 * 
	 * Parameters:
	 * {Geo.Filter} 过滤器。
	 */
	_filter: null,
	
	/**
     * Constructor: Geo.Query.GeoCodingQuery.v1_1_0
     * Geo.Query.GeoCodingQuery.v1_1_0类的构造函数。
     *
     * Parameters:
     * url - {String} 
     * options - {Object} 相关属性的设置项，可选。
     *    version  {String} 服务版本。
     */
	initialize: function(url, options){
		OpenLayers.Util.extend(this,options);
		this._filter = new OpenLayers.Format.Filter({
			version: "1.0.0"
		});
		this.xmlFormat = new OpenLayers.Format.XML();
		
		Geo.Query.GeoCodingQuery.v1.prototype.initialize.apply(this, arguments);  
	},
	
	/**
	 * APIMethod: addressesToLocations
	 * 根据地址匹配查询参数查询匹配的地址信息。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 *   address  {String} (必选) 查询的地址名称集合。
	 *   categoryCode  {Integer} (可选) 类别编码，该编码值可以通过获取分类的接口获取。
	 *   extent   {<Geo.Bounds>} (可选) 查询的空间范围。缺省情况无查询范围限制。
	 *   fuzzyMatch    {Boolean} (可选) 是否模糊匹配，true表示精确匹配，false表示模糊匹配。默认值为false。
	 *   resultType  {String} (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 *   maxCount  {Integer} (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 *   startPosition  {Integer} (可选) 从第几条开始查询，缺省值是1。
	 *   semanticAnalysis  {Boolean} (可选) 针对匹配关键字是否做语义分析，默认值为true。
	 *   filter  {Geo.Filter} 匹配附加过滤条件
	 *   sortFields  {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC" 
	 * 	 scoreFilter  {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95 
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * failFn - {Function} 请求失败的回调函数。 
	 * 
	 * 	示例：根据范围和地址进行查询：
	 * (code)
	 * 		var coding = new Geo.Query.GeoCodingQuery("http://192.168.42.76:7021/GeoCoding/geocoding");
	 * 		coding.addressesToLocations({
	 *			extent:Geo.Bounds.fromString("-180,-90,180,90"),
	 *			address:"法库县"
	 *		},function(GeoCoding) {},function() {});
	 * (end)
	 */
	addressesToLocations: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GeoCoder"
		});
		params.reverseMatch = false;
		if(typeof options.address === "string") {
			params.keyword = options.address;
		}
		if(typeof options.categoryCode === "number") {
			params.categoryCode  = options.categoryCode;
		}
		if(options.extent instanceof Geo.Bounds) {
			params.bbox = options.extent.toBBOX(null,true);
		}
		if(typeof options.fuzzyMatch === "boolean") {
			params.fuzzyMatch = options.fuzzyMatch;
		}
		if(typeof options.resultType  === "string") {
			params.resultType = options.resultType;
		}
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		if(typeof options.startPosition  === "number") {
			params.startPosition = options.startPosition;
		}
		if(typeof options.semanticAnalysis  === "boolean") {
			params.semanticAnalysis = options.semanticAnalysis;
		}
		this._setGeoCoderCommonProperty(params,options);
		this._getCodingRequest(params,successFn,failFn);
		
	},
	
	/**
	 * Method: _getCodingRequest
	 * 
	 * Parameters:
	 * 	params {Object} 键值对
	 * 	successFn {Function} 成功回调
	 * 	failFn {Function} 失败回调
	 */
	_getCodingRequest: function(params,successFn,failFn) {
		if(this.method == "get") {
			OpenLayers.loadURL(this.url,params,this,function(result) {
				try{
					var json = this.format.read(result.responseText);
					var GeoCodingResult = this._analysis_GeoCodeResult(json);
				}catch(e) {
					successFn(result.responseText);
					return;
				}
				successFn(GeoCodingResult);
			},this.failFn);
		}else {
			var paramsStr = OpenLayers.Util.getParameterString(params);
			OpenLayers.Request.POST({
	            url: this.url,
	            data: paramsStr,
	            success: function(result) {
					try{
						var json = this.format.read(result.responseText);
						var GeoCodingResult = this._analysis_GeoCodeResult(json);
					}catch(e) {
						successFn(result.responseText);
						return;
					}
					successFn(GeoCodingResult);
				},
	            failure: this.failFn,
	            scope: this
	        });
		}
	},
	
	/**
	 * Method: _setGeoCoderCommonProperty
	 * 
	 * Parameters:
	 * 	params {Object} 键值对
	 * 	options
	 */
	_setGeoCoderCommonProperty: function(params,options) {
		if(options.filter instanceof Geo.Filter) {
			var dom = this._filter.write(options.filter);
			var domStr = this.xmlFormat.write(dom);
			params.filter = domStr;
		}
		if(typeof options.sortFields  === "string") {
			params.sortFields = options.sortFields;
		}
		if(typeof options.scoreFilter  === "string") {
			params.scoreFilter = options.scoreFilter;
		}
	},
	
	/**
	 * APIMethod: locationToAddresses
	 * 根据位置查找匹配的地址信息。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * 	 lonlat  {Geo.LonLat} (必选) 位置。
	 *   tolerance  {Number} (可选) 容差范围,默认单位为度。默认值为0.000899。
	 *   unit  {Number} (可选)容差的单位,默认值为度。
	 *   resultType  {String} (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 *   maxCount  {Integer} (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 *   startPosition  {Integer} (可选) 从第几条开始查询，缺省值是1。
	 *   sortFields {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 *   filter {Geo.Filter} (可选) 匹配附加过滤条件。
	 *   scoreFilter {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * 示例：根据坐标位置和容差进行查询
	 * (code)
	 * 		var coding = new Geo.Query.GeoCodingQuery("http://192.168.42.76:7021/GeoCoding/geocoding");
	 * 		coding.locationToAddresses({
	 *			lonlat:new Geo.LonLat(41.79427361488343,123.3541488647461),
	 *			tolerance:0.000899
	 *		},function(GeoCoding) {
	 *			
	 *		},function() {});
	 * (end)
	 */
	locationToAddresses: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GeoCoder"
		});
		params.reverseMatch = true;
		if(options.lonlat instanceof Geo.LonLat) {
			params.keyword = options.lonlat.lat+","+options.lonlat.lon;
		}else  {
			throw "address是必选参数！请填写正确的数据类型！";
		}
		if(typeof options.tolerance === "number") {
			params.tolerance  = options.tolerance;
		}
		if(typeof options.unit === "string") {
			params.unit  = options.unit;
		}
		if(typeof options.resultType  === "string") {
			params.resultType = options.resultType;
		}
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		if(typeof options.startPosition  === "number") {
			params.startPosition = options.startPosition;
		}
		this._setGeoCoderCommonProperty(params,options);
		this._getCodingRequest(params,successFn,failFn);
	},
	
	/**
	 * APIMethod: batchAddressesToLocations
	 * 根据一到多个地址查询坐标位置信息。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 *   address  {Array(String)} (必选) 查询的地址名称集合。
	 *   filter  {Geo.Filter} (可选) 
	 *   sortFields  {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"
	 * 	 scoreFilter  {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95
	 *   singleKeywordResultCount  {Integer} (可选) 单个关键字匹配地址个数，用于限制服务返回的匹配结果数,默认值为1。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * 	示例：根据范围和地址进行查询：
	 * (code)
	 * 		var coding = new Geo.Query.GeoCodingQuery("http://192.168.42.76:7021/GeoCoding/geocoding");
	 * 		coding.batchAddressesToLocations({
	 *			address:["小学"],
	 *			singleKeywordResultCount:2,
	 *			sortFields:"address.desc",
	 *			scoreFilter:"0<=score<=88"
	 *		
	 *		},function(GeoCodingResult) {
	 *			
	 *		},function() {});
	 * (end)
	 */
	batchAddressesToLocations: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "BatchGeoCoder",
			service:"GeoCoding"
		});
		params.reverseMatch = false;
		if(options.address instanceof Array) {
			var address = "";
			for(var i = 0; i < options.address.length;i++) {
				address += (options.address[i] + ",");
			}
			address = address.substr(0, address.length - 1);
			params.keywords = address;
		}else if(options.address == undefined || options.address == null) {
			throw "address是必选参数！";
		}
		if(typeof options.singleKeywordResultCount === "number") {
			params.singleKeywordResultCount  = options.singleKeywordResultCount;
		}
		this._setGeoCoderCommonProperty(params,options);
		OpenLayers.loadURL(this.url,params,this,function(result) {
			try{
				var json = this.format.read(result.responseText);
				var GeoCodingResult = this._analysis_GeoCodeResult(json);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(GeoCodingResult);
		},this.failFn);
	},
	
	/**
	 * APIMethod: batchLocationToAddresses
	 * 根据位置查找匹配的地址信息。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * 	 lonlats  {Array(Geo.LonLat)} (必选) 位置。
	 *   tolerance  {Number} (可选) 容差范围,默认单位为度。默认值为0.000899。
	 *   unit  {Number} (可选)容差的单位,默认值为度。
	 *   sortFields {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 *   filter {Geo.Filter} (可选) 匹配附加过滤条件。
	 *   scoreFilter {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 *   singleKeywordResultCount {Integer} (可选) 单个关键字匹配地址个数，用于限制服务返回的匹配结果数,默认值为1。
	 *   
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * 示例：根据坐标位置和容差进行查询
	 * (code)
	 * 		var coding = new Geo.Query.GeoCodingQuery("http://192.168.42.76:7021/GeoCoding/geocoding");
	 * 		coding.batchLocationToAddresses({
	 *			lonlats:[new Geo.LonLat(123.43888042, 41.759929371),new Geo.LonLat(123.423848649, 41.771748608)],
	 *			singleKeywordResultCount:2,
	 *			tolerance:0.5,
	 *			unit:"degree",
	 *			sortFields:"address.desc",
	 *			scoreFilter:"0<=score<=88"
	 *		
	 *		},function(GeoCodingResult) {
	 *
	 *		},function() {});
	 * (end)
	 */
	batchLocationToAddresses: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "BatchGeoCoder",
			service:"GeoCoding"
		});
		params.reverseMatch = true;
		if(options.lonlats instanceof Geo.LonLat) {
			options.lonlats = [options.lonlats];
		//	params.keywords = options.lonlat.lat+","+options.lonlat.lon;
		}else  if(!OpenLayers.Util.isArray(options.lonlats)) {
			throw "address是必选参数！请填写正确的数据类型！";
		}
		if(options.lonlats instanceof Array) {
			var lonlatsStr = "";
			for(var i = 0; i < options.lonlats.length;i++) {
				lonlatsStr += options.lonlats[i].lat+","+options.lonlats[i].lon+";";
			}
			lonlatsStr = lonlatsStr.substr(0, lonlatsStr.length - 1);
			params.keywords = lonlatsStr;
		}
		if(typeof options.tolerance === "number") {
			params.tolerance  = options.tolerance;
		}
		if(typeof options.unit === "string") {
			params.unit  = options.unit;
		}
		if(typeof options.singleKeywordResultCount === "number") {
			params.singleKeywordResultCount  = options.singleKeywordResultCount;
		}
		this._setGeoCoderCommonProperty(params,options);
		OpenLayers.loadURL(this.url,params,this,function(result) {
			try{
				var json = this.format.read(result.responseText);
				var GeoCodingResult = this._analysis_GeoCodeResult(json);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(GeoCodingResult);
		},this.failFn);
	},
	
	CLASS_NAME: "Geo.Query.GeoCodingQuery.v1_1_0" 
});/**
 * Class: Geo.Strategy.AttributeCluster
 * 基于要素属性的聚合策略。
 *
 * Inherits from:
 *  - <Geo.Strategy.Cluster>
 */
Geo.Strategy.AttributeCluster = Geo.Class(Geo.Strategy.Cluster, {
	
    /**
     * APIProperty: attributes
     * 用于比较的一组属性。
     */
    attributes: [],
	
    /**
     * Method: shouldCluster
     * 判断要素是否被包含在一个要素簇内。
     *
     * Parameters:
     * cluster - {<Geo.Feature.Vector>} 一个要素簇。
     * feature - {<Geo.Feature.Vector>} 一个要素。
     *
     * Returns:
     * {Boolean} 返回布尔值，表示要素是否被包含在一个要素簇内。
     */
    shouldCluster: function(cluster, feature){
		var bool = false;
        for (var i = 0; i < this.attributes.length; i++) {
            var attribute = this.attributes[i];
            var cc_attrval = cluster.cluster[0].attributes[attribute];
            var fc_attrval = feature.attributes[attribute];
            bool = (cc_attrval === fc_attrval);
			if(!bool){
				break;
			}
        }
		var superProto = Geo.Strategy.Cluster.prototype;
		return bool && superProto.shouldCluster.apply(this, arguments);
    },
	
    CLASS_NAME: "OpenLayers.Strategy.AttributeCluster"
});/**
 * Class: Geo.Service
 * 服务类。本类是服务类的基类，需要由子类去实现。
 */
Geo.Service = Geo.Class({
	
	/**
     * APIProperty: name
     * {String} 服务名称。
     */
	name: null,
	
	/**
     * APIProperty: url
     * {String} 服务地址。
     */	
	url: null,
	
	/**
     * APIProperty: version
     * {String} 服务版本号。
     */		
	version: null,

	
	/**
     * APIProperty: userid
     * {String} 用户名。
     */			
	userid: "test@liferay.com",
	
	/**
     * Constructor: Geo.Service.Bus
     * Geo.Service.Bus类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		this.name = name;
		this.url = url;
		OpenLayers.Util.extend(this, options);
	},


	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息，由子类实现。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */		
	getCapabilities: function(successFn,failFn){
		//由子类实现
	},

	/**
     * APIMethod: isExist
     * 检查服务是否存在，由子类实现。
     */		
	isExist: function(){
		//由子类实现
	},


	/**
     * APIMethod: failFn
     * 服务操作失败响应回调函数。
     * 
     * operate - 失败的操作类型。
     */		
	failFn: function(operate){
		alert("服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" + 
			"请求地址：" + this.url + "\n操作类型：" + operate);
	},

	//将结果解析成XML
	_parseToXML: function(result){
		var doc = result.responseXML;
        if(!doc || !doc.documentElement) {
            doc = result.responseText;
        }
		var xmlParser = new OpenLayers.Format.XML();
		return xmlParser.read(doc);
	},
	
	//对返回结果进行检查，是否为错误信息
	_checkIsError: function(xmlString){
		var xmlparser = new OpenLayers.Format.XML();
		var xml = xmlparser.read(xmlString);
		var exceptions = xml.selectNodes("ServiceExceptionReport");
        if(exceptions.length > 0){
            return this._parseToJSON(xmlString);
        }
        return null;
	},
	
	//对解析后的JSON对象进行判断是否为服务抛出的异常
	_isException:function(result){
		if(result && result.ServiceExceptionReport){
			return true;
		}
		return false;
		
	},
	
	_parseToJSON: function(result){
		var parser = new Geo.Util.Format.XML2JSON();
		return parser.read(result);
	},
	
	CLASS_NAME: "Geo.Service"
	
});/**
 * Class: Geo.Service.GlobeTile
 * 吉奥瓦片服务类。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.GlobeTile = Geo.Class(Geo.Service, {
	
	/**
     * Constructor: Geo.Service.GlobeTile
     * Geo.Service.GlobeTile类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		Geo.Service.prototype.initialize.apply(this, arguments);
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
	getCapabilities: function(successFn,failFn){
		var request = "GetCapabilities";
		var url = this.url + "/" + request;
		
		if(!failFn){
			failFn = function(){
				this.failFn(request);
			};
		}
		OpenLayers.loadURL(url,null,this,function(result){
			successFn(result);
		},failFn);
	},
	
	
	/**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * 
     * Returns:
     * {Boolean} 服务是否存在。
     */	
	isExist: function(){
		var isExist = false;
		var request = "GetCapabilities";
		var url = this.url + "/" + request;
		var xhr = OpenLayers.Request.GET({
            url: url,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},

	CLASS_NAME: "Geo.Service"
});/**
 * Class: Geo.Service.Bus
 * 公交服务类。
 * 
 * Inherits from:
 *  - <Geo.Service>
 */
Geo.Service.Bus = Geo.Class(Geo.Service,{
	
	/**
     * Constructor: Geo.Service.Bus
     * Geo.Service.Bus类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     * 
     * 例如：
     * (code)
     *  var url = "http://map.geostar.com.cn:9001/bus_sdk_new/bus";
     *  var busService = new Geo.Service.Bus("公交服务", url);
     * (end)
     */
	initialize: function(name, url,  options){ 
		this.name = name;
		this.url = url;
		OpenLayers.Util.extend(this, options);
	},

	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities"
		};
		if(!failFn){
			failFn = function(){
				this.failFn(params.REQUEST);
			};
		}
		OpenLayers.loadURL(url,params,this,function(result){
			successFn(result);
		},failFn);
	},
	
	/**
     * APIMethod: isExist
     * 将向服务发送"GetCapabilities"同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * 
     * Returns:
     * {Boolean} 服务是否存在。
     */	
	isExist: function(){
		var isExist = false;
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities"
		};		
		var xhr = OpenLayers.Request.GET({
            url: url,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},	
	
	/**
     * APIMethod: queryStation
     * 站点查询操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     * 	 networkName {String} (必选) 网络模型名称。
     *   stationName {String} (可选) 站点名称。
     *   stationId   {Integer} (可选) 站点ID  必须为正整型。
     *   lineId      {Integer} (可选) 线路ID。
     *   lineName    {String}  (可选) 线路名称。
     *   coordinate  {String} (可选) 站点位置  用逗号分隔XY轴坐标如(X,Y)。
     *   bbox 		 {String} (可选) 矩形范围。
     *   
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     *       
     * 示例1 根据站点名称查询:
     * (code)
     *  busService.queryStation({
     *      networkName: "BusChangeModule",
     *      stationName: encodeURIComponent('口'),
     *  }
     *  (end)
     * 示例2 根据站点ID查询:
     * (code)
     *  busService.queryStation({
     *      networkName: "BusChangeModule",
     *      stationId : 2
     *  }
     *  (end)
     * 示例3 根据矩形范围查询:
     * (code)
     *  busService.queryStation({
     *      networkName: "BusChangeModule",
     *      bbox : '-1,-1,1,1'
     *  }
     *  (end)
     */	
    queryStation:function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryStation"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
        if(options.stationId !== null && options.stationId !== undefined){
            params.STATIONID = options.stationId;
        }
		
        if(options.stationName !== null && options.stationName !== undefined){
            params.STATIONNAME = options.stationName;
        }
		
        if(options.lineId !== null && options.lineId !== undefined){
            params.LINEID = options.lineId;
        }
		
		if(options.lineName !== null && options.lineName !== undefined){
            params.LINENAME = options.lineName;
        }
		
		if(options.coordinate !== null && options.coordinate !== undefined){
        	params.COORDINATE = options.coordinate;
        }   
		
        if(options.bbox !== null && options.bbox !== undefined){
            params.BOX = options.bbox;
        }
        
        var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
                
                var features = this._parserFeatures(result.responseText);
                successFn(features);
            },
            failure: failFn
        });

    },

	/**
     * APIMethod: queryLine
     * 线路查询操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     *   networkName {String} (必选) 网络模型名称。
     *   lineName    {String} (可选) 线路名称。
     *   lineId      {Integer} (可选) 线路ID。
     *   stationName {String} (可选) 站点名称。
     *   stationId   {Integer} (可选) 站点ID。
     *   coordinate  {String} (可选) 站点位置。
     *   bbox        {String} (可选) 矩形范围。
     * 
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     *       
     * 示例1 根据站点名称查询:
     * (code)
     *  busService.queryLine({
     *      networkName: "BusChangeModule",
     *      stationName: encodeURIComponent('口'),
     *  }
     *  (end)
     * 示例2 根据站点ID查询:
     * (code)
     *  busService.queryLine({
     *      networkName: "BusChangeModule",
     *      stationId : 2
     *  }
     *  (end)
     * 示例3 根据路线名称查询:
     * (code)
     *  busService.queryLine({
     *      networkName: "BusChangeModule",
     *      lineName : '4'
     *  }
     *  (end)
     */	
    queryLine: function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryLine"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
        if(options.lineName !== null && options.lineName !== undefined){
            params.LINENAME = options.lineName;
        }
        
        if(options.lineId !== null && options.lineId !== undefined){
            params.LINEID = options.lineId;
        }
        
        if(options.stationName !== null && options.stationName !== undefined){
            params.STATIONNAME = options.stationName;
        }    
        
        if(options.stationId !== null && options.stationId !== undefined){
            params.STATIONID = options.stationId;
        }    
                
        if(options.coordinate !== null && options.coordinate !== undefined){
            params.COORDINATE = options.coordinate;
        }   
                     
        if(options.bbox !== null && options.bbox !== undefined){
            params.BOX = options.bbox;
        }
        var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
                
                var features = this._parserFeatures(result.responseText);
                successFn(features);
            },
            failure: failFn
        });

    },
    
	/**
     * APIMethod: queryChange
     * 公交换乘方案查询操作。
     * 
     * Parameters:
     * 	options - {Object} 请求参数。
     *    networkName   {String} (必选) 网络模型名称。
     *    startStationId  {Integer} (可选) 起始站点ID。
     *    endStationId     {Integer} (可选) 终止站点ID。
     *    startCoordinate  {String} (可选) 起始站点坐标。
     *    endCoordinate    {String} (可选) 起始站点坐标。
     *    maxDepth         {Integer}(可选) 最大边数范围,正整型参数,没有则默认值为5。
     *    maxCost         {Float} (可选) 最大权值范围,正双精度符点型参数,没有则默认为100.0。
     *    maxSolutions   {Integer} (可选) 最多解决方案数量,正整型参数,没有则默认为5。
     *    orderType   {String}(可选) 值为LeastCost时表示较快捷，值为LeastWalk时表示少步行，值为LeastChange时表示少换乘。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * * 示例1 根据站点名称查询:
     * (code)
     *  busService.queryChange({
     *      networkName: "BusChangeModule",
     *        startStationId: "238",
     *        endStationId: "25",
	 *		  maxDepth:5,
	 *		  maxCost:100.0,
	 *		  maxSolutions:5,
	 *		  //orderType表示换乘的类型。LeastCost表示较快捷，用户还可以选择LeastWalk或LeastChange，LeastWalk表示少步行，值为LeastChange时表示少换乘
	 *		  orderType:"LeastCost" 
     *  })
     *  (end)
     */	
    queryChange: function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryChange"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
        if(options.startStationId !== null && options.startStationId !== undefined){
            params.STARTSTATIONID = options.startStationId;
        }
        
        if(options.endStationId !== null && options.endStationId !== undefined){
            params.ENDSTATIONID = options.endStationId;
        }
		
		if(options.orderType !== null && options.orderType !== undefined){
            params.ORDERTYPE = options.orderType;
        }
        
        if(options.startCoordinate !== null && options.startCoordinate !== undefined){
            params.STARTCOORDINATE = options.startCoordinate;
        }    
        
        if(options.endCoordinate !== null && options.endCoordinate !== undefined){
            params.ENDCOORDINATE = options.endCoordinate;
        }  
		
		if(options.maxDepth !== null && options.maxDepth !== undefined){
            params.MAXDEPTH = options.maxDepth;
        } 
		
		if(options.maxCost !== null && options.maxCost !== undefined){
            params.MAXCOST = options.maxCost;
        }  
		
		if(options.maxSolutions !== null && options.maxSolutions !== undefined){
            params.MAXSOLUTIONS = options.maxSolutions;
        }  
		  
        var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
            	var  featureCollection = [];
				var resXML;//= result.responseXML;
				if (!result.responseXML.documentElement) {
					resXML = format.read(result.responseText);
				}
				else {         
					resXML = result.responseXML;
				}       

				var docElement = resXML.selectNodes("/Features/FeatureCollection");
				
            	var xmlparser = new OpenLayers.Format.XML();
				
            	for(var i = 0; i < docElement.length; i++) {
					//获取FeatureCollection元素节点的属性
					var featureCollectionElement = docElement[i];
					var attArray = ['cost','price','walkingDistance','transferTimes'];
					var attributionObj = this._getAttibutionOfNode(featureCollectionElement, attArray);
					
					var str = xmlparser.write(docElement[i]);
					var features = this._parserFeatures(str);
					//features或featureCollectionElement相当于一个FeatureCollection
					features.attributes= attributionObj;
					var featureMember = featureCollectionElement.selectNodes("featureMember");
					for(var j = 0; j < featureMember.length; j++) {
						var road = featureMember[j].selectNodes("Road");
						//线路添加是否步行属性：isOnFoot
						features[j]["isOnFoot"] = road[0].getAttribute("isOnFoot");
					}
	            	featureCollection.push(features);
            	}

                successFn(featureCollection);
            },
            failure: failFn
        });

    },
	
	//根据节点得到节点的属性
	_getAttibutionOfNode: function(node, keyArray) {
		//获取FeatureCollection属性信息
		var fcAttibution = {};
		if(node.tagName){
			for(var i = 0; i < keyArray.length; i++) {
				fcAttibution[keyArray[i]] = node.getAttribute(keyArray[i])
			}
	    }
		return fcAttibution;
	},
   
    _getGeometryType: function(geometry){
        var maping = {
            "OpenLayers.Geometry.Point": "point",
            "OpenLayers.Geometry.LineString": "line",
            "OpenLayers.Geometry.Polygon": "polygon"
        };
        return "polygon";
    },
    
    _pagingToString: function(curPage,maxPerPage){
        maxPerPage = maxPerPage || this.maxPerPage;
        curPage = curPage || 1;
        return "<numPerPage>" + maxPerPage + "</numPerPage>"+
                "<curPage>" + curPage + "</curPage>";
    },
    
    _orderByToString: function(property,type){
        var str = "<orderBy>"+
    	            "<PropertyName>" + property + "</PropertyName>"+
    	        "</orderBy>";
        return property ? str : "";
    },
    
    _geometryToString: function(geometry){
        return '<geometry>'+
                    '<Polygon>'+
                        '<outerBoundaryIs>'+
                            '<LinearRing>'+
                                '<coordinates decimal="." cs="," ts=" ">20,30 21,41 52,42 53,33 20,30</coordinates>'+
                            '</LinearRing>'+
                        '</outerBoundaryIs>'+
                    '</Polygon>'+
                '</geometry>';
    },
    
    _stringToGeometry: function(string){
        return Geo.Geometry.Polygon.createRegularPolygon(
            new Geo.Geometry.Point( Math.random()*360 - 160, 
                                           Math.random()*90 - 70 ),
            Math.round(Math.random()*20),
            Math.round(Math.random()*10)
        );
    },
	
    _parserFeatures: function(resultString){
        var parser = new OpenLayers.Format.GML();
        parser.gmlns = "*";
        var features = parser.read(resultString);
        return features;
    },
	
	// 把节点名称所在的节点外套上<featureMember></featureMember>
	_parserResponseText: function(resultString, nodeName){
		if(nodeName){
			var re1 = new RegExp("<" + nodeName + ">", ["g"]);
	        var re2 = new RegExp("</" + nodeName + ">", ["g"]);
			
	        resultString = resultString.replace(re1, "<featureMember><" + nodeName + ">");
	        resultString = resultString.replace(re2, "</" + nodeName + "></featureMember>");
		}
		
		resultString = resultString.replace(/<gml:LineString>/g,"<gml:LineString><gml:coordinates>");
		resultString = resultString.replace(/<\/gml:LineString>/g,"</gml:coordinates></gml:LineString>");
		resultString = resultString.replace(/<gml:Point>/g,"<gml:Point><gml:coordinates>");
		resultString = resultString.replace(/<\/gml:Point>/g,"</gml:coordinates></gml:Point>");
		return resultString;
	},
	
	_parserFeaturesNew: function(resultString, featureName){
		var parser = new OpenLayers.Format.GML();
        parser.gmlns = "*";
		if(featureName){
			parser.featureName = featureName;
		}
        var features = parser.read(resultString);
        return features;
    },
    
	_parserSuccessResult: function(result){
		var parser = new Geo.Util.Format.XML2JSON();
		return parser.read(result);
	},
	
	_parseToXML: function(result){
		var doc = result.responseXML;
        if(!doc || !doc.documentElement) {
            doc = result.responseText;
        }
		var xmlParser = new OpenLayers.Format.XML();
		return xmlParser.read(doc);

	},
	
	_parseToJSON: function(result){
		var parser = new Geo.Util.Format.XML2JSON();
		return parser.read(result);
	},
	
	/**
	 * APIMethod: queryTransferScheme
	 * 根据始终点的空间坐标或一组起始站点ID和一组终止站点的ID，查询公交换乘的文字信息，必要时也查询出第一条方案的几何信息。（公交2.0）
	 * 
	 * Parameters:
	 * options - {Object} 请求参数。
	 * 		networkName {String} (必选) 网络模型名称。
	 * 		transferMode - {Integer} (必选) 换乘模式  ,有三种值：0-较快捷   1-少换乘  2-少步行。
	 * 		startInput - {String} (必选) 始点信息，可以是坐标信息也可也是ID类型（坐标类型,格式为:x y。分隔符为空格符；ID类型,格式为:id,… ,id。分隔符为逗号）。
	 * 		endInput - {String} (必选)终点信息支持坐标与ID类型:坐标类型,格式为:x y。分隔符为空格符ID类型,格式为:id,… ,id。分隔符为逗号。
	 * 
	 * 		inputMode - {Integer}(可选)始终点输入模式,值为0|1|2: 0-坐标,1-车站外部唯一编号,2-车站内部唯一编号（当前服务没有外部唯一编号）。
	 * 		ComputeModel - 	
	 * 		transferSubset
	 * 		existGoTime
	 * 		startTime
	 * 		specificSubset
	 * 		maxSearchDistance
	 * 		computeSort
	 * 		transferPolicy
	 * 		resultSort
	 * 		prioritySubset
	 * 		existAbsolutePriority
	 * 		lagSubset
	 * 		outputPage
	 * 		pageSize
	 * 
	 * successFn - {Function}请求成功的回调函数。
	 * failFn - {Function}请求失败的回调函数。
	 */
	queryTransferScheme: function(options, successFn, failFn) {
		var params = {
			request: "QueryTransferScheme",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
		//四个必选参数
		var required = {
			networkName:true,
            transferMode: true,
            startInput: true,
			endInput: true
        };
        for (var prop in required) {
            if (!(prop in options)) {
                throw new Error("缺少必选属性：'" + prop + "'。");
            }
        }
		params.networkName = options.networkName;
		
		//这样判断的原因是为了避免0,1这样的值在进行if判断的时候被当做false把参数给过滤掉；""串不需要被过滤，这个已经向服务组确认
        if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
		if(options.transferMode !== null && options.transferMode !== undefined) {
			params.TRANSFERMODE = options.transferMode;
        }
		if(options.startInput !== null && options.startInput !== undefined) {
			params.STARTINPUT = options.startInput;
        }
		if(options.endInput !== null && options.endInput !== undefined) {
			params.ENDINPUT = options.endInput;
        }
		if(options.inputMode !== null && options.inputMode !== undefined) {
			params.INPUTMODEL = options.inputMode;
        }
		if (options.ExistGoTime !== null && options.ExistGoTime !== undefined) {
			params.EXISTGOTIME = options.ExistGoTime;
        }
		if (options.StartTime !== null && options.StartTime !== undefined) {
			params.STARTTIME = options.StartTime;
        }
		if (options.MaxSearchDistance !== null && options.MaxSearchDistance !== undefined) {
			params.MAXSEARCHDISTANCE = options.MaxSearchDistance;
		}
		if (options.PrioritySubset !== null && options.PrioritySubset !== undefined) {
			params.PRIORITYSUBSET = options.PrioritySubset;
        }
		if (options.ExistAbsolutePriority !== null && options.ExistAbsolutePriority !== undefined) {
			params.EXISTABSOLUTEPRIORITY = options.ExistAbsolutePriority;
        }
		if (options.LagSubset !== null && options.LagSubset !== undefined) {
			params.LAGSUBSET = options.LagSubset;
        }
		if (options.OutputPage !== null && options.OutputPage !== undefined) {
			params.OUTPUTPAGE = options.OutputPage;
        }
		if (options.PageSize !== null && options.PageSize !== undefined) {
			params.PAGESIZE = options.PageSize;
        }
		if (options.ChangeCount !== null && options.ChangeCount !== undefined) {
			params.CHANGECOUNT = options.ChangeCount;
        }
		
		var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: OpenLayers.Function.bind(function(result){
				var resXML = result.responseXML;
                var features = {
                    startPoint: [],
                    transferScheme: [],
                    endPoint: []
                };	
				if(!resXML) {
					successFn(features);
					return features;
				}
				var xmlparser = new OpenLayers.Format.XML();
				var errorTemp = resXML.selectNodes("/ServiceExceptionReport/ServiceExceptionMessage");
				//没有查询到数据的情况
				if(errorTemp && errorTemp.length > 0) {
					successFn(features);
					return features;
				}
				
				var element = resXML.selectNodes("/QueryTransferSchemeResponse");	
				var elementXMLStr = xmlparser.write(element[0]);
				// XML解析成json对象
				var jsonObj = this._parseToJSON(elementXMLStr);
				var startPoint = jsonObj.QueryTransferSchemeResponse.StartPoint;
				if (!OpenLayers.Util.isArray(startPoint)) {
		            startPoint = [startPoint];
		        }
				var endPoint = jsonObj.QueryTransferSchemeResponse.EndPoint;
				if (!OpenLayers.Util.isArray(endPoint)) {
		            endPoint = [endPoint];
		        }
				var transferScheme = jsonObj.QueryTransferSchemeResponse.TransferScheme;
				
				// 起点要素
                var startPointGeometry = this._getPointGeometryByGMLPointStr(startPoint[0].Geometry.gml_Point);
            	var startPointFeature = new Geo.Feature.Vector(startPointGeometry);
				// 终点要素
                var endPointGeometry = this._getPointGeometryByGMLPointStr(endPoint[0].Geometry.gml_Point);
            	var endPointFeature = new Geo.Feature.Vector(endPointGeometry);
				// 换乘要素
				var transferSchemeFeatures = this._parserTransferScheme(transferScheme);
				
                features = {
                    startPoint: startPointFeature,
                    transferScheme: transferSchemeFeatures,
                    endPoint: endPointFeature
                };
				successFn(features);
            },this)
			,
            failure: failFn
        });
	},
	
	// 解析换乘要素
    _parserTransferScheme: function(transferSchemeObjs){
		if (!OpenLayers.Util.isArray(transferSchemeObjs)) {
            transferSchemeObjs = [transferSchemeObjs];
        }
        var transferSchemeFeatures = new Array();
        for (var i = 0; i < transferSchemeObjs.length; i++) {
			var transferSchemeObj = transferSchemeObjs[i];
			// 解析片段信息
			var SectionInfo = this._parserSectionInfo(transferSchemeObj.SectionInfo);
			// 解析片段步行
			var SectionRoutingFeatures = this._parserSectionRouting(transferSchemeObj.SectionRouting);
            
			var transferSchemeFeature = {
                Cost: transferSchemeObjs[i].Cost,
                SectionInfo: SectionInfo,
                SectionRouting: SectionRoutingFeatures,
                TotalDistance: transferSchemeObjs[i].TotalDistance,
                TransferCount: transferSchemeObjs[i].TransferCount
            };
            transferSchemeFeatures.push(transferSchemeFeature);
        }
        return transferSchemeFeatures;
    },
	
	// 解析片段信息
    _parserSectionInfo: function(sectionInfoObjs){
		if (!OpenLayers.Util.isArray(sectionInfoObjs)) {
            sectionInfoObjs = [sectionInfoObjs];
        }
		var sectionInfos = new Array();
		for (var i = 0; i < sectionInfoObjs.length; i++) {
			
			// 上车点要素
			var fromStationFeature = this._getPointFeatureByObj(sectionInfoObjs[i].FromStation);
			if (sectionInfoObjs[i].FromStation.PassagewayRouting) {
                var passagewayRoutingFeature = this._getPointFeatureByObj(sectionInfoObjs[i].FromStation.PassagewayRouting);
				if(passagewayRoutingFeature.SectionRouting){
                    passagewayRoutingFeature.attributes.SectionRouting = passagewayRoutingFeature.data.SectionRouting = this._parserSectionRouting(passagewayRoutingFeature.SectionRouting);
				}
                fromStationFeature.attributes.PassagewayRouting = fromStationFeature.data.PassagewayRouting = passagewayRoutingFeature;
            }
			
			// 下车点要素
			var toStationFeature = this._getPointFeatureByObj(sectionInfoObjs[i].ToStation);
			if (sectionInfoObjs[i].ToStation.PassagewayRouting) {
                var passagewayRoutingFeature = this._getPointFeatureByObj(sectionInfoObjs[i].ToStation.PassagewayRouting);
                if(passagewayRoutingFeature.SectionRouting){
                    passagewayRoutingFeature.attributes.SectionRouting = passagewayRoutingFeature.data.SectionRouting = this._parserSectionRouting(passagewayRoutingFeature.SectionRouting);
				}
				toStationFeature.attributes.PassagewayRouting = toStationFeature.data.PassagewayRouting = passagewayRoutingFeature;
            }
			
			// 线路要素
			var sectionLine = this._parserSectionLines(sectionInfoObjs[i].SectionLines.SectionLine);
			var sectionRouting = this._parserSectionRouting(sectionInfoObjs[i].SectionRouting);
			
			sectionInfos.push({
				FromStation: fromStationFeature,
				SectionLine: sectionLine,
				ToStation: toStationFeature,
				SectionRouting: sectionRouting
			});
		}
		return sectionInfos;
	},
	
	// 解析片段信息内的片段线路
    _parserSectionLines: function(sectionLineObjs){
        if (!OpenLayers.Util.isArray(sectionLineObjs)) {
            sectionLineObjs = [sectionLineObjs];
        }
		var sectionLineFeatures = new Array();
		for (var i = 0; i < sectionLineObjs.length; i++) {
            var sectionLineFeature = new Geo.Feature.Vector(null, sectionLineObjs[i]);
			sectionLineFeatures.push(sectionLineFeature);
		}
		return sectionLineFeatures;
	},
	
	// 解析片段步行
    _parserSectionRouting: function(sectionRoutingObjs){
		// TODO
        if (!OpenLayers.Util.isArray(sectionRoutingObjs)) {
            sectionRoutingObjs = [sectionRoutingObjs];
        }
		var sectionRoutingFeatures = new Array();
		for (var i = 0; i < sectionRoutingObjs.length; i++) {
			sectionRoutingFeatures.push(sectionRoutingObjs[i]);
		}
		return sectionRoutingFeatures;
	},
	
	// -----根据点串得到点对象
	_getPointGeometryByGMLPointStr: function(pointStr) {
		var pointArr = pointStr.split(",");
		var point = new Geo.Geometry.Point(parseFloat(pointArr[0]),parseFloat(pointArr[1]));
		return point;
	},
	
	// 解析站点或出入口点的要素
    _getPointFeatureByObj: function(pointInfoObj){
        var pointGeometry = null;
        if (pointInfoObj.Geometry && pointInfoObj.Geometry.gml_Point) {
            pointGeometry = this._getPointGeometryByGMLPointStr(pointInfoObj.Geometry.gml_Point);
        }
        var pointFeature = new Geo.Feature.Vector(pointGeometry, pointInfoObj);
        return pointFeature;
    },
	
	// -----根据id等信息获取geometry串并生成geometry对象
    _getLineGeometryByGMLLineStr: function(geometryStr){
        if (!geometryStr) {
            return null;
        }
        var pointStrArr = geometryStr.split(" ");
        var pointArr = [];
        for (var i = 0, j = pointStrArr.length; i < j; i++) {
            var pointGeometry = this._getPointGeometryByGMLPointStr(pointStrArr[i]);
            pointArr.push(pointGeometry);
        }
        var lineGeometry = new OpenLayers.Geometry.LineString(pointArr);
        return lineGeometry;
    },
	
	/**
	 * APIMethod: queryTransferGeometry
	 * 根据线路ID或者步行ID来获取相应的线要素（公交2.0。注意：这些线要素不包含属性信息）。
	 * 
     * Parameters:
	 * options - {Object} 请求参数。
	 * 		networkName - {String} (必选) 网络模型名称。
	 * 		parameterInfo - {Arrays} 取值格式：[[geometryTypeID,geometryInfoID,FromOrdinal,ToOrdinal]]例如[[0,10,22,24]]。
	 * 			geometryTypeID - {Integer} (必选) 0-线路内部ID,1-步行路由内部ID  
	 * 				如果这个属性的值为1，那么FromOrdinal和ToOrdinal这两个属性的的值就都为0。
	 * 			geometryInfoID - {Integer}几何信息 的ID。
	 * 			FromOrdinal -  {Integer} (必选) 起点序号。
	 * 			ToOrdinal -  {Integer} (必选) 终点序号。
	 */
	queryTransferGeometry: function(options, successFn, failFn) {
		var params = {
			request: "QueryTransferGeometry",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
		if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.parameterInfo === null || options.parameterInfo === undefined || options.parameterInfo === ""){
            throw "Error!Not parameterInfo for bus query.";
            return;
        }
		params.networkName = options.networkName;
		params.PARAMETERINFO = "";
        for (var i = 0; i < options.parameterInfo.length; i++) {
            params.PARAMETERINFO += options.parameterInfo[i].toString();
            if (i != options.parameterInfo.length - 1) {
                params.PARAMETERINFO += "_";
            }
        }
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
		
		var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: OpenLayers.Function.bind(function(result){
				var features = this._parseQueryTransferGeometryResult(result);
				successFn(features);
            },this)
			,
            failure: failFn
        });
	},
	
	//解析QueryTransferGeometry接口返回结果 -----获取线路要素
	_parseQueryTransferGeometryResult: function(result) {
		resXML = result.responseXML;
		var features = [];
		if(!resXML) {
			return features;
		}
		var xmlparser = new OpenLayers.Format.XML();
		var geometrysStrTemp = resXML.selectNodes("/QueryTransferGeometryResponse");	
		//没有查询到数据的情况
		if(geometrysStrTemp && geometrysStrTemp.length <= 0) {
			return features;
		}
		var geometrysXMLStr = xmlparser.write(geometrysStrTemp[0]);
		var geometrysXMLObj = this._parseToJSON(geometrysXMLStr);
		var geometrys = geometrysXMLObj.QueryTransferGeometryResponse.SectionGeometry;	
		
		if(geometrys) {
			if(!OpenLayers.Util.isArray(geometrys)) {
				geometrys = [geometrys];
			}
			//得到一个个站点
			for(var i = 0 ;i < geometrys.length; i++)  {
				//得到几何对象
				var geometryTemp = this._getLineGeometryByGMLLineStr(geometrys[i].Geometry.gml_LineString);
				//得到线要素
                var lineFeature = new Geo.Feature.Vector(geometryTemp, {
                    ID: geometrys[i].ID
                });
				features.push(lineFeature);
			}
		}
		return features;
	},
	
	/**
	 * APIMethod: queryKeyWord
	 * 根据关键字来获取线路信息或者站点信息或者出入口信息。（公交2.0）
	 * 
     * Parameters:
	 * options - {Object} 请求参数。
	 * 		networkName - {String} (必选) 网络模型名称。
	 * 		keyWord - {String} (必选)查询关键字。
	 *      searchType - {Integer} (可选) 查询类型，默认值为 2，查询类型，其值为0|1|2:0-完全配匹，1-模糊查询，2-先完全后模糊默认值为2。
	 * 		keyWordType - {Integer} (可选) 查询关键字类型，默认值为 -1，
	 *     		可供选择的值为-1|0|1|2:-1:先查线路，然后查车站，最后查出入口0-查线路，1-查车站，2-查出入口。
	 *     
	 * Returns:
	 * {Array(Geo.Feature.Vector)} 返回的是出入口、站点、线路要素。
	 */
	queryKeyWord: function(options, successFn, failFn) {
		var params = {
			REQUEST: "QueryKeyWord",
			SERVICE: "BUS",
			VERSION: "1.0.0",
			SEARCHTYPE: 2
		};
		if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.keyWord === null || options.keyWord === undefined || options.keyWord === ""){
            throw "Error!Not keyWord for bus query.";
            return;
        }
		params.NETWORKNAME = options.networkName;
		params.KEYWORD = options.keyWord;
		
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
		if (options.searchType !== null && options.searchType !== undefined) {
        	params.SEARCHTYPE = options.searchType;
        }
		if (options.keyWordType !== null && options.keyWordType !== undefined) {
        	params.KEYWORDTYPE = options.keyWordType;
        }
		var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: OpenLayers.Function.bind(function(result){
				var features = this._parserQueryKeyWordResult(result,options.keyWordType);
				successFn(features);
            },this)
			,
            failure: failFn
        });
	},
	
	//解析queryKeyWord接口返回结果 -----获取站点或出入口或线路文字描述信息
	_parserQueryKeyWordResult: function(result,keyWordType) {
		var resXML = result.responseXML;
		var features = [];	
		if(!resXML) {
			return features;
		}
		var xmlparser = new OpenLayers.Format.XML();
		var errorTemp = resXML.selectNodes("/ServiceExceptionReport/ServiceExceptionMessage");
		//没有查询到数据的情况
		if(errorTemp && errorTemp.length > 0) {
			return features;
		}
		var objectsStrTemp = resXML.selectNodes("/QueryKeyWordResponse");	
		var objectsXMLStr = xmlparser.write(objectsStrTemp[0]);
		var objectsXMLObj = this._parseToJSON(objectsXMLStr);
		
		// 0-查线路，1-查车站，2-查出入口
        if (keyWordType === 1) {
            var stations = objectsXMLObj.QueryKeyWordResponse.Stations.Station;
			if (stations && !(stations instanceof Array)) {
				stations = [stations];
			}
            for (var i = 0; i < stations.length; i++) {
                var pointFeature = this._getPointFeatureByObj(stations[i]);
                features.push(pointFeature);
            }
        } else if (keyWordType === 2) {
            var passageways = objectsXMLObj.QueryKeyWordResponse.Passageways.Passageway;
			if (passageways && !(passageways instanceof Array)) {
				passageways = [passageways];
			}
            for (var i = 0; i < passageways.length; i++) {
                var pointFeature = this._getPointFeatureByObj(passageways[i]);
                features.push(pointFeature);
            }
        } else {
            var lines = objectsXMLObj.QueryKeyWordResponse.Lines.Line;
			if (lines && !(lines instanceof Array)) {
				lines = [lines];
			}
            for (var i = 0; i < lines.length; i++) {
                var lineFeature = new Geo.Feature.Vector(null,lines[i]);
                features.push(lineFeature);
            }
        }
		return features;
	},
	
	/**
     * APIMethod: queryStationInfo
     * 站点查询操作。（公交2.0）
     * 
     * Parameters:
     * options - {Object} 请求参数。
     * 	 networkName {String} (必选) 网络模型名称。
     *   stationId   {Integer} (必选) 站点ID  必须为正整型。
     *   
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     *       
     * 示例 根据站点ID查询:
     * (code)
     *  busService.queryStationInfo({
     *      networkName: "BusChangeModule",
     *      stationId : 2
     *  }
     *  (end)
     */	
    queryStationInfo:function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryStationInfo",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.stationId === null || options.stationId === undefined || options.stationId === ""){
            throw "Error!Not stationId for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
        if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
		
        if(options.stationId !== null && options.stationId !== undefined){
            params.STATIONID = options.stationId;
        }
        
        var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
				resXML = result.responseXML;
				if(!resXML) {
					var features = {
						lines:[],
						passageways:[]
					};
	                successFn(features);
					return;
				}
				var xmlparser = new OpenLayers.Format.XML();
				
				//根据节点名字，解析成对象
				var lines = this._parserQueryStationInfoNode("Lines", xmlparser, resXML);
				var passageways = this._parserQueryStationInfoNode("Passageways", xmlparser, resXML);
                
				//解析后转feature
				var passagewaysFeature = new Array();
                for (var i = 0; i < passageways.length; i++) {
					var pointFeature = this._getPointFeatureByObj(passageways[i]);
					passagewaysFeature.push(pointFeature);
                }
		
				var features = {
					lines: lines,
					passageways: passagewaysFeature
				};
                successFn(features);
            },
            failure: failFn
        });

    },
	
	//解析queryStationInfo接口返回的结果中的xml串
    _parserQueryStationInfoNode: function(nodeName, xmlparser, resXML){
		switch (nodeName) {
            case "Lines":
                //解析lines
	            var element = resXML.selectNodes("/QueryStationInfoResponse/StationInfo/Lines");
	            var lines = new Array();
	            if (element.length > 0) {
	                var xmlObj = xmlparser.write(element[0]);
	                var jsonObj = this._parseToJSON(xmlObj);
	                lines = jsonObj.Lines.Line;
	                if (!(lines instanceof Array)) {
	                    lines = [lines];
	                }
	            }
	            return lines;
                break;
            case "Passageways":
                //解析Passageways
	            var element = resXML.selectNodes("/QueryStationInfoResponse");
	            var passageways = new Array();
	            if (element.length > 0) {
	                var xmlObj = xmlparser.write(element[0]);
	                var jsonObj = this._parseToJSON(xmlObj);
					var passagewaysJson = jsonObj.QueryStationInfoResponse.StationInfo.Passageways;
					if(passagewaysJson){
						passageways = passagewaysJson.Passageway;
		                if (!(passageways instanceof Array)) {
		                    passageways = [passageways];
		                }
					}
	            }
	            return passageways;
                break;
            default:
				return [];
                break;
        }
    },
    
    /**
     * APIMethod: queryLineInfo
     * 线路查询操作。（公交2.0）
     * 
     * Parameters:
     * options - {Object} 请求参数。
     *   networkName {String} (必选) 网络模型名称。
     *   lineId      {Integer} (必选) 线路ID。
     *   STARTNODENUMBER {String} (可选) 线路中某一个站点的序号。多个序号采用逗号分割。
     *   ENDNODENUMBER   {String} (可选) 线路中某一个站点的序号。多个序号采用逗号分割。
     * 
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     *       
     * 示例 根据站点ID查询:
     * (code)
     *  busService.queryLineInfo({
     *      networkName: "BusChangeModule",
     *      stationId : 2
     *  }
     *  (end)
     */
    queryLineInfo: function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryLineInfo",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.lineId === null || options.lineId === undefined || options.lineId === ""){
            throw "Error!Not lineId for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
        
        if(options.lineId !== null && options.lineId !== undefined){
            params.LINEID = options.lineId;
        }
        
        if(options.startNodeNumber !== null && options.startNodeNumber !== undefined){
            params.STARTNODENUMBER = options.startNodeNumber;
        }    
                
        if(options.endNodeNumber !== null && options.endNodeNumber !== undefined){
            params.ENDNODENUMBER = options.endNodeNumber;
        }   
                     
        var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
//				// 传入包含gml的结点名称
//				var resultString = this._parserResponseText(result.responseText, "Line");
//				var features = this._parserFeaturesNew(resultString);
//				
//				// 线路所包含的站点要素
//				var resultStationString = this._parserResponseText(result.responseText, "Station");
//				var stationFeatures = this._parserFeaturesNew(resultStationString);
//                features[0].attributes.Stations = features[0].data.Stations = stationFeatures;
//				
//				successFn(features);
//				return;
				
				var features = [];
				var resXML = null;
				if(result.responseXML) {         
					resXML = result.responseXML;
					var errorTemp = resXML.selectNodes("/ServiceExceptionReport/ServiceExceptionMessage");
					//没有查询到数据的情况
					if(errorTemp && errorTemp.length > 0) {
						successFn(features);
						return;
					}
					var xmlparser = new OpenLayers.Format.XML();
					//根据节点名字，解析成对象
					var line = this._parserQueryLineInfoNode("Line", xmlparser, resXML);
					//解析后转feature
					var lineFeatures = new Array();
	                for (var i = 0; i < line.length; i++) {
						//线路内站点信息转要素
						var stationFeatures = new Array();
	                    for (var j = 0; j < line[i].VIAStations.Station.length; j++) {
							//得到点要素
	                    	var stationFeature = this._getPointFeatureByObj(line[i].VIAStations.Station[j]);
							stationFeatures.push(stationFeature);
	                    }
						line[i].Stations = stationFeatures;
						//得到线几何对象
						var lineGeometry = this._getLineGeometryByGMLLineStr(line[i].Geometry.gml_LineString);
						//得到线要素
	                    var lineFeature = new Geo.Feature.Vector(lineGeometry, line[i]);
						lineFeatures.push(lineFeature);
	                }
			
					features = lineFeatures;
				}
				successFn(features);
            },
            failure: failFn
        });

    },
	//解析queryStationInfo接口返回的结果中的xml串
    _parserQueryLineInfoNode: function(nodeName, xmlparser, resXML){
		switch (nodeName) {
            case "Line":
                //解析line
	            var element = resXML.selectNodes("/QueryLineInfoResponse");
				var xmlObj = xmlparser.write(element[0]);
                var jsonObj = this._parseToJSON(xmlObj);
				var l = jsonObj.QueryLineInfoResponse.Line;
				
	            var lines = new Array();
                if (l && !(l instanceof Array)) {
                    lines = [l];
                }else{
					lines = l;
				}
	            return lines;
                break;
            default:
				return [];
                break;
        }
    },
	
	/**
     * APIMethod: queryPassagewayInfo
     * 根据出入口ID获取与此出入口有关的站点信息，包括出入口所对应的车站信息。（公交2.0）
     * 
     * Parameters:
     * options - {Object} 请求参数。
     *   networkName {String} (必选) 网络模型名称。
     *   passagewayId      {Integer} (必选) 出入口ID。
     * 
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     *       
     * 示例 根据出入口ID查询:
     * (code)
     *  busService.queryPassagewayInfo({
     *      networkName: "BusChangeModule",
     *      passagewayId : 2
     *  }
     *  (end)
     */
    queryPassagewayInfo: function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryPassagewayInfo",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.passagewayId === null || options.passagewayId === undefined || options.passagewayId === ""){
            throw "Error!Not passagewayId for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
        
        if(options.passagewayId !== null && options.passagewayId !== undefined){
            params.PASSAGEWAYID = options.passagewayId;
        }
        var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
				var resXML = result.responseXML;
				var features = [];	
				if(!resXML) {
					successFn(features);
					return features;
				}
				var xmlparser = new OpenLayers.Format.XML();
				var errorTemp = resXML.selectNodes("/ServiceExceptionReport/ServiceExceptionMessage");
				//没有查询到数据的情况
				if(errorTemp && errorTemp.length > 0) {
					successFn(features);
					return features;
				}
				var responseText = this._parserResponseText(result.responseText);
				features = this._parserFeaturesNew(responseText, "Stations");
				successFn(features);
            }
        });
	},
	
	CLASS_NAME: "Geo.Service.Bus"
});

//FF,chrome兼容selectNodes,selectSingleNode
(function xmlNodesTool(){
    if (document.implementation.hasFeature("XPath", "3.0")) {
        // prototying the XMLDocument 
        XMLDocument.prototype.selectNodes = function(cXPathString, xNode){
            if (!xNode) {
                xNode = this;
            }
            //name space resolver defined  
            function nsResolver(prefix){
                var ns = {
                    'csw': 'http://www.opengis.net/cat/csw',
                    'smmd': 'http://data.sbsm.gov.cn/smmd/2007',
                    'wfs': 'http://www.opengis.net/wfs',
                    'gml': 'http://www.opengis.net/gml',
                    'geoglobe': 'http://www.geostar.com.cn/geoglobe'
                };
                return ns[prefix] || null;
            }
            //var oNSResolver = this.createNSResolver(this.documentElement||this.ownerDocument.documentElement)||nsResolver;
            var aItems = this.evaluate(cXPathString, xNode, nsResolver, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
            var aResult = [];
            for (var i = 0; i < aItems.snapshotLength; i++) {
                aResult[i] = aItems.snapshotItem(i);
            }
            return aResult;
        };
        
        // prototying the Element 
        Element.prototype.selectNodes = function(cXPathString){
            if (this.ownerDocument.selectNodes) {
                return this.ownerDocument.selectNodes(cXPathString, this);
            }
            else {
                throw "For XML Elements Only";
            }
        };
        
    }
    if (document.implementation.hasFeature("XPath", "3.0")) {
        // prototying the XMLDocument 
        XMLDocument.prototype.selectSingleNode = function(cXPathString, xNode){
            if (!xNode) {
                xNode = this;
            }
            var xItems = this.selectNodes(cXPathString, xNode);
            if (xItems.length > 0) {
                return xItems[0];
            }
            else {
                return null;
            }
        };
        
        // prototying the Element 
        Element.prototype.selectSingleNode = function(cXPathString){
            if (this.ownerDocument.selectSingleNode) {
                return this.ownerDocument.selectSingleNode(cXPathString, this);
            }
            else {
                throw "For XML Elements Only";
            }
        };
    }
})();/**
 * Class: Geo.Service.Plot
 * 标绘服务类。
 * 
 * Inherits from:
 *  - <Geo.Service>
 */
Geo.Service.Plot = Geo.Class(Geo.Service,{
	
    
	/**
     * APIProperty: maxPerPage
     * {Integer} 每页的最大条数。
     */	
    maxPerPage: 100,
	
	/**
     * Constructor: Geo.Service.Plot
     * Geo.Service.Plot类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url, options){
		this.name = name;
		this.url = url;
		OpenLayers.Util.extend(this, options);
	},

	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息操作。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn, failFn){
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities"
		};
		OpenLayers.loadURL(url,params,this,function(result){
			result = this._parseToXML(result);
			successFn(result);
		},failFn);
	},
	
	/**
     * APIMethod: addClasses
     * 添加标绘分类操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     *   className -{String} 必填,分类名称,该名称不能重复。
     *   parentId -{String}   可填,父类ID。
     *   description -{String} 可填,描述信息。
     *   pictureUrl -{String} 可填,图片地址。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * 
     * (code)
     * plotService.addClasses({
	 *		className: "names",
	 *		parentId:"df",
	 *		description:"asdfsdfsdfsd",
	 *		pictureUrl:"fasdfasdfs"
	 *	});
	 * (end)
     */	
	addClasses: function(options, successFn, failFn){
		var params = {
			REQUEST: "AddClasses",
			userid: this.userid
		};
		var url = this.url;
		//name标签为必须
		var requestTemplate = 
			"<AddClasses>"+
				"<Feature>"+
					"<name>${className}</name>"+
					"<parentid>${parentId}</parentid>"+
					"<description>${description}</description>"+
					"<pictureurl>${pictureUrl}</pictureurl>"+
				"</Feature>"+
			"</AddClasses>";
		var className = options.className;
		var parentId = options.parentId;
		var description = options.description;
		var pictureUrl = options.pictureUrl;
		var requestString = OpenLayers.String.format(requestTemplate,{
			className: className,
			parentId: parentId,
			description: description,
			pictureUrl: pictureUrl
		});
		
        var xhr = OpenLayers.Request.POST({
            url: url,
            params: params,
            scope: this,
            data: requestString,
            success: function(result){
                var resultObj = this._parseToJSON(result.responseText);
                successFn(resultObj);
            },
            failure: failFn
        });
	},
	
	/**
     * APIMethod: deleteClasses
     * 删除分类操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     *   id	- {String} 类别ID,必填。
     * 
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * (code)
     * 	plotService.deleteClasses({
	 *				classId:"1101"
	 *			},function(result){
	 *			  //doSomeThing...
	 *			});
	 * (end)
     */
	deleteClasses: function(options, successFn, failFn){
		var params = {
			REQUEST: "DeleteClasses",
			userid: this.userid
		};
		var requestTemplate = 
			"<FeatureCollection>"+
			    "<Feature>"+
			        "<id>${classId}</id>"+
			    "</Feature>"+
			"</FeatureCollection>";
		var classId = options.classId;
		var requestString = OpenLayers.String.format(requestTemplate,{
			classId: classId
		});
		
		var url = this.url + "?" + OpenLayers.Util.getParameterString(params);
		
        var xhr = OpenLayers.Request.POST({
            url: url,
            params: params,
            scope: this,
            data: requestString,
            success: function(result){
                var resultObj = this._parseToJSON(result.responseText);
                successFn(resultObj);
            },
            failure: failFn
        });
	},

	
	/**
     * APIMethod: updateClasses
     * 修改分类操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     *   classId - {String}类别id,必填。唯一标识。
     *   description - {String} 可填,更新的分类描述。
     *   name - {String} 可填,图片的ID。
     *   pictureUrl - {String} 可填,图片地址。
     *   status - {String} 可填,分类状态。
     *   
     *   
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * (code)
     * plotService.updateClasses({
	 *			classId:classid,
     *          description: name,
     *          name: name,
     *          pictureUrl: "超市",
     *          status: "1"
	 *		},function(result){
	 *         //doSomeThing...
	 *      });
	 * (end)
     */	
	updateClasses: function(options, successFn, failFn){
		var params = {
			REQUEST: "UpdateClasses",
			userid: this.userid
		};
		var requestTemplate = 
    		"<FeatureCollection>"+
        		"<Feature>"+
        			"<id>${classId}</id>"+                    
        			"${name}"+
        			"${description}"+
        			"${pictureUrl}"+
        		"</Feature>"+
    		"</FeatureCollection>";
		var classId = options.classId;
        var name = options.name;
        var description = options.description;
        var pictureUrl = options.pictureUrl;
        var status = options.status;
        
		var requestString = OpenLayers.String.format(requestTemplate,{
			classId: classId,
            name:function(){
                return (name === null || name === undefined) ? 
                        "" : "<name>" + name + "</name>";
            },
            description:function(){
                return (description === null || description === undefined) ? 
                        "" : "<description>" + description + "</description>";
            },
            pictureUrl:function(){
                return (pictureUrl === null || pictureUrl === undefined) ? 
                        "" : "<pictureurl>" + pictureUrl + "</pictureurl>";
            }
            
		});
		
		var xhr = OpenLayers.Request.POST({
            url: this.url,
            params: params,
            scope: this,
            data: requestString,
            success: function(result){
                var resultObj = this._parseToJSON(result.responseText);
                successFn(resultObj);
            },
            failure: failFn
        });
	},
	
	/**
     * APIMethod: queryClasses
     * 查询分类操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     *     options的请求参数包括:
     *         requestType - 对象查询类型,必填(private私有,public公开,pending绑定,all所有)。
     *         filters - [],可以有零到多个 
     *     			例如：filters : [{type:'PropertyIsEqueTo',propertyName : "classcode",propertyValue : currentClassid}
	 *					            ],
     *         orderBy - {Object} 排序类型 例如： orderBy : {property:'EDITTIME',type:'desc'}
     *         		orderBy的请求参数包括 property和type。
     *         
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * (code)
     * plotService.queryClasses({
	 *				className:"class123",
	 *				filter : [{type:'PropertyIsNotEqualTo',propertyName : "parentid",propertyValue : 'A'},
	 *			  	{type:'PropertyIsLike',propertyName : "classname",propertyValue : 'on'}
	 *					],
	 *			},function(result){
	 *				//doSomeThing...
	 *			});
	 *(end)
     */		
	queryClasses: function(options, successFn, failFn){
		var params = {
			REQUEST: "QueryClasses",
			userid: this.userid
		};
		var url = this.url;
		
		var requestTemplate = 
			"<FeatureCollection>"+
			    "<Query>"+
			        "${pagingInfo}"+
					"${filter}" +
					"${orderBy}" +
			    "</Query>"+
			"</FeatureCollection>";
        var filterString = this._filterToString(options.filter);    
        var requestString = OpenLayers.String.format(requestTemplate,{
			pagingInfo: OpenLayers.Function.bind(function(){
                return this._pagingToString(options.maxPerPage,options.currentPage);
            },this),
			filter:filterString,
			orderBy: OpenLayers.Function.bind(function(){
				if(options.orderBy === undefined) {
					return "";
				}
                return this._orderByToString(options.orderBy.property,options.orderBy.type);
            },this)
		});

	
        var xhr = OpenLayers.Request.POST({
            url: url,
            params: params,
            scope: this,
            data: requestString,
            success: function(result){
                var resultObj = this._parseToJSON(result.responseText);
                successFn(resultObj);
            },
            failure: failFn
        });
			
	},
	
	/**
     * APIMethod: publishFeatures
     * 发布要素操作。
     * 
     * Parameters:
     * options - {Object} json格式的请求参数。
     *   bookmarkId - {String} 对象的唯一标识。必填。如果数据库中已存在,那么为更新操作,如果没有,则为新增操作。
     *   type - {String} 对象类型，必填。（点，线，面，point,line,polygon）。
     * 
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * 
     * (code)
     * plotService.publishFeatures({
     *					bookmarkId: "3455-345345-234234-3454",
     *                  type: "point"
     * },function(result){
	 *		//doSomeThing...
     * }); 
     * (end)
     */		
	publishFeatures: function(options, successFn, failFn){
		var requestTemplate = 
			"<FeatureCollection>"+
				"<Feature>"+
					"<BOOKMARKID>${bookmarkId}</BOOKMARKID>"+
					"<TYPE>${type}</TYPE>"+
				"</Feature>"+
			"</FeatureCollection>";
			
		var params = {
			REQUEST: "PublishFeatures",
			userid: this.userid
		};
		var url = this.url;
		
        var requestString = OpenLayers.String.format(requestTemplate,{
			bookmarkId: options.bookmarkId,
            type: options.type
		});
		
        var xhr = OpenLayers.Request.POST({
            url: url,
            params: params,
            scope: this,
            data: requestString,
            success: function(result){
                var resultObj = this._parseToJSON(result.responseText);
                successFn(resultObj);
            },
            failure: failFn
        });
	},

	/**
     * APIMethod: approvalFeatures
     * 审核要素操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     *   bookmarkId - {String} 对象的唯一标识。必填。如果数据库中已存在,那么为更新操作,如果没有,则为新增操作。
     *   type - {String} 对象类型，必填。（点，线，面，point,line,polygon）。
     *   
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * 
     * (code)
     *  plotService.approvalFeatures({
     *	   bookmarkId: "3455-345345-234234-3454",
     *     type: "point"
     *	},function(result){
	 *		//doSomeThing...
     *  }); 
     * (end)
     */		
	approvalFeatures: function(options, successFn, failFn){
		var requestTemplate = 
			"<FeatureCollection>"+
				"<Feature>"+
					"<BOOKMARKID>${bookmarkId}</BOOKMARKID>"+
					"<TYPE>${type}</TYPE>"+
				"</Feature>"+
			"</FeatureCollection>";
			
		var params = {
			REQUEST: "ApprovalFeatures",
			userid: this.userid,
			passresult:"pass"
		};
		var url = this.url;
		
        var requestString = OpenLayers.String.format(requestTemplate,{
			bookmarkId: options.bookmarkId,
            type: options.type
		});
		
        var xhr = OpenLayers.Request.POST({
            url: url,
            params: params,
            scope: this,
            data: requestString,
            success: function(result){
                var resultObj = this._parseToJSON(result.responseText);
                successFn(resultObj);
            },
            failure: failFn
        });
	},

	/**
     * APIMethod: addFeatures
     * 添加要素操作。
     *   
     * Parameters:
     * options - {Object} 请求参数。
     *   featureId - {String} 可填,对象ID。
     *   sortId - {String} 可填,标绘分类ID。
     *   sortType - {String} 可填,标绘分类码。
     *   bookmarkId - {String} 对象的唯一标识。必填。（如果数据库中已存在,那么为更新操作,如果没有,则为新增操作）。
     *   title - {String} 可填,标题。
     *   status - {String} 可填,要素的状态  "1"表示私有，"2"，表示发布，"3"表示审核。
     *   height - {String} 可填,高度。
     *   pitching - {String} 可填,投影。
     *   brief - {String} 可填，图片。
     *   type - {String} 对象类型，必填。(点,线,面,point,line,polygon)。
     *   linecolor - {String} 可填,线颜色。
     *   iconpath - {String}可填,图标路径。
     *   linewidth - {String} 可填,线宽度。
     *   fillcolor - {String} 可填,填充色。
     *   opacity - {String} 可填,是否透明。
     *   geometry - {<Geo.Geometry.LineString>} 必填 要素的几何属性。
     *  bookmarkId - {String} 对象的唯一标识。必填。如果数据库中已存在,那么为更新操作,如果没有,则为新增操作。
     *  sortType - {String} 分类ID  可填,标绘分类ID。
     *  
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * 
     * (code)
     *      plotService.addFeatures({
     *          title:title,
     *          sortType:classid,
	 *			type:'line',
     *          geometry:new Geo.Geometry.LineString([
	 *              new Geo.Geometry.Point(114.4,30.6),
	 *              new Geo.Geometry.Point(113.9,34.7),
	 *              new Geo.Geometry.Point(116.2,40.1),
	 *              new Geo.Geometry.Point(111.5,40.8)
	 *          ])
     *          },function(result){
     *             //doSomeThing...
     *          });
     *  (end)
     */		
    addFeatures: function(options, successFn, failFn){

        if(options.sortType === null && options.sortType === undefined){
            throw "Error!Not sortType of class.";
            return;
        }
        var uuid = Geo.Math.uuid();
        options.bookmarkId = uuid;
        
        this.updateFeatures(options,successFn,failFn);
    },

	/**
     * APIMethod: updateFeatures
     * 更新要素操作。
     *   
     * Parameters:
     * options - {Object} 请求参数。
     *   type - {String} 对象类型，必填。(点，线，面，point，line，polygon)
     *   bookmarkId - {String} 对象的唯一标识。必填。（如果数据库中已存在，那么为更新操作，如果没有，则为新增操作）
     *   featureId - {String} 可填，对象ID。
     *   sortId - {String} 可填，标绘分类ID。
     *   sortType - {String} 可填，标绘分类码。
     *   title - {String} 可填，标题。
     *   status - {String} 可填，要素的状态  "1"表示私有，"2"，表示发布，"3"表示审核。
     *   height - {String} 可填，高度。
     *   pitching - {String} 可填，投影。
     *   brief - {String} 可填，图片。
     *   linecolor - {String} 可填，线颜色。
     *   iconpath - {String}可填，图标路径。
     *   linewidth - {String} 可填，线宽度。
     *   fillcolor - {String} 可填，填充色。
     *   opacity - {String} 可填，是否透明。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * 
     * (code)
     * plotService.updateFeatures({
     * 	      bookmarkId:"234234-234234-234234-234234",
     *        type:"point",
     *        title:"招商银行"
     *  },function(result){
     *     //doSomeThing...
     *	}); 
     * (end)
     */		
	updateFeatures: function(options, successFn, failFn){
        
        var fOptions = options;
        
		var requestTemplate = 
		    '<Feature>'+
		        '${featureId}'+
		        '${sortId}'+
                '${sortType}'+
		        '${bookmarkId}'+
		        '${type}'+
		        '${iconpath}'+
		        '${brief}'+
		        '${linecolor}'+
		        '${linewidth}'+
		        '${fillcolor}'+
		        '${opacity}'+
		        '${title}'+
		        '${status}'+
		        '${height}'+
		        '${pitching}'+
		        '${geometry}'+
		    '</Feature>';
		var requestString = OpenLayers.String.format(requestTemplate,{
            featureId: function(){
                return (fOptions.featureId === null || fOptions.featureId === undefined) ? 
                        "" : "<FEATUREID>" + fOptions.featureId + "</FEATUREID>";
            },
            sortId: function(){
                return (fOptions.sortId === null || fOptions.sortId === undefined) ? 
                        "" : "<SORTID>" + fOptions.sortId + "</SORTID>";
            },
            sortType: function(){
                return (fOptions.sortType === null || fOptions.sortType === undefined) ? 
                        "" : "<SORTTYPE>" + fOptions.sortType + "</SORTTYPE>";
            },
            bookmarkId: function(){
                return (fOptions.bookmarkId === null || fOptions.bookmarkId === undefined) ? 
                        "" : "<BOOKMARKID>" + fOptions.bookmarkId + "</BOOKMARKID>";
            },
            title: function(){
                return (fOptions.title === null || fOptions.title === undefined) ? 
                        "" : "<TITLE>" + fOptions.title + "</TITLE>";
            },
            status: function(){
                return (fOptions.status === null || fOptions.status === undefined) ? 
                        "" : "<STATUS>" + fOptions.status + "</STATUS>";
            },
            height: function(){
                return (fOptions.height === null || fOptions.height === undefined) ? 
                        "" : "<HEIGHT>" + fOptions.height + "</HEIGHT>";
            },
            pitching: function(){
                return (fOptions.pitching === null || fOptions.pitching === undefined) ? 
                        "" : "<PITCHING>" + fOptions.pitching + "</PITCHING>";
            },
            brief: OpenLayers.Function.bind(function(){
                return (fOptions.brief === null || fOptions.brief === undefined) ? 
                        "" : "<BRIEF>" + fOptions.brief + "</BRIEF>";
            },this),
            type: OpenLayers.Function.bind(function(){
                return (fOptions.type === null || fOptions.type === undefined) ? 
                        "" : "<TYPE>" + fOptions.type + "</TYPE>";
            },this),
            linecolor: OpenLayers.Function.bind(function(){
                return (fOptions.linecolor === null || fOptions.linecolor === undefined) ? 
                        "" : "<LINECOLOR>" + fOptions.linecolor + "</LINECOLOR>";
            },this),
            iconpath: OpenLayers.Function.bind(function(){
                return (fOptions.iconpath === null || fOptions.iconpath === undefined) ? 
                        "" : "<ICONPATH>" + fOptions.iconpath + "</ICONPATH>";
            },this),
            linewidth: OpenLayers.Function.bind(function(){
                return (fOptions.linewidth === null || fOptions.linewidth === undefined) ? 
                        "" : "<LINEWIDTH>" + fOptions.linewidth + "</LINEWIDTH>";
            },this),
            fillcolor: OpenLayers.Function.bind(function(){
                return (fOptions.fillcolor === null || fOptions.fillcolor === undefined) ? 
                        "" : "<FILLCOLOR>" + fOptions.fillcolor + "</FILLCOLOR>";
            },this),
         	opacity: OpenLayers.Function.bind(function(){
                return (fOptions.opacity === null || fOptions.opacity === undefined) ? 
                        "" : "<OPACITY>" + fOptions.opacity + "</OPACITY>";
            },this),
            geometry: OpenLayers.Function.bind(function(){
                return (fOptions.geometry === null || fOptions.geometry === undefined) ? 
                        "" : this._geometryToString(fOptions.geometry);
            },this)
        });
        requestString = '<FeatureCollection>' + requestString + '</FeatureCollection>';
		
        var params = {
			REQUEST: "UpdateFeatures",
			userid: this.userid
		};
        
        var xhr = OpenLayers.Request.POST({
            url: this.url,
            params: params,
            scope: this,
            data: requestString,
            success: function(result){
                var resultObj = this._parseToJSON(result.responseText);
                successFn(resultObj);
            },
            failure: failFn
        });
	},

	/**
     * APIMethod: deleteFeatures
     * 删除要素操作。
     *   
     * Parameters:
     * options - {Object} 请求参数。
     * 	bookmarkId - {String} 对象的唯一标识。必填。
     *  type - {String} 对象类型，必填。（点，线，面，point,line,polygon）
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * (code)
     *   plotService.deleteFeatures({
	 *		 bookmarkId: "23434-3434-23234-1234",
	 *       type: "line"
	 *   },function(result){
	 *      //doSomeThing...
     *   });
     *   (end)
     */		
	deleteFeatures: function(options, successFn, failFn){
		var requestTemplate = 
			"<FeatureCollection>"+
				"<Feature>"+
					"<BOOKMARKID>${bookmarkId}</BOOKMARKID>"+
					"<TYPE>${type}</TYPE>"+
				"</Feature>"+
			"</FeatureCollection>";
			
		var params = {
			REQUEST: "DeleteFeatures",
			userid: this.userid
		};
		var url = this.url;
		
        var requestString = OpenLayers.String.format(requestTemplate,{
			bookmarkId: options.bookmarkId,
            type: options.type
		});
		
        var xhr = OpenLayers.Request.POST({
            url: url,
            params: params,
            scope: this,
            data: requestString,
            success: function(result){
                var resultObj = this._parseToJSON(result.responseText);
                successFn(resultObj);
            },
            failure: failFn
        });
	},
    
	/**
     * APIMethod: queryFeatures
     * 查询要素操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     *   requestType - 对象查询类型,必填(private私有,public公开,pending绑定,all所有)。
     *   filters - [],可以有零到多个。
     *			例如：filters : [{type: 'PropertyIsEqueTo',propertyName: "plotclass",propertyValue: currentClassid},
	 *				  	{type: 'PropertyIsLike',propertyName: "TITLE",propertyValue: 'ATM'}
	 *				  ],
     *   orderBy - {Object} 排序类型 例如： orderBy : {property: 'EDITTIME',type: 'desc'}
     *    		orderBy的请求参数包括 property和type。
     *   
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 方法使用举例:
     * (code)
     * plotService.queryFeatures({
	 *		requestType:"public",
	 *		filters: [{type: 'PropertyIsEqueTo',propertyName: "plotclass",propertyValue: currentClassid},
	 *			{type: 'PropertyIsLike',propertyName: "TITLE",propertyValue: 'ATM'}
	 *		],
	 *		orderBy: {property: 'EDITTIME',type: 'desc'}
	 *	},function(features){
	 *     //doSomeThing...
	 *  }); 
	 * (end)
     */		
	queryFeatures: function(options, successFn, failFn){
        
		var params = {
			REQUEST: "QueryFeatures",
			userid: this.userid
		};
		var url = this.url;
        	
		var requestTemplate = 
			"<FeatureCollection>"+
			    "<Query>"+
                    "${pagingInfo}"+
			        "<requestType>${requestType}</requestType>"+
			        "${orderBy}"+
					"${filter}"+
			    "</Query>"+
			"</FeatureCollection>";
        var requestString = OpenLayers.String.format(requestTemplate,{
            pagingInfo: OpenLayers.Function.bind(function(){
                return this._pagingToString(options.maxPerPage,options.currentPage);
            },this),
            classcode: options.classcode,
			filter : OpenLayers.Function.bind(function(){
                return this._filterToString(options.filters);
            },this),
            orderBy:OpenLayers.Function.bind(function(){
				if(options.orderBy === undefined) {
					return "";
				}
                return this._orderByToString(options.orderBy.property,options.orderBy.type);
            },
            this), requestType:options.requestType
		});
        				
        var xhr = OpenLayers.Request.POST({
            url: url,
            params: params,
            scope: this,
            data: requestString,
            success: function(result){
                var features = this._parserFeatures(result.responseText);
                successFn(features);
            },
            failure: failFn
        });
	},
    
    _getGeometryType: function(geometry){
        var maping = {
            "OpenLayers.Geometry.Point": "point",
            "OpenLayers.Geometry.LineString": "line",
            "OpenLayers.Geometry.Polygon": "polygon"
        };
        return maping[geometry.CLASS_NAME];
    },
	
	_filterToString:function(filters){
		if(!filters) {
			return "";
		}
		var filterString = "";
		if(!(filters instanceof Array)) {
			filters = [filters];
		} 
		for(var i = 0; i < filters.length; i++) {
				filterString +=  "<Filter>"+
	            "<"+filters[i].type+">"+
	            "<PropertyName>"+filters[i].propertyName+"</PropertyName>"+
	            "<Literal>"+filters[i].propertyValue+"</Literal>"+
	            "</"+filters[i].type+">";
		        filterString += "</Filter>";
		}
		
		return filterString;
	},
    
    _pagingToString: function(curPage, maxPerPage){
        maxPerPage = maxPerPage || this.maxPerPage;
        curPage = curPage || 1;
        return "<numPerPage>" + maxPerPage + "</numPerPage>"+
                "<curPage>" + curPage + "</curPage>";
    },
    
    _orderByToString: function(property, type){
        var str = "<orderBy>"+
    	            "<PropertyName>" + property + "</PropertyName>"+
					"<OrderType>" + type + "</OrderType>"+
    	        "</orderBy>";
        return property ? str : "";
    },
    
    _geometryToString: function(geometry){
        var parser = new OpenLayers.Format.GML();
        var xmlnode = parser.buildGeometryNode(geometry);
        return '<geometry>' + xmlnode.xml + '</geometry>';
    },
    
	//解析器
	_parserGetcapabilities:  function(result){
			return result;
	},
    
    _parserFeatures: function(resultString){
        var parser = new OpenLayers.Format.GML();
        parser.gmlns = "*";
        parser.featureName = "featureMember";
        var features = parser.read(resultString);
        return features;
    },
    
	_parserSuccessResult: function(result){
		var parser = new Geo.Util.Format.XML2JSON();
		return parser.read(result);
	},
	
	_parseToXML: function(result){
        var xmlParser = new OpenLayers.Format.XML();
		return xmlParser.read(result.responseText);

	},
	
	_parseToJSON: function(result){
		var parser = new Geo.Util.Format.XML2JSON();
		return parser.read(result);
	},

	CLASS_NAME: "Geo.Service.Plot"
});/**
 * Class: Geo.Service.ShortestPath
 * 最短路径服务类。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.ShortestPath = Geo.Class(Geo.Service, {

	
	/**
     * Constructor: Geo.Service.ShortestPath
     * Geo.Service.ShortestPath类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		this.name = name;
		this.url = url;
		OpenLayers.Util.extend(this, options);
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities"
		};
		OpenLayers.loadURL(url,params,this,successFn,failFn);
	},
	
	/**
     * APIMethod: shortestPath
     * 最短路径查询操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     *   start - {String} 起点坐标。
     *   end - {String}终点坐标。
     *   network - {String}网络模型名称。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例：
     * var service = new Geo.Service.ShortestPath();
     * service.shortestPath({
     *         start: "113,29",
     *         end: "116,39",
     *         network: "RouteModelDis"
     *     },function(features){
     *         //doSomeThing
     *     });
     */	
	shortestPath: function(options, successFn, failFn){
		var url = this.url;
        var startcoord = options.start;
        var endcoord = options.end;
        var network = options.network;
		var params = {
			REQUEST:"ShortestPath",
			STARTCOORD: startcoord,
			ENDCOORD: endcoord,
			NETWORKNAME: network
		};
		OpenLayers.loadURL(url,params,this,function(result){
            var features = this._parseShortestPath(result);
            successFn(features);
        },failFn);
	},
    
    //解析最短路径结果
    _parseShortestPath: function(result){
		var xmlParser = new OpenLayers.Format.XML();
		if(!result.responseXML){
			result.responseXML = xmlParser.read(result.responseText);
		}
        var parser = new OpenLayers.Format.GML();
        parser.gmlns = "*";
        var features = parser.read(result.responseXML);
        return features;
    },
    
	//解析服务能力描述信息
	_parseCapabilities: function(xml){
		
	},
	
	/*
	 * APIMethod:findRoute
	 * 返回请求起始坐标对应路网模型的导航链路信息
	 */
	findRoute: function(options, successFn, failFn) {
		var params = {
			REQUEST: "FindRoute",
			SERVICE:"ROUTE",
			VERSION:"1.0.0"
		};
        var required = {
            data: true,
            orig: true,
            dest: true
        };
        for (var prop in required) {
            if (!(prop in config)) {
                throw new Error("Missing property '" + prop + "'");
            }
        }
		params.DATA = options.data;
		params.ORIG = options.orig;
		params.DEST = options.dest;
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
	  	if(options.radius !== null && options.radius !== undefined){
            params.RADIUS = options.radius;
        }
        
        if(options.queryType !== null && options.queryType !== undefined){
            params.QUERYTYPE = options.queryType;
        }
		
		if(options.midpos !== null && options.midpos !== undefined){
            params.MIDPOS = options.midpos;
        }
		if(options.avoidPos !== null && options.avoidPos !== undefined){
            params.AVOIDPOS = options.avoidPos;
        }
		if(options.filterRoute !== null && options.filterRoute !== undefined){
            params.FILTERROUTE = options.filterRoute;
        }
		if(options.resultCount !== null && options.resultCount !== undefined){
            params.RESULTCOUNT = options.resultCount;
        }
		var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
                var Routes = this._parseFindRouteResult(result);
                successFn(Routes);
            },
            failure: failFn
        });
	},
	
	_parseToJSON: function(result){
		var parser = new Geo.Util.Format.XML2JSON();
		return parser.read(result.responseText);
	},
	
	_parseFindRouteResult: function(result) {
		var routesTemp =  this._parseToJSON(result);
		this._parserFeatures(routesTemp);
		var Routes = {
			Route:routesTemp.Routes.Route
		}
		return Routes;
	},
	
	_parserFeatures: function(data) {
		var route = data.Routes.Route;
		if(route) {
			if(!(route instanceof Array)) {
				route = [route];
				data.Routes.Route = route;
			}
			for(var i = 0,j = route.length; i < j;i++) {
				var item = route[i].Item;
				var features = [];
				if(item) {
					if(!(item instanceof Array)) {
						item = [item];
					}
					for(var m = 0, n = item.length; m < n; m++) {
						var feature = this._getFeatureForFindRoute(item[m]);
						features.push(feature);
					}
				}
				route[i].Item = features;
			}
		}
	},
	
	_getFeatureForFindRoute: function(attribute) {
		if(!attribute || !attribute.Geometry) {
			throw "FindRoute查询中，查询结果缺少item或Geometry";
			return;
		}
		var geometry = attribute.Geometry;
		if(geometry.gml_Point) {
			geometry = this._geometryForFindRoute["point"](geometry.gml_Point);
		}else if(geometry.gml_LineString) {
			geometry = this._geometryForFindRoute["line"](geometry.gml_LineString);
		}
		
		var feature = new Geo.Feature.Vector(geometry,attribute);
		return feature;
	},
	
	_geometryForFindRoute : {
		point: function(pointStr) {
			var pointArr = pointStr.split(",");
			var point = new Geo.Geometry.Point(parseFloat(pointArr[0]),parseFloat(pointArr[1]));
			return point;
		},
		line: function(lineStr) {
			if(lineStr) {
				var pointStrArr = lineStr.split(" ");
				var pointArr = [];
				for(var i = 0,j = pointStrArr.length; i < j; i++) {
					var pointGeometry = _geometryForFindRoute["point"](pointStrArr[i]);
					pointArr.push(pointGeometry);
				}
				var lineGeometry = new OpenLayers.Geometry.LineString(pointArr);
				return lineGeometry;
			}else {
				return null;
			}
		}
	},
	
	/**
	 * APIMethod:getRouteInfo
	 * 返回请求编号查询到路段的详细信息。
	 */
	getRouteInfo: function(options, successFn, failFn) {
		var params = {
			REQUEST: "GetRouteInfo",
			SERVICE:"ROUTE",
			VERSION:"1.0.0"
		};
		if(!options.data || !options.id){
            throw "Error!Not data and id for bus query.";
            return;
        }
		params.DATA = options.data;
		params.ID = options.id;
		var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
				var features = this._parserFeaturesForRouteInfo(result);
            	successFn(features);
            },
            failure: failFn
        });
	},	
	
	_parserFeaturesForRouteInfo: function(resultString){
        var resultJson = this._parseToJSON(resultString);
		var RouteInfo = this._getFeaturesForRouteInfo(resultJson);
		return RouteInfo;
    },
	
	_getFeaturesForRouteInfo: function(data) {
		var route = data.RouteInfo.Route;
		if(route) {
			if(!(route instanceof Array)) {
				route = [route];
				data.RouteInfo.Route = route;
			}
			var features = [];
			for(var i = 0,j = route.length; i < j;i++) {
				var routeTemp = route[i];
				var feature = this._getFeatureForFindRoute(routeTemp);
				features.push(feature);
			}
			data.RouteInfo.Route = features;
		}
		var RouteInfo = {
			Route:data.RouteInfo.Route
		}
		return RouteInfo;
	},
    
	CLASS_NAME: "Geo.Service.ShortestPath"
});/**
 * Class: Geo.Service.Route
 * 最短路径服务类。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.Route = Geo.Class(Geo.Service, {

	
	/**
     * Constructor: Geo.Service.Route
     * Geo.Service.Route类的构造函数
     *
     * Parameters:
     * name - {String} 服务名称
     * url - {String} 服务地址
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		this.name = name;
		this.url = url;
		OpenLayers.Util.extend(this, options);
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities"
		};
		OpenLayers.loadURL(url,params,this,successFn,failFn);
	},
	
	/*
	 * APIMethod:findRoute
	 * 返回请求起始坐标对应路网模型的导航链路信息
	 * Parameters:
	 * options - {Object} 请求参数
	 * 		data - {String} （必选）路网名称
	 * 		orig - {String} （必选）起点坐标   例如："120,30"
	 * 		dest -  {String} （必选）终点坐标
	 * 		radius — {Number}(可选) 抓取起点与终点距离有效道路的半径范围，单位为米，默认值为10米
	 * 		queryType - {Number} (可选)导航查询类型。0表示最快时间；1表示最短路径，默认为按最短路径查询
	 * 		midpos - {String}(可选) 途径点坐标集，多个坐标之间以分号分隔，XY坐标之间以逗号分隔。（如：x1,y1;x2,y2）
	 * 		avoidPos - {String}(可选) 规避点坐标集，多个坐标之间以分号分隔，XY坐标之间以逗号分隔。（如：x1,y1;x2,y2）
	 *      filterRoute - {Number}(可选) 导航查询的途径路段类型过滤，可选值：0 – 不进行过滤；1 – 过滤高速公路；2 – 过滤小路；默认值为0
	 *      resultCount - {Number}返回导航查询的最大解决方案数量，参数值必须为正整数,默认值为1
	 *   (code) 
	 *   	//创建路网查询对象
	 *   	var ShortestPath =new  Geo.Service.ShortestPath("shortPath","http://10.4.6.248:7009/Route_L/route");
	 *   	ShortestPath.findRoute({
	 *				data:"XZ",
	 *				id:"706,347"
	 *			},function(routes){
	 *				debugger;
	 *			});
	 *   (end)
	 */
	findRoute: function(options, successFn, failFn) {
		var params = {
			REQUEST: "FindRoute",
			SERVICE:"ROUTE",
			VERSION:"1.0.0"
		};
        var required = {
            data: true,
            orig: true,
            dest: true
        };
        for (var prop in required) {
            if (!(prop in options)) {
                throw new Error("Missing property '" + prop + "'");
            }
        }
		params.DATA = options.data;
		params.ORIG = options.orig;
		params.DEST = options.dest;
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
	  	if(options.radius !== null && options.radius !== undefined){
            params.RADIUS = options.radius;
        }
        
        if(options.queryType !== null && options.queryType !== undefined){
            params.QUERYTYPE = options.queryType;
        }
		
		if(options.midpos !== null && options.midpos !== undefined){
            params.MIDPOS = options.midpos;
        }
		if(options.avoidPos !== null && options.avoidPos !== undefined){
            params.AVOIDPOS = options.avoidPos;
        }
		if(options.filterRoute !== null && options.filterRoute !== undefined){
            params.FILTERROUTE = options.filterRoute;
        }
		if(options.resultCount !== null && options.resultCount !== undefined){
            params.RESULTCOUNT = options.resultCount;
        }
		var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
                var Routes = this._parseFindRouteResult(result);
                successFn(Routes);
            },
            failure: failFn
        });
	},
	
	_parseToJSON: function(result){
		var parser = new Geo.Util.Format.XML2JSON();
		var xml = result.responseXML.xml;
		return parser.read(xml);
	},
	
	_parseFindRouteResult: function(result) {
		var routesTemp =  this._parseToJSON(result);
		var rTemp = this._parserFeatures(routesTemp);
		var Routes = {
			Route:rTemp
		}
		return Routes;
	},
	
	_parserFeatures: function(data) {
		if(!data.Routes) {
			return {};
		}
		var route = data.Routes.Route;
		if(route) {
			if(!(route instanceof Array)) {
				route = [route];
				data.Routes.Route = route;
			}
			for(var i = 0,j = route.length; i < j;i++) {
				var item = route[i].Item;
				var features = [];
				if(item) {
					if(!(item instanceof Array)) {
						item = [item];
					}
					for(var m = 0, n = item.length; m < n; m++) {
						var feature = this._getFeatureForFindRoute(item[m]);
						features.push(feature);
					}
				}
				route[i].Item = features;
			}
		}
		return route;
	},
	
	_getFeatureForFindRoute: function(attribute) {
		if(!attribute || !attribute.Geometry) {
			throw "FindRoute查询中，查询结果缺少item或Geometry";
			return;
		}
		var geometry = attribute.Geometry;
		if(geometry.gml_Point) {
			geometry = this._geometryForFindRoute["point"](geometry.gml_Point);
		}else if(geometry.gml_LineString) {
			geometry = this._geometryForFindRoute["line"](geometry.gml_LineString);
		}
		
		var feature = new Geo.Feature.Vector(geometry,attribute);
		return feature;
	},
	
	_geometryForFindRoute : {
		point: function(pointStr) {
			var pointArr = pointStr.split(",");
			var point = new Geo.Geometry.Point(parseFloat(pointArr[0]),parseFloat(pointArr[1]));
			return point;
		},
		line: function(lineStr) {
			if(lineStr) {
				var pointStrArr = lineStr.split(" ");
				var pointArr = [];
				for(var i = 0,j = pointStrArr.length; i < j; i++) {
					var pointGeometry = Geo.Service.Route.prototype._geometryForFindRoute["point"](pointStrArr[i]);
					pointArr.push(pointGeometry);
				}
				var lineGeometry = new OpenLayers.Geometry.LineString(pointArr);
				return lineGeometry;
			}else {
				return null;
			}
		}
	},
	
	/*
	 * APIMethod:getRouteInfo
	 * 返回请求编号查询到路段的详细信息
	 * 	Parameters:
	 * 		options - {Object} 请求参数
	 * 			data - {String} （必选）路网名称
	 *   (code) 
	 *   	//创建路网查询对象
	 *   	var ShortestPath =new  Geo.Service.ShortestPath("shortPath","http://10.4.6.248:7009/Route_L/route");
	 *   	ShortestPath.getRouteInfo({
	 *				data:"XZ",
	 *				id:"706,347"
	 *			},function(routes){
	 *				debugger;
	 *			});
	 *   (end)
	 */
	getRouteInfo: function(options, successFn, failFn) {
		var params = {
			REQUEST: "GetRouteInfo",
			SERVICE:"ROUTE",
			VERSION:"1.0.0"
		};
		if(!options.data || !options.id){
            throw "Error!Not data and id for bus query.";
            return;
        }
		params.DATA = options.data;
		params.ID = options.id;
		var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
				var features = this._parserFeaturesForRouteInfo(result);
            	successFn(features);
            },
            failure: failFn
        });
	},	
	
	_parserFeaturesForRouteInfo: function(result){
        var resultJson = this._parseToJSON(result);
		var RouteInfo = this._getFeaturesForRouteInfo(resultJson);
		return RouteInfo;
    },
	
	_getFeaturesForRouteInfo: function(data) {
		var routeInfoTemp = data.RouteInfo;
		if(!routeInfoTemp || !routeInfoTemp.Route) {
			var RouteInfo = {
				Route:{}
			}
			return RouteInfo;
		}
		var route = routeInfoTemp.Route;
		if(route) {
			if(!(route instanceof Array)) {
				route = [route];
				routeInfoTemp.Route = route;
			}
			var features = [];
			for(var i = 0,j = route.length; i < j;i++) {
				var routeTemp = route[i];
				var feature = this._getFeatureForFindRoute(routeTemp);
				features.push(feature);
			}
			routeInfoTemp.Route = features;
		}
		var RouteInfo = {
			Route:routeInfoTemp.Route
		}
		return RouteInfo;
	},
    
	CLASS_NAME: "Geo.Service.Route"
	
});/**
 * Class: Geo.Service.TAS
 * 地形分析服务类。
 *
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.TAS = Geo.Class(Geo.Service, {

    /**
     * Constructor: Geo.Service.TAS
     * Geo.Service.TAS 类的构造函数。
     *
     * Parameters:
     * 	name - {String} 服务名称。
     * 	url - {String} 服务地址。
     * 	options - {Object} 实例的选项设置，此参数可选。
     *
     */
    initialize: function(name, url, options){
        this.name = name;
        this.url = url;
        OpenLayers.Util.extend(this, options);
    },
    
    /**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     *
     * Parameters:
     * 	successFn - {Function} 请求成功的回调函数。
     * 	failFn - {Function} 请求失败的回调函数。
     */
    getCapabilities: function(successFn, failFn){
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            VERSION: "1.0.0",
            SERVICE: "TAS"
        };
        OpenLayers.loadURL(url, params, null, successFn, failFn);
    },
    
    /**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     *
     * Returns:
     * {Boolean} 服务是否存在。
     */
    isExist: function(){
        var isExist = false;
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            VERSION: "1.0.0",
            SERVICE: "TAS"
        };
        var xhr = OpenLayers.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(){
                isExist = true;
            }
        });
        return isExist;
    },
    
    /**
     * APIMethod: pointAltitude
     * 地形高程查询操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.pointAltitude({
     *      layerLevel: 3,
     *      pointCount: 1,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049",
     *      subjoin : 10
     *  })
     *  (end)
     */
    pointAltitude: function(options, successFn, failFn){
        this._sendRequest("PointAltitude", options, successFn, failFn);
    },
    
    /**
     * APIMethod: pointSlope
     * 坡度查询操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.pointSlope({
     *      layerLevel: 3,
     *      pointCount: 1,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049",
     *      subjoin : 10
     *  })
     *  (end)
     */
    pointSlope: function(options, successFn, failFn){
        this._sendRequest("PointSlope", options, successFn, failFn);
    },
    
    /**
     * APIMethod: pointAspect
     * 坡向查询操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.pointAspect({
     *      layerLevel: 3,
     *      pointCount: 1,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049",
     *      subjoin : 10
     *  }
     *  (end)
     */
    pointAspect: function(options, successFn, failFn){
        this._sendRequest("PointAspect", options, successFn, failFn);
    },
    
    /**
     * APIMethod: surfaceArea
     * 表面面积查询操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.surfaceArea({
     *      layerLevel: 3,
     *      pointCount: 3,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049,104.061,25.293686487049,104.4542,23.558429",
     *      subjoin : 10
     *  }
     *  (end)
     */
    surfaceArea: function(options, successFn, failFn){
        this._sendRequest("SurfaceArea", options, successFn, failFn);
    },
    
    /**
     * APIMethod: volume
     * 体积查询操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.volume({
     *      layerLevel: 3,
     *      pointCount: 3,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049,104.061,25.293686487049,104.4542,23.558429",
     *      subjoin : 10
     *  }
     *  (end)
     */
    volume: function(options, successFn, failFn){
        this._sendRequest("Volume", options, successFn, failFn);
    },
    
    /**
     * APIMethod: surfaceDistance
     * 表面矩离查询操作。
     *
     * Parameters:
     * options - {Object} 请求参数
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.surfaceDistance({
     *      layerLevel: 3,
     *      pointCount: 2,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049,104.061123,25.293686487049",
     *      subjoin : 10
     *  }
     *  (end)
     */
    surfaceDistance: function(options, successFn, failFn){
        this._sendRequest("SurfaceDistance", options, successFn, failFn);
    },
    
    /**
     * APIMethod: profileAnalysis
     * 剖面分析操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.profileAnalysis({
     *      layerLevel: 3,
     *      pointCount: 2,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049,104.061123,25.293686487049",
     *      subjoin : 10
     *  }
     *  (end)
     */
    profileAnalysis: function(options, successFn, failFn){
        this._sendRequest("ProfileAnalysis", options, successFn, failFn);
    },
    
    /**
     * APIMethod: contourAnalysis
     * 等高线分析操作
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.contourAnalysis({
     *      layerLevel: 3,
     *      pointCount: 3,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049,104.061,25.293686487049,104.4542,23.558429",
     *      subjoin : 10
     *  }
     *  (end)
     */
    contourAnalysis: function(options, successFn, failFn){
        this._sendRequest("ContourAnalysis", options, successFn, failFn);
    },
    
    /**
     * APIMethod: topPoint
     * 顶点查询操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.topPoint({
     *      layerLevel: 3,
     *      pointCount: 3,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049,104.061,25.293686487049,104.4542,23.558429",
     *      subjoin : 10
     *  }
     *  (end)
     */
    topPoint: function(options, successFn, failFn){
        this._sendRequest("TopPoint", options, successFn, failFn);
    },
    
    /**
     * APIMethod: singlePointVisiable
     * 单点可视查询操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.singlePointVisiable({
     *      layerLevel: 3,
     *      pointCount: 3,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049,104.061,25.293686487049,104.4542,23.558429",
     *      subjoin : 10
     *  }
     *  (end)
     */
    singlePointVisiable: function(options, successFn, failFn){
        this._sendRequest("SinglePointVisiable", options, successFn, failFn);
    },
    
    /**
     * APIMethod: floodAnalysis
     * 洪水淹沿分析操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.floodAnalysis({
     *      layerLevel: 3,
     *      pointCount: 3,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049,104.061,25.293686487049,104.4542,23.558429",
     *      subjoin : 10
     *  }
     *  (end)
     */
    floodAnalysis: function(options, successFn, failFn){
        this._sendRequest("FloodAnalysis", options, successFn, failFn);
    },
    
    /**
     * APIMethod: topLowPoint
     * 最高点与最低点的查询操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.topLowPoint({
     *      layerLevel: 3,
     *      pointCount: 3,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049,104.061,25.293686487049,104.4542,23.558429",
     *      subjoin : 10
     *  }
     *  (end)
     */
    topLowPoint: function(options, successFn, failFn){
        this._sendRequest("TopLowPoint", options, successFn, failFn);
    },
    
    /**
     * APIMethod: getMetaData
     * 元数据查询操作。
     *
     * Parameters:
     * caller - {Object}
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    getMetaData: function(caller, successFn, failFn){
        this._sendRequest("GetMetaData", options, successFn, failFn);
    },
    
    //发送请求
    _sendRequest: function(action, options, successFn, failFn){
        var url = this.url;
        var layerLevel = options.layerLevel;
        var layerName = options.layerName;
        var pointCount = options.pointCount;
        var coordinates = this._convertRadian(options.coordinates);
        var subjoin = options.subjoin || 0;
        var params = {
            REQUEST: action,
            LAYERLEVEL: layerLevel,
            LAYERNAME: layerName,
            POINTCOUNT: pointCount,
            COORDINATES: coordinates,
            SUBJOIN: subjoin
        };
        OpenLayers.loadURL(url, params, this, function(result){
            var resultObj = this._parseResult(result);
            successFn(resultObj);
        }, failFn);
    },
    
    //经纬度转弧度
    _convertRadian: function(coordinates){
        var arr = coordinates.split(",");
        for (var i = 0; i < arr.length; i++) {
            arr[i] = arr[i] * 3.1415926 / 180;
        }
        return arr.join(",");
    },
    
    _countCoord: function(pointString){
        var arr = pointString.split(",");
        return arr.length / 2;
    },
    
    _parseResult: function(result){
        var errorResult = this._checkIsError(result.responseText);
        if (!errorResult) {
            var parser = new Geo.Util.Format.XML2JSON();
            var resultObj = parser.read(result.responseText);
            return resultObj;
        }
        return errorResult;
    },
    
    CLASS_NAME: "Geo.Service.TAS"
});
/**
 * Class: Geo.Service.WPS
 * OGC-WPS服务类。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.WPS = Geo.Class(Geo.Service, {
	
	/**
     * Constructor: Geo.Service.WPS
     * Geo.Service.WPS类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		Geo.Service.prototype.initialize.apply(this, arguments);
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		var request = "GetCapabilities";
		var url = this.url + "/" + request;
		
		if(!failFn){
			failFn = function(){
				this.failFn(request);
			};
		}
		OpenLayers.loadURL(url,null,this,function(result){
			successFn(result);
		},failFn);
	},
	
	/**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * 
     * Returns:
     * {Boolean} 服务是否存在。
     */
	isExist: function(){
		var isExist = false;
		var request = "GetCapabilities";
		var url = this.url + "/" + request;
		var xhr = OpenLayers.Request.GET({
            url: url,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},
	
	/**
     * APIMethod: describeProcess
     * 获取指定Process描述信息。
     * 
     * Parameters:
     * process - {String} Process名称。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例：
     * (code)
     * serviceObj.describeProcess("buffer", function(result){
     *     alert(result.reponseText);
     * });
     * (end)
     */	
	describeProcess: function(process,successFn,failFn){
		var requestTemplate = 
			'<DescribeProcess xmlns="http://www.opengis.net/wps/1.0.0" ' +
							  'xmlns:ows="http://www.opengis.net/ows/1.1" ' +
							  'xmlns:xlink="http://www.w3.org/1999/xlink" ' +
							  'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" ' +
							  'xsi:schemaLocation="http://www.opengis.net/wps/1.0.0 ../wpsDescribeProcess_request.xsd" ' +
							  'service="WPS" ' +
							  'version="1.0.0" ' +
							  'language="en-CA">' +
			    '<ows:Identifier>' +
			        '${process}' +
			    '</ows:Identifier>' +
			'</DescribeProcess>';
		var postStr = OpenLayers.String.format(
			requestTemplate,
			{process:process}
		);
		
		var request = "DescribeProcess";
		var url = this.url + "/" + request;
		
		if(!failFn){
			failFn = function(){
				this.failFn(request);
			};
		}
		
		var xhr = new OpenLayers.Request.POST({
			url: url,
			data: postStr,
			scope: this,
			success:successFn,
			failure:failFn
		});
	},
	
	/**
     * APIMethod: execute
     * 执行分析操作。
     * 
     * Parameters:
     * content - {String} 分析操作请求内容。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * (code)
     *       var requestStr = '<wps:Execute service="WPS" version="1.0.0" 
     *       xmlns:gml="http://www.opengis.net/gml" 
     *       xmlns:wps="http://www.opengis.net/wps/1.0.0" 
     *       xmlns:ows="http://www.opengis.net/ows/1.1" 
     *       xmlns:wfs="http://www.opengis.net/wfs" 
     *       xmlns:xlink="http://www.w3.org/1999/xlink" 
     *       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
     *       xsi:schemaLocation="http://www.opengis.net/wps/1.0.0 ../wpsExecute_request.xsd">' +
     *           '<ows:Identifier>Intersection</ows:Identifier>' +
     *           '<wps:DataInputs>' +
     *           '<wps:Input>' +
     *           '<ows:Identifier>InputPolygon</ows:Identifier>' +
     *           '<wps:Data>' +
     *           '<wps:ComplexData schema="http://foo.bar/MyComplexValueSchema.xsd" mimeType="text/xml" encoding="UTF-8">' +
     *           '<wfs:FeatureCollection xmlns:wfs="http://www.opengis.net/wfs">' +
     *           '<gml:featureMember xmlns:gml="http://www.opengis.net/gml">' +
     *           '<feature:features xmlns:feature="http://mapserver.gis.umn.edu/mapserver" fid="Geo.Feature.Vector_112">' +
     *           '<feature:geometry>' +
     *           '<gml:LineString>' +
     *           '<gml:coordinates decimal="." cs="," ts=" ">100.40625,12.09765625 110.10546875,45.83203125</gml:coordinates>' +
     *           '</gml:LineString>' +
     *           '</feature:geometry>' +
     *           '</feature:features>' +
     *           '</gml:featureMember>' +
     *           '</wfs:FeatureCollection>' +
     *           '<wfs:FeatureCollection xmlns:wfs="http://www.opengis.net/wfs">' +
     *           '<gml:featureMember xmlns:gml="http://www.opengis.net/gml">' +
     *           '<feature:features xmlns:feature="http://mapserver.gis.umn.edu/mapserver" fid="Geo.Feature.Vector_118">' +
     *           '<feature:geometry>' +
     *           '<gml:LineString>' +
     *           '<gml:coordinates decimal="." cs="," ts=" ">100.40625,30.09765625 110.10546875,30.83203125</gml:coordinates>' +
     *           '</gml:LineString>' +
     *           '</feature:geometry>' +
     *           '</feature:features>' +
     *           '</gml:featureMember>' +
     *           '</wfs:FeatureCollection>' +
     *           '</wps:ComplexData>' +
     *           '</wps:Data>' +
     *           '</wps:Input>' +
     *           '</wps:DataInputs>' +
     *           '<wps:ResponseForm>' +
     *           '<wps:RawDataOutput>' +
     *           '<ows:Identifier>BufferedPolygon</ows:Identifier>' +
     *           '</wps:RawDataOutput>' +
     *           '</wps:ResponseForm>' +
     *           '</wps:Execute>';
     *           
     *           serviceObj.execute(requestStr, function(result){});
     * (end)
     */	
	execute: function(content,successFn,failFn){
		var request = "Execute";
		var url = this.url + "/" + request;
		
		if(!failFn){
			failFn = function(){
				this.failFn(request);
			};
		}
		
		var xhr = new OpenLayers.Request.POST({
			url: url,
			data: content,
			scope: this,
			success:successFn,
			failure:failFn
		});
	},

	CLASS_NAME: "Geo.Service.WPS"
});/**
 * Class: Geo.Service.WFS
 * OGC-WFS服务类。
 * 说明：本类也适用于聚合网络要素服务（Aggregation Web Feature Service简称AWFS）
 * 和地名地址要素服务（Web Feature Service Gazetteer简称WFS-G）。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.WFS = Geo.Class(Geo.Service, {
	
	/**
     * Constructor: Geo.Service.WFS
     * Geo.Service.WFS类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		Geo.Service.prototype.initialize.apply(this, arguments);
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities",
			SERVICE:"WFS",
			VERSION: "1.0.0"
		};
		if(!failFn){
			failFn = function(){
				this.failFn(params.REQUEST);
			};
		}
		OpenLayers.loadURL(url,params,this,function(result){
			successFn(result);
		},failFn);
	},

	/**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * 
     * Returns:
     * {Boolean} 服务是否存在。
     */	
	isExist: function(){
		var isExist = false;
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities",
			SERVICE:"WFS"
		};
		var xhr = OpenLayers.Request.GET({
            url: url,
			params: params,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},
	
	/**
     * APIMethod: describeFeatureType
     * 获取要素类型描述操作。
     * 
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WFS标准。
     *   params有三个参数(service,version,request)默认可以不填，其中version默认值是1.0.0，如果要设置其他版本请设置version参数。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例：
     * (code)
     * serviceObj.describeFeatureType({
     *     TypeName: "RES1_T_PN"
     * }, showResult);
     * (end)
     */	
	describeFeatureType: function(params,successFn,failFn){
		var url = this.url;
		var DEFAULT_PARAMS = { 
			service: "WFS",
			version: "1.0.0",
			request: "DescribeFeatureType"
		};
		OpenLayers.Util.applyDefaults(params,DEFAULT_PARAMS);
		
		if(!failFn){
			failFn = function(){
				this.failFn(params.REQUEST);
			};
		}
		
		OpenLayers.loadURL(url,params,this,function(result){
			successFn(result);
		},failFn);
	},
	
	/**
     * APIMethod: getFeature
     * 获取要素操作。
     * 
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WFS标准。
     * 	TypeName - {String} 必选 类型名称。
     * 	version - {String} 版本，默认值是1.0.0,如果用户请求的服务版本不是1.0.0，请设置该参数。
     *  MaxFeatures - {Integer} 可选 查询的返回的结果总数。
     *  filter - {Geo.Filter} 可选 过滤器。
     *  以上是常用的属性，其他属性请参考OGC-WFS标准。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * (code)
     * 	 serviceObj.getFeature({
     *      TypeName: "RES1_T_PN",
     *      MaxFeatures: 10
     *   }, function(){});
     * (end)
     */	
	getFeature: function(params,successFn,failFn){
		var url = this.url;
		var DEFAULT_PARAMS = { 
			service: "WFS",
			version: "1.0.0",
			request: "GetFeature"
		};
		OpenLayers.Util.applyDefaults(params,DEFAULT_PARAMS);
		
		if(!failFn){
			failFn = function(){
				this.failFn(params.REQUEST);
			};
		}
		
		OpenLayers.loadURL(url,params,this,function(result){
			successFn(result);
		},failFn);
	},

	CLASS_NAME: "Geo.Service.WFS"
	
});/**
 * Class: Geo.Service.WFST
 * OGC-WFST服务类。Web要素服务-T（Web Feature Service-Transaction简称WFST）遵循OGC的WFS1.0.0规范，
 * 本服务提供对要素的增加、修改、删除等事务操作。
 *
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.WFST = Geo.Class(Geo.Service, {

    /**
     * Constructor: Geo.Service.WFST
     * Geo.Service.WFST类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     */
    initialize: function(name, url, options){
        Geo.Service.prototype.initialize.apply(this, arguments);
    },
    
    /**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     *
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    getCapabilities: function(successFn, failFn){
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WFS",
            VERSION: "1.0.0"
        };
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        OpenLayers.loadURL(url, params, this, function(result){
            successFn(result);
        }, failFn);
    },
    
    /**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     *
     * Returns:
     * {Boolean} 服务是否存在。
     */
    isExist: function(){
        var isExist = false;
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WFS"
        };
        var xhr = OpenLayers.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(){
                isExist = true;
            }
        });
        return isExist;
    },
    
    /**
     * APIMethod: describeFeatureType
     * 获取要素类型描述操作。
     *
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WFS标准。
     *   params有三个参数(service,version,request)默认可以不填，其中version默认值是1.0.0，如果要设置其他版本请设置version参数。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例：
     * (code)
     * serviceObj.describeFeatureType({
     *     TypeName: "RES1_T_PN"
     * }, showResult);
     * (end)
     */
    describeFeatureType: function(params, successFn, failFn){
        var url = this.url;
        var DEFAULT_PARAMS = {
            SERVICE: "WFS",
            VERSION: "1.0.0",
            REQUEST: "DescribeFeatureType"
        };
        OpenLayers.Util.applyDefaults(params, DEFAULT_PARAMS);
        
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        
        OpenLayers.loadURL(url, params, this, function(result){
            successFn(result);
        }, failFn);
    },
    
    /**
     * APIMethod: getFeature
     * 获取要素操作。
     *
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WFS标准。
     * 	TypeName - {String} 必选 类型名称。
     * 	version - {String} 版本，默认值是1.0.0,如果用户请求的服务版本不是1.0.0，请设置该参数。
     *  MaxFeatures - {Integer} 可选 查询的返回的结果总数。
     *  filter - {Geo.Filter} 可选 过滤器。
     *  以上是常用的属性，其他属性请参考OGC-WFS标准。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     * 	 serviceObj.getFeature({
     *      TypeName: "RES1_T_PN",
     *      MaxFeatures: 10
     *   }, function(){});
     * (end)
     */
    getFeature: function(params, successFn, failFn){
        var url = this.url;
        var DEFAULT_PARAMS = {
            SERVICE: "WFS",
            VERSION: "1.0.0",
            REQUEST: "GetFeature"
        };
        OpenLayers.Util.applyDefaults(params, DEFAULT_PARAMS);
        
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        
        OpenLayers.loadURL(url, params, this, function(result){
            successFn(result);
        }, failFn);
    },
    
    /**
     * APIMethod: lockFeature
     * 锁定要素操作。
     *
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WFS标准。
     * 	typeName - {String} 必选 指定操作的图层类型名称。
     * 	version - {String} 可选 版本号，默认值是1.0.0，如果用户请求的服务版本不是1.0.0，请设置该参数。
     *  expiry - {Number} 可选 锁定的分钟数，如果没有则默认为1分钟。
     *  lockAction - {String} 可选 指定如何获得锁，如果没有则默认为"ALL"。
     *  filter - {Geo.Filter} 可选 操作要素的条件过滤器。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    lockFeature: function(params, successFn, failFn){
        var url = this.url;
        var DEFAULT_PARAMS = {
            service: "WFS",
            version: "1.0.0",
            request: "LockFeature",
            expiry: 1,
            lockAction: "ALL"
        };
        OpenLayers.Util.applyDefaults(params, DEFAULT_PARAMS);
        
		//解析filter对象，转换为XML字符串。
		var filterXMLString = this._parserFilterToString(params.filter);
        
        var requestStringTemplate = '<?xml version="1.0" encoding="UTF-8"?>' +
        '<LockFeature version="${version}" service="${service}" lockAction="${lockAction}" expiry="${expiry}" ' +
	        'xmlns:wfs=" http://www.opengis.net/wfs" ' +
	        'xmlns:gml=" http://www.opengis.net/gml" ' +
	        'xmlns:myns=" http://www.someserver.com/myns" ' +
	        'xmlns:ogc=" http://www.opengis.net/ogc" ' +
	        'xmlns:xsi=" http://www.w3.org/2001/XMLSchema-instance" ' +
	        'xsi:schemaLocation="http://www.opengis.net/wfs ../wfs/1.1.0/WFS.xsd">' +
	        '<Lock typeName="${typeName}">' +
		        '${filterXMLString}' +
	        '</Lock>' +
        '</LockFeature>';
        
        var requestString = OpenLayers.String.format(requestStringTemplate, {
            version: params.version,
            service: params.service,
            lockAction: params.lockAction,
            expiry: params.expiry,
            typeName: params.typeName,
            filterXMLString: filterXMLString
        });
        
        
        if (!failFn) {
            failFn = function(){
                this.failFn(params.request);
            };
        }
        
        var xhr = new OpenLayers.Request.POST({
            url: this.url,
            data: requestString,
            scope: this,
            success: successFn,
            failure: failFn
        });
        
        //        OpenLayers.loadURL(url, params, this, function(result){
        //            successFn(result);
        //        }, failFn);
    },
    
    /**
     * APIMethod: transaction
     * 要素的事务操作，可以对服务中的要素内容进行增加、删除和修改操作。
     *
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WFS标准。
     * 	version {String} 可选 版本号，默认值是1.0.0，如果用户请求的服务版本不是1.0.0，请设置该参数。
     * 	releaseAction {String} 可选 指定如何释放锁，提供有"ALL"和"SOME"两种方式，默认值是"ALL"。
     *             在做更新或删除要素的时候，releaseAction="ALL"或"SOME"决定LockId对应的所有要素是否全部释放。
     *             如果是"ALL",表示LockId对应的所有要素全部解锁释放。
     *             如果是"SOME",表示LockId只对正在操作的要素解锁释放，其他要素还是保持锁定状态。
     *  lockId {String} 可选 锁定编号。
     * inserts - {Object} 添加要素的请求参数。
     *  features {Array(<Geo.Feature.Vector>)} 必选 一系列要素的集合。
     *  typeName {String} 必选 指定操作的图层类型名称。
     * updates - {Object} 修改要素的请求参数。
     *  feature {<Geo.Feature.Vector>} 必选 要素对象。
     *  typeName {String} 必选 指定操作的图层类型名称。
     *  filter {Geo.Filter} 可选 操作要素的条件过滤器。
     * deletes - {Object} 删除要素的请求参数。
     *  typeName {String} 必选 指定操作的图层类型名称。
     *  filter {Geo.Filter} 可选 操作要素的条件过滤器。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    transaction: function(params, inserts, updates, deletes, successFn, failFn){
		var url = this.url;
		//默认参数
        var DEFAULT_PARAMS = {
            service: "WFS",
            version: "1.0.0",
            request: "Transaction",
            releaseAction: "ALL"
        };
		//合并默认参数，获得实际请求参数
		OpenLayers.Util.applyDefaults(params, DEFAULT_PARAMS);
		
		//定义post请求模板
		var requestStringTemplate = '<?xml version="1.0" encoding="UTF-8"?>' +
        '<wfs:Transaction releaseAction="${releaseAction}" handle="Transaction 01" version="${version}" service="${service}" '+
		'xmlns="http://www.someserver.com/myns" ' +
		'xmlns:gml="http://www.opengis.net/gml" ' +
		'xmlns:ogc="http://www.opengis.net/ogc" ' +
		'xmlns:wfs="http://www.opengis.net/wfs" ' +
		'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">' +
	        '${lockIdString}' +
	        '${transactionString}' +
        '</wfs:Transaction>';
		
		//lockId的请求标签
        var lockId = params.lockId;
		var lockIdString = "";
		if(lockId){
			lockIdString += '<LockId>' + lockId + '</LockId>';
		}
		
		var transactionString = "";
		//添加
        if (inserts) {
            transactionString += this._getInsertString(inserts);
        }
		//修改
		if(updates){
			transactionString += this._getUpdateString(updates);
		}
		//删除
		if(deletes){
			transactionString += this._getDeleteString(deletes);
		}
		
		//根据模板，获得post请求串
        var requestString = OpenLayers.String.format(requestStringTemplate, {
            releaseAction: params.releaseAction,
            version: params.version,
            service: params.service,
            lockIdString: lockIdString,
            transactionString: transactionString
        });
		
		//请求失败的回调函数
		if (!failFn) {
            failFn = function(){
                this.failFn(params.request);
            };
        }
		
		//发送post请求
		var xhr = new OpenLayers.Request.POST({
            url: url,
            data: requestString,
            scope: this,
            success: successFn,
            failure: failFn
        });
	},
	
	/**
     * Method: _getInsertString
     * 获取插入的XML字符串。 
     * 
     * Parameters:
     * insert - {object} 添加要素的参数对象。
     *
     * Returns:
     * {String} 返回插入的XML字符串。
	 */
    _getInsertString: function(inserts){
		var features = inserts.features;
		var typeName = inserts.typeName;
		var insertStr = "";
        for (var i = 0; i < features.length; i++) {
            var feature = features[i];
            insertStr += '<wfs:Insert handle="Insert ' + i + '">' +
			this._getInsertFeatureString(feature, typeName) +
			'</wfs:Insert>';
        };
		return insertStr;
	},
	
	/**
     * Method: _getInsertFeatureString
     * 获取保存要素所需的外部属性串。 
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 要素。
     * typeName - {String} 指定操作的图层类型名称。
     *
     * Returns:
     * {String} 返回保存要素所需的外部属性串。
	 */
    _getInsertFeatureString: function(feature, typeName){
			        
        var str = "";
        
        var featureTemplate = '<${typeName}>${content}</${typeName}>';
        var geoTemplate = "<GEOMETRY>${geometry}</GEOMETRY>";
        
        var attrTemplate = "<${tag}><![CDATA[${value}]]></${tag}>"
        
        for (var item in feature.data) {
            if (item == "OID") {
                continue;
            }
            str += OpenLayers.String.format(attrTemplate, {
                value: (feature.data[item] ? feature.data[item] : ""),
                tag: item
            });
        }
        str += OpenLayers.String.format(geoTemplate, {
            geometry: this._getGeometryStringByFeature(feature)
        });
        
        str = OpenLayers.String.format(featureTemplate, {
            typeName: typeName,
            content: str
        });
        return str;
    },
	
	/**
     * Method: _getUpdateString
     * 获取插入的XML字符串。 
     * 
     * Parameters:
     * updates - {object} 修改要素的参数对象。
     *
     * Returns:
     * {String} 返回XML字符串。
	 */
    _getUpdateString: function(updates){
        var filter = updates.filter;
        var typeName = updates.typeName;
        var feature = updates.feature;
        
        //要素的要修改的属性和值的XML字符串
        var propertyString = this._getUpdatePropertyString(feature);
        //解析filter对象，转换为XML字符串。
        var filterXMLString = this._parserFilterToString(filter);
        var updateStr = '<wfs:Update typeName="' + typeName + '" handle="Update 1">' +
	        propertyString +
	        filterXMLString +
        '</wfs:Update>';
        
        return updateStr;
    },
	
	/**
     * Method: _getUpdatePropertyString
     * 获取修改的要素属性的XML字符串。 
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 要素。
     *
     * Returns:
     * {String} 返回修改的要素属性的XML字符串。
	 */
    _getUpdatePropertyString: function(feature){
        var str = "";
        for (var item in feature.data) {
            if (item == "OID") {
                continue;
            }
            str += '<wfs:Property>' +
	            '<wfs:Name><![CDATA[' +
	            item +
	            ']]></wfs:Name>' +
	            '<wfs:Value><![CDATA[' +
	            (feature.data[item] ? feature.data[item] : "") +
	            ']]></wfs:Value>' +
            '</wfs:Property>';
        }
        str += '<wfs:Property>' +
	        '<wfs:Name>Geometry</wfs:Name>' +
	        '<wfs:Value>' +
	        this._getGeometryStringByFeature(feature) +
	        '</wfs:Value>' +
        '</wfs:Property>';
        return str;
    },
	
	/**
     * Method: _getGeometryStringByFeature
     * 获取修改的要素geometry的XML字符串。 
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 要素。
     *
     * Returns:
     * {String} 返回修改的要素geometry的XML字符串。
	 */
	_getGeometryStringByFeature: function(feature){
		//DOMElement. A GML polygon node.
		var gmlDOMElement = new OpenLayers.Format.GML().buildGeometryNode(feature.geometry);
		var xmlParser = new OpenLayers.Format.XML();
		var geometrtXmlStr = xmlParser.write(gmlDOMElement);
		return geometrtXmlStr;
    },
	
	/**
     * Method: _getDeleteString
     * 获取插入的XML字符串。 
     * 
     * Parameters:
     * deletes - {object} 删除要素的参数对象。
     *
     * Returns:
     * {String} 返回插入的XML字符串。
	 */
    _getDeleteString: function(deletes){
        var filter = deletes.filter;
        var typeName = deletes.typeName;
        
        //解析filter对象，转换为XML字符串。
        var filterXMLString = this._parserFilterToString(filter);
        
        var deleteStr = "";
        deleteStr += '<wfs:Delete typeName="' + typeName + '" handle="Delete 1">';
        deleteStr += filterXMLString;
        deleteStr += '</wfs:Delete>';
        return deleteStr;
    },
	
	/**
     * Method: _parserFilterToString
     * 解析filter对象，转换为XML字符串。
     * 
     * Parameters:
     *  filter - {<Geo.Filter>} 可选 操作要素的条件过滤器。
     *
     * Returns:
     * {String} 过滤器字符串。
	 */
    _parserFilterToString: function(filter){
		//解析filter对象，转换为XML字符串。
		var filterXMLString = "";
        if (filter) {
            var filterFormatter = new Geo.Format.Filter.v1();
            var result = filterFormatter.write(filter);//{DOMElement} An ogc:Filter element.
			var xmlParser = new OpenLayers.Format.XML();
			filterXMLString = xmlParser.write(result);
			return filterXMLString;
        }
		return filterXMLString;
	},
	
    CLASS_NAME: "Geo.Service.WFST"
});
/**
 * Class: Geo.Service.WMS
 * OGC-WMS服务类。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.WMS = Geo.Class(Geo.Service, {
	
	/**
     * Constructor: Geo.Service.WMS
     * Geo.Service.WMS类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		Geo.Service.prototype.initialize.apply(this, arguments);
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities",
			SERVICE:"WMS"
		};
		if(!failFn){
			failFn = function(){
				this.failFn(params.REQUEST);
			};
		}
		OpenLayers.loadURL(url,params,this,function(result){
			successFn(result);
		},failFn);
	},
	
	/**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * 
     * Returns:
     * {Boolean} 服务是否存在。
     */
	isExist: function(){
		var isExist = false;
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities",
			SERVICE:"WMS"
		};
		var xhr = OpenLayers.Request.GET({
            url: url,
			params: params,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},
	
	/**
     * APIMethod: getMap
     * 获取地图内容操作。
     * 
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WMS标准。
     * 	version - {String} 版本，默认值是1.1.1。
     *  layers - {String} 图层名称。
     *  styles - {String}  样式，默认是空串。
     *  srs -  - {String} 默认值是"EPSG:4326"。
     *  width - {Integer} 必选 宽。
     *  height - {Integer} 必选 长。
     *  format - {String} 默认值是"image/jpeg"。
     *  bbox  - {String} 必选 范围。
     * Returns:
 	 * {String} 地图内容图片地址。
 	 * 
 	 * 示例:
 	 * (code)
 	 * var url = wmsService.getMap({
     *     layers: "basic",
     *     bbox: "-180,-90,180,270",
     *     width: 256,
     *     height: 256
     * });
     * (end)         
     */	
	getMap: function(params){
		var url = this.url;
		var DEFAULT_PARAMS = { 
			service: "WMS",
			version: "1.1.1",
			request: "GetMap",
			styles: "",
			srs:"EPSG:4326",
			exceptions: "application/vnd.ogc.se_inimage",
			format: "image/jpeg"
		};
		OpenLayers.Util.applyDefaults(params,DEFAULT_PARAMS);
		var paramsString = OpenLayers.Util.getParameterString(params);
		return OpenLayers.Util.urlAppend(url, paramsString);
	},

	CLASS_NAME: "Geo.Service.WMS"
});/**
 * Class: Geo.Service.WMTS
 * OGC-WMTS服务类。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.WMTS = Geo.Class(Geo.Service, {
	
	/**
     * Constructor: Geo.Service.WMTS
     * Geo.Service.WMTS类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		Geo.Service.prototype.initialize.apply(this, arguments);
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities",
			SERVICE:"WMTS"
		};
		if(!failFn){
			failFn = function(){
				this.failFn(params.REQUEST);
			};
		}
		OpenLayers.loadURL(url,params,this,function(result){
			successFn(result);
		},failFn);
	},
	
	/**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * 
     * Returns:
     * {Boolean} 服务是否存在。
     */
	isExist: function(){
		var isExist = false;
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities",
			SERVICE:"WMTS"
		};
		var xhr = OpenLayers.Request.GET({
            url: url,
			params: params,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},
	
	/**
     * APIMethod: getTile
     * 获取瓦片内容操作。
     * 
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WMTS标准。
 	 * service - {String} 默认值是"WMTS"。
 	 * version - {String} 默认值是"1.0.0"。
 	 * layer - {String} 必选 图层标示。
 	 * style - {String} 必选 图层样式标示。
 	 * format - {String} 默认值是"image/png"。
 	 * TileMatrixSet - {String} 必选 矩阵集。
 	 * TileMatrix - {String} 必选 矩阵。
 	 * TileRow - {Integer} 必选 瓦片行号。
 	 * TileCol - {Integer} 必选 瓦片列号。
     * 
     * Returns:
 	 * {String} 瓦片内容图片地址。
 	 * 
 	 * 示例：
 	 * (code)
     * var url = wmtsService.getTile({
     *     layer: "dgdom0624",
     *     style: "dgdom0624",
     *     TileMatrixSet: "Matrix_0",
     *     TileMatrix: "12",
     *     TileRow: 761,
     *     TileCol: 3342
     * });
 	 * (end)
     */	
	getTile:function(params){
		var url = this.url;
		var DEFAULT_PARAMS = { 
			service: "WMTS",
			version: "1.0.0",
			request: "GetTile",
			format: "image/png"
		};
		OpenLayers.Util.applyDefaults(params,DEFAULT_PARAMS);
		var paramsString = OpenLayers.Util.getParameterString(params);
		return OpenLayers.Util.urlAppend(url, paramsString);
	},
	
	/**
     * APIMethod: getCapabilitiesForRest
     * WMTS-RESTful的获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilitiesForRest: function(successFn, failFn){
		var version = "1.0.0";
		var docName = "WMTSCapabilities.xml";
		var path = version + "/" + docName;
        var url = this.url;
        if (!url.match(/\/$/)) {
            url = url + "/";
        }
		url = url + path;
		
        if (!failFn) {
            failFn = function(){
                this.failFn("GetCapabilities");
            };
        }
		
        OpenLayers.loadURL(url, null, this, function(result){
            successFn(result);
        }, failFn);
	},
	
	/**
     * APIMethod: getTileForRest
     * WMTS-RESTful的获取瓦片内容操作。
     * 
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WMTS标准。
     * 
     * Returns:
 	 * {String} 瓦片内容图片地址。
 	 * 	layer - {String} 必选 图层标示。
 	 * 	style - {String} 必选 图层样式标示。
 	 * 	format - {String} 必选 瓦片图片格式。默认值是"image/png"。
 	 * 	TileMatrixSet - {String} 必选 矩阵集。
 	 * 	TileMatrix - {String} 必选 矩阵。
 	 * 	TileRow - {Integer} 必选 瓦片行号。
 	 * 	TileCol - {Integer} 必选 瓦片列号。
 	 * 
 	 * 示例：
 	 * (code)
     * var url = wmtsService.getTile({
     *     layer: "dgdom0624",
     *     style: "dgdom0624",
     *     TileMatrixSet: "Matrix_0",
     *     TileMatrix: "12",
     *     TileRow: 761,
     *     TileCol: 3342
     * });
 	 * (end)
     */	
    getTileForRest: function(params){
		var layer = params.layer;
		var style = params.style;
		var tileMatrixSet = params.tileMatrixSet;
		var tileMatrix = params.tileMatrix;
		var tileRow = params.tileRow;
		var tileCol = params.tileCol;
		
		var formatSuffix = null;
		var format = params.format ? params.format : "image/png";
        var formatSuffixMap = {
            "image/png": "png",
            "image/png8": "png",
            "image/png24": "png",
            "image/png32": "png",
            "png": "png",
            "image/jpeg": "jpg",
            "image/jpg": "jpg",
            "jpeg": "jpg",
            "jpg": "jpg"
        };
		if (!formatSuffix) {
            formatSuffix = formatSuffixMap[format] || format.split("/").pop();            
        }
		
		var path = layer + "/" + style + "/" + tileMatrixSet + 
		"/" + tileMatrix + "/" + tileRow + "/" + tileCol + "." + formatSuffix;
        var url = this.url;
        if (!url.match(/\/$/)) {
            url = url + "/";
        }
		url = url + path;
        return url;
    },

	CLASS_NAME: "Geo.Service.WMTS"
});/**
 * Class: Geo.Service.GeoWMTS
 * 武大吉奥WMTS服务类，该服务类基于OGC-WMTS服务类，并在OGC-WMTS服务类的基础上做了扩展，
 * 实现了获取多时相WMTS服务的时间版本信息的接口
 * 
 * Inherits from:
 * - <Geo.Service.WMTS>
 */
Geo.Service.GeoWMTS = Geo.Class(Geo.Service.WMTS, {
	
	/**
     * Constructor: Geo.Service.GeoWMTS
     * Geo.Service.GeoWMTS类的构造函数
     *
     * Parameters:
     * name - {String} 服务名称
     * url - {String} 服务地址
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url, options){
		Geo.Service.WMTS.prototype.initialize.apply(this, arguments);
	},
	
	/**
	 * APIMethod: getVersions
	 * 得到服务的版本信息
	 * 
     * Parameters:
     *  params:
     * 	  layer - {String} 图层名称
     *    tileMatrix - {String} 图层层级
     *    tileMatrixSet - {String} 矩阵集名称
     *    tileBox - {String} 行列号范围，格式为“最小列,最小行,最大列,最大行” 如“3,6,7,12”表示获取3-7列、6-12行中所有的瓦片版本ID与名称。
     *    
     * 	options：
     *    content -  {String} 服务返回数据的详细程度 ，当值为"brief"时，返回信息中仅包含版本名称和版本ID；当值为"detail"时，返回信息中会
     *    包含更加详细的版本相关信息，如数据的生产时间，生产单位以及服务的提供单位等信息。当值为"full"时，返回所有信息。默认值是"full"
     *    version - {String} 服务的版本，默认值是"1.0.0"  
     *     
     *  successFn - {Function} 请求成功的回调函数
     *  failFn - {Function} 请求失败的回调函数。
     *  (code)
     *  var serviceObj = new Geo.Service.GeoWMTS("GeoWMTS服务", "http://10.4.6.49:7001/wmts_time_wuhan/wmts");
     *  serviceObj.getVersions({
     *      layer: "wuhan",
     *      tileMatrix: 5,
     *      tileBox: "24,4,27,6",
     *      tileMatrixSet: "Matrix_0" 
     *  }, {
     *      content: "full"
     *  }, function(request){
     *   	alert(request.responseText);  
     *  });
     *  (end)
	 */
	getVersions: function(params, options, successFn, failFn) {
		var url = this.url;
		//下面请求参数中需要增加CONTENT属性
		var DEFAULT_OPTIONS = { 
			content: "full",
			service: "WMTS",
			version: "1.0.0",
			request: "GetVersions"
		};
		OpenLayers.Util.applyDefaults(options, DEFAULT_OPTIONS);
		
		if(!failFn){
			failFn = function(){
				this.failFn(options.request);
			};
		}
		
		OpenLayers.loadURL(url, {
			request: options.request,
			layer: params.layer,
			tileMatrixSet: params.tileMatrixSet,
			tileMatrix: params.tileMatrix,
			tileBox: params.tileBox,
			content: options.content,
			service: options.service,
			version: options.version
			
		}, this, 
		function(request){
			successFn(request);
		},failFn);
	},
	
	/**
	 * APIMethod: GetVersionInfo
	 * 得到服务的版本信息
	 *  说明：getVersions方法也是得到用户版本信息，它是根据行列号范围等参数得到时间版本信息，而GetVersionInfo是根据版本名称等参数得到时间版本信息
	 * 
     * Parameters:
     *  params:
     * 	  layer - {String} 图层名称
     *    versionNames - {String} 多时相版本名称
     *    tileMatrixSet - {String} 矩阵集名称
     *    
     *  options：
     *    content -  {String} 服务返回数据的详细程度 ，当值为"brief"时，返回信息中仅包含版本名称和版本ID；当值为"detail"时，返回信息中会
     *    包含更加详细的版本相关信息，如数据的生产时间，生产单位以及服务的提供单位等信息。当值为"full"时，返回所有信息。默认值是"full"
     *    version - {String} 服务的版本，默认值是"1.0.0"  
     *    
     *  successFn - {Function} 请求成功的回调函数
     *  failFn - {Function} 请求失败的回调函数。
	 */
	getVersionInfo: function(params, options, successFn, failFn) {
		var url = this.url;
		//下面请求参数中需要增加CONTENT属性
		var DEFAULT_OPTIONS = { 
			content: "brief",
			service: "WMTS",
			version: "1.0.0",
			request: "GetVersionInfo"
			
		};
		OpenLayers.Util.applyDefaults(options, DEFAULT_OPTIONS);
		
		OpenLayers.loadURL(url, {
			layer: params.layer,
			versionNames: params.versionNames,
			tileMatrixSet: params.tileMatrixSet,
			content: options.content,
			service: options.service,
			version: options.version,
			request: options.request
		}, this, 
		function(request){
			successFn(request);
		},failFn);
	},

	/**
	 * 
	 */
	CLASS_NAME: "Geo.Service.GeoWMTS"
	
});/**
 * Class: Geo.Service.WCS
 * OGC-WCS服务类。仅支持OGC标准的WCS1.0.0规范。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.WCS = Geo.Class(Geo.Service, {
	
	/**
     * Constructor: Geo.Service.WCS
     * Geo.Service.WCS类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		Geo.Service.prototype.initialize.apply(this, arguments);
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn, failFn){
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities",
			SERVICE:"WCS"
		};
		if(!failFn){
			failFn = function(){
				this.failFn(params.REQUEST);
			};
		}
		OpenLayers.loadURL(url,params,this,function(result){
			successFn(result);
		},failFn);
	},
	
	/**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * 
     * Returns:
     * {Boolean} 服务是否存在。
     */
	isExist: function(){
		var isExist = false;
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities",
			SERVICE:"WCS"
		};
		var xhr = OpenLayers.Request.GET({
            url: url,
			params: params,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},
	
	/**
     * APIMethod: describeCoverage
     * 获取Coverage的描述信息。
     * 
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WCS标准。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例：
     * (code)
     * wcsService.describeCoverage(
     *     {identifiers: "Cov1,Cov2,Cov3"},
     *     function(result){
     *         alert(result.responseText);
     *     }
     * );
     * (end)
     * 
     */	
	describeCoverage: function(params, successFn, failFn){
		var url = this.url;
		var DEFAULT_PARAMS = { 
			SERVICE: "WCS",
			VERSION: "1.0.0",
			REQUEST: "DescribeCoverage"
		};
		OpenLayers.Util.applyDefaults(params,DEFAULT_PARAMS);
		
		if(!failFn){
			failFn = function(){
				this.failFn(params.REQUEST);
			};
		}
		
		OpenLayers.loadURL(url,params,this,function(result){
			successFn(result);
		},failFn);
	},
	
	/**
     * APIMethod: getCoverage
     * 获取Coverage内容。
     * 
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WCS标准。
     *   identifier - {String} 必选 请求标示。
     *   BoundingBox - {String} 必选 请求范围。
     *   format - {String} 必选  数据格式。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例：
     * (code)
     * wcsService.getCoverage(
     *     { identifier:"Cov123",
     *       BoundingBox: "-71,47,-66,51,urn:ogc:def:crs:OGC:2:84"
     *       format: "image/netcdf"
     *     },
     *     function(result){
     *         //do something...
     *     }
     * );
     * (end)
     */	
	getCoverage: function(params,successFn,failFn){
		var url = this.url;
		var DEFAULT_PARAMS = { 
			SERVICE: "WCS",
			VERSION: "1.1.2",
			REQUEST: "GetCoverage"
		};
		OpenLayers.Util.applyDefaults(params,DEFAULT_PARAMS);
		
		if(!failFn){
			failFn = function(){
				this.failFn(params.REQUEST);
			};
		}
		
		OpenLayers.loadURL(url,params,this,function(result){
			successFn(result);
		},failFn);
	},
	
	CLASS_NAME: "Geo.Service.WCS"
});/**
 * Class: Geo.Service.CSW
 * OGC-CSW服务类。
 *
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.CSW = Geo.Class(Geo.Service, {

    /**
     * Constructor: Geo.Service.CSW
     * Geo.Service.CSW类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
    initialize: function(name, url, options){
        Geo.Service.prototype.initialize.apply(this, arguments);
    },
    
    /**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     *
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    getCapabilities: function(successFn, failFn){
        var content = '<csw:GetCapabilities service="CSW" xmlns:csw="http://www.opengis.net/cat/csw" xmlns:ows="http://www.opengis.net/ows">' +
        '<ows:AcceptVersions>' +
        '<ows:Version>2.0.2' +
        '</ows:Version>' +
        '</ows:AcceptVersions>' +
        '<ows:AcceptFormats>' +
        '<ows:OutputFormat>text/xml</ows:OutputFormat>' +
        '</ows:AcceptFormats>' +
        '</csw:GetCapabilities>';
        
        content = OpenLayers.String.format(this._soapTemplate, {
            soapBody: content
        });
        
        if (!failFn) {
            failFn = function(request){
                this.failFn(request);
            };
        }
        
        var xhr = new OpenLayers.Request.POST({
            url: this.url,
            data: content,
            scope: this,
            success: successFn,
            failure: failFn
        });
    },
    
    /**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     *
     * Returns:
     * {Boolean} 服务是否存在。
     */
    isExist: function(){
        var isExist = false;
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "CSW"
        };
        var xhr = OpenLayers.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(){
                isExist = true;
            }
        });
        return isExist;
    },
    
    /**
     * APIMethod: getRecords
     * 获取服务元数据记录。
     *
     * Parameters:
     * content - {String} CSW服务POST请求串，具体格式参考OGC关于CSW服务文档。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    getRecords: function(content, successFn, failFn){
    
        content = OpenLayers.String.format(this._getRecordsTemplate, {});
        
        if (!failFn) {
            failFn = function(request){
                this.failFn(request);
            };
        }
        
        var xhr = new OpenLayers.Request.POST({
            url: this.url,
            data: content,
            scope: this,
            success: successFn,
            failure: failFn
        });
    },
    
    //查询请求串模板
    _getRecordsTemplate: '<?xml version="1.0" encoding="UTF-8"?>' +
    '<csw:GetRecords service="CSW" version="2.0.2" xmlns:csw="http://www.opengis.net/cat/csw" xmlns:ogc="http://www.opengis.net/ogc" xmlns:smmd="http://data.sbsm.gov.cn/smmd/2007" outputFormat="text/xml" resultType="results" outputSchema="smmd:Metadata" startPosition="1" maxRecords="10">' +
    '<csw:Query typeNames="smmd:Metadata">' +
    ' <csw:ElementSetName>full</csw:ElementSetName>' +
    ' <csw:Constraint version="2.0.0">' +
    '<ogc:Filter>' +
    ' <ogc:PropertyIsLike wildCard="*" singleChar="_" escape="\\\">' +
    '<ogc:PropertyName>/smmd:Metadata/smmd:mdFileID</ogc:PropertyName>' +
    '<ogc:Literal>*</ogc:Literal>' +
    '</ogc:PropertyIsLike>' +
    '</ogc:Filter>' +
    '</csw:Constraint>' +
    '</csw:Query>' +
    '</csw:GetRecords>',
    
    //soap格式请求串模板
    _soapTemplate: '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xsi:schemaLocation="http://www.opengis.net/ows" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">' +
    '<soapenv:Body>' +
    '${soapBody}' +
    '</soapenv:Body>' +
    '</soapenv:Envelope>',
    
    /**
     * APIMethod: GetRecordById
     * 根据元数据ID查询服务元数据。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   request -{String} 必填,请求名称。值必须为"getRecordById",不区分大小写。
     *   id -{String} 必填,请求检索的元数据ID。例如：ee90cbea-dc5e-4c8d-8225-03b06f5788b1。
     *   service -{String}  必填,服务名称，值必须为CSW。
     *   version -{String}  必填,服务版本号，值必须为2.0.2。
     *	 outputFormat -{String} 必须为一个Mime type ，值必须为application/xml或text/xml。
     *	 outputSchema -{String} 默认值："http://opengis.net/cat/csw/2.0.2" 请求结果的命名空间。
     *   elementSetName -{String} 默认值：summary返回的数据描述，值可为brief，summary，full。当值为brief时返回简明描述;当值为summary时返回概括描述;当值为full时返回全部的元数据信息。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     *
     * 示例:
     *
     * (code)
     * cswService.getRecordById({
     * 		request : "getRecordById",
     *		id : "ee90cbea-dc5e-4c8d-8225-03b06f5788b1",
     *		service: "CSW",
     *		version: "2.0.2",
     *		outputFormat: "Application/xml",
     *		outputSchema: "http://opengis.net/cat/csw/2.0.2",
     *		typeNames: "smmd:Metadata",
     *		elementSetName: "full"
     * });
     * (end)
     */
    getRecordById: function(options, successFn, failFn){
        var optionsTmp = {
            request: options.request ? options.request : "getRecordById",
            id: options.id ? options.id : "",
            service: options.service ? options.service : "CSW",
            version: options.version ? options.version : "2.0.2",
            outputFormat: options.outputFormat ? options.outputFormat : "Application/xml",
            outputSchema: options.outputSchema ? options.outputSchema : "http://opengis.net/cat/csw/2.0.2",
            elementSetName: options.elementSetName ? options.elementSetName : "summary"
        };
        var requestStringTemplate = '<csw:GetRecordById service="${service}" xmlns:csw="http://www.opengis.net/cat/csw" version="${version}">' +
        '<csw:Id>${id}</csw:Id>' +
        '<csw:ElementSetName typeNames="smmd:Metadata">${elementSetName}</csw:ElementSetName>' +
        '</csw:GetRecordById >';
        
        var requestString = OpenLayers.String.format(requestStringTemplate, {
            id: optionsTmp.id,
            service: optionsTmp.service,
            version: optionsTmp.version,
            elementSetName: optionsTmp.elementSetName
        });
        
        if (!failFn) {
            failFn = function(request){
                this.failFn(request);
            };
        }
        
        var xhr = new OpenLayers.Request.POST({
            url: this.url,
            data: requestString,
            scope: this,
            success: successFn,
            failure: failFn
        });
    },
    
    /**
     * APIMethod: describeRecord
     * 查询服务元数据描述记录。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   request -{String} 必填,请求名称。值必须为"describeRecord",该值是不区分大小写。
     *   service -{String} 必填,服务名称，值必须为CSW。
     *   version -{String} 必填,服务版本号，值必须为2.0.2。
     *   nameSpace -{String} 字符串列表，以逗号分隔。用于指定命名空间和前缀。格式是的xmlns（[前缀]命名空间URL）。如果没有指定前缀，那么这是默认的命名空间。
     *	 typeName -{String} 字符串列表，以逗号分隔。要描述一个或多个限定的类型名称。
     *   outputFormat -{String} 显示输出文件的格式必须为一个Mime type ，值必须为application/xml或text/xml。
     *	 schemaLanguage -{String} 零个或一个（可选）默认值是XMLSCHEMA。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     *
     * 示例:
     *
     * (code)
     * cswService.describeRecord({
     * 		request : "getRecordById",
     *		service: "CSW",
     *		version: "2.0.2",
     *		typeName: "smmd:Metadata"
     * });
     * (end)
     */
    describeRecord: function(options, successFn, failFn){
        var optionsTmp = {
            request: options.request ? options.request : "describeRecord",
            service: options.service ? options.service : "CSW",
            version: options.version ? options.version : "2.0.2",
            nameSpace: options.nameSpace ? options.nameSpace : "",
            typeName: options.typeName ? options.typeName : "smmd:Metadata",
            outputSchema: options.outputSchema ? options.outputSchema : "application/xml",
            schemaLanguage: options.schemaLanguage ? options.schemaLanguage : "XMLSCHEMA"
        };
        
        var requestStringTemplate = '<csw:DescribeRecord service="${service}" xmlns:csw="http://www.opengis.net/cat/csw" version="${version}">' +
        '<csw:TypeName>${typeName}</csw:TypeName>' +
        '</csw:DescribeRecord >';
        
        var requestString = OpenLayers.String.format(requestStringTemplate, {
            service: optionsTmp.service,
            version: optionsTmp.version,
            typeName: optionsTmp.typeName
        });
        
        if (!failFn) {
            failFn = function(request){
                this.failFn(request);
            };
        }
        
        var xhr = new OpenLayers.Request.POST({
            url: this.url,
            data: requestString,
            scope: this,
            success: successFn,
            failure: failFn
        });
    },
    
    /**
     * APIMethod: getDomain
     * 获得域名。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   request -{String} 必填,请求名称。值必须为"getDomain",该值是不区分大小写。
     *   service -{String} 必填,服务名称，值必须为CSW。
     *   version -{String} 必填,服务版本号，值必须为2.0.2。
     *   parameterName -{String} 字符串列表，以逗号分隔。无序列表的接口参数的名称。parameterName和propertyName只能有其中一个。
     *	 propertyName -{String} 字符串列表，以逗号分隔。无序的请求的属性名称列表。
     *							（定义信息模型）在搜索属性的情况下，使用不带任何前缀等只有普通的名称（区分大小写），
     *	 						因为这些是唯一定义。例如：分母而不是SpatialResolution.Denominator。
     *							parameterName和propertyName只能有其中一个。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     *
     * 示例:
     *
     * (code)
     * cswService.getDomain({
     * 		request : "getRecordById",
     *		service: "CSW",
     *		version: "2.0.2",
     *		propertyName: "brief"
     * });
     * (end)
     */
    getDomain: function(options, successFn, failFn){
        var optionsTmp = {
            request: options.request ? options.request : "describeRecord",
            service: options.service ? options.service : "CSW",
            version: options.version ? options.version : "2.0.2",
            propertyName: options.propertyName ? options.propertyName : "",//brief
            parameterName: options.parameterName ? options.parameterName : ""//GetRecords.ElementSetName
        };
        
        var requestStringTemplate = '<csw:GetDomain service="${service}" xmlns:csw="http://www.opengis.net/cat/csw" version="${version}">';
        if (options.propertyName) {
            requestStringTemplate += '<csw:PropertyName>${propertyName}</csw:PropertyName>';
        }
        if (options.parameterName) {
            requestStringTemplate += '<csw:ParameterName>${parameterName}</csw:ParameterName>';
        }
        requestStringTemplate += '</csw:GetDomain >';
        
        var requestString = OpenLayers.String.format(requestStringTemplate, {
            service: optionsTmp.service,
            version: optionsTmp.version,
            propertyName: optionsTmp.propertyName,
            parameterName: optionsTmp.parameterName
        });
        
        if (!failFn) {
            failFn = function(request){
                this.failFn(request);
            };
        }
        
        var xhr = new OpenLayers.Request.POST({
            url: this.url,
            data: requestString,
            scope: this,
            success: successFn,
            failure: failFn
        });
    },
    
    /**
     * APIMethod: transaction
     * 事务操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   request -{String} 必填,请求名称。值必须为"transaction",该值是不区分大小写。
     *   service -{String} 必填,服务名称，值必须为CSW。
     *   version -{String} 必填,服务版本号，值必须为2.0.2。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     *
     * 示例:
     *
     * (code)
     * cswService.transaction({
     * 		request : "getRecordById",
     *		service: "CSW",
     *		version: "2.0.2",
     *		transactionType: "Insert"
     * });
     * (end)
     */
    transaction: function(options, successFn, failFn){
        // insert的参数md_metaData,handle
        
        // update的参数md_metaData,typeName,constraintLanguage,constraint_Language_version,constraint,handle
        
        // delete的参数typeName,constraintLanguage,constraint_Language_version,constraint,handle
        var optionsTmp = {
            request: options.request ? options.request : "transaction",// 必须
            service: options.service ? options.service : "CSW",// 必须
            version: options.version ? options.version : "2.0.2",// 必须
            transaction: options.transaction ? options.transaction : "",
            
            transactionType: options.transactionType ? options.transactionType : "", // 必须 One of “Insert”, “Update”, “Delete”
            requestId: options.requestId ? options.requestId : 0,// 0 or 1
            verboseResponse: options.verboseResponse ? options.verboseResponse : false,
            
            md_metaData: options.md_metaData ? options.md_metaData : "",// 必须
            typeName: options.typeName ? options.typeName : "", // 0 or smmd:Metadata
            constraintLanguage: options.constraintLanguage ? options.constraintLanguage : "", // "CQL_TEXT" or "FILTER"
            constraint_Language_version: options.constraint_Language_version ? options.constraint_Language_version : "",// 必须. 例：1.1.0
            constraint: options.constraint ? options.constraint : "",// 必须. 谓词表达式中指定的语言表示的约束语言参数。
            handle: options.handle ? options.handle : 0// 0 or 1 用于错误处理的目的关联的助记符名称
        };
        
        var requestStringTemplate = '';
        var requestString = "";
        switch (optionsTmp.transactionType) {
            case "Insert":
                requestStringTemplate += '<csw:Transaction xmlns:csw="http://www.opengis.net/cat/csw" version="${version}" service="${service}">' +
                '<csw:Insert xmlns:smmd="http://data.sbsm.gov.cn/smmd/2007" ' +
                'xmlns:wrs="http://www.opengis.net/cat/wrs/1.0" xmlns:gco="http://www.isotc211.org/2005/gco" ' +
                'xmlns:gmd="http://www.isotc211.org/2005/gmd" xmlns:xlink="http://www.w3.org/1999/xlink" ' +
                'xmlns:srv="http://www.isotc211.org/2005/srv" xmlns:gml="http://www.opengis.net/gml" ' +
                'xmlns:gmx="http://www.isotc211.org/2005/gmx" xmlns:rim="urn:oasis:names:tc:ebxml-regrep:xsd:rim:3.0" ' +
                'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">' +
                '${md_metaData}' +
                '</csw:Insert>' +
                '</csw:Transaction>';
                requestString = OpenLayers.String.format(requestStringTemplate, {
                    service: optionsTmp.service,
                    version: optionsTmp.version,
                    md_metaData: optionsTmp.md_metaData
                });
                break;
            case "Update":
                requestStringTemplate += '<csw:Transaction service="${service}" version="${version}" xmlns:csw="http://www.opengis.net/cat/csw">' +
                '<csw:Update xmlns:srv="http://www.isotc211.org/2005/srv" xmlns:gml="http://www.opengis.net/gml" ' +
                'xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:gmd="http://www.isotc211.org/2005/gmd" ' +
                'xmlns:rim="urn:oasis:names:tc:ebxml-regrep:xsd:rim:3.0" xmlns:wrs="http://www.opengis.net/cat/wrs/1.0" ' +
                'xmlns:gco="http://www.isotc211.org/2005/gco" xmlns:gmx="http://www.isotc211.org/2005/gmx" ' +
                'xmlns:ogc="http://www.opengis.net/ogc" xmlns:smmd="http://data.sbsm.gov.cn/smmd/2007">' +
                '${md_metaData}' +
                '${constraint}' +
                '</csw:Update>' +
                '</csw:Transaction>';
                requestString = OpenLayers.String.format(requestStringTemplate, {
                    service: optionsTmp.service,
                    version: optionsTmp.version,
                    md_metaData: optionsTmp.md_metaData,
                    constraint: optionsTmp.constraint
                });
                break;
            case "Delete":
                requestStringTemplate += '<csw:Transaction service="${service}" version="${version}" xmlns:smmd="http://data.sbsm.gov.cn/smmd/2007" ' +
                'xmlns:csw="http://www.opengis.net/cat/csw" xmlns:ogc="http://www.opengis.net/ogc">' +
                '<csw:Delete typeName="${typeName}">' +
                '${constraint}' +
                '</csw:Delete>' +
                '</csw:Transaction>';
                requestString = OpenLayers.String.format(requestStringTemplate, {
                    service: optionsTmp.service,
                    version: optionsTmp.version,
                    typeName: optionsTmp.typeName,
                    constraint: optionsTmp.constraint
                });
                break;
                
        }
        
        if (!failFn) {
            failFn = function(request){
                this.failFn(request);
            };
        }
        
        var xhr = new OpenLayers.Request.POST({
            url: this.url,
            data: requestString,
            scope: this,
            success: successFn,
            failure: failFn
        });
        
    },
    
    /**
     * APIMethod: harvest
     * 查询服务元数据描述记录。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   request -{String} 必填,请求名称。值必须为"harvest",该值是不区分大小写。
     *   service -{String} 必填,服务名称，值必须为CSW。
     *   version -{String} 必填,服务版本号，值必须为2.0.2。
     *   nameSpace -{String} 字符串列表，以逗号分隔。用于指定命名空间和前缀。格式是的xmlns（[前缀]命名空间URL）。如果没有指定前缀，那么这是默认的命名空间。
     *	 source -{String} 必填,URI,参考源资源收割。
     *   resourceType -{String} 必填,字符串,参考资源的类型。例如：http://www.isotc211.org/schemas/2005/gmd/。
     *	 resourceFormat -{String} 字符的字符串,表示正在收获的资源格式的MIME类型。
     *	 responseHandler -{String} 可选。
     *	 harvestInterval -{String} 可选。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     *
     * 示例:
     *
     * (code)
     * cswService.describeRecord({
     * 		request : "harvest",
     *		service: "CSW",
     *		version: "2.0.2",
     *		source: "http://10.4.6.23:7001/CSW/csw",
     *		resourceType: "http://data.sbsm.gov.cn/smmd/2007"
     * });
     * (end)
     */
    harvest: function(options, successFn, failFn){
        var optionsTmp = {
            request: options.request ? options.request : "harvest",
            service: options.service ? options.service : "CSW",
            version: options.version ? options.version : "2.0.2",
            nameSpace: options.nameSpace ? options.nameSpace : "",//
            source: options.source ? options.source : "",//http://10.4.6.23:7001/CSW/csw
            resourceType: options.resourceType ? options.resourceType : "",//http://data.sbsm.gov.cn/smmd/2007
            resourceFormat: options.resourceFormat ? options.resourceFormat : "",//
            responseHandler: options.responseHandler ? options.responseHandler : "",//D:/
            harvestInterval: options.harvestInterval ? options.harvestInterval : ""//2012-12-22 12:12:12
        };
        
        var requestStringTemplate = '<csw:Harvest service="${service}" xmlns:csw="http://www.opengis.net/cat/csw" version="${version}">';
        requestStringTemplate += '<csw:Source>${source}</csw:Source>';
        requestStringTemplate += '<csw:ResourceType>${resourceType}</csw:ResourceType>';
        if (options.harvestInterval) {
            requestStringTemplate += '<csw:HarvestInterval>${harvestInterval}</csw:HarvestInterval>';
        }
        if (options.responseHandler) {
            requestStringTemplate += '<csw:ResponseHandler>${responseHandler}</csw:ResponseHandler>';
        }
        requestStringTemplate += '</csw:Harvest>';
        
        var requestString = OpenLayers.String.format(requestStringTemplate, {
            service: optionsTmp.service,
            version: optionsTmp.version,
            source: optionsTmp.source,
            resourceType: optionsTmp.resourceType,
            harvestInterval: optionsTmp.harvestInterval,
            responseHandler: optionsTmp.responseHandler
        });
        
        
        if (!failFn) {
            failFn = function(request){
                this.failFn(request);
            };
        }
        
        var xhr = new OpenLayers.Request.POST({
            url: this.url,
            data: requestString,
            scope: this,
            success: successFn,
            failure: failFn
        });
    },
	
    CLASS_NAME: "Geo.Service.CSW"
});
/**
 * Class: Geo.Service.CWMS
 * CWMS服务类。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.CWMS = Geo.Class(Geo.Service, {
	
	/**
     * Constructor: Geo.Service.CWMS
     * Geo.Service.CWMS类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url, options){
		Geo.Service.prototype.initialize.apply(this, arguments);
		this.format = new OpenLayers.Format.JSON();
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		if(!failFn){
			failFn = function(){
				this.failFn("GetCapabilities");
			};
		}
		OpenLayers.loadURL(this.url,null,this,function(result){
			var res = this.format.read(result.responseText);
			successFn(res);
		},failFn);
	},
	
	/**
	 * APIMethod: GetLayerInfo
	 * 本操作是获取缓存地图服务的图层（单个图层的详细信息），结果以JSON形式返回。
	 * 
	 * Parameters:
	 *   layerId - {String}图层id 必填。
	 *   successFn - {Function} 请求成功的回调函数。
     *   failFn - {Function} 请求失败的回调函数。
     *   
     *   例子:
     *   (code)
     *     serviceObj.getLayerInfo(layers[0].id,
     *        function(result) {
	 *			var obj = new OpenLayers.Format.JSON();
	 *			var res = obj.write(result);
	 *			document.getElementById("serviceCapabilities").innerText = res;
	 *		  });
     *   (end)
	 */
	getLayerInfo : function(layerId,successFn,failFn) {
		var location = this.url.indexOf("/",this.url.length - 1);
		if(location != -1) {
			var url = this.url + layerId;
		}else {
			var url = this.url + "/" + layerId;
		}
		
		if(!failFn){
			failFn = function(){
				this.failFn("GetLayerInfo");
			};
		}
		OpenLayers.loadURL(url,null,this,function(result){
			var res = this.format.read(result.responseText);
			successFn(res);
		},failFn);
				
	},
	
	/**
     * APIMethod: isExist
     * 将向服务发送同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * 
     * Returns:
     * {Boolean} 服务是否存在。
     */
	isExist: function(){
		var isExist = false;
		var url = this.url;
		var xhr = OpenLayers.Request.GET({
            url: url,
			params: null,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},
	
	/**
     * APIMethod: getMap
     * 获取地图内容操作。
     * 
     * Parameters:
     * 	params - {Object} 
     *    layerId - {String}图层Id 必填。
     *    mapstyleId - {String}当前请求图层样式的唯一编号 必填。
     *    srid -{String} 图层的参考坐标系 必填。
     *    sourceDate - {Date}据的最后更新日期 必填。
     *    level - {Integer}请求图层的层号 必填。
     *    formatSuffix - {String}输出图片格式 必填。
     *    col - {Integer} 瓦片列号 必填。
     *    row - {Integer} 瓦片行号 必填。
     *  
     * Returns:
 	 * {String} 地图内容图片地址。
 	 * 
 	 * 示例:
 	 * (code)
 	 * var url = serviceObj.getMap({
     *     col	: 1506,
	 *	   formatSuffix:"png",
	 *	   layerId	:"GeoGlobeMap_1",
	 *	   level:11,
	 *	   mapStyleId:"GISP:1",
	 *	   row:259	,
	 *	   sourceDate:myDate,
	 *	   srid : "EPSG:4326"
     *  });
     *   (end)
     */	
	getMap: function(params){
		var path =  encodeURIComponent(params.layerId) + "/" + encodeURIComponent(params.mapStyleId) + "/" + 
		encodeURIComponent(params.srid) + "/" +params.sourceDate.getYear() + params.sourceDate.getMonth() + params.sourceDate.getDate() + "/" +
		"L"+ params.level + "/" + params.col+ encodeURIComponent(",") + params.row + "." + params.formatSuffix;
		var location = this.url.indexOf("/",this.url.length - 1);
		if(location != -1) {
			var url = this.url + path;
		}else {
			var url = this.url + "/" + path;
		}
		return url;
	},

	CLASS_NAME: "Geo.Service.CWMS"
});/**
 * Class: Geo.Service.MapService
 * MAPSERVICE-REST服务类。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.MapService = Geo.Class(Geo.Service, {
	
	/**
     * Constructor: Geo.Service.MapService
     * Geo.Service.MapService类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		Geo.Service.prototype.initialize.apply(this, arguments);
		this.format = new OpenLayers.Format.JSON();
		this.jsonp = new OpenLayers.Protocol.Script({
			format:this.format
		});
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		var url = this.url;
		var params = {
			f:"json"
			//callback:"flightHandler"
		};
		if(!failFn){
			failFn = function(){
				this.failFn(params.REQUEST);
			};
		}
		this.jsonp.createRequest(url,params, OpenLayers.Function.bind(function(result){
			successFn(result);
		},this));
	},
	/**
	 * 获取查询结果的json表示法
	 * @param {Object} result
	 */
	_getJson: function(result) {
		var resultObj = this.format.read(result.responseText);
		return resultObj;
	},
	/**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * 
     * Returns:
     * {Boolean} 服务是否存在。
     */
	isExist: function(){
		var isExist = false;
		var url = this.url;
		var params = {
			f:"json"
			//callback:"flightHandler"
		};
		var xhr = OpenLayers.Request.GET({
            url: url,
			params: params,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},

	CLASS_NAME: "Geo.Service.MapService"
});/**
 * Class: Geo.Service.GeoCoding
 * 地址匹配服务
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.GeoCoding = Geo.Class(Geo.Service, {
	
	/**
	 * APIProperty: version
	 * 服务版本，默认值是"1.0.0"。
	 */
	version:"1.0.0",
	
	/**
     * Constructor: Geo.Service.GeoCoding
     * Geo.Service.GeoCoding类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url, options){
		Geo.Service.prototype.initialize.apply(this, arguments);
		this.format = new OpenLayers.Format.JSON();
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		if(!failFn){
			failFn = function(){
				this.failFn("GetCapabilities");
			};
		}
		var params = {
			request:"GetCapabilities",
			output:"json",
			version:this.version,
			service:"GeoCoding"
		};
		OpenLayers.loadURL(this.url,params,this,function(result) {
			var json = this.format.read(result.responseText);
			successFn({
				result:result,
				json:json
			});
		},failFn);
	},

	CLASS_NAME: "Geo.Service.GeoCoding"
});/**
 * APIMethod: setProxyHost
 * 设置代理地址,根据自己的代理器地址来配置
 * 
 * Parameters:
 * proxyHost - {String} 代理地址
 * 
 */
Geo.Request.setProxyHost = function(proxyHost){
	OpenLayers.ProxyHost = proxyHost;
}

/**
 * APIMethod: getProxyHost
 * 代理地址
 *
 * Returns:
 * {String} 代理地址
 */
Geo.Request.getProxyHost = function(){
	return OpenLayers.ProxyHost;
}